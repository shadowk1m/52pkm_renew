const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["js/yLOmadMK-1734942186555.js", "js/BJuXgwRK-1734942186473.js", "js/BqM_3Dap-1734942186631.js", "assets/css/BLNqON5M-1734942186825.css", "js/D4SdJOpd-1734942186631.js", "js/BYHFfOeP-1734942186631.js", "js/Cer01-TO-1734942186631.js", "js/D7CEF2-h-1734942186631.js", "assets/css/BE96cb4L-1734942186817.css", "js/CK8fVlpN-1734942186556.js", "js/c6-8uMZm-1734942186635.js", "js/CyctVqw6-1734942186635.js", "js/C5MVmxrN-1734942186635.js", "js/CNnkmHkq-1734942186635.js", "assets/css/BDr5OuAL-1734942186817.css", "js/BbmWxrVm-1734942186556.js", "assets/css/B7QQUrbH-1734942186817.css", "assets/css/BVdSh830-1734942186824.css", "assets/css/DuevJDmg-1734942186817.css", "js/DkxBSZrA-1734942186556.js", "assets/css/CSbUSRoB-1734942186817.css", "js/Bv-Hqr6V-1734942186556.js", "assets/css/WoyPXaEG-1734942186817.css", "js/BTdDI8VH-1734942186556.js", "js/BGutT2xV-1734942186641.js", "assets/css/DachpazC-1734942186817.css", "js/DBmgIBkK-1734942186556.js", "assets/css/njg7YNZ_-1734942186817.css", "js/Dx1jtChx-1734942186556.js", "js/DhVNkQgO-1734942186655.js", "assets/css/C-ruVn46-1734942186817.css", "js/q7-UOM5J-1734942186556.js", "js/CR8ryJau-1734942186656.js", "assets/css/DIQcZz55-1734942186817.css", "js/B_J_lvoV-1734942186556.js", "assets/css/Ce1vJZAa-1734942186817.css", "js/DkMx9PLu-1734942186556.js", "assets/css/i36Rdtza-1734942186818.css", "js/BwOW9MoH-1734942186556.js", "js/Ckr9O2VH-1734942186556.js", "assets/css/B_26tdV0-1734942186818.css", "js/CMvuvdfu-1734942186556.js", "assets/css/_zB_f2wv-1734942186818.css", "js/ClyW5ei0-1734942186556.js", "assets/css/kFuu0_bA-1734942186818.css", "js/CNet2Hol-1734942186556.js", "assets/css/Dd3H1j21-1734942186818.css", "js/6mwn1y04-1734942186556.js", "js/ByVawsvp-1734942186556.js", "js/BdN5Zu_0-1734942186668.js", "assets/css/IG10Pnij-1734942186825.css", "js/heyoo-oC-1734942186556.js", "assets/css/C7TThf_p-1734942186826.css", "js/aeIKCm5w-1734942186556.js", "assets/css/CY_HGAwf-1734942186826.css", "js/BvFhacO9-1734942186556.js", "assets/css/CilYdLCN-1734942186826.css", "js/CHt17t75-1734942186556.js", "js/D0p3yAfo-1734942186681.js", "assets/css/Dv6F-JXI-1734942186826.css", "js/DSHBoZvi-1734942186556.js", "assets/css/naueGu7j-1734942186827.css", "js/C2Vez5yY-1734942186556.js", "assets/css/DCKIp6tm-1734942186827.css", "js/B3U7qeKb-1734942186556.js", "assets/css/CPcjQYm5-1734942186827.css"]))) => i.map(i => d[i]);
var e, t;
import {d as a, o as i, c as n, u as r, R as o, a as s, r as l, b as c, e as u, p as d, m as h, f as p, g as v, h as g, i as f, j as m, k as b, l as x, n as y, T as w, q as k, s as S, t as C, v as A, w as P, x as L, y as I, z as _, A as T, B as E, C as O, D as V, E as F, F as B, G as M, H as D, I as R, J as N, K as z, L as H, M as X, S as Y, N as W, O as G, P as j, Q as $, U, V as q, W as Z, X as K, Y as J, Z as Q, _ as ee, $ as te, a0 as ae, a1 as ie, a2 as ne, a3 as re, a4 as oe, a5 as se, a6 as le, a7 as ce, a8 as ue, a9 as de, aa as he, ab as pe, ac as ve, ad as ge, ae as fe, af as me, ag as be, ah as xe, ai as ye, aj as we, ak as ke, al as Se, am as Ce, an as Ae, ao as Pe, ap as Le, aq as Ie, ar as _e, as as Te, at as Ee, au as Oe, av as Ve, aw as Fe, ax as Be, ay as Me, az as De, aA as Re, aB as Ne, aC as ze, aD as He, aE as Xe, aF as Ye, aG as We, aH as Ge, aI as je, aJ as $e, aK as Ue, aL as qe, aM as Ze, aN as Ke, aO as Je, aP as Qe, aQ as et, aR as tt, aS as at, aT as it, aU as nt, aV as rt, aW as ot, aX as st, aY as lt, aZ as ct, a_ as ut, a$ as dt, b0 as ht, b1 as pt, b2 as vt, b3 as gt, b4 as ft, b5 as mt, b6 as bt, b7 as xt, b8 as yt, b9 as wt, ba as kt, bb as St, bc as Ct, bd as At, be as Pt, bf as Lt, bg as It, bh as _t, bi as Tt, bj as Et, bk as Ot, bl as Vt, bm as Ft, bn as Bt, bo as Mt, bp as Dt, bq as Rt, br as Nt, bs as zt, bt as Ht, bu as Xt, bv as Yt, bw as Wt, bx as Gt, by as jt, bz as $t, bA as Ut, bB as qt, bC as Zt, bD as Kt, bE as Jt, bF as Qt, bG as ea, bH as ta, bI as aa, bJ as ia, bK as na, bL as ra, bM as oa, bN as sa, bO as la, bP as ca, bQ as ua, bR as da, bS as ha, bT as pa, bU as va, bV as ga, bW as fa, bX as ma, bY as ba, bZ as xa, b_ as ya, b$ as wa, c0 as ka, c1 as Sa} from "./BJuXgwRK-1734942186473.js";
!function() {
    const e = document.createElement("link").relList;
    if (!(e && e.supports && e.supports("modulepreload"))) {
        for (const e of document.querySelectorAll('link[rel="modulepreload"]'))
            t(e);
        new MutationObserver((e => {
            for (const a of e)
                if ("childList" === a.type)
                    for (const e of a.addedNodes)
                        "LINK" === e.tagName && "modulepreload" === e.rel && t(e)
        }
        )).observe(document, {
            childList: !0,
            subtree: !0
        })
    }
    function t(e) {
        if (e.ep)
            return;
        e.ep = !0;
        const t = function(e) {
            const t = {};
            return e.integrity && (t.integrity = e.integrity),
            e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy),
            "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin",
            t
        }(e);
        fetch(e.href, t)
    }
}();
!function(e, t) {
    void 0 === t && (t = {});
    var a = t.insertAt;
    if ("undefined" != typeof document) {
        var i = document.head || document.getElementsByTagName("head")[0]
          , n = document.createElement("style");
        n.type = "text/css",
        "top" === a && i.firstChild ? i.insertBefore(n, i.firstChild) : i.appendChild(n),
        n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e))
    }
}("@keyframes watermark{0%{background-position:0 0}25%{background-position:100% 100%}50%{background-position:0 0}75%{background-position:100% -100%}to{background-position:0 0}}");
var Ca = function(e, t) {
    return (Ca = Object.setPrototypeOf || {
        __proto__: []
    }instanceof Array && function(e, t) {
        e.__proto__ = t
    }
    || function(e, t) {
        for (var a in t)
            Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a])
    }
    )(e, t)
};
var Aa = function() {
    return Aa = Object.assign || function(e) {
        for (var t, a = 1, i = arguments.length; a < i; a++)
            for (var n in t = arguments[a])
                Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
        return e
    }
    ,
    Aa.apply(this, arguments)
};
function Pa(e, t, a, i) {
    return new (a || (a = Promise))((function(n, r) {
        function o(e) {
            try {
                l(i.next(e))
            } catch (t) {
                r(t)
            }
        }
        function s(e) {
            try {
                l(i.throw(e))
            } catch (t) {
                r(t)
            }
        }
        function l(e) {
            var t;
            e.done ? n(e.value) : (t = e.value,
            t instanceof a ? t : new a((function(e) {
                e(t)
            }
            ))).then(o, s)
        }
        l((i = i.apply(e, t || [])).next())
    }
    ))
}
function La(e, t) {
    var a, i, n, r, o = {
        label: 0,
        sent: function() {
            if (1 & n[0])
                throw n[1];
            return n[1]
        },
        trys: [],
        ops: []
    };
    return r = {
        next: s(0),
        throw: s(1),
        return: s(2)
    },
    "function" == typeof Symbol && (r[Symbol.iterator] = function() {
        return this
    }
    ),
    r;
    function s(s) {
        return function(l) {
            return function(s) {
                if (a)
                    throw new TypeError("Generator is already executing.");
                for (; r && (r = 0,
                s[0] && (o = 0)),
                o; )
                    try {
                        if (a = 1,
                        i && (n = 2 & s[0] ? i.return : s[0] ? i.throw || ((n = i.return) && n.call(i),
                        0) : i.next) && !(n = n.call(i, s[1])).done)
                            return n;
                        switch (i = 0,
                        n && (s = [2 & s[0], n.value]),
                        s[0]) {
                        case 0:
                        case 1:
                            n = s;
                            break;
                        case 4:
                            return o.label++,
                            {
                                value: s[1],
                                done: !1
                            };
                        case 5:
                            o.label++,
                            i = s[1],
                            s = [0];
                            continue;
                        case 7:
                            s = o.ops.pop(),
                            o.trys.pop();
                            continue;
                        default:
                            if (!(n = o.trys,
                            (n = n.length > 0 && n[n.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
                                o = 0;
                                continue
                            }
                            if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {
                                o.label = s[1];
                                break
                            }
                            if (6 === s[0] && o.label < n[1]) {
                                o.label = n[1],
                                n = s;
                                break
                            }
                            if (n && o.label < n[2]) {
                                o.label = n[2],
                                o.ops.push(s);
                                break
                            }
                            n[2] && o.ops.pop(),
                            o.trys.pop();
                            continue
                        }
                        s = t.call(e, o)
                    } catch (l) {
                        s = [6, l],
                        i = 0
                    } finally {
                        a = n = 0
                    }
                if (5 & s[0])
                    throw s[1];
                return {
                    value: s[0] ? s[1] : void 0,
                    done: !0
                }
            }([s, l])
        }
    }
}
var Ia = function(e) {
    return e.toDataURL("image/png", 1)
}
  , _a = function(e) {
    return "function" == typeof e
}
  , Ta = function(e) {
    return void 0 === e
}
  , Ea = function(e, t, a) {
    void 0 === t && (t = {}),
    void 0 === a && (a = "http://www.w3.org/2000/svg");
    var i = document.createElementNS(a, e);
    for (var n in t)
        i.setAttribute(n, t[n]);
    return i
}
  , Oa = function(e, t) {
    return Pa(void 0, void 0, void 0, (function() {
        var a, i, n, r, o, s, l, c, u;
        return La(this, (function(d) {
            switch (d.label) {
            case 0:
                return a = Ea("svg", {
                    xmlns: "http://www.w3.org/2000/svg"
                }),
                (i = document.createElement("div")).setAttribute("xmlns", "http://www.w3.org/1999/xhtml"),
                i.style.cssText = "\n  text-align: center;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  font: ".concat(e.font, ";\n  color: ").concat(t.fontColor, ";\n"),
                i.innerHTML = "<div class='rich-text-content'>".concat(t.content, "</div>"),
                document.body.appendChild(i),
                [4, Va(i)];
            case 1:
                return d.sent(),
                n = null === (u = i.querySelector(".rich-text-content")) || void 0 === u ? void 0 : u.getBoundingClientRect(),
                r = null == n ? void 0 : n.width,
                o = null == n ? void 0 : n.height,
                document.body.removeChild(i),
                s = t.richTextWidth || r || t.width,
                l = t.richTextHeight || o || t.height,
                a.setAttribute("width", s.toString()),
                a.setAttribute("height", l.toString()),
                (c = Ea("foreignObject", {
                    width: s.toString(),
                    height: l.toString()
                })).appendChild(i),
                a.appendChild(c),
                [2, {
                    element: a,
                    width: s,
                    height: l
                }]
            }
        }
        ))
    }
    ))
};
function Va(e) {
    return Pa(this, void 0, void 0, (function() {
        var t, a, i, n, r;
        return La(this, (function(o) {
            switch (o.label) {
            case 0:
                t = e.querySelectorAll("img"),
                a = function(e) {
                    var t, a, i;
                    return La(this, (function(n) {
                        switch (n.label) {
                        case 0:
                            if (!(t = e.getAttribute("src")))
                                return [3, 6];
                            n.label = 1;
                        case 1:
                            return n.trys.push([1, 5, , 6]),
                            [4, fetch(t)];
                        case 2:
                            return [4, n.sent().blob()];
                        case 3:
                            return a = n.sent(),
                            [4, new Promise((function(e, t) {
                                var i = new FileReader;
                                i.onloadend = function() {
                                    return e(i.result)
                                }
                                ,
                                i.onerror = t,
                                i.readAsDataURL(a)
                            }
                            ))];
                        case 4:
                            return i = n.sent(),
                            "string" == typeof i && e.setAttribute("src", i),
                            [3, 6];
                        case 5:
                            return n.sent(),
                            [3, 6];
                        case 6:
                            return [2]
                        }
                    }
                    ))
                }
                ,
                i = 0,
                n = Array.from(t),
                o.label = 1;
            case 1:
                return i < n.length ? (r = n[i],
                [5, a(r)]) : [3, 4];
            case 2:
                o.sent(),
                o.label = 3;
            case 3:
                return i++,
                [3, 1];
            case 4:
                return [2]
            }
        }
        ))
    }
    ))
}
var Fa = function(e, t) {
    return Ta(e) ? t : e
}
  , Ba = function(e, t, a) {
    void 0 === t && (t = void 0),
    void 0 === a && (a = void 0);
    var i = new Image;
    return i.setAttribute("crossOrigin", "Anonymous"),
    !Ta(t) && (i.width = t),
    !Ta(a) && (i.height = a),
    i.src = e,
    new Promise((function(e) {
        i.onload = function() {
            e(i)
        }
    }
    ))
}
  , Ma = {
    width: 300,
    height: 300,
    rotate: 45,
    layout: "default",
    auxiliaryLine: !1,
    translatePlacement: "middle",
    contentType: "text",
    content: "hello watermark-js-plus",
    textType: "fill",
    imageWidth: 0,
    imageHeight: 0,
    lineHeight: 30,
    zIndex: 2147483647,
    backgroundPosition: "0 0",
    backgroundRepeat: "repeat",
    fontSize: "20px",
    fontFamily: "sans-serif",
    fontStyle: "",
    fontVariant: "",
    fontColor: "#000",
    fontWeight: "normal",
    filter: "none",
    letterSpacing: "0px",
    wordSpacing: "0px",
    globalAlpha: .5,
    mode: "default",
    mutationObserve: !0,
    monitorProtection: !1,
    movable: !1,
    parent: "body",
    onSuccess: function() {},
    onBeforeDestroy: function() {},
    onDestroyed: function() {},
    onObserveError: function() {}
}
  , Da = function(e) {
    "undefined" != typeof window && e && (Object.defineProperty(window, "MutationObserver", {
        writable: !1,
        configurable: !1
    }),
    Object.defineProperty(window, "requestAnimationFrame", {
        writable: !1,
        configurable: !1
    }))
}
  , Ra = function() {
    function e(t, a) {
        this.props = t,
        this.options = a,
        this.canvas = e.createCanvas(this.options.width, this.options.height),
        this.recommendOptions = function(e, t, a) {
            var i = e.getContext("2d");
            if (null === i)
                throw new Error("get context error");
            i.font = "".concat(t.fontStyle, " ").concat(t.fontVariant, " ").concat(t.fontWeight, " ").concat(t.fontSize, " ").concat(t.fontFamily),
            i.filter = t.filter,
            i.letterSpacing = t.letterSpacing,
            i.wordSpacing = t.wordSpacing,
            (null == t ? void 0 : t.rotate) && (t.rotate = (360 - t.rotate % 360) * (Math.PI / 180)),
            Ta(a.textRowMaxWidth) && (t.textRowMaxWidth = t.width);
            var n = {
                image: {
                    rect: {
                        width: t.imageWidth,
                        height: t.imageHeight
                    },
                    position: {
                        x: 0,
                        y: 0
                    }
                },
                textLine: {
                    data: [],
                    yOffsetValue: 0
                },
                advancedStyleParams: {
                    linear: {
                        x0: 0,
                        x1: 0
                    },
                    radial: {
                        x0: 0,
                        y0: 0,
                        r0: 0,
                        x1: 0,
                        y1: 0,
                        r1: 0
                    },
                    conic: {
                        x: 0,
                        y: 0,
                        startAngle: 0
                    },
                    pattern: {}
                }
            };
            switch (t.contentType) {
            case "text":
                n.textLine.data = [t.content];
                break;
            case "multi-line-text":
                n.textLine.data = function(e, t, a) {
                    for (var i = [], n = "", r = "", o = 0, s = t.length; o < s; o++)
                        "\n" !== (r = t.charAt(o)) ? (n += r,
                        e.measureText(n).width > a && (i.push(n.substring(0, n.length - 1)),
                        n = "",
                        o--)) : (i.push(n),
                        n = "");
                    return i.push(n),
                    i
                }(i, t.content, t.textRowMaxWidth)
            }
            var r = t.width / 2
              , o = t.height / 2
              , s = "middle"
              , l = "center";
            switch (Ta(null == a ? void 0 : a.translateX) || Ta(null == a ? void 0 : a.translateY) ? (n.advancedStyleParams.linear.x0 = -t.width / 2,
            n.advancedStyleParams.linear.x1 = t.width / 2,
            n.advancedStyleParams.radial.r0 = 0,
            n.advancedStyleParams.radial.r1 = t.width / 2) : (r = null == a ? void 0 : a.translateX,
            o = null == a ? void 0 : a.translateY,
            s = "top",
            l = "left"),
            a.translatePlacement) {
            case "top":
                r = t.width / 2,
                o = 0,
                s = "top",
                n.advancedStyleParams.linear.x0 = -t.width / 2,
                n.advancedStyleParams.linear.x1 = t.width / 2,
                n.advancedStyleParams.radial.y0 = n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.radial.y1 = n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.conic.y = n.textLine.data.length * t.lineHeight / 2;
                break;
            case "top-start":
                r = 0,
                o = 0,
                s = "top",
                l = "start",
                n.advancedStyleParams.linear.x0 = 0,
                n.advancedStyleParams.linear.x1 = t.width,
                n.advancedStyleParams.radial.x0 = t.width / 2,
                n.advancedStyleParams.radial.y0 = n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.radial.x1 = t.width / 2,
                n.advancedStyleParams.radial.y1 = n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.conic.x = t.width / 2,
                n.advancedStyleParams.conic.y = n.textLine.data.length * t.lineHeight / 2;
                break;
            case "top-end":
                r = t.width,
                o = 0,
                s = "top",
                l = "end",
                n.advancedStyleParams.linear.x0 = 0,
                n.advancedStyleParams.linear.x1 = -t.width,
                n.advancedStyleParams.radial.x0 = -t.width / 2,
                n.advancedStyleParams.radial.y0 = n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.radial.x1 = -t.width / 2,
                n.advancedStyleParams.radial.y1 = n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.conic.x = -t.width / 2,
                n.advancedStyleParams.conic.y = n.textLine.data.length * t.lineHeight / 2;
                break;
            case "bottom":
                r = t.width / 2,
                o = t.height,
                s = "bottom",
                n.advancedStyleParams.linear.x0 = -t.width / 2,
                n.advancedStyleParams.linear.x1 = t.width / 2,
                n.advancedStyleParams.radial.y0 = -n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.radial.y1 = -n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.conic.x = 0,
                n.advancedStyleParams.conic.y = -n.textLine.data.length * t.lineHeight / 2;
                break;
            case "bottom-start":
                r = 0,
                o = t.height,
                s = "bottom",
                l = "start",
                n.advancedStyleParams.linear.x0 = 0,
                n.advancedStyleParams.linear.x1 = t.width,
                n.advancedStyleParams.radial.x0 = t.width / 2,
                n.advancedStyleParams.radial.y0 = -n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.radial.x1 = t.width / 2,
                n.advancedStyleParams.radial.y1 = -n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.conic.x = t.width / 2,
                n.advancedStyleParams.conic.y = -n.textLine.data.length * t.lineHeight / 2;
                break;
            case "bottom-end":
                r = t.width,
                o = t.height,
                s = "bottom",
                l = "end",
                n.advancedStyleParams.linear.x0 = 0,
                n.advancedStyleParams.linear.x1 = -t.width,
                n.advancedStyleParams.radial.x0 = -t.width / 2,
                n.advancedStyleParams.radial.y0 = -n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.radial.x1 = -t.width / 2,
                n.advancedStyleParams.radial.y1 = -n.textLine.data.length * t.lineHeight / 2,
                n.advancedStyleParams.conic.x = -t.width / 2,
                n.advancedStyleParams.conic.y = -n.textLine.data.length * t.lineHeight / 2;
                break;
            case "left":
                r = 0,
                o = t.height / 2,
                l = "start",
                n.advancedStyleParams.linear.x0 = 0,
                n.advancedStyleParams.linear.x1 = t.width,
                n.advancedStyleParams.radial.x0 = t.width / 2,
                n.advancedStyleParams.radial.x1 = t.width / 2,
                n.advancedStyleParams.conic.x = t.width / 2,
                n.advancedStyleParams.conic.y = 0;
                break;
            case "right":
                r = t.width,
                o = t.height / 2,
                l = "end",
                n.advancedStyleParams.linear.x0 = 0,
                n.advancedStyleParams.linear.x1 = -t.width,
                n.advancedStyleParams.radial.x0 = -t.width / 2,
                n.advancedStyleParams.radial.x1 = -t.width / 2,
                n.advancedStyleParams.conic.x = -t.width / 2,
                n.advancedStyleParams.conic.y = 0
            }
            if (t.translateX = r,
            t.translateY = o,
            Ta(null == a ? void 0 : a.textBaseline) && (t.textBaseline = s),
            Ta(null == a ? void 0 : a.textAlign) && (t.textAlign = l),
            ["text", "multi-line-text"].includes(t.contentType))
                switch (t.textBaseline) {
                case "middle":
                    n.textLine.yOffsetValue = (n.textLine.data.length - 1) * t.lineHeight / 2;
                    break;
                case "bottom":
                case "alphabetic":
                case "ideographic":
                    n.textLine.yOffsetValue = (n.textLine.data.length - 1) * t.lineHeight + (t.lineHeight - parseInt(t.fontSize)) / 2;
                    break;
                case "top":
                case "hanging":
                    n.textLine.yOffsetValue = -t.lineHeight / 2 + parseInt(t.fontSize) / 2
                }
            return n
        }(this.canvas, this.options, this.props)
    }
    return e.createCanvas = function(e, t) {
        var a, i = window.devicePixelRatio || 1, n = document.createElement("canvas");
        return n.width = e * i,
        n.height = t * i,
        n.style.width = "".concat(e, "px"),
        n.style.height = "".concat(t, "px"),
        null === (a = n.getContext("2d")) || void 0 === a || a.setTransform(i, 0, 0, i, 0, 0),
        n
    }
    ,
    e.clearCanvas = function(e) {
        var t = e.getContext("2d");
        if (null === t)
            throw new Error("get context error");
        t.restore(),
        t.resetTransform(),
        t.clearRect(0, 0, e.width, e.height);
        var a = window.devicePixelRatio || 1;
        t.setTransform(a, 0, 0, a, 0, 0)
    }
    ,
    e.prototype.getCanvas = function() {
        return this.canvas
    }
    ,
    e.prototype.clear = function() {
        e.clearCanvas(this.canvas)
    }
    ,
    e.prototype.draw = function() {
        var e = this
          , t = this.canvas.getContext("2d");
        if (null === t)
            throw new Error("get context error");
        return this.options.auxiliaryLine && (t.beginPath(),
        t.rect(0, 0, this.options.width, this.options.height),
        t.lineWidth = 1,
        t.strokeStyle = "#000",
        t.stroke(),
        t.closePath(),
        t.beginPath(),
        t.rect(this.options.translateX, this.options.translateY, 1, 1),
        t.lineWidth = 1,
        t.strokeStyle = "#f00",
        t.stroke(),
        t.closePath()),
        this.setStyle(t),
        t.save(),
        t.translate(this.options.translateX, this.options.translateY),
        t.rotate(this.options.rotate),
        new Promise((function(a) {
            switch (e.options.contentType) {
            case "text":
                e.drawText(t, a);
                break;
            case "image":
                e.drawImage(t, a);
                break;
            case "multi-line-text":
                e.drawMultiLineText(t, a);
                break;
            case "rich-text":
                e.drawRichText(t, a)
            }
        }
        ))
    }
    ,
    e.prototype.setStyle = function(e) {
        var t, a = "fillStyle";
        "stroke" === this.options.textType && (a = "strokeStyle");
        var i = this.options.fontColor;
        if (null === (t = this.options) || void 0 === t ? void 0 : t.advancedStyle)
            switch (this.options.advancedStyle.type) {
            case "linear":
                i = this.createLinearGradient(e);
                break;
            case "radial":
                i = this.createRadialGradient(e);
                break;
            case "conic":
                i = this.createConicGradient(e);
                break;
            case "pattern":
                i = this.createPattern(e)
            }
        e[a] && i && (e[a] = i),
        this.options.textAlign && (e.textAlign = this.options.textAlign),
        this.options.textBaseline && (e.textBaseline = this.options.textBaseline),
        e.globalAlpha = this.options.globalAlpha,
        this.options.shadowStyle && (e.shadowBlur = Fa(this.options.shadowStyle.shadowBlur, 0),
        e.shadowColor = Fa(this.options.shadowStyle.shadowColor, "#00000000"),
        e.shadowOffsetX = Fa(this.options.shadowStyle.shadowOffsetX, 0),
        e.shadowOffsetY = Fa(this.options.shadowStyle.shadowOffsetY, 0)),
        _a(this.options.extraDrawFunc) && this.options.extraDrawFunc(e)
    }
    ,
    e.prototype.createLinearGradient = function(e) {
        var t, a, i, n, r, o, s, l, c, u, d, h, p, v, g, f = e.createLinearGradient(Fa(null === (i = null === (a = null === (t = this.options.advancedStyle) || void 0 === t ? void 0 : t.params) || void 0 === a ? void 0 : a.linear) || void 0 === i ? void 0 : i.x0, this.recommendOptions.advancedStyleParams.linear.x0), Fa(null === (o = null === (r = null === (n = this.options.advancedStyle) || void 0 === n ? void 0 : n.params) || void 0 === r ? void 0 : r.linear) || void 0 === o ? void 0 : o.y0, 0), Fa(null === (c = null === (l = null === (s = this.options.advancedStyle) || void 0 === s ? void 0 : s.params) || void 0 === l ? void 0 : l.linear) || void 0 === c ? void 0 : c.x1, this.recommendOptions.advancedStyleParams.linear.x1), Fa(null === (h = null === (d = null === (u = this.options.advancedStyle) || void 0 === u ? void 0 : u.params) || void 0 === d ? void 0 : d.linear) || void 0 === h ? void 0 : h.y1, 0));
        return null === (g = null === (v = null === (p = this.options) || void 0 === p ? void 0 : p.advancedStyle) || void 0 === v ? void 0 : v.colorStops) || void 0 === g || g.forEach((function(e) {
            f.addColorStop(e.offset, e.color)
        }
        )),
        f
    }
    ,
    e.prototype.createConicGradient = function(e) {
        var t, a, i, n, r, o, s, l, c, u, d, h, p, v, g, f = e.createConicGradient(Fa(null === (n = null === (i = null === (a = null === (t = this.options) || void 0 === t ? void 0 : t.advancedStyle) || void 0 === a ? void 0 : a.params) || void 0 === i ? void 0 : i.conic) || void 0 === n ? void 0 : n.startAngle, 0), Fa(null === (l = null === (s = null === (o = null === (r = this.options) || void 0 === r ? void 0 : r.advancedStyle) || void 0 === o ? void 0 : o.params) || void 0 === s ? void 0 : s.conic) || void 0 === l ? void 0 : l.x, this.recommendOptions.advancedStyleParams.conic.x), Fa(null === (h = null === (d = null === (u = null === (c = this.options) || void 0 === c ? void 0 : c.advancedStyle) || void 0 === u ? void 0 : u.params) || void 0 === d ? void 0 : d.conic) || void 0 === h ? void 0 : h.y, this.recommendOptions.advancedStyleParams.conic.y));
        return null === (g = null === (v = null === (p = this.options) || void 0 === p ? void 0 : p.advancedStyle) || void 0 === v ? void 0 : v.colorStops) || void 0 === g || g.forEach((function(e) {
            f.addColorStop(e.offset, e.color)
        }
        )),
        f
    }
    ,
    e.prototype.createRadialGradient = function(e) {
        var t, a, i, n, r, o, s, l, c, u, d, h, p, v, g, f, m, b, x, y, w, k, S, C, A, P, L, I = e.createRadialGradient(Fa(null === (n = null === (i = null === (a = null === (t = this.options) || void 0 === t ? void 0 : t.advancedStyle) || void 0 === a ? void 0 : a.params) || void 0 === i ? void 0 : i.radial) || void 0 === n ? void 0 : n.x0, this.recommendOptions.advancedStyleParams.radial.x0), Fa(null === (l = null === (s = null === (o = null === (r = this.options) || void 0 === r ? void 0 : r.advancedStyle) || void 0 === o ? void 0 : o.params) || void 0 === s ? void 0 : s.radial) || void 0 === l ? void 0 : l.y0, this.recommendOptions.advancedStyleParams.radial.y0), Fa(null === (h = null === (d = null === (u = null === (c = this.options) || void 0 === c ? void 0 : c.advancedStyle) || void 0 === u ? void 0 : u.params) || void 0 === d ? void 0 : d.radial) || void 0 === h ? void 0 : h.r0, this.recommendOptions.advancedStyleParams.radial.r0), Fa(null === (f = null === (g = null === (v = null === (p = this.options) || void 0 === p ? void 0 : p.advancedStyle) || void 0 === v ? void 0 : v.params) || void 0 === g ? void 0 : g.radial) || void 0 === f ? void 0 : f.x1, this.recommendOptions.advancedStyleParams.radial.x1), Fa(null === (y = null === (x = null === (b = null === (m = this.options) || void 0 === m ? void 0 : m.advancedStyle) || void 0 === b ? void 0 : b.params) || void 0 === x ? void 0 : x.radial) || void 0 === y ? void 0 : y.y1, this.recommendOptions.advancedStyleParams.radial.y1), Fa(null === (C = null === (S = null === (k = null === (w = this.options) || void 0 === w ? void 0 : w.advancedStyle) || void 0 === k ? void 0 : k.params) || void 0 === S ? void 0 : S.radial) || void 0 === C ? void 0 : C.r1, this.recommendOptions.advancedStyleParams.radial.r1));
        return null === (L = null === (P = null === (A = this.options) || void 0 === A ? void 0 : A.advancedStyle) || void 0 === P ? void 0 : P.colorStops) || void 0 === L || L.forEach((function(e) {
            I.addColorStop(e.offset, e.color)
        }
        )),
        I
    }
    ,
    e.prototype.createPattern = function(e) {
        var t, a, i, n, r, o, s, l;
        return e.createPattern(null === (n = null === (i = null === (a = null === (t = this.options) || void 0 === t ? void 0 : t.advancedStyle) || void 0 === a ? void 0 : a.params) || void 0 === i ? void 0 : i.pattern) || void 0 === n ? void 0 : n.image, (null === (l = null === (s = null === (o = null === (r = this.options) || void 0 === r ? void 0 : r.advancedStyle) || void 0 === o ? void 0 : o.params) || void 0 === s ? void 0 : s.pattern) || void 0 === l ? void 0 : l.repetition) || "")
    }
    ,
    e.prototype.setText = function(e, t) {
        var a = "fillText";
        "stroke" === this.options.textType && (a = "strokeText"),
        e[a] && e[a](t.text, t.x, t.y, t.maxWidth)
    }
    ,
    e.prototype.drawText = function(e, t) {
        this.setText(e, {
            text: this.options.content,
            x: 0,
            y: 0 - this.recommendOptions.textLine.yOffsetValue,
            maxWidth: this.options.textRowMaxWidth || this.options.width
        }),
        t(e.canvas)
    }
    ,
    e.prototype.drawImage = function(e, t) {
        var a = this;
        Ba(this.options.image).then((function(i) {
            var n = a.getImageRect(i)
              , r = n.width
              , o = n.height
              , s = a.getDrawImagePosition(r, o);
            e.drawImage(i, s.x, s.y, r, o),
            t(e.canvas)
        }
        ))
    }
    ,
    e.prototype.drawMultiLineText = function(e, t) {
        var a = this
          , i = this.recommendOptions.textLine.data
          , n = this.recommendOptions.textLine.yOffsetValue;
        i.forEach((function(t, i) {
            a.setText(e, {
                text: t,
                x: 0,
                y: a.options.lineHeight * i - n,
                maxWidth: a.options.textRowMaxWidth || a.options.width
            })
        }
        )),
        t(e.canvas)
    }
    ,
    e.prototype.drawRichText = function(e, t) {
        return Pa(this, void 0, void 0, (function() {
            var a, i = this;
            return La(this, (function(n) {
                switch (n.label) {
                case 0:
                    return [4, Oa(e, this.options)];
                case 1:
                    return a = n.sent(),
                    Ba((r = a.element,
                    o = r.outerHTML.replace(/<(img|br|input|hr|embed)(.*?)>/g, "<$1$2/>").replace(/\n/g, "").replace(/\t/g, "").replace(/#/g, "%23"),
                    "data:image/svg+xml;charset=utf-8,".concat(o)), a.width, a.height).then((function(a) {
                        var n = i.getDrawImagePosition(a.width, a.height);
                        e.drawImage(a, n.x, n.y, a.width, a.height),
                        t(e.canvas)
                    }
                    )),
                    [2]
                }
                var r, o
            }
            ))
        }
        ))
    }
    ,
    e.prototype.getImageRect = function(e) {
        var t = {
            width: this.options.imageWidth || 0,
            height: this.options.imageHeight || 0
        };
        switch (!0) {
        case 0 !== t.width && 0 === t.height:
            t.height = t.width * e.height / e.width;
            break;
        case 0 === t.width && 0 !== t.height:
            t.width = t.height * e.width / e.height;
            break;
        case 0 === t.width && 0 === t.height:
            t.width = e.width,
            t.height = e.height
        }
        return t
    }
    ,
    e.prototype.getDrawImagePosition = function(e, t) {
        var a, i, n = {
            x: -e / 2,
            y: -t / 2
        };
        switch (this.options.translatePlacement) {
        case "top":
            n.x = -e / 2,
            n.y = 0;
            break;
        case "top-start":
            n.x = 0,
            n.y = 0;
            break;
        case "top-end":
            n.x = -e,
            n.y = 0;
            break;
        case "bottom":
            n.x = -e / 2,
            n.y = -t;
            break;
        case "bottom-start":
            n.x = 0,
            n.y = -t;
            break;
        case "bottom-end":
            n.x = -e,
            n.y = -t;
            break;
        case "left":
            n.x = 0,
            n.y = -t / 2;
            break;
        case "right":
            n.x = -e,
            n.y = -t / 2
        }
        return !Ta(null === (a = this.props) || void 0 === a ? void 0 : a.translateX) && (n.x = 0),
        !Ta(null === (i = this.props) || void 0 === i ? void 0 : i.translateY) && (n.y = 0),
        n
    }
    ,
    e
}()
  , Na = function() {
    function e(e, t) {
        var a, i, n, r, o, s, l;
        this.options = e,
        this.partialWidth = this.options.width,
        this.partialHeight = this.options.height,
        this.rows = (null === (a = this.options.gridLayoutOptions) || void 0 === a ? void 0 : a.rows) || 1,
        this.cols = (null === (i = this.options.gridLayoutOptions) || void 0 === i ? void 0 : i.cols) || 1,
        this.matrix = (null === (n = this.options.gridLayoutOptions) || void 0 === n ? void 0 : n.matrix) || (o = this.rows,
        s = this.cols,
        l = 1,
        Array.from({
            length: o
        }, (function() {
            return new Array(s).fill(l)
        }
        ))),
        this.gap = (null === (r = this.options.gridLayoutOptions) || void 0 === r ? void 0 : r.gap) || [0, 0],
        this.partialCanvas = t
    }
    return e.prototype.draw = function() {
        var e, t, a, i, n, r, o, s, l = Ra.createCanvas((null === (e = this.options.gridLayoutOptions) || void 0 === e ? void 0 : e.width) || this.partialWidth * this.cols + this.gap[0] * this.cols, (null === (t = this.options.gridLayoutOptions) || void 0 === t ? void 0 : t.height) || this.partialHeight * this.rows + this.gap[1] * this.rows), c = l.getContext("2d");
        (null === (a = this.options.gridLayoutOptions) || void 0 === a ? void 0 : a.backgroundImage) && (null == c || c.drawImage(null === (i = this.options.gridLayoutOptions) || void 0 === i ? void 0 : i.backgroundImage, 0, 0, null === (n = this.options.gridLayoutOptions) || void 0 === n ? void 0 : n.width, null === (r = this.options.gridLayoutOptions) || void 0 === r ? void 0 : r.height));
        for (var u = 0; u < this.rows; u++)
            for (var d = 0; d < this.cols; d++)
                (null === (s = null === (o = this.matrix) || void 0 === o ? void 0 : o[u]) || void 0 === s ? void 0 : s[d]) && (null == c || c.drawImage(this.partialCanvas, this.partialWidth * d + this.gap[0] * d, this.partialHeight * u + this.gap[1] * u, this.partialWidth, this.partialHeight));
        return l
    }
    ,
    e
}()
  , za = function(e) {
    function t(t) {
        void 0 === t && (t = {});
        return e.call(this, Aa(Aa({}, t), {
            globalAlpha: .005,
            mode: "blind"
        })) || this
    }
    return function(e, t) {
        if ("function" != typeof t && null !== t)
            throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        function a() {
            this.constructor = e
        }
        Ca(e, t),
        e.prototype = null === t ? Object.create(t) : (a.prototype = t.prototype,
        new a)
    }(t, e),
    t.decode = function(e) {
        var t = e.url
          , a = void 0 === t ? "" : t
          , i = e.fillColor
          , n = void 0 === i ? "#000" : i
          , r = e.compositeOperation
          , o = void 0 === r ? "color-burn" : r
          , s = e.mode
          , l = void 0 === s ? "canvas" : s
          , c = e.compositeTimes
          , u = void 0 === c ? 3 : c
          , d = e.onSuccess;
        if (a && "canvas" === l) {
            var h = new Image;
            h.src = a,
            h.addEventListener("load", (function() {
                var e = h.width
                  , t = h.height
                  , a = Ra.createCanvas(e, t)
                  , i = a.getContext("2d");
                if (!i)
                    throw new Error("get context error");
                i.drawImage(h, 0, 0, e, t),
                i.globalCompositeOperation = o,
                i.fillStyle = n;
                for (var r = 0; r < u; r++)
                    i.fillRect(0, 0, e, t);
                var s = Ia(a);
                _a(d) && (null == d || d(s))
            }
            ))
        }
    }
    ,
    t
}(function() {
    function e(e) {
        void 0 === e && (e = {}),
        this.parentElement = document.body,
        this.isCreating = !1,
        this.props = e,
        this.options = Aa(Aa({}, Ma), e),
        this.changeParentElement(this.options.parent),
        this.watermarkCanvas = new Ra(this.props,this.options),
        Da(this.options.monitorProtection)
    }
    return e.prototype.changeOptions = function() {
        return Pa(this, arguments, void 0, (function(e, t, a) {
            return void 0 === e && (e = {}),
            void 0 === t && (t = "overwrite"),
            void 0 === a && (a = !0),
            La(this, (function(i) {
                switch (i.label) {
                case 0:
                    return this.initConfigData(e, t),
                    Da(this.options.monitorProtection),
                    a ? (this.remove(),
                    [4, this.create()]) : [3, 2];
                case 1:
                    i.sent(),
                    i.label = 2;
                case 2:
                    return [2]
                }
            }
            ))
        }
        ))
    }
    ,
    e.prototype.create = function() {
        return Pa(this, void 0, void 0, (function() {
            var e, t, a, i, n, r, o, s, l, c, u, d;
            return La(this, (function(h) {
                switch (h.label) {
                case 0:
                    return this.isCreating ? [2] : (this.isCreating = !0,
                    this.validateUnique() && this.validateContent() ? (e = Ta(this.watermarkDom),
                    [4, null === (r = this.watermarkCanvas) || void 0 === r ? void 0 : r.draw()]) : (this.isCreating = !1,
                    [2]));
                case 1:
                    if (h.sent(),
                    this.layoutCanvas = (p = this.options,
                    v = null === (o = this.watermarkCanvas) || void 0 === o ? void 0 : o.getCanvas(),
                    "grid" === p.layout ? new Na(p,v).draw() : v),
                    t = Ia(this.layoutCanvas),
                    null === (s = this.watermarkCanvas) || void 0 === s || s.clear(),
                    this.watermarkDom = document.createElement("div"),
                    a = document.createElement("div"),
                    this.watermarkDom.__WATERMARK__ = "watermark",
                    this.watermarkDom.__WATERMARK__INSTANCE__ = this,
                    i = this.checkParentElementType(),
                    this.watermarkDom.style.cssText = "\n      z-index:".concat(this.options.zIndex, "!important;display:block!important;visibility:visible!important;transform:none!important;scale:none!important;\n      ").concat("custom" === i ? "top:0!important;bottom:0!important;left:0!important;right:0!important;height:100%!important;pointer-events:none!important;position:absolute!important;" : "position:relative!important;", "\n    "),
                    n = function(e) {
                        var t, a, i;
                        if ("grid" === e.layout) {
                            var n = (null === (t = e.gridLayoutOptions) || void 0 === t ? void 0 : t.cols) || 1
                              , r = (null === (a = e.gridLayoutOptions) || void 0 === a ? void 0 : a.rows) || 1
                              , o = (null === (i = e.gridLayoutOptions) || void 0 === i ? void 0 : i.gap) || [0, 0];
                            return [e.width * n + o[0] * n, e.height * r + o[1] * r]
                        }
                        return [e.width, e.height]
                    }(this.options),
                    a.style.cssText = "\n      display:block!important;visibility:visible!important;pointer-events:none;top:0;bottom:0;left:0;right:0;transform:none!important;scale:none!important;\n      position:".concat("root" === i ? "fixed" : "absolute", "!important;-webkit-print-color-adjust:exact!important;width:100%!important;height:100%!important;\n      z-index:").concat(this.options.zIndex, "!important;background-image:url(").concat(t, ")!important;background-repeat:").concat(this.options.backgroundRepeat, "!important;\n      background-size:").concat(n[0], "px ").concat(n[1], "px!important;background-position:").concat(this.options.backgroundPosition, ";\n      ").concat(this.options.movable ? "animation: 200s ease 0s infinite normal none running watermark !important;" : "", "\n    "),
                    this.watermarkDom.appendChild(a),
                    this.parentElement.appendChild(this.watermarkDom),
                    this.options.mutationObserve)
                        try {
                            this.bindMutationObserve()
                        } catch (g) {
                            null === (c = (l = this.options).onObserveError) || void 0 === c || c.call(l)
                        }
                    return e && (null === (d = (u = this.options).onSuccess) || void 0 === d || d.call(u)),
                    this.isCreating = !1,
                    [2]
                }
                var p, v
            }
            ))
        }
        ))
    }
    ,
    e.prototype.destroy = function() {
        this.remove(),
        this.watermarkDom = void 0
    }
    ,
    e.prototype.check = function() {
        return Pa(this, void 0, void 0, (function() {
            return La(this, (function(e) {
                return [2, this.parentElement.contains(this.watermarkDom)]
            }
            ))
        }
        ))
    }
    ,
    e.prototype.remove = function() {
        var e, t, a, i, n, r, o, s;
        null === (t = (e = this.options).onBeforeDestroy) || void 0 === t || t.call(e),
        null === (a = this.observer) || void 0 === a || a.disconnect(),
        null === (i = this.parentObserve) || void 0 === i || i.disconnect(),
        this.unbindCheckWatermarkElementEvent(),
        null === (r = null === (n = this.watermarkDom) || void 0 === n ? void 0 : n.parentNode) || void 0 === r || r.removeChild(this.watermarkDom),
        null === (s = (o = this.options).onDestroyed) || void 0 === s || s.call(o)
    }
    ,
    e.prototype.initConfigData = function(e, t) {
        var a = this;
        void 0 === t && (t = "overwrite"),
        "append" === t ? Object.keys(e).forEach((function(t) {
            a.props && (a.props[t] = e[t])
        }
        )) : this.props = e,
        this.options = Aa(Aa({}, Ma), this.props),
        this.changeParentElement(this.options.parent),
        this.watermarkCanvas = new Ra(this.props,this.options)
    }
    ,
    e.prototype.changeParentElement = function(e) {
        if ("string" == typeof e) {
            var t = document.querySelector(e);
            t && (this.parentElement = t)
        } else
            this.parentElement = e;
        this.parentElement
    }
    ,
    e.prototype.validateUnique = function() {
        var e = !0;
        return Array.from(this.parentElement.childNodes).forEach((function(t) {
            e && Object.hasOwnProperty.call(t, "__WATERMARK__") && (e = !1)
        }
        )),
        e
    }
    ,
    e.prototype.validateContent = function() {
        switch (this.options.contentType) {
        case "image":
            return Object.hasOwnProperty.call(this.options, "image");
        case "multi-line-text":
        case "rich-text":
        case "text":
            return this.options.content.length > 0
        }
    }
    ,
    e.prototype.checkParentElementType = function() {
        return ["html", "body"].includes(this.parentElement.tagName.toLocaleLowerCase()) ? "root" : "custom"
    }
    ,
    e.prototype.checkWatermarkElement = function() {
        return Pa(this, void 0, void 0, (function() {
            return La(this, (function(e) {
                switch (e.label) {
                case 0:
                    return this.parentElement.contains(this.watermarkDom) ? [3, 2] : (this.remove(),
                    [4, this.create()]);
                case 1:
                    e.sent(),
                    e.label = 2;
                case 2:
                    return this.bindCheckWatermarkElementEvent(),
                    [2]
                }
            }
            ))
        }
        ))
    }
    ,
    e.prototype.bindMutationObserve = function() {
        var e = this;
        this.watermarkDom && (this.bindCheckWatermarkElementEvent(),
        this.observer = new MutationObserver((function(t) {
            return Pa(e, void 0, void 0, (function() {
                return La(this, (function(e) {
                    switch (e.label) {
                    case 0:
                        return t.length > 0 ? (this.remove(),
                        [4, this.create()]) : [3, 2];
                    case 1:
                        e.sent(),
                        e.label = 2;
                    case 2:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        )),
        this.observer.observe(this.watermarkDom, {
            attributes: !0,
            childList: !0,
            subtree: !0,
            characterData: !0
        }),
        this.parentObserve = new MutationObserver((function(t) {
            return Pa(e, void 0, void 0, (function() {
                var e, a, i, n;
                return La(this, (function(r) {
                    switch (r.label) {
                    case 0:
                        e = 0,
                        a = t,
                        r.label = 1;
                    case 1:
                        return e < a.length ? (null == (i = a[e]) ? void 0 : i.target) === this.watermarkDom || (null === (n = null == i ? void 0 : i.removedNodes) || void 0 === n ? void 0 : n[0]) === this.watermarkDom || "childList" === i.type && i.target === this.parentElement && i.target.lastChild !== this.watermarkDom ? (this.remove(),
                        [4, this.create()]) : [3, 3] : [3, 4];
                    case 2:
                        r.sent(),
                        r.label = 3;
                    case 3:
                        return e++,
                        [3, 1];
                    case 4:
                        return [2]
                    }
                }
                ))
            }
            ))
        }
        )),
        this.parentObserve.observe(this.parentElement, {
            attributes: !0,
            childList: !0,
            subtree: !0,
            characterData: !0
        }))
    }
    ,
    e.prototype.bindCheckWatermarkElementEvent = function() {
        this.unbindCheckWatermarkElementEvent(),
        this.checkWatermarkElementRequestID = requestAnimationFrame(this.checkWatermarkElement.bind(this))
    }
    ,
    e.prototype.unbindCheckWatermarkElementEvent = function() {
        Ta(this.checkWatermarkElementRequestID) || cancelAnimationFrame(this.checkWatermarkElementRequestID)
    }
    ,
    e
}());
const Ha = a({
    __name: "App",
    setup: e => (e, t) => (i(),
    n(r(o)))
})
  , Xa = {}
  , Ya = function(e, t, a) {
    let i = Promise.resolve();
    if (t && t.length > 0) {
        document.getElementsByTagName("link");
        const e = document.querySelector("meta[property=csp-nonce]")
          , a = (null == e ? void 0 : e.nonce) || (null == e ? void 0 : e.getAttribute("nonce"));
        i = Promise.allSettled(t.map((e => {
            if ((e = function(e) {
                return "/" + e
            }(e))in Xa)
                return;
            Xa[e] = !0;
            const t = e.endsWith(".css")
              , i = t ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${e}"]${i}`))
                return;
            const n = document.createElement("link");
            return n.rel = t ? "stylesheet" : "modulepreload",
            t || (n.as = "script"),
            n.crossOrigin = "",
            n.href = e,
            a && n.setAttribute("nonce", a),
            document.head.appendChild(n),
            t ? new Promise(( (t, a) => {
                n.addEventListener("load", t),
                n.addEventListener("error", ( () => a(new Error(`Unable to preload CSS for ${e}`))))
            }
            )) : void 0
        }
        )))
    }
    function n(e) {
        const t = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (t.payload = e,
        window.dispatchEvent(t),
        !t.defaultPrevented)
            throw e
    }
    return i.then((t => {
        for (const e of t || [])
            "rejected" === e.status && n(e.reason);
        return e().catch(n)
    }
    ))
}
  , Wa = {
    path: "/main",
    meta: {
        requiresAuth: !0
    },
    redirect: "/main/dashboard",
    component: () => Ya(( () => import("./yLOmadMK-1734942186555.js")), __vite__mapDeps([0, 1, 2, 3, 4, 5, 6, 7, 8])),
    children: [{
        name: "",
        path: "/dashboard",
        component: () => Ya(( () => import("./CK8fVlpN-1734942186556.js")), __vite__mapDeps([9, 1, 10, 11, 12, 13, 5, 14]))
    }, {
        name: "",
        path: "/order",
        component: () => Ya(( () => import("./BbmWxrVm-1734942186556.js")), __vite__mapDeps([15, 12, 13, 1, 16, 17, 18]))
    }, {
        name: "",
        path: "/ticket",
        component: () => Ya(( () => import("./DkxBSZrA-1734942186556.js")), __vite__mapDeps([19, 12, 13, 1, 20, 17, 18]))
    }, {
        name: "",
        path: "/knowledge",
        component: () => Ya(( () => import("./Bv-Hqr6V-1734942186556.js")), __vite__mapDeps([21, 12, 13, 1, 22]))
    }, {
        name: "",
        path: "/knowledge/:id",
        component: () => Ya(( () => import("./BTdDI8VH-1734942186556.js")), __vite__mapDeps([23, 12, 13, 24, 1, 11, 25]))
    }, {
        name: "",
        path: "/profile",
        component: () => Ya(( () => import("./DBmgIBkK-1734942186556.js")), __vite__mapDeps([26, 12, 13, 1, 24, 27, 17]))
    }, {
        name: "",
        path: "/invite",
        component: () => Ya(( () => import("./Dx1jtChx-1734942186556.js")), __vite__mapDeps([28, 7, 12, 13, 1, 29, 30, 17, 18]))
    }, {
        name: "",
        path: "/traffic",
        component: () => Ya(( () => import("./q7-UOM5J-1734942186556.js")), __vite__mapDeps([31, 32, 1, 4, 12, 13, 33, 17, 18]))
    }, {
        name: "",
        path: "/node",
        component: () => Ya(( () => import("./B_J_lvoV-1734942186556.js")), __vite__mapDeps([34, 32, 1, 12, 13, 10, 35, 17, 18]))
    }, {
        name: "",
        path: "/appleid",
        component: () => Ya(( () => import("./DkMx9PLu-1734942186556.js")), __vite__mapDeps([36, 13, 1, 37]))
    }, {
        name: "S",
        path: "/docs",
        component: () => Ya(( () => import("./BwOW9MoH-1734942186556.js")), __vite__mapDeps([38, 1]))
    }, {
        name: "Pricing 1",
        path: "/plan",
        component: () => Ya(( () => import("./Ckr9O2VH-1734942186556.js")), __vite__mapDeps([39, 12, 13, 1, 40, 17]))
    }, {
        name: "Pricing2",
        path: "/plan/:id(\\d+)",
        component: () => Ya(( () => import("./CMvuvdfu-1734942186556.js")), __vite__mapDeps([41, 1, 12, 13, 42, 17]))
    }, {
        name: "Pricing2WithCycle",
        path: "/plan/:id/:cycle",
        component: () => Ya(( () => import("./CMvuvdfu-1734942186556.js")), __vite__mapDeps([41, 1, 12, 13, 42, 17]))
    }, {
        name: "",
        path: "/ticket/:id",
        component: () => Ya(( () => import("./ClyW5ei0-1734942186556.js")), __vite__mapDeps([43, 1, 12, 13, 29, 44]))
    }, {
        name: "Invoice details",
        path: "/order/:id",
        component: () => Ya(( () => import("./CNet2Hol-1734942186556.js")), __vite__mapDeps([45, 6, 1, 12, 13, 10, 46, 17]))
    }]
}
  , Ga = {
    path: "/auth",
    component: () => Ya(( () => import("./6mwn1y04-1734942186556.js")), __vite__mapDeps([47, 1, 2, 3])),
    meta: {
        requiresAuth: !1
    },
    children: [{
        path: "",
        redirect: "/login"
    }, {
        name: "Login 2",
        path: "/auth/login2",
        component: () => Ya(( () => import("./ByVawsvp-1734942186556.js")), __vite__mapDeps([48, 6, 1, 49, 12, 13, 50]))
    }, {
        name: "",
        path: "/login",
        component: () => Ya(( () => import("./heyoo-oC-1734942186556.js")), __vite__mapDeps([51, 6, 1, 49, 12, 13, 52])),
        beforeEnter: (e, t, a) => {
            Ya(( () => import("./CK8fVlpN-1734942186556.js")), __vite__mapDeps([9, 1, 10, 11, 12, 13, 5, 14])),
            a()
        }
    }, {
        name: "",
        path: "/register",
        component: () => Ya(( () => import("./aeIKCm5w-1734942186556.js")), __vite__mapDeps([53, 6, 1, 12, 13, 54]))
    }, {
        name: "",
        path: "/forgetpassword",
        component: () => Ya(( () => import("./BvFhacO9-1734942186556.js")), __vite__mapDeps([55, 6, 1, 12, 13, 56]))
    }, {
        name: "",
        path: "/pages/error777",
        component: () => Ya(( () => import("./CHt17t75-1734942186556.js")), __vite__mapDeps([57, 1, 58, 59]))
    }, {
        name: "Error 404",
        path: "/pages/error",
        component: () => Ya(( () => import("./DSHBoZvi-1734942186556.js")), __vite__mapDeps([60, 58, 1, 61]))
    }, {
        name: "Error 500",
        path: "/pages/error500",
        component: () => Ya(( () => import("./C2Vez5yY-1734942186556.js")), __vite__mapDeps([62, 1, 63]))
    }, {
        path: "/ua-check",
        component: () => Ya(( () => import("./B3U7qeKb-1734942186556.js")), __vite__mapDeps([64, 1, 65]))
    }]
}
  , ja = {
    get: $a("GET"),
    post: $a("POST"),
    put: $a("PUT"),
    delete: $a("DELETE")
};
function $a(e) {
    return (t, a) => {
        const i = {
            method: e,
            headers: Ua(t)
        };
        return a && (i.headers["Content-Type"] = "application/json",
        i.body = JSON.stringify(a)),
        fetch(t, i).then(qa)
    }
}
function Ua(e) {
    const {user: t} = Za()
      , a = !!(null == t ? void 0 : t.token)
      , i = e.startsWith(void 0);
    return a && i ? {
        Authorization: `Bearer ${t.token}`
    } : {}
}
function qa(e) {
    return e.text().then((t => {
        const a = t && JSON.parse(t);
        if (!e.ok) {
            const {user: t, logout: i} = Za();
            [401, 403].includes(e.status) && t && i();
            const n = a && a.message || e.statusText;
            return Promise.reject(n)
        }
        return a
    }
    ))
}
const Za = s({
    id: "auth",
    state: () => ({
        user: JSON.parse(localStorage.getItem("user") || "{}"),
        authData: localStorage.getItem("auth_data"),
        returnUrl: null
    }),
    actions: {
        async login(e, t) {
            const a = await ja.post("undefined/users/authenticate", {
                username: e,
                password: t
            });
            this.setUser(a),
            "/dashboard" !== Ja.currentRoute.value.path && Ja.push(this.returnUrl || "/dashboard")
        },
        logout() {
            var e, t;
            this.user = null,
            this.authData = null,
            localStorage.removeItem("user"),
            localStorage.removeItem("auth_data"),
            e = "/login",
            "hash" === (null == (t = window.APP_CONFIG.router) ? void 0 : t.mode) ? window.location.href = `/#${e}` : window.location.href = e
        },
        setAuthData(e) {
            this.authData = e,
            localStorage.setItem("auth_data", e)
        },
        setUser(e) {
            this.user = e,
            localStorage.setItem("user", JSON.stringify(e))
        }
    }
})
  , Ka = s("ui", ( () => ({
    isLoading: l(!1)
})))
  , Ja = c({
    history: u("/"),
    routes: [{
        path: "/",
        redirect: "/login"
    }, {
        path: "/:pathMatch(.*)*",
        redirect: "/dashboard"
    }, Wa, Ga]
});
function Qa() {
    const e = navigator.userAgent.toLowerCase();
    return /micromessenger/.test(e) || /qq/.test(e)
}
Ja.beforeEach((async (e, t, a) => {
    const i = ["/login", "/register", "/forgetpassword", "/auth/login2"]
      , n = "/ua-check";
    if (i.push(n),
    Qa() && e.path !== n)
        return a(n);
    if (!Qa() && e.path === n)
        return a("/login");
    const r = !i.includes(e.path)
      , o = localStorage.getItem("auth_data");
    return r ? o ? "/login" === e.path ? a("/dashboard") : a() : a("/login") : a()
}
)),
Ja.beforeEach(( () => {
    Ka().isLoading = !0
}
)),
Ja.afterEach(( () => {
    Ka().isLoading = !1
}
));
const ei = d({
    ...h(),
    ...p({
        fullHeight: !0
    }),
    ...v()
}, "VApp")
  , ti = g()({
    name: "VApp",
    props: ei(),
    setup(e, t) {
        let {slots: a} = t;
        const i = f(e)
          , {layoutClasses: n, getLayoutItem: r, items: o, layoutRef: s} = m(e)
          , {rtlClasses: l} = b();
        return x(( () => {
            var t;
            return y("div", {
                ref: s,
                class: ["v-application", i.themeClasses.value, n.value, l.value, e.class],
                style: [e.style]
            }, [y("div", {
                class: "v-application__wrap"
            }, [null == (t = a.default) ? void 0 : t.call(a)])])
        }
        )),
        {
            getLayoutItem: r,
            items: o,
            theme: i
        }
    }
})
  , ai = d({
    tag: {
        type: String,
        default: "div"
    }
}, "tag")
  , ii = d({
    text: String,
    ...h(),
    ...ai()
}, "VToolbarTitle")
  , ni = g()({
    name: "VToolbarTitle",
    props: ii(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => {
            const t = !!(a.default || a.text || e.text);
            return y(e.tag, {
                class: ["v-toolbar-title", e.class],
                style: e.style
            }, {
                default: () => {
                    var i;
                    return [t && y("div", {
                        class: "v-toolbar-title__placeholder"
                    }, [a.text ? a.text() : e.text, null == (i = a.default) ? void 0 : i.call(a)])]
                }
            })
        }
        )),
        {}
    }
})
  , ri = d({
    disabled: Boolean,
    group: Boolean,
    hideOnLeave: Boolean,
    leaveAbsolute: Boolean,
    mode: String,
    origin: String
}, "transition");
function oi(e, t, a) {
    return g()({
        name: e,
        props: ri({
            mode: a,
            origin: t
        }),
        setup(t, a) {
            let {slots: i} = a;
            const n = {
                onBeforeEnter(e) {
                    t.origin && (e.style.transformOrigin = t.origin)
                },
                onLeave(e) {
                    if (t.leaveAbsolute) {
                        const {offsetTop: t, offsetLeft: a, offsetWidth: i, offsetHeight: n} = e;
                        e._transitionInitialStyles = {
                            position: e.style.position,
                            top: e.style.top,
                            left: e.style.left,
                            width: e.style.width,
                            height: e.style.height
                        },
                        e.style.position = "absolute",
                        e.style.top = `${t}px`,
                        e.style.left = `${a}px`,
                        e.style.width = `${i}px`,
                        e.style.height = `${n}px`
                    }
                    t.hideOnLeave && e.style.setProperty("display", "none", "important")
                },
                onAfterLeave(e) {
                    if (t.leaveAbsolute && (null == e ? void 0 : e._transitionInitialStyles)) {
                        const {position: t, top: a, left: i, width: n, height: r} = e._transitionInitialStyles;
                        delete e._transitionInitialStyles,
                        e.style.position = t || "",
                        e.style.top = a || "",
                        e.style.left = i || "",
                        e.style.width = n || "",
                        e.style.height = r || ""
                    }
                }
            };
            return () => {
                const a = t.group ? w : k;
                return S(a, {
                    name: t.disabled ? "" : e,
                    css: !t.disabled,
                    ...t.group ? void 0 : {
                        mode: t.mode
                    },
                    ...t.disabled ? {} : n
                }, i.default)
            }
        }
    })
}
function si(e, t) {
    let a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "in-out";
    return g()({
        name: e,
        props: {
            mode: {
                type: String,
                default: a
            },
            disabled: Boolean
        },
        setup(a, i) {
            let {slots: n} = i;
            return () => S(k, {
                name: a.disabled ? "" : e,
                css: !a.disabled,
                ...a.disabled ? {} : t
            }, n.default)
        }
    })
}
function li() {
    let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
    const t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1] ? "width" : "height"
      , a = C(`offset-${t}`);
    return {
        onBeforeEnter(e) {
            e._parent = e.parentNode,
            e._initialStyle = {
                transition: e.style.transition,
                overflow: e.style.overflow,
                [t]: e.style[t]
            }
        },
        onEnter(i) {
            const n = i._initialStyle;
            i.style.setProperty("transition", "none", "important"),
            i.style.overflow = "hidden";
            const r = `${i[a]}px`;
            i.style[t] = "0",
            i.offsetHeight,
            i.style.transition = n.transition,
            e && i._parent && i._parent.classList.add(e),
            requestAnimationFrame(( () => {
                i.style[t] = r
            }
            ))
        },
        onAfterEnter: n,
        onEnterCancelled: n,
        onLeave(e) {
            e._initialStyle = {
                transition: "",
                overflow: e.style.overflow,
                [t]: e.style[t]
            },
            e.style.overflow = "hidden",
            e.style[t] = `${e[a]}px`,
            e.offsetHeight,
            requestAnimationFrame(( () => e.style[t] = "0"))
        },
        onAfterLeave: i,
        onLeaveCancelled: i
    };
    function i(t) {
        e && t._parent && t._parent.classList.remove(e),
        n(t)
    }
    function n(e) {
        const a = e._initialStyle[t];
        e.style.overflow = e._initialStyle.overflow,
        null != a && (e.style[t] = a),
        delete e._initialStyle
    }
}
const ci = d({
    target: [Object, Array]
}, "v-dialog-transition")
  , ui = g()({
    name: "VDialogTransition",
    props: ci(),
    setup(e, t) {
        let {slots: a} = t;
        const i = {
            onBeforeEnter(e) {
                e.style.pointerEvents = "none",
                e.style.visibility = "hidden"
            },
            async onEnter(t, a) {
                var i;
                await new Promise((e => requestAnimationFrame(e))),
                await new Promise((e => requestAnimationFrame(e))),
                t.style.visibility = "";
                const {x: n, y: r, sx: o, sy: s, speed: l} = hi(e.target, t)
                  , c = P(t, [{
                    transform: `translate(${n}px, ${r}px) scale(${o}, ${s})`,
                    opacity: 0
                }, {}], {
                    duration: 225 * l,
                    easing: L
                });
                null == (i = di(t)) || i.forEach((e => {
                    P(e, [{
                        opacity: 0
                    }, {
                        opacity: 0,
                        offset: .33
                    }, {}], {
                        duration: 450 * l,
                        easing: I
                    })
                }
                )),
                c.finished.then(( () => a()))
            },
            onAfterEnter(e) {
                e.style.removeProperty("pointer-events")
            },
            onBeforeLeave(e) {
                e.style.pointerEvents = "none"
            },
            async onLeave(t, a) {
                var i;
                await new Promise((e => requestAnimationFrame(e)));
                const {x: n, y: r, sx: o, sy: s, speed: l} = hi(e.target, t);
                P(t, [{}, {
                    transform: `translate(${n}px, ${r}px) scale(${o}, ${s})`,
                    opacity: 0
                }], {
                    duration: 125 * l,
                    easing: _
                }).finished.then(( () => a())),
                null == (i = di(t)) || i.forEach((e => {
                    P(e, [{}, {
                        opacity: 0,
                        offset: .2
                    }, {
                        opacity: 0
                    }], {
                        duration: 250 * l,
                        easing: I
                    })
                }
                ))
            },
            onAfterLeave(e) {
                e.style.removeProperty("pointer-events")
            }
        };
        return () => e.target ? y(k, A({
            name: "dialog-transition"
        }, i, {
            css: !1
        }), a) : y(k, {
            name: "dialog-transition"
        }, a)
    }
});
function di(e) {
    var t;
    const a = null == (t = e.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) ? void 0 : t.children;
    return a && [...a]
}
function hi(e, t) {
    const a = T(e)
      , i = E(t)
      , [n,r] = getComputedStyle(t).transformOrigin.split(" ").map((e => parseFloat(e)))
      , [o,s] = getComputedStyle(t).getPropertyValue("--v-overlay-anchor-origin").split(" ");
    let l = a.left + a.width / 2;
    "left" === o || "left" === s ? l -= a.width / 2 : "right" !== o && "right" !== s || (l += a.width / 2);
    let c = a.top + a.height / 2;
    "top" === o || "top" === s ? c -= a.height / 2 : "bottom" !== o && "bottom" !== s || (c += a.height / 2);
    const u = a.width / i.width
      , d = a.height / i.height
      , h = Math.max(1, u, d)
      , p = u / h || 0
      , v = d / h || 0
      , g = i.width * i.height / (window.innerWidth * window.innerHeight)
      , f = g > .12 ? Math.min(1.5, 10 * (g - .12) + 1) : 1;
    return {
        x: l - (n + i.left),
        y: c - (r + i.top),
        sx: p,
        sy: v,
        speed: f
    }
}
const pi = oi("fab-transition", "center center", "out-in")
  , vi = oi("dialog-bottom-transition")
  , gi = oi("dialog-top-transition")
  , fi = oi("fade-transition")
  , mi = oi("scale-transition")
  , bi = oi("scroll-x-transition")
  , xi = oi("scroll-x-reverse-transition")
  , yi = oi("scroll-y-transition")
  , wi = oi("scroll-y-reverse-transition")
  , ki = oi("slide-x-transition")
  , Si = oi("slide-x-reverse-transition")
  , Ci = oi("slide-y-transition")
  , Ai = oi("slide-y-reverse-transition")
  , Pi = si("expand-transition", li())
  , Li = si("expand-x-transition", li("", !0))
  , Ii = d({
    defaults: Object,
    disabled: Boolean,
    reset: [Number, String],
    root: [Boolean, String],
    scoped: Boolean
}, "VDefaultsProvider")
  , _i = g(!1)({
    name: "VDefaultsProvider",
    props: Ii(),
    setup(e, t) {
        let {slots: a} = t;
        const {defaults: i, disabled: n, reset: r, root: o, scoped: s} = O(e);
        return V(i, {
            reset: r,
            root: o,
            scoped: s,
            disabled: n
        }),
        () => {
            var e;
            return null == (e = a.default) ? void 0 : e.call(a)
        }
    }
})
  , Ti = d({
    height: [Number, String],
    maxHeight: [Number, String],
    maxWidth: [Number, String],
    minHeight: [Number, String],
    minWidth: [Number, String],
    width: [Number, String]
}, "dimension");
function Ei(e) {
    return {
        dimensionStyles: F(( () => ({
            height: B(e.height),
            maxHeight: B(e.maxHeight),
            maxWidth: B(e.maxWidth),
            minHeight: B(e.minHeight),
            minWidth: B(e.minWidth),
            width: B(e.width)
        })))
    }
}
const Oi = d({
    aspectRatio: [String, Number],
    contentClass: String,
    inline: Boolean,
    ...h(),
    ...Ti()
}, "VResponsive")
  , Vi = g()({
    name: "VResponsive",
    props: Oi(),
    setup(e, t) {
        let {slots: a} = t;
        const {aspectStyles: i} = function(e) {
            return {
                aspectStyles: F(( () => {
                    const t = Number(e.aspectRatio);
                    return t ? {
                        paddingBottom: String(1 / t * 100) + "%"
                    } : void 0
                }
                ))
            }
        }(e)
          , {dimensionStyles: n} = Ei(e);
        return x(( () => {
            var t;
            return y("div", {
                class: ["v-responsive", {
                    "v-responsive--inline": e.inline
                }, e.class],
                style: [n.value, e.style]
            }, [y("div", {
                class: "v-responsive__sizer",
                style: i.value
            }, null), null == (t = a.additional) ? void 0 : t.call(a), a.default && y("div", {
                class: ["v-responsive__content", e.contentClass]
            }, [a.default()])])
        }
        )),
        {}
    }
});
function Fi(e) {
    return D(( () => {
        const t = []
          , a = {};
        if (e.value.background)
            if (R(e.value.background)) {
                if (a.backgroundColor = e.value.background,
                !e.value.text && N(e.value.background)) {
                    const t = z(e.value.background);
                    if (null == t.a || 1 === t.a) {
                        const e = H(t);
                        a.color = e,
                        a.caretColor = e
                    }
                }
            } else
                t.push(`bg-${e.value.background}`);
        return e.value.text && (R(e.value.text) ? (a.color = e.value.text,
        a.caretColor = e.value.text) : t.push(`text-${e.value.text}`)),
        {
            colorClasses: t,
            colorStyles: a
        }
    }
    ))
}
function Bi(e, t) {
    const a = F(( () => ({
        text: M(e) ? e.value : t ? e[t] : null
    })))
      , {colorClasses: i, colorStyles: n} = Fi(a);
    return {
        textColorClasses: i,
        textColorStyles: n
    }
}
function Mi(e, t) {
    const a = F(( () => ({
        background: M(e) ? e.value : t ? e[t] : null
    })))
      , {colorClasses: i, colorStyles: n} = Fi(a);
    return {
        backgroundColorClasses: i,
        backgroundColorStyles: n
    }
}
const Di = d({
    rounded: {
        type: [Boolean, Number, String],
        default: void 0
    },
    tile: Boolean
}, "rounded");
function Ri(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    return {
        roundedClasses: F(( () => {
            const a = M(e) ? e.value : e.rounded
              , i = M(e) ? e.value : e.tile
              , n = [];
            if (!0 === a || "" === a)
                n.push(`${t}--rounded`);
            else if ("string" == typeof a || 0 === a)
                for (const e of String(a).split(" "))
                    n.push(`rounded-${e}`);
            else
                i && n.push("rounded-0");
            return n
        }
        ))
    }
}
const Ni = d({
    transition: {
        type: [Boolean, String, Object],
        default: "fade-transition",
        validator: e => !0 !== e
    }
}, "transition")
  , zi = (e, t) => {
    let {slots: a} = t;
    const {transition: i, disabled: n, ...r} = e
      , {component: o=k, ...s} = "object" == typeof i ? i : {};
    return S(o, A("string" == typeof i ? {
        name: n ? "" : i
    } : s, r, {
        disabled: n
    }), a)
}
;
function Hi(e, t) {
    var a;
    const i = null == (a = e._observe) ? void 0 : a[t.instance.$.uid];
    i && (i.observer.unobserve(e),
    delete e._observe[t.instance.$.uid])
}
const Xi = {
    mounted: function(e, t) {
        if (!Y)
            return;
        const a = t.modifiers || {}
          , i = t.value
          , {handler: n, options: r} = "object" == typeof i ? i : {
            handler: i,
            options: {}
        }
          , o = new IntersectionObserver((function() {
            var i;
            let r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
              , o = arguments.length > 1 ? arguments[1] : void 0;
            const s = null == (i = e._observe) ? void 0 : i[t.instance.$.uid];
            if (!s)
                return;
            const l = r.some((e => e.isIntersecting));
            !n || a.quiet && !s.init || a.once && !l && !s.init || n(l, r, o),
            l && a.once ? Hi(e, t) : s.init = !0
        }
        ),r);
        e._observe = Object(e._observe),
        e._observe[t.instance.$.uid] = {
            init: !1,
            observer: o
        },
        o.observe(e)
    },
    unmounted: Hi
}
  , Yi = d({
    alt: String,
    cover: Boolean,
    color: String,
    draggable: {
        type: [Boolean, String],
        default: void 0
    },
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
        type: Object,
        default: () => ({
            root: void 0,
            rootMargin: void 0,
            threshold: void 0
        })
    },
    sizes: String,
    src: {
        type: [String, Object],
        default: ""
    },
    crossorigin: String,
    referrerpolicy: String,
    srcset: String,
    position: String,
    ...Oi(),
    ...h(),
    ...Di(),
    ...Ni()
}, "VImg")
  , Wi = g()({
    name: "VImg",
    directives: {
        intersect: Xi
    },
    props: Yi(),
    emits: {
        loadstart: e => !0,
        load: e => !0,
        error: e => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(W(e, "color"))
          , {roundedClasses: o} = Ri(e)
          , s = G("VImg")
          , c = j("")
          , u = l()
          , d = j(e.eager ? "loading" : "idle")
          , h = j()
          , p = j()
          , v = F(( () => e.src && "object" == typeof e.src ? {
            src: e.src.src,
            srcset: e.srcset || e.src.srcset,
            lazySrc: e.lazySrc || e.src.lazySrc,
            aspect: Number(e.aspectRatio || e.src.aspect || 0)
        } : {
            src: e.src,
            srcset: e.srcset,
            lazySrc: e.lazySrc,
            aspect: Number(e.aspectRatio || 0)
        }))
          , g = F(( () => v.value.aspect || h.value / p.value || 0));
        function f(t) {
            if ((!e.eager || !t) && (!Y || t || e.eager)) {
                if (d.value = "loading",
                v.value.lazySrc) {
                    const e = new Image;
                    e.src = v.value.lazySrc,
                    S(e, null)
                }
                v.value.src && q(( () => {
                    var e;
                    a("loadstart", (null == (e = u.value) ? void 0 : e.currentSrc) || v.value.src),
                    setTimeout(( () => {
                        var e;
                        if (!s.isUnmounted)
                            if (null == (e = u.value) ? void 0 : e.complete) {
                                if (u.value.naturalWidth || b(),
                                "error" === d.value)
                                    return;
                                g.value || S(u.value, null),
                                "loading" === d.value && m()
                            } else
                                g.value || S(u.value),
                                w()
                    }
                    ))
                }
                ))
            }
        }
        function m() {
            var e;
            s.isUnmounted || (w(),
            S(u.value),
            d.value = "loaded",
            a("load", (null == (e = u.value) ? void 0 : e.currentSrc) || v.value.src))
        }
        function b() {
            var e;
            s.isUnmounted || (d.value = "error",
            a("error", (null == (e = u.value) ? void 0 : e.currentSrc) || v.value.src))
        }
        function w() {
            const e = u.value;
            e && (c.value = e.currentSrc || e.src)
        }
        $(( () => e.src), ( () => {
            f("idle" !== d.value)
        }
        )),
        $(g, ( (e, t) => {
            !e && t && u.value && S(u.value)
        }
        )),
        U(( () => f()));
        let k = -1;
        function S(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 100;
            const a = () => {
                if (clearTimeout(k),
                s.isUnmounted)
                    return;
                const {naturalHeight: i, naturalWidth: n} = e;
                i || n ? (h.value = n,
                p.value = i) : e.complete || "loading" !== d.value || null == t ? (e.currentSrc.endsWith(".svg") || e.currentSrc.startsWith("data:image/svg+xml")) && (h.value = 1,
                p.value = 1) : k = window.setTimeout(a, t)
            }
            ;
            a()
        }
        Z(( () => {
            clearTimeout(k)
        }
        ));
        const C = F(( () => ({
            "v-img__img--cover": e.cover,
            "v-img__img--contain": !e.cover
        })))
          , P = () => {
            var t;
            if (!v.value.src || "idle" === d.value)
                return null;
            const a = y("img", {
                class: ["v-img__img", C.value],
                style: {
                    objectPosition: e.position
                },
                src: v.value.src,
                srcset: v.value.srcset,
                alt: e.alt,
                crossorigin: e.crossorigin,
                referrerpolicy: e.referrerpolicy,
                draggable: e.draggable,
                sizes: e.sizes,
                ref: u,
                onLoad: m,
                onError: b
            }, null)
              , n = null == (t = i.sources) ? void 0 : t.call(i);
            return y(zi, {
                transition: e.transition,
                appear: !0
            }, {
                default: () => [K(n ? y("picture", {
                    class: "v-img__picture"
                }, [n, a]) : a, [[ee, "loaded" === d.value]])]
            })
        }
          , L = () => y(zi, {
            transition: e.transition
        }, {
            default: () => [v.value.lazySrc && "loaded" !== d.value && y("img", {
                class: ["v-img__img", "v-img__img--preload", C.value],
                style: {
                    objectPosition: e.position
                },
                src: v.value.lazySrc,
                alt: e.alt,
                crossorigin: e.crossorigin,
                referrerpolicy: e.referrerpolicy,
                draggable: e.draggable
            }, null)]
        })
          , I = () => i.placeholder ? y(zi, {
            transition: e.transition,
            appear: !0
        }, {
            default: () => [("loading" === d.value || "error" === d.value && !i.error) && y("div", {
                class: "v-img__placeholder"
            }, [i.placeholder()])]
        }) : null
          , _ = () => i.error ? y(zi, {
            transition: e.transition,
            appear: !0
        }, {
            default: () => ["error" === d.value && y("div", {
                class: "v-img__error"
            }, [i.error()])]
        }) : null
          , T = () => e.gradient ? y("div", {
            class: "v-img__gradient",
            style: {
                backgroundImage: `linear-gradient(${e.gradient})`
            }
        }, null) : null
          , E = j(!1);
        {
            const e = $(g, (t => {
                t && (requestAnimationFrame(( () => {
                    requestAnimationFrame(( () => {
                        E.value = !0
                    }
                    ))
                }
                )),
                e())
            }
            ))
        }
        return x(( () => {
            const t = Vi.filterProps(e);
            return K(y(Vi, A({
                class: ["v-img", {
                    "v-img--booting": !E.value
                }, n.value, o.value, e.class],
                style: [{
                    width: B("auto" === e.width ? h.value : e.width)
                }, r.value, e.style]
            }, t, {
                aspectRatio: g.value,
                "aria-label": e.alt,
                role: e.alt ? "img" : void 0
            }), {
                additional: () => y(Q, null, [y(P, null, null), y(L, null, null), y(T, null, null), y(I, null, null), y(_, null, null)]),
                default: i.default
            }), [[J("intersect"), {
                handler: f,
                options: e.options
            }, null, {
                once: !0
            }]])
        }
        )),
        {
            currentSrc: c,
            image: u,
            state: d,
            naturalWidth: h,
            naturalHeight: p
        }
    }
})
  , Gi = d({
    border: [Boolean, Number, String]
}, "border");
function ji(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    return {
        borderClasses: F(( () => {
            const a = M(e) ? e.value : e.border
              , i = [];
            if (!0 === a || "" === a)
                i.push(`${t}--border`);
            else if ("string" == typeof a || 0 === a)
                for (const e of String(a).split(" "))
                    i.push(`border-${e}`);
            return i
        }
        ))
    }
}
const $i = d({
    elevation: {
        type: [Number, String],
        validator(e) {
            const t = parseInt(e);
            return !isNaN(t) && t >= 0 && t <= 24
        }
    }
}, "elevation");
function Ui(e) {
    return {
        elevationClasses: F(( () => {
            const t = M(e) ? e.value : e.elevation
              , a = [];
            return null == t || a.push(`elevation-${t}`),
            a
        }
        ))
    }
}
const qi = [null, "prominent", "default", "comfortable", "compact"]
  , Zi = d({
    absolute: Boolean,
    collapse: Boolean,
    color: String,
    density: {
        type: String,
        default: "default",
        validator: e => qi.includes(e)
    },
    extended: Boolean,
    extensionHeight: {
        type: [Number, String],
        default: 48
    },
    flat: Boolean,
    floating: Boolean,
    height: {
        type: [Number, String],
        default: 64
    },
    image: String,
    title: String,
    ...Gi(),
    ...h(),
    ...$i(),
    ...Di(),
    ...ai({
        tag: "header"
    }),
    ...v()
}, "VToolbar")
  , Ki = g()({
    name: "VToolbar",
    props: Zi(),
    setup(e, t) {
        var a;
        let {slots: i} = t;
        const {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(W(e, "color"))
          , {borderClasses: o} = ji(e)
          , {elevationClasses: s} = Ui(e)
          , {roundedClasses: l} = Ri(e)
          , {themeClasses: c} = f(e)
          , {rtlClasses: u} = b()
          , d = j(!(!e.extended && !(null == (a = i.extension) ? void 0 : a.call(i))))
          , h = F(( () => parseInt(Number(e.height) + ("prominent" === e.density ? Number(e.height) : 0) - ("comfortable" === e.density ? 8 : 0) - ("compact" === e.density ? 16 : 0), 10)))
          , p = F(( () => d.value ? parseInt(Number(e.extensionHeight) + ("prominent" === e.density ? Number(e.extensionHeight) : 0) - ("comfortable" === e.density ? 4 : 0) - ("compact" === e.density ? 8 : 0), 10) : 0));
        return V({
            VBtn: {
                variant: "text"
            }
        }),
        x(( () => {
            var t;
            const a = !(!e.title && !i.title)
              , v = !(!i.image && !e.image)
              , g = null == (t = i.extension) ? void 0 : t.call(i);
            return d.value = !(!e.extended && !g),
            y(e.tag, {
                class: ["v-toolbar", {
                    "v-toolbar--absolute": e.absolute,
                    "v-toolbar--collapse": e.collapse,
                    "v-toolbar--flat": e.flat,
                    "v-toolbar--floating": e.floating,
                    [`v-toolbar--density-${e.density}`]: !0
                }, n.value, o.value, s.value, l.value, c.value, u.value, e.class],
                style: [r.value, e.style]
            }, {
                default: () => [v && y("div", {
                    key: "image",
                    class: "v-toolbar__image"
                }, [i.image ? y(_i, {
                    key: "image-defaults",
                    disabled: !e.image,
                    defaults: {
                        VImg: {
                            cover: !0,
                            src: e.image
                        }
                    }
                }, i.image) : y(Wi, {
                    key: "image-img",
                    cover: !0,
                    src: e.image
                }, null)]), y(_i, {
                    defaults: {
                        VTabs: {
                            height: B(h.value)
                        }
                    }
                }, {
                    default: () => {
                        var t, n, r;
                        return [y("div", {
                            class: "v-toolbar__content",
                            style: {
                                height: B(h.value)
                            }
                        }, [i.prepend && y("div", {
                            class: "v-toolbar__prepend"
                        }, [null == (t = i.prepend) ? void 0 : t.call(i)]), a && y(ni, {
                            key: "title",
                            text: e.title
                        }, {
                            text: i.title
                        }), null == (n = i.default) ? void 0 : n.call(i), i.append && y("div", {
                            class: "v-toolbar__append"
                        }, [null == (r = i.append) ? void 0 : r.call(i)])])]
                    }
                }), y(_i, {
                    defaults: {
                        VTabs: {
                            height: B(p.value)
                        }
                    }
                }, {
                    default: () => [y(Pi, null, {
                        default: () => [d.value && y("div", {
                            class: "v-toolbar__extension",
                            style: {
                                height: B(p.value)
                            }
                        }, [g])]
                    })]
                })]
            })
        }
        )),
        {
            contentHeight: h,
            extensionHeight: p
        }
    }
})
  , Ji = d({
    scrollTarget: {
        type: String
    },
    scrollThreshold: {
        type: [String, Number],
        default: 300
    }
}, "scroll");
function Qi() {
    const e = j(!1);
    ae(( () => {
        window.requestAnimationFrame(( () => {
            e.value = !0
        }
        ))
    }
    ));
    return {
        ssrBootStyles: F(( () => e.value ? void 0 : {
            transition: "none !important"
        })),
        isBooted: ie(e)
    }
}
const en = d({
    scrollBehavior: String,
    modelValue: {
        type: Boolean,
        default: !0
    },
    location: {
        type: String,
        default: "top",
        validator: e => ["top", "bottom"].includes(e)
    },
    ...Zi(),
    ...ne(),
    ...Ji(),
    height: {
        type: [Number, String],
        default: 64
    }
}, "VAppBar")
  , tn = g()({
    name: "VAppBar",
    props: en(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = l()
          , n = re(e, "modelValue")
          , r = F(( () => {
            var t;
            const a = new Set((null == (t = e.scrollBehavior) ? void 0 : t.split(" ")) ?? []);
            return {
                hide: a.has("hide"),
                inverted: a.has("inverted"),
                collapse: a.has("collapse"),
                elevate: a.has("elevate"),
                fadeImage: a.has("fade-image")
            }
        }
        ))
          , o = F(( () => {
            const e = r.value;
            return e.hide || e.inverted || e.collapse || e.elevate || e.fadeImage || !n.value
        }
        ))
          , {currentScroll: s, scrollThreshold: c, isScrollingUp: u, scrollRatio: d} = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            const {canScroll: a} = t;
            let i = 0;
            const n = l(null)
              , r = j(0)
              , o = j(0)
              , s = j(0)
              , c = j(!1)
              , u = j(!1)
              , d = F(( () => Number(e.scrollThreshold)))
              , h = F(( () => te((d.value - r.value) / d.value || 0)))
              , p = () => {
                const e = n.value;
                !e || a && !a.value || (i = r.value,
                r.value = "window"in e ? e.pageYOffset : e.scrollTop,
                u.value = r.value < i,
                s.value = Math.abs(r.value - d.value))
            }
            ;
            return $(u, ( () => {
                o.value = o.value || r.value
            }
            )),
            $(c, ( () => {
                o.value = 0
            }
            )),
            ae(( () => {
                $(( () => e.scrollTarget), (e => {
                    var t;
                    const a = e ? document.querySelector(e) : window;
                    a && a !== n.value && (null == (t = n.value) || t.removeEventListener("scroll", p),
                    n.value = a,
                    n.value.addEventListener("scroll", p, {
                        passive: !0
                    }))
                }
                ), {
                    immediate: !0
                })
            }
            )),
            Z(( () => {
                var e;
                null == (e = n.value) || e.removeEventListener("scroll", p)
            }
            )),
            a && $(a, p, {
                immediate: !0
            }),
            {
                scrollThreshold: d,
                currentScroll: r,
                currentThreshold: s,
                isScrollActive: c,
                scrollRatio: h,
                isScrollingUp: u,
                savedScroll: o
            }
        }(e, {
            canScroll: o
        })
          , h = F(( () => e.collapse || r.value.collapse && (r.value.inverted ? d.value > 0 : 0 === d.value)))
          , p = F(( () => e.flat || r.value.elevate && (r.value.inverted ? s.value > 0 : 0 === s.value)))
          , v = F(( () => r.value.fadeImage ? r.value.inverted ? 1 - d.value : d.value : void 0))
          , g = F(( () => {
            var e, t;
            if (r.value.hide && r.value.inverted)
                return 0;
            return ((null == (e = i.value) ? void 0 : e.contentHeight) ?? 0) + ((null == (t = i.value) ? void 0 : t.extensionHeight) ?? 0)
        }
        ));
        oe(F(( () => !!e.scrollBehavior)), ( () => {
            le(( () => {
                r.value.hide ? r.value.inverted ? n.value = s.value > c.value : n.value = u.value || s.value < c.value : n.value = !0
            }
            ))
        }
        ));
        const {ssrBootStyles: f} = Qi()
          , {layoutItemStyles: m} = se({
            id: e.name,
            order: F(( () => parseInt(e.order, 10))),
            position: W(e, "location"),
            layoutSize: g,
            elementSize: j(void 0),
            active: n,
            absolute: W(e, "absolute")
        });
        return x(( () => {
            const t = Ki.filterProps(e);
            return y(Ki, A({
                ref: i,
                class: ["v-app-bar", {
                    "v-app-bar--bottom": "bottom" === e.location
                }, e.class],
                style: [{
                    ...m.value,
                    "--v-toolbar-image-opacity": v.value,
                    height: void 0,
                    ...f.value
                }, e.style]
            }, t, {
                collapse: h.value,
                flat: p.value
            }), a)
        }
        )),
        {}
    }
})
  , an = [null, "default", "comfortable", "compact"]
  , nn = d({
    density: {
        type: String,
        default: "default",
        validator: e => an.includes(e)
    }
}, "density");
function rn(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    return {
        densityClasses: F(( () => `${t}--density-${e.density}`))
    }
}
const on = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function sn(e, t) {
    return y(Q, null, [e && y("span", {
        key: "overlay",
        class: `${t}__overlay`
    }, null), y("span", {
        key: "underlay",
        class: `${t}__underlay`
    }, null)])
}
const ln = d({
    color: String,
    variant: {
        type: String,
        default: "elevated",
        validator: e => on.includes(e)
    }
}, "variant");
function cn(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    const a = F(( () => {
        const {variant: a} = r(e);
        return `${t}--variant-${a}`
    }
    ))
      , {colorClasses: i, colorStyles: n} = Fi(F(( () => {
        const {variant: t, color: a} = r(e);
        return {
            [["elevated", "flat"].includes(t) ? "background" : "text"]: a
        }
    }
    )));
    return {
        colorClasses: i,
        colorStyles: n,
        variantClasses: a
    }
}
const un = d({
    divided: Boolean,
    ...Gi(),
    ...h(),
    ...nn(),
    ...$i(),
    ...Di(),
    ...ai(),
    ...v(),
    ...ln()
}, "VBtnGroup")
  , dn = g()({
    name: "VBtnGroup",
    props: un(),
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {densityClasses: n} = rn(e)
          , {borderClasses: r} = ji(e)
          , {elevationClasses: o} = Ui(e)
          , {roundedClasses: s} = Ri(e);
        V({
            VBtn: {
                height: "auto",
                color: W(e, "color"),
                density: W(e, "density"),
                flat: !0,
                variant: W(e, "variant")
            }
        }),
        x(( () => y(e.tag, {
            class: ["v-btn-group", {
                "v-btn-group--divided": e.divided
            }, i.value, r.value, n.value, o.value, s.value, e.class],
            style: e.style
        }, a)))
    }
})
  , hn = d({
    modelValue: {
        type: null,
        default: void 0
    },
    multiple: Boolean,
    mandatory: [Boolean, String],
    max: Number,
    selectedClass: String,
    disabled: Boolean
}, "group")
  , pn = d({
    value: null,
    disabled: Boolean,
    selectedClass: String
}, "group-item");
function vn(e, t) {
    let a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    const i = G("useGroupItem");
    if (!i)
        throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
    const n = ce();
    ue(Symbol.for(`${t.description}:id`), n);
    const r = de(t, null);
    if (!r) {
        if (!a)
            return r;
        throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${t.description}`)
    }
    const o = W(e, "value")
      , s = F(( () => !(!r.disabled.value && !e.disabled)));
    r.register({
        id: n,
        value: o,
        disabled: s
    }, i),
    Z(( () => {
        r.unregister(n)
    }
    ));
    const l = F(( () => r.isSelected(n)))
      , c = F(( () => l.value && [r.selectedClass.value, e.selectedClass]));
    return $(l, (e => {
        i.emit("group:selected", {
            value: e
        })
    }
    ), {
        flush: "sync"
    }),
    {
        id: n,
        isSelected: l,
        toggle: () => r.select(n, !l.value),
        select: e => r.select(n, e),
        selectedClass: c,
        value: o,
        disabled: s,
        group: r
    }
}
function gn(e, t) {
    let a = !1;
    const i = he([])
      , n = re(e, "modelValue", [], (e => null == e ? [] : fn(i, ve(e))), (t => {
        const a = function(e, t) {
            const a = [];
            return t.forEach((t => {
                const i = e.findIndex((e => e.id === t));
                if (~i) {
                    const t = e[i];
                    a.push(null != t.value ? t.value : i)
                }
            }
            )),
            a
        }(i, t);
        return e.multiple ? a : a[0]
    }
    ))
      , o = G("useGroup");
    function s() {
        const t = i.find((e => !e.disabled));
        t && "force" === e.mandatory && !n.value.length && (n.value = [t.id])
    }
    function l(t) {
        if (e.multiple,
        n.value.length) {
            const e = n.value[0]
              , a = i.findIndex((t => t.id === e));
            let r = (a + t) % i.length
              , o = i[r];
            for (; o.disabled && r !== a; )
                r = (r + t) % i.length,
                o = i[r];
            if (o.disabled)
                return;
            n.value = [i[r].id]
        } else {
            const e = i.find((e => !e.disabled));
            e && (n.value = [e.id])
        }
    }
    ae(( () => {
        s()
    }
    )),
    Z(( () => {
        a = !0
    }
    ));
    const c = {
        register: function(e, a) {
            const n = e
              , s = Symbol.for(`${t.description}:id`)
              , l = ge(s, null == o ? void 0 : o.vnode).indexOf(a);
            null == r(n.value) && (n.value = l),
            l > -1 ? i.splice(l, 0, n) : i.push(n)
        },
        unregister: function(e) {
            if (a)
                return;
            s();
            const t = i.findIndex((t => t.id === e));
            i.splice(t, 1)
        },
        selected: n,
        select: function(t, a) {
            const r = i.find((e => e.id === t));
            if (!a || !(null == r ? void 0 : r.disabled))
                if (e.multiple) {
                    const i = n.value.slice()
                      , r = i.findIndex((e => e === t))
                      , o = ~r;
                    if (a = a ?? !o,
                    o && e.mandatory && i.length <= 1)
                        return;
                    if (!o && null != e.max && i.length + 1 > e.max)
                        return;
                    r < 0 && a ? i.push(t) : r >= 0 && !a && i.splice(r, 1),
                    n.value = i
                } else {
                    const i = n.value.includes(t);
                    if (e.mandatory && i)
                        return;
                    n.value = a ?? !i ? [t] : []
                }
        },
        disabled: W(e, "disabled"),
        prev: () => l(i.length - 1),
        next: () => l(1),
        isSelected: e => n.value.includes(e),
        selectedClass: F(( () => e.selectedClass)),
        items: F(( () => i)),
        getItemIndex: e => function(e, t) {
            const a = fn(e, [t]);
            return a.length ? e.findIndex((e => e.id === a[0])) : -1
        }(i, e)
    };
    return ue(t, c),
    c
}
function fn(e, t) {
    const a = [];
    return t.forEach((t => {
        const i = e.find((e => pe(t, e.value)))
          , n = e[t];
        null != (null == i ? void 0 : i.value) ? a.push(i.id) : null != n && a.push(n.id)
    }
    )),
    a
}
const mn = Symbol.for("vuetify:v-btn-toggle")
  , bn = d({
    ...un(),
    ...hn()
}, "VBtnToggle")
  , xn = g()({
    name: "VBtnToggle",
    props: bn(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {isSelected: i, next: n, prev: r, select: o, selected: s} = gn(e, mn);
        return x(( () => {
            const t = dn.filterProps(e);
            return y(dn, A({
                class: ["v-btn-toggle", e.class]
            }, t, {
                style: e.style
            }), {
                default: () => {
                    var e;
                    return [null == (e = a.default) ? void 0 : e.call(a, {
                        isSelected: i,
                        next: n,
                        prev: r,
                        select: o,
                        selected: s
                    })]
                }
            })
        }
        )),
        {
            next: n,
            prev: r,
            select: o
        }
    }
})
  , yn = ["x-small", "small", "default", "large", "x-large"]
  , wn = d({
    size: {
        type: [String, Number],
        default: "default"
    }
}, "size");
function kn(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    return D(( () => {
        let a, i;
        return fe(yn, e.size) ? a = `${t}--size-${e.size}` : e.size && (i = {
            width: B(e.size),
            height: B(e.size)
        }),
        {
            sizeClasses: a,
            sizeStyles: i
        }
    }
    ))
}
const Sn = d({
    color: String,
    start: Boolean,
    end: Boolean,
    icon: me,
    ...h(),
    ...wn(),
    ...ai({
        tag: "i"
    }),
    ...v()
}, "VIcon")
  , Cn = g()({
    name: "VIcon",
    props: Sn(),
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const n = l()
          , {themeClasses: r} = f(e)
          , {iconData: o} = be(F(( () => n.value || e.icon)))
          , {sizeClasses: s} = kn(e)
          , {textColorClasses: c, textColorStyles: u} = Bi(W(e, "color"));
        return x(( () => {
            var t, l;
            const d = null == (t = i.default) ? void 0 : t.call(i);
            return d && (n.value = null == (l = xe(d).filter((e => e.type === ye && e.children && "string" == typeof e.children))[0]) ? void 0 : l.children),
            y(o.value.component, {
                tag: e.tag,
                icon: o.value.icon,
                class: ["v-icon", "notranslate", r.value, s.value, c.value, {
                    "v-icon--clickable": !!a.onClick,
                    "v-icon--start": e.start,
                    "v-icon--end": e.end
                }, e.class],
                style: [s.value ? void 0 : {
                    fontSize: B(e.size),
                    height: B(e.size),
                    width: B(e.size)
                }, u.value, e.style],
                role: a.onClick ? "button" : void 0,
                "aria-hidden": !a.onClick
            }, {
                default: () => [d]
            })
        }
        )),
        {}
    }
});
function An(e, t) {
    const a = l()
      , i = j(!1);
    if (Y) {
        const n = new IntersectionObserver((t => {
            null == e || e(t, n),
            i.value = !!t.find((e => e.isIntersecting))
        }
        ),t);
        Z(( () => {
            n.disconnect()
        }
        )),
        $(a, ( (e, t) => {
            t && (n.unobserve(t),
            i.value = !1),
            e && n.observe(e)
        }
        ), {
            flush: "post"
        })
    }
    return {
        intersectionRef: a,
        isIntersecting: i
    }
}
const Pn = d({
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
        type: [Number, String],
        default: 0
    },
    rotate: {
        type: [Number, String],
        default: 0
    },
    width: {
        type: [Number, String],
        default: 4
    },
    ...h(),
    ...wn(),
    ...ai({
        tag: "div"
    }),
    ...v()
}, "VProgressCircular")
  , Ln = g()({
    name: "VProgressCircular",
    props: Pn(),
    setup(e, t) {
        let {slots: a} = t;
        const i = 2 * Math.PI * 20
          , n = l()
          , {themeClasses: r} = f(e)
          , {sizeClasses: o, sizeStyles: s} = kn(e)
          , {textColorClasses: c, textColorStyles: u} = Bi(W(e, "color"))
          , {textColorClasses: d, textColorStyles: h} = Bi(W(e, "bgColor"))
          , {intersectionRef: p, isIntersecting: v} = An()
          , {resizeRef: g, contentRect: m} = we()
          , b = F(( () => Math.max(0, Math.min(100, parseFloat(e.modelValue)))))
          , w = F(( () => Number(e.width)))
          , k = F(( () => s.value ? Number(e.size) : m.value ? m.value.width : Math.max(w.value, 32)))
          , S = F(( () => 20 / (1 - w.value / k.value) * 2))
          , C = F(( () => w.value / k.value * S.value))
          , A = F(( () => B((100 - b.value) / 100 * i)));
        return le(( () => {
            p.value = n.value,
            g.value = n.value
        }
        )),
        x(( () => y(e.tag, {
            ref: n,
            class: ["v-progress-circular", {
                "v-progress-circular--indeterminate": !!e.indeterminate,
                "v-progress-circular--visible": v.value,
                "v-progress-circular--disable-shrink": "disable-shrink" === e.indeterminate
            }, r.value, o.value, c.value, e.class],
            style: [s.value, u.value, e.style],
            role: "progressbar",
            "aria-valuemin": "0",
            "aria-valuemax": "100",
            "aria-valuenow": e.indeterminate ? void 0 : b.value
        }, {
            default: () => [y("svg", {
                style: {
                    transform: `rotate(calc(-90deg + ${Number(e.rotate)}deg))`
                },
                xmlns: "http://www.w3.org/2000/svg",
                viewBox: `0 0 ${S.value} ${S.value}`
            }, [y("circle", {
                class: ["v-progress-circular__underlay", d.value],
                style: h.value,
                fill: "transparent",
                cx: "50%",
                cy: "50%",
                r: 20,
                "stroke-width": C.value,
                "stroke-dasharray": i,
                "stroke-dashoffset": 0
            }, null), y("circle", {
                class: "v-progress-circular__overlay",
                fill: "transparent",
                cx: "50%",
                cy: "50%",
                r: 20,
                "stroke-width": C.value,
                "stroke-dasharray": i,
                "stroke-dashoffset": A.value
            }, null)]), a.default && y("div", {
                class: "v-progress-circular__content"
            }, [a.default({
                value: b.value
            })])]
        }))),
        {}
    }
})
  , In = {
    center: "center",
    top: "bottom",
    bottom: "top",
    left: "right",
    right: "left"
}
  , _n = d({
    location: String
}, "location");
function Tn(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
      , a = arguments.length > 2 ? arguments[2] : void 0;
    const {isRtl: i} = b();
    return {
        locationStyles: F(( () => {
            if (!e.location)
                return {};
            const {side: n, align: r} = ke(e.location.split(" ").length > 1 ? e.location : `${e.location} center`, i.value);
            function o(e) {
                return a ? a(e) : 0
            }
            const s = {};
            return "center" !== n && (t ? s[In[n]] = `calc(100% - ${o(n)}px)` : s[n] = 0),
            "center" !== r ? t ? s[In[r]] = `calc(100% - ${o(r)}px)` : s[r] = 0 : ("center" === n ? s.top = s.left = "50%" : s[{
                top: "left",
                bottom: "left",
                left: "top",
                right: "top"
            }[n]] = "50%",
            s.transform = {
                top: "translateX(-50%)",
                bottom: "translateX(-50%)",
                left: "translateY(-50%)",
                right: "translateY(-50%)",
                center: "translate(-50%, -50%)"
            }[n]),
            s
        }
        ))
    }
}
const En = d({
    absolute: Boolean,
    active: {
        type: Boolean,
        default: !0
    },
    bgColor: String,
    bgOpacity: [Number, String],
    bufferValue: {
        type: [Number, String],
        default: 0
    },
    clickable: Boolean,
    color: String,
    height: {
        type: [Number, String],
        default: 4
    },
    indeterminate: Boolean,
    max: {
        type: [Number, String],
        default: 100
    },
    modelValue: {
        type: [Number, String],
        default: 0
    },
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean,
    ...h(),
    ..._n({
        location: "top"
    }),
    ...Di(),
    ...ai(),
    ...v()
}, "VProgressLinear")
  , On = g()({
    name: "VProgressLinear",
    props: En(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , {isRtl: n, rtlClasses: r} = b()
          , {themeClasses: o} = f(e)
          , {locationStyles: s} = Tn(e)
          , {textColorClasses: l, textColorStyles: c} = Bi(e, "color")
          , {backgroundColorClasses: u, backgroundColorStyles: d} = Mi(F(( () => e.bgColor || e.color)))
          , {backgroundColorClasses: h, backgroundColorStyles: p} = Mi(e, "color")
          , {roundedClasses: v} = Ri(e)
          , {intersectionRef: g, isIntersecting: m} = An()
          , w = F(( () => parseInt(e.max, 10)))
          , S = F(( () => parseInt(e.height, 10)))
          , C = F(( () => parseFloat(e.bufferValue) / w.value * 100))
          , A = F(( () => parseFloat(i.value) / w.value * 100))
          , P = F(( () => n.value !== e.reverse))
          , L = F(( () => e.indeterminate ? "fade-transition" : "slide-x-transition"))
          , I = F(( () => null == e.bgOpacity ? e.bgOpacity : parseFloat(e.bgOpacity)));
        function _(e) {
            if (!g.value)
                return;
            const {left: t, right: a, width: n} = g.value.getBoundingClientRect()
              , r = P.value ? n - e.clientX + (a - n) : e.clientX - t;
            i.value = Math.round(r / n * w.value)
        }
        return x(( () => y(e.tag, {
            ref: g,
            class: ["v-progress-linear", {
                "v-progress-linear--absolute": e.absolute,
                "v-progress-linear--active": e.active && m.value,
                "v-progress-linear--reverse": P.value,
                "v-progress-linear--rounded": e.rounded,
                "v-progress-linear--rounded-bar": e.roundedBar,
                "v-progress-linear--striped": e.striped
            }, v.value, o.value, r.value, e.class],
            style: [{
                bottom: "bottom" === e.location ? 0 : void 0,
                top: "top" === e.location ? 0 : void 0,
                height: e.active ? B(S.value) : 0,
                "--v-progress-linear-height": B(S.value),
                ...s.value
            }, e.style],
            role: "progressbar",
            "aria-hidden": e.active ? "false" : "true",
            "aria-valuemin": "0",
            "aria-valuemax": e.max,
            "aria-valuenow": e.indeterminate ? void 0 : A.value,
            onClick: e.clickable && _
        }, {
            default: () => [e.stream && y("div", {
                key: "stream",
                class: ["v-progress-linear__stream", l.value],
                style: {
                    ...c.value,
                    [P.value ? "left" : "right"]: B(-S.value),
                    borderTop: `${B(S.value / 2)} dotted`,
                    opacity: I.value,
                    top: `calc(50% - ${B(S.value / 4)})`,
                    width: B(100 - C.value, "%"),
                    "--v-progress-linear-stream-to": B(S.value * (P.value ? 1 : -1))
                }
            }, null), y("div", {
                class: ["v-progress-linear__background", u.value],
                style: [d.value, {
                    opacity: I.value,
                    width: B(e.stream ? C.value : 100, "%")
                }]
            }, null), y(k, {
                name: L.value
            }, {
                default: () => [e.indeterminate ? y("div", {
                    class: "v-progress-linear__indeterminate"
                }, [["long", "short"].map((e => y("div", {
                    key: e,
                    class: ["v-progress-linear__indeterminate", e, h.value],
                    style: p.value
                }, null)))]) : y("div", {
                    class: ["v-progress-linear__determinate", h.value],
                    style: [p.value, {
                        width: B(A.value, "%")
                    }]
                }, null)]
            }), a.default && y("div", {
                class: "v-progress-linear__content"
            }, [a.default({
                value: A.value,
                buffer: C.value
            })])]
        }))),
        {}
    }
})
  , Vn = d({
    loading: [Boolean, String]
}, "loader");
function Fn(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    return {
        loaderClasses: F(( () => ({
            [`${t}--loading`]: e.loading
        })))
    }
}
function Bn(e, t) {
    var a;
    let {slots: i} = t;
    return y("div", {
        class: `${e.name}__loader`
    }, [(null == (a = i.default) ? void 0 : a.call(i, {
        color: e.color,
        isActive: e.active
    })) || y(On, {
        absolute: e.absolute,
        active: e.active,
        color: e.color,
        height: "2",
        indeterminate: !0
    }, null)])
}
const Mn = ["static", "relative", "fixed", "absolute", "sticky"]
  , Dn = d({
    position: {
        type: String,
        validator: e => Mn.includes(e)
    }
}, "position");
function Rn(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    return {
        positionClasses: F(( () => e.position ? `${t}--${e.position}` : void 0))
    }
}
function Nn() {
    var e, t;
    return null == (t = null == (e = G("useRouter")) ? void 0 : e.proxy) ? void 0 : t.$router
}
function zn(e, t) {
    const a = Se("RouterLink")
      , i = F(( () => !(!e.href && !e.to)))
      , n = F(( () => (null == i ? void 0 : i.value) || Ce(t, "click") || Ce(e, "click")));
    if ("string" == typeof a)
        return {
            isLink: i,
            isClickable: n,
            href: W(e, "href")
        };
    const r = e.to ? a.useLink(e) : void 0
      , o = function() {
        const e = G("useRoute");
        return F(( () => {
            var t;
            return null == (t = null == e ? void 0 : e.proxy) ? void 0 : t.$route
        }
        ))
    }();
    return {
        isLink: i,
        isClickable: n,
        route: null == r ? void 0 : r.route,
        navigate: null == r ? void 0 : r.navigate,
        isActive: r && F(( () => {
            var t, a, i;
            return e.exact ? o.value ? (null == (i = r.isExactActive) ? void 0 : i.value) && pe(r.route.value.query, o.value.query) : null == (a = r.isExactActive) ? void 0 : a.value : null == (t = r.isActive) ? void 0 : t.value
        }
        )),
        href: F(( () => e.to ? null == r ? void 0 : r.route.value.href : e.href))
    }
}
const Hn = d({
    href: String,
    replace: Boolean,
    to: [String, Object],
    exact: Boolean
}, "router");
let Xn = !1;
const Yn = Symbol("rippleStop");
function Wn(e, t) {
    e.style.transform = t,
    e.style.webkitTransform = t
}
function Gn(e) {
    return "TouchEvent" === e.constructor.name
}
function jn(e) {
    return "KeyboardEvent" === e.constructor.name
}
const $n = {
    show(e, t) {
        var a;
        let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        if (!(null == (a = null == t ? void 0 : t._ripple) ? void 0 : a.enabled))
            return;
        const n = document.createElement("span")
          , r = document.createElement("span");
        n.appendChild(r),
        n.className = "v-ripple__container",
        i.class && (n.className += ` ${i.class}`);
        const {radius: o, scale: s, x: l, y: c, centerX: u, centerY: d} = function(e, t) {
            var a;
            let i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
              , n = 0
              , r = 0;
            if (!jn(e)) {
                const a = t.getBoundingClientRect()
                  , i = Gn(e) ? e.touches[e.touches.length - 1] : e;
                n = i.clientX - a.left,
                r = i.clientY - a.top
            }
            let o = 0
              , s = .3;
            (null == (a = t._ripple) ? void 0 : a.circle) ? (s = .15,
            o = t.clientWidth / 2,
            o = i.center ? o : o + Math.sqrt((n - o) ** 2 + (r - o) ** 2) / 4) : o = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
            const l = (t.clientWidth - 2 * o) / 2 + "px"
              , c = (t.clientHeight - 2 * o) / 2 + "px";
            return {
                radius: o,
                scale: s,
                x: i.center ? l : n - o + "px",
                y: i.center ? c : r - o + "px",
                centerX: l,
                centerY: c
            }
        }(e, t, i)
          , h = 2 * o + "px";
        r.className = "v-ripple__animation",
        r.style.width = h,
        r.style.height = h,
        t.appendChild(n);
        const p = window.getComputedStyle(t);
        p && "static" === p.position && (t.style.position = "relative",
        t.dataset.previousPosition = "static"),
        r.classList.add("v-ripple__animation--enter"),
        r.classList.add("v-ripple__animation--visible"),
        Wn(r, `translate(${l}, ${c}) scale3d(${s},${s},${s})`),
        r.dataset.activated = String(performance.now()),
        setTimeout(( () => {
            r.classList.remove("v-ripple__animation--enter"),
            r.classList.add("v-ripple__animation--in"),
            Wn(r, `translate(${u}, ${d}) scale3d(1,1,1)`)
        }
        ), 0)
    },
    hide(e) {
        var t;
        if (!(null == (t = null == e ? void 0 : e._ripple) ? void 0 : t.enabled))
            return;
        const a = e.getElementsByClassName("v-ripple__animation");
        if (0 === a.length)
            return;
        const i = a[a.length - 1];
        if (i.dataset.isHiding)
            return;
        i.dataset.isHiding = "true";
        const n = performance.now() - Number(i.dataset.activated)
          , r = Math.max(250 - n, 0);
        setTimeout(( () => {
            i.classList.remove("v-ripple__animation--in"),
            i.classList.add("v-ripple__animation--out"),
            setTimeout(( () => {
                var t;
                1 === e.getElementsByClassName("v-ripple__animation").length && e.dataset.previousPosition && (e.style.position = e.dataset.previousPosition,
                delete e.dataset.previousPosition),
                (null == (t = i.parentNode) ? void 0 : t.parentNode) === e && e.removeChild(i.parentNode)
            }
            ), 300)
        }
        ), r)
    }
};
function Un(e) {
    return void 0 === e || !!e
}
function qn(e) {
    const t = {}
      , a = e.currentTarget;
    if ((null == a ? void 0 : a._ripple) && !a._ripple.touched && !e[Yn]) {
        if (e[Yn] = !0,
        Gn(e))
            a._ripple.touched = !0,
            a._ripple.isTouch = !0;
        else if (a._ripple.isTouch)
            return;
        if (t.center = a._ripple.centered || jn(e),
        a._ripple.class && (t.class = a._ripple.class),
        Gn(e)) {
            if (a._ripple.showTimerCommit)
                return;
            a._ripple.showTimerCommit = () => {
                $n.show(e, a, t)
            }
            ,
            a._ripple.showTimer = window.setTimeout(( () => {
                var e;
                (null == (e = null == a ? void 0 : a._ripple) ? void 0 : e.showTimerCommit) && (a._ripple.showTimerCommit(),
                a._ripple.showTimerCommit = null)
            }
            ), 80)
        } else
            $n.show(e, a, t)
    }
}
function Zn(e) {
    e[Yn] = !0
}
function Kn(e) {
    const t = e.currentTarget;
    if (null == t ? void 0 : t._ripple) {
        if (window.clearTimeout(t._ripple.showTimer),
        "touchend" === e.type && t._ripple.showTimerCommit)
            return t._ripple.showTimerCommit(),
            t._ripple.showTimerCommit = null,
            void (t._ripple.showTimer = window.setTimeout(( () => {
                Kn(e)
            }
            )));
        window.setTimeout(( () => {
            t._ripple && (t._ripple.touched = !1)
        }
        )),
        $n.hide(t)
    }
}
function Jn(e) {
    const t = e.currentTarget;
    (null == t ? void 0 : t._ripple) && (t._ripple.showTimerCommit && (t._ripple.showTimerCommit = null),
    window.clearTimeout(t._ripple.showTimer))
}
let Qn = !1;
function er(e) {
    Qn || e.keyCode !== Ie.enter && e.keyCode !== Ie.space || (Qn = !0,
    qn(e))
}
function tr(e) {
    Qn = !1,
    Kn(e)
}
function ar(e) {
    Qn && (Qn = !1,
    Kn(e))
}
function ir(e, t, a) {
    const {value: i, modifiers: n} = t
      , r = Un(i);
    if (r || $n.hide(e),
    e._ripple = e._ripple ?? {},
    e._ripple.enabled = r,
    e._ripple.centered = n.center,
    e._ripple.circle = n.circle,
    Le(i) && i.class && (e._ripple.class = i.class),
    r && !a) {
        if (n.stop)
            return e.addEventListener("touchstart", Zn, {
                passive: !0
            }),
            void e.addEventListener("mousedown", Zn);
        e.addEventListener("touchstart", qn, {
            passive: !0
        }),
        e.addEventListener("touchend", Kn, {
            passive: !0
        }),
        e.addEventListener("touchmove", Jn, {
            passive: !0
        }),
        e.addEventListener("touchcancel", Kn),
        e.addEventListener("mousedown", qn),
        e.addEventListener("mouseup", Kn),
        e.addEventListener("mouseleave", Kn),
        e.addEventListener("keydown", er),
        e.addEventListener("keyup", tr),
        e.addEventListener("blur", ar),
        e.addEventListener("dragstart", Kn, {
            passive: !0
        })
    } else
        !r && a && nr(e)
}
function nr(e) {
    e.removeEventListener("mousedown", qn),
    e.removeEventListener("touchstart", qn),
    e.removeEventListener("touchend", Kn),
    e.removeEventListener("touchmove", Jn),
    e.removeEventListener("touchcancel", Kn),
    e.removeEventListener("mouseup", Kn),
    e.removeEventListener("mouseleave", Kn),
    e.removeEventListener("keydown", er),
    e.removeEventListener("keyup", tr),
    e.removeEventListener("dragstart", Kn),
    e.removeEventListener("blur", ar)
}
const rr = {
    mounted: function(e, t) {
        ir(e, t, !1)
    },
    unmounted: function(e) {
        delete e._ripple,
        nr(e)
    },
    updated: function(e, t) {
        if (t.value === t.oldValue)
            return;
        ir(e, t, Un(t.oldValue))
    }
}
  , or = d({
    active: {
        type: Boolean,
        default: void 0
    },
    symbol: {
        type: null,
        default: mn
    },
    flat: Boolean,
    icon: [Boolean, String, Function, Object],
    prependIcon: me,
    appendIcon: me,
    block: Boolean,
    slim: Boolean,
    stacked: Boolean,
    ripple: {
        type: [Boolean, Object],
        default: !0
    },
    text: String,
    ...Gi(),
    ...h(),
    ...nn(),
    ...Ti(),
    ...$i(),
    ...pn(),
    ...Vn(),
    ..._n(),
    ...Dn(),
    ...Di(),
    ...Hn(),
    ...wn(),
    ...ai({
        tag: "button"
    }),
    ...v(),
    ...ln({
        variant: "elevated"
    })
}, "VBtn")
  , sr = g()({
    name: "VBtn",
    directives: {
        Ripple: rr
    },
    props: or(),
    emits: {
        "group:selected": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const {themeClasses: n} = f(e)
          , {borderClasses: r} = ji(e)
          , {colorClasses: o, colorStyles: s, variantClasses: l} = cn(e)
          , {densityClasses: c} = rn(e)
          , {dimensionStyles: u} = Ei(e)
          , {elevationClasses: d} = Ui(e)
          , {loaderClasses: h} = Fn(e)
          , {locationStyles: p} = Tn(e)
          , {positionClasses: v} = Rn(e)
          , {roundedClasses: g} = Ri(e)
          , {sizeClasses: m, sizeStyles: b} = kn(e)
          , w = vn(e, e.symbol, !1)
          , k = zn(e, a)
          , S = F(( () => {
            var t;
            return void 0 !== e.active ? e.active : k.isLink.value ? null == (t = k.isActive) ? void 0 : t.value : null == w ? void 0 : w.isSelected.value
        }
        ))
          , C = F(( () => (null == w ? void 0 : w.disabled.value) || e.disabled))
          , A = F(( () => "elevated" === e.variant && !(e.disabled || e.flat || e.border)))
          , P = F(( () => {
            if (void 0 !== e.value && "symbol" != typeof e.value)
                return Object(e.value) === e.value ? JSON.stringify(e.value, null, 0) : e.value
        }
        ));
        function L(e) {
            var t;
            C.value || k.isLink.value && (e.metaKey || e.ctrlKey || e.shiftKey || 0 !== e.button || "_blank" === a.target) || (null == (t = k.navigate) || t.call(k, e),
            null == w || w.toggle())
        }
        return function(e, t) {
            $(( () => {
                var t;
                return null == (t = e.isActive) ? void 0 : t.value
            }
            ), (a => {
                e.isLink.value && a && t && q(( () => {
                    t(!0)
                }
                ))
            }
            ), {
                immediate: !0
            })
        }(k, null == w ? void 0 : w.select),
        x(( () => {
            var t, a;
            const f = k.isLink.value ? "a" : e.tag
              , x = !(!e.prependIcon && !i.prepend)
              , I = !(!e.appendIcon && !i.append)
              , _ = !(!e.icon || !0 === e.icon)
              , T = (null == w ? void 0 : w.isSelected.value) && (!k.isLink.value || (null == (t = k.isActive) ? void 0 : t.value)) || !w || (null == (a = k.isActive) ? void 0 : a.value);
            return K(y(f, {
                type: "a" === f ? void 0 : "button",
                class: ["v-btn", null == w ? void 0 : w.selectedClass.value, {
                    "v-btn--active": S.value,
                    "v-btn--block": e.block,
                    "v-btn--disabled": C.value,
                    "v-btn--elevated": A.value,
                    "v-btn--flat": e.flat,
                    "v-btn--icon": !!e.icon,
                    "v-btn--loading": e.loading,
                    "v-btn--slim": e.slim,
                    "v-btn--stacked": e.stacked
                }, n.value, r.value, T ? o.value : void 0, c.value, d.value, h.value, v.value, g.value, m.value, l.value, e.class],
                style: [T ? s.value : void 0, u.value, p.value, b.value, e.style],
                disabled: C.value || void 0,
                href: k.href.value,
                onClick: L,
                value: P.value
            }, {
                default: () => {
                    var t;
                    return [sn(!0, "v-btn"), !e.icon && x && y("span", {
                        key: "prepend",
                        class: "v-btn__prepend"
                    }, [i.prepend ? y(_i, {
                        key: "prepend-defaults",
                        disabled: !e.prependIcon,
                        defaults: {
                            VIcon: {
                                icon: e.prependIcon
                            }
                        }
                    }, i.prepend) : y(Cn, {
                        key: "prepend-icon",
                        icon: e.prependIcon
                    }, null)]), y("span", {
                        class: "v-btn__content",
                        "data-no-activator": ""
                    }, [!i.default && _ ? y(Cn, {
                        key: "content-icon",
                        icon: e.icon
                    }, null) : y(_i, {
                        key: "content-defaults",
                        disabled: !_,
                        defaults: {
                            VIcon: {
                                icon: e.icon
                            }
                        }
                    }, {
                        default: () => {
                            var t;
                            return [(null == (t = i.default) ? void 0 : t.call(i)) ?? e.text]
                        }
                    })]), !e.icon && I && y("span", {
                        key: "append",
                        class: "v-btn__append"
                    }, [i.append ? y(_i, {
                        key: "append-defaults",
                        disabled: !e.appendIcon,
                        defaults: {
                            VIcon: {
                                icon: e.appendIcon
                            }
                        }
                    }, i.append) : y(Cn, {
                        key: "append-icon",
                        icon: e.appendIcon
                    }, null)]), !!e.loading && y("span", {
                        key: "loader",
                        class: "v-btn__loader"
                    }, [(null == (t = i.loader) ? void 0 : t.call(i)) ?? y(Ln, {
                        color: "boolean" == typeof e.loading ? void 0 : e.loading,
                        indeterminate: !0,
                        size: "23",
                        width: "2"
                    }, null)])]
                }
            }), [[J("ripple"), !C.value && e.ripple, null]])
        }
        )),
        {
            group: w
        }
    }
})
  , lr = d({
    ...or({
        icon: "$menu",
        variant: "text"
    })
}, "VAppBarNavIcon")
  , cr = g()({
    name: "VAppBarNavIcon",
    props: lr(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => y(sr, A(e, {
            class: ["v-app-bar-nav-icon"]
        }), a))),
        {}
    }
})
  , ur = g()({
    name: "VAppBarTitle",
    props: ii(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => y(ni, A(e, {
            class: "v-app-bar-title"
        }), a))),
        {}
    }
})
  , dr = _e("v-alert-title")
  , hr = ["success", "info", "warning", "error"]
  , pr = d({
    border: {
        type: [Boolean, String],
        validator: e => "boolean" == typeof e || ["top", "end", "bottom", "start"].includes(e)
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
        type: me,
        default: "$close"
    },
    closeLabel: {
        type: String,
        default: "$vuetify.close"
    },
    icon: {
        type: [Boolean, String, Function, Object],
        default: null
    },
    modelValue: {
        type: Boolean,
        default: !0
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
        type: String,
        validator: e => hr.includes(e)
    },
    ...h(),
    ...nn(),
    ...Ti(),
    ...$i(),
    ..._n(),
    ...Dn(),
    ...Di(),
    ...ai(),
    ...v(),
    ...ln({
        variant: "flat"
    })
}, "VAlert")
  , vr = g()({
    name: "VAlert",
    props: pr(),
    emits: {
        "click:close": e => !0,
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const n = re(e, "modelValue")
          , r = F(( () => {
            if (!1 !== e.icon)
                return e.type ? e.icon ?? `$${e.type}` : e.icon
        }
        ))
          , o = F(( () => ({
            color: e.color ?? e.type,
            variant: e.variant
        })))
          , {themeClasses: s} = f(e)
          , {colorClasses: l, colorStyles: c, variantClasses: u} = cn(o)
          , {densityClasses: d} = rn(e)
          , {dimensionStyles: h} = Ei(e)
          , {elevationClasses: p} = Ui(e)
          , {locationStyles: v} = Tn(e)
          , {positionClasses: g} = Rn(e)
          , {roundedClasses: m} = Ri(e)
          , {textColorClasses: b, textColorStyles: x} = Bi(W(e, "borderColor"))
          , {t: w} = Te()
          , k = F(( () => ({
            "aria-label": w(e.closeLabel),
            onClick(e) {
                n.value = !1,
                a("click:close", e)
            }
        })));
        return () => {
            const t = !(!i.prepend && !r.value)
              , a = !(!i.title && !e.title)
              , o = !(!i.close && !e.closable);
            return n.value && y(e.tag, {
                class: ["v-alert", e.border && {
                    "v-alert--border": !!e.border,
                    [`v-alert--border-${!0 === e.border ? "start" : e.border}`]: !0
                }, {
                    "v-alert--prominent": e.prominent
                }, s.value, l.value, d.value, p.value, g.value, m.value, u.value, e.class],
                style: [c.value, h.value, v.value, e.style],
                role: "alert"
            }, {
                default: () => {
                    var n, s;
                    return [sn(!1, "v-alert"), e.border && y("div", {
                        key: "border",
                        class: ["v-alert__border", b.value],
                        style: x.value
                    }, null), t && y("div", {
                        key: "prepend",
                        class: "v-alert__prepend"
                    }, [i.prepend ? y(_i, {
                        key: "prepend-defaults",
                        disabled: !r.value,
                        defaults: {
                            VIcon: {
                                density: e.density,
                                icon: r.value,
                                size: e.prominent ? 44 : 28
                            }
                        }
                    }, i.prepend) : y(Cn, {
                        key: "prepend-icon",
                        density: e.density,
                        icon: r.value,
                        size: e.prominent ? 44 : 28
                    }, null)]), y("div", {
                        class: "v-alert__content"
                    }, [a && y(dr, {
                        key: "title"
                    }, {
                        default: () => {
                            var t;
                            return [(null == (t = i.title) ? void 0 : t.call(i)) ?? e.title]
                        }
                    }), (null == (n = i.text) ? void 0 : n.call(i)) ?? e.text, null == (s = i.default) ? void 0 : s.call(i)]), i.append && y("div", {
                        key: "append",
                        class: "v-alert__append"
                    }, [i.append()]), o && y("div", {
                        key: "close",
                        class: "v-alert__close"
                    }, [i.close ? y(_i, {
                        key: "close-defaults",
                        defaults: {
                            VBtn: {
                                icon: e.closeIcon,
                                size: "x-small",
                                variant: "text"
                            }
                        }
                    }, {
                        default: () => {
                            var e;
                            return [null == (e = i.close) ? void 0 : e.call(i, {
                                props: k.value
                            })]
                        }
                    }) : y(sr, A({
                        key: "close-btn",
                        icon: e.closeIcon,
                        size: "x-small",
                        variant: "text"
                    }, k.value), null)])]
                }
            })
        }
    }
})
  , gr = d({
    start: Boolean,
    end: Boolean,
    icon: me,
    image: String,
    text: String,
    ...h(),
    ...nn(),
    ...Di(),
    ...wn(),
    ...ai(),
    ...v(),
    ...ln({
        variant: "flat"
    })
}, "VAvatar")
  , fr = g()({
    name: "VAvatar",
    props: gr(),
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {colorClasses: n, colorStyles: r, variantClasses: o} = cn(e)
          , {densityClasses: s} = rn(e)
          , {roundedClasses: l} = Ri(e)
          , {sizeClasses: c, sizeStyles: u} = kn(e);
        return x(( () => y(e.tag, {
            class: ["v-avatar", {
                "v-avatar--start": e.start,
                "v-avatar--end": e.end
            }, i.value, n.value, s.value, l.value, c.value, o.value, e.class],
            style: [r.value, u.value, e.style]
        }, {
            default: () => [a.default ? y(_i, {
                key: "content-defaults",
                defaults: {
                    VImg: {
                        cover: !0,
                        image: e.image
                    },
                    VIcon: {
                        icon: e.icon
                    }
                }
            }, {
                default: () => [a.default()]
            }) : e.image ? y(Wi, {
                key: "image",
                src: e.image,
                alt: "",
                cover: !0
            }, null) : e.icon ? y(Cn, {
                key: "icon",
                icon: e.icon
            }, null) : e.text, sn(!1, "v-avatar")]
        }))),
        {}
    }
})
  , mr = d({
    text: String,
    onClick: Ee(),
    ...h(),
    ...v()
}, "VLabel")
  , br = g()({
    name: "VLabel",
    props: mr(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => {
            var t;
            return y("label", {
                class: ["v-label", {
                    "v-label--clickable": !!e.onClick
                }, e.class],
                style: e.style,
                onClick: e.onClick
            }, [e.text, null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {}
    }
})
  , xr = Symbol.for("vuetify:selection-control-group")
  , yr = d({
    color: String,
    disabled: {
        type: Boolean,
        default: null
    },
    defaultsTarget: String,
    error: Boolean,
    id: String,
    inline: Boolean,
    falseIcon: me,
    trueIcon: me,
    ripple: {
        type: Boolean,
        default: !0
    },
    multiple: {
        type: Boolean,
        default: null
    },
    name: String,
    readonly: {
        type: Boolean,
        default: null
    },
    modelValue: null,
    type: String,
    valueComparator: {
        type: Function,
        default: pe
    },
    ...h(),
    ...nn(),
    ...v()
}, "SelectionControlGroup")
  , wr = d({
    ...yr({
        defaultsTarget: "VSelectionControl"
    })
}, "VSelectionControlGroup")
  , kr = g()({
    name: "VSelectionControlGroup",
    props: wr(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , n = ce()
          , r = F(( () => e.id || `v-selection-control-group-${n}`))
          , o = F(( () => e.name || r.value))
          , s = new Set;
        return ue(xr, {
            modelValue: i,
            forceUpdate: () => {
                s.forEach((e => e()))
            }
            ,
            onForceUpdate: e => {
                s.add(e),
                Pe(( () => {
                    s.delete(e)
                }
                ))
            }
        }),
        V({
            [e.defaultsTarget]: {
                color: W(e, "color"),
                disabled: W(e, "disabled"),
                density: W(e, "density"),
                error: W(e, "error"),
                inline: W(e, "inline"),
                modelValue: i,
                multiple: F(( () => !!e.multiple || null == e.multiple && Array.isArray(i.value))),
                name: o,
                falseIcon: W(e, "falseIcon"),
                trueIcon: W(e, "trueIcon"),
                readonly: W(e, "readonly"),
                ripple: W(e, "ripple"),
                type: W(e, "type"),
                valueComparator: W(e, "valueComparator")
            }
        }),
        x(( () => {
            var t;
            return y("div", {
                class: ["v-selection-control-group", {
                    "v-selection-control-group--inline": e.inline
                }, e.class],
                style: e.style,
                role: "radio" === e.type ? "radiogroup" : void 0
            }, [null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {}
    }
})
  , Sr = d({
    label: String,
    baseColor: String,
    trueValue: null,
    falseValue: null,
    value: null,
    ...h(),
    ...yr()
}, "VSelectionControl");
const Cr = g()({
    name: "VSelectionControl",
    directives: {
        Ripple: rr
    },
    inheritAttrs: !1,
    props: Sr(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const {group: n, densityClasses: r, icon: o, model: s, textColorClasses: c, textColorStyles: u, backgroundColorClasses: d, backgroundColorStyles: h, trueValue: p} = function(e) {
            const t = de(xr, void 0)
              , {densityClasses: a} = rn(e)
              , i = re(e, "modelValue")
              , n = F(( () => void 0 !== e.trueValue ? e.trueValue : void 0 === e.value || e.value))
              , r = F(( () => void 0 !== e.falseValue && e.falseValue))
              , o = F(( () => !!e.multiple || null == e.multiple && Array.isArray(i.value)))
              , s = F({
                get() {
                    const a = t ? t.modelValue.value : i.value;
                    return o.value ? ve(a).some((t => e.valueComparator(t, n.value))) : e.valueComparator(a, n.value)
                },
                set(a) {
                    if (e.readonly)
                        return;
                    const s = a ? n.value : r.value;
                    let l = s;
                    o.value && (l = a ? [...ve(i.value), s] : ve(i.value).filter((t => !e.valueComparator(t, n.value)))),
                    t ? t.modelValue.value = l : i.value = l
                }
            })
              , {textColorClasses: l, textColorStyles: c} = Bi(F(( () => {
                if (!e.error && !e.disabled)
                    return s.value ? e.color : e.baseColor
            }
            )))
              , {backgroundColorClasses: u, backgroundColorStyles: d} = Mi(F(( () => !s.value || e.error || e.disabled ? void 0 : e.color)))
              , h = F(( () => s.value ? e.trueIcon : e.falseIcon));
            return {
                group: t,
                densityClasses: a,
                trueValue: n,
                falseValue: r,
                model: s,
                textColorClasses: l,
                textColorStyles: c,
                backgroundColorClasses: u,
                backgroundColorStyles: d,
                icon: h
            }
        }(e)
          , v = ce()
          , g = j(!1)
          , f = j(!1)
          , m = l()
          , b = F(( () => e.id || `input-${v}`))
          , w = F(( () => !e.disabled && !e.readonly));
        function k(e) {
            w.value && (g.value = !0,
            !1 !== Ve(e.target, ":focus-visible") && (f.value = !0))
        }
        function S() {
            g.value = !1,
            f.value = !1
        }
        function C(e) {
            e.stopPropagation()
        }
        function P(t) {
            w.value && (e.readonly && n && q(( () => n.forceUpdate())),
            s.value = t.target.checked)
        }
        return null == n || n.onForceUpdate(( () => {
            m.value && (m.value.checked = s.value)
        }
        )),
        x(( () => {
            var t, n;
            const l = i.label ? i.label({
                label: e.label,
                props: {
                    for: b.value
                }
            }) : e.label
              , [v,x] = Oe(a)
              , w = y("input", A({
                ref: m,
                checked: s.value,
                disabled: !!e.disabled,
                id: b.value,
                onBlur: S,
                onFocus: k,
                onInput: P,
                "aria-disabled": !!e.disabled,
                type: e.type,
                value: p.value,
                name: e.name,
                "aria-checked": "checkbox" === e.type ? s.value : void 0
            }, x), null);
            return y("div", A({
                class: ["v-selection-control", {
                    "v-selection-control--dirty": s.value,
                    "v-selection-control--disabled": e.disabled,
                    "v-selection-control--error": e.error,
                    "v-selection-control--focused": g.value,
                    "v-selection-control--focus-visible": f.value,
                    "v-selection-control--inline": e.inline
                }, r.value, e.class]
            }, v, {
                style: e.style
            }), [y("div", {
                class: ["v-selection-control__wrapper", c.value],
                style: u.value
            }, [null == (t = i.default) ? void 0 : t.call(i, {
                backgroundColorClasses: d,
                backgroundColorStyles: h
            }), K(y("div", {
                class: ["v-selection-control__input"]
            }, [(null == (n = i.input) ? void 0 : n.call(i, {
                model: s,
                textColorClasses: c,
                textColorStyles: u,
                backgroundColorClasses: d,
                backgroundColorStyles: h,
                inputNode: w,
                icon: o.value,
                props: {
                    onFocus: k,
                    onBlur: S,
                    id: b.value
                }
            })) ?? y(Q, null, [o.value && y(Cn, {
                key: "icon",
                icon: o.value
            }, null), w])]), [[J("ripple"), e.ripple && [!e.disabled && !e.readonly, null, ["center", "circle"]]]])]), l && y(br, {
                for: b.value,
                onClick: C
            }, {
                default: () => [l]
            })])
        }
        )),
        {
            isFocused: g,
            input: m
        }
    }
})
  , Ar = d({
    indeterminate: Boolean,
    indeterminateIcon: {
        type: me,
        default: "$checkboxIndeterminate"
    },
    ...Sr({
        falseIcon: "$checkboxOff",
        trueIcon: "$checkboxOn"
    })
}, "VCheckboxBtn")
  , Pr = g()({
    name: "VCheckboxBtn",
    props: Ar(),
    emits: {
        "update:modelValue": e => !0,
        "update:indeterminate": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "indeterminate")
          , n = re(e, "modelValue");
        function r(e) {
            i.value && (i.value = !1)
        }
        const o = F(( () => i.value ? e.indeterminateIcon : e.falseIcon))
          , s = F(( () => i.value ? e.indeterminateIcon : e.trueIcon));
        return x(( () => {
            const t = Fe(Cr.filterProps(e), ["modelValue"]);
            return y(Cr, A(t, {
                modelValue: n.value,
                "onUpdate:modelValue": [e => n.value = e, r],
                class: ["v-checkbox-btn", e.class],
                style: e.style,
                type: "checkbox",
                falseIcon: o.value,
                trueIcon: s.value,
                "aria-checked": i.value ? "mixed" : void 0
            }), a)
        }
        )),
        {}
    }
});
function Lr(e) {
    const {t: t} = Te();
    return {
        InputIcon: function(a) {
            let {name: i} = a;
            const n = {
                prepend: "prependAction",
                prependInner: "prependAction",
                append: "appendAction",
                appendInner: "appendAction",
                clear: "clear"
            }[i]
              , r = e[`onClick:${i}`]
              , o = r && n ? t(`$vuetify.input.${n}`, e.label ?? "") : void 0;
            return y(Cn, {
                icon: e[`${i}Icon`],
                "aria-label": o,
                onClick: r
            }, null)
        }
    }
}
const Ir = d({
    active: Boolean,
    color: String,
    messages: {
        type: [Array, String],
        default: () => []
    },
    ...h(),
    ...Ni({
        transition: {
            component: Ci,
            leaveAbsolute: !0,
            group: !0
        }
    })
}, "VMessages")
  , _r = g()({
    name: "VMessages",
    props: Ir(),
    setup(e, t) {
        let {slots: a} = t;
        const i = F(( () => ve(e.messages)))
          , {textColorClasses: n, textColorStyles: r} = Bi(F(( () => e.color)));
        return x(( () => y(zi, {
            transition: e.transition,
            tag: "div",
            class: ["v-messages", n.value, e.class],
            style: [r.value, e.style],
            role: "alert",
            "aria-live": "polite"
        }, {
            default: () => [e.active && i.value.map(( (e, t) => y("div", {
                class: "v-messages__message",
                key: `${t}-${i.value}`
            }, [a.message ? a.message({
                message: e
            }) : e])))]
        }))),
        {}
    }
})
  , Tr = d({
    focused: Boolean,
    "onUpdate:focused": Ee()
}, "focus");
function Er(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X();
    const a = re(e, "focused");
    return {
        focusClasses: F(( () => ({
            [`${t}--focused`]: a.value
        }))),
        isFocused: a,
        focus: function() {
            a.value = !0
        },
        blur: function() {
            a.value = !1
        }
    }
}
const Or = Symbol.for("vuetify:form")
  , Vr = d({
    disabled: Boolean,
    fastFail: Boolean,
    readonly: Boolean,
    modelValue: {
        type: Boolean,
        default: null
    },
    validateOn: {
        type: String,
        default: "input"
    }
}, "form");
function Fr() {
    return de(Or, null)
}
const Br = d({
    disabled: {
        type: Boolean,
        default: null
    },
    error: Boolean,
    errorMessages: {
        type: [Array, String],
        default: () => []
    },
    maxErrors: {
        type: [Number, String],
        default: 1
    },
    name: String,
    label: String,
    readonly: {
        type: Boolean,
        default: null
    },
    rules: {
        type: Array,
        default: () => []
    },
    modelValue: null,
    validateOn: String,
    validationValue: null,
    ...Tr()
}, "validation");
function Mr(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : X()
      , a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : ce();
    const i = re(e, "modelValue")
      , n = F(( () => void 0 === e.validationValue ? i.value : e.validationValue))
      , o = Fr()
      , s = l([])
      , c = j(!0)
      , u = F(( () => !(!ve("" === i.value ? null : i.value).length && !ve("" === n.value ? null : n.value).length)))
      , d = F(( () => !!(e.disabled ?? (null == o ? void 0 : o.isDisabled.value))))
      , h = F(( () => !!(e.readonly ?? (null == o ? void 0 : o.isReadonly.value))))
      , p = F(( () => {
        var t;
        return (null == (t = e.errorMessages) ? void 0 : t.length) ? ve(e.errorMessages).concat(s.value).slice(0, Math.max(0, +e.maxErrors)) : s.value
    }
    ))
      , v = F(( () => {
        let t = (e.validateOn ?? (null == o ? void 0 : o.validateOn.value)) || "input";
        "lazy" === t && (t = "input lazy");
        const a = new Set((null == t ? void 0 : t.split(" ")) ?? []);
        return {
            blur: a.has("blur") || a.has("input"),
            input: a.has("input"),
            submit: a.has("submit"),
            lazy: a.has("lazy")
        }
    }
    ))
      , g = F(( () => {
        var t;
        return !e.error && !(null == (t = e.errorMessages) ? void 0 : t.length) && (!e.rules.length || (c.value ? !s.value.length && !v.value.lazy || null : !s.value.length))
    }
    ))
      , f = j(!1)
      , m = F(( () => ({
        [`${t}--error`]: !1 === g.value,
        [`${t}--dirty`]: u.value,
        [`${t}--disabled`]: d.value,
        [`${t}--readonly`]: h.value
    })))
      , b = F(( () => e.name ?? r(a)));
    function x() {
        i.value = null,
        q(y)
    }
    function y() {
        c.value = !0,
        v.value.lazy ? s.value = [] : w(!0)
    }
    async function w() {
        let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
        const a = [];
        f.value = !0;
        for (const i of e.rules) {
            if (a.length >= +(e.maxErrors ?? 1))
                break;
            const t = "function" == typeof i ? i : () => i
              , r = await t(n.value);
            !0 !== r && (!1 !== r && "string" != typeof r || a.push(r || ""))
        }
        return s.value = a,
        f.value = !1,
        c.value = t,
        s.value
    }
    return U(( () => {
        null == o || o.register({
            id: b.value,
            validate: w,
            reset: x,
            resetValidation: y
        })
    }
    )),
    Z(( () => {
        null == o || o.unregister(b.value)
    }
    )),
    ae((async () => {
        v.value.lazy || await w(!0),
        null == o || o.update(b.value, g.value, p.value)
    }
    )),
    oe(( () => v.value.input), ( () => {
        $(n, ( () => {
            if (null != n.value)
                w();
            else if (e.focused) {
                const t = $(( () => e.focused), (e => {
                    e || w(),
                    t()
                }
                ))
            }
        }
        ))
    }
    )),
    oe(( () => v.value.blur), ( () => {
        $(( () => e.focused), (e => {
            e || w()
        }
        ))
    }
    )),
    $([g, p], ( () => {
        null == o || o.update(b.value, g.value, p.value)
    }
    )),
    {
        errorMessages: p,
        isDirty: u,
        isDisabled: d,
        isReadonly: h,
        isPristine: c,
        isValid: g,
        isValidating: f,
        reset: x,
        resetValidation: y,
        validate: w,
        validationClasses: m
    }
}
const Dr = d({
    id: String,
    appendIcon: me,
    centerAffix: {
        type: Boolean,
        default: !0
    },
    prependIcon: me,
    hideDetails: [Boolean, String],
    hideSpinButtons: Boolean,
    hint: String,
    persistentHint: Boolean,
    messages: {
        type: [Array, String],
        default: () => []
    },
    direction: {
        type: String,
        default: "horizontal",
        validator: e => ["horizontal", "vertical"].includes(e)
    },
    "onClick:prepend": Ee(),
    "onClick:append": Ee(),
    ...h(),
    ...nn(),
    ...Br()
}, "VInput")
  , Rr = g()({
    name: "VInput",
    props: {
        ...Dr()
    },
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i, emit: n} = t;
        const {densityClasses: r} = rn(e)
          , {rtlClasses: o} = b()
          , {InputIcon: s} = Lr(e)
          , l = ce()
          , c = F(( () => e.id || `input-${l}`))
          , u = F(( () => `${c.value}-messages`))
          , {errorMessages: d, isDirty: h, isDisabled: p, isReadonly: v, isPristine: g, isValid: f, isValidating: m, reset: w, resetValidation: k, validate: S, validationClasses: C} = Mr(e, "v-input", c)
          , A = F(( () => ({
            id: c,
            messagesId: u,
            isDirty: h,
            isDisabled: p,
            isReadonly: v,
            isPristine: g,
            isValid: f,
            isValidating: m,
            reset: w,
            resetValidation: k,
            validate: S
        })))
          , P = F(( () => {
            var t;
            return (null == (t = e.errorMessages) ? void 0 : t.length) || !g.value && d.value.length ? d.value : e.hint && (e.persistentHint || e.focused) ? e.hint : e.messages
        }
        ));
        return x(( () => {
            var t, a, n, l;
            const c = !(!i.prepend && !e.prependIcon)
              , d = !(!i.append && !e.appendIcon)
              , h = P.value.length > 0
              , p = !e.hideDetails || "auto" === e.hideDetails && (h || !!i.details);
            return y("div", {
                class: ["v-input", `v-input--${e.direction}`, {
                    "v-input--center-affix": e.centerAffix,
                    "v-input--hide-spin-buttons": e.hideSpinButtons
                }, r.value, o.value, C.value, e.class],
                style: e.style
            }, [c && y("div", {
                key: "prepend",
                class: "v-input__prepend"
            }, [null == (t = i.prepend) ? void 0 : t.call(i, A.value), e.prependIcon && y(s, {
                key: "prepend-icon",
                name: "prepend"
            }, null)]), i.default && y("div", {
                class: "v-input__control"
            }, [null == (a = i.default) ? void 0 : a.call(i, A.value)]), d && y("div", {
                key: "append",
                class: "v-input__append"
            }, [e.appendIcon && y(s, {
                key: "append-icon",
                name: "append"
            }, null), null == (n = i.append) ? void 0 : n.call(i, A.value)]), p && y("div", {
                class: "v-input__details"
            }, [y(_r, {
                id: u.value,
                active: h,
                messages: P.value
            }, {
                message: i.message
            }), null == (l = i.details) ? void 0 : l.call(i, A.value)])])
        }
        )),
        {
            reset: w,
            resetValidation: k,
            validate: S,
            isValid: f,
            errorMessages: d
        }
    }
})
  , Nr = d({
    ...Dr(),
    ...Fe(Ar(), ["inline"])
}, "VCheckbox")
  , zr = g()({
    name: "VCheckbox",
    inheritAttrs: !1,
    props: Nr(),
    emits: {
        "update:modelValue": e => !0,
        "update:focused": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const n = re(e, "modelValue")
          , {isFocused: r, focus: o, blur: s} = Er(e)
          , l = ce()
          , c = F(( () => e.id || `checkbox-${l}`));
        return x(( () => {
            const [t,l] = Oe(a)
              , u = Rr.filterProps(e)
              , d = Pr.filterProps(e);
            return y(Rr, A({
                class: ["v-checkbox", e.class]
            }, t, u, {
                modelValue: n.value,
                "onUpdate:modelValue": e => n.value = e,
                id: c.value,
                focused: r.value,
                style: e.style
            }), {
                ...i,
                default: e => {
                    let {id: t, messagesId: a, isDisabled: r, isReadonly: c} = e;
                    return y(Pr, A(d, {
                        id: t.value,
                        "aria-describedby": a.value,
                        disabled: r.value,
                        readonly: c.value
                    }, l, {
                        modelValue: n.value,
                        "onUpdate:modelValue": e => n.value = e,
                        onFocus: o,
                        onBlur: s
                    }), i)
                }
            })
        }
        )),
        {}
    }
});
function Hr(e) {
    const t = Math.abs(e);
    return Math.sign(e) * (t / ((1 / .501 - 2) * (1 - t) + 1))
}
function Xr(e) {
    let {selectedElement: t, containerSize: a, contentSize: i, isRtl: n, currentScrollOffset: r, isHorizontal: o} = e;
    const s = o ? t.clientWidth : t.clientHeight
      , l = o ? t.offsetLeft : t.offsetTop
      , c = n && o ? i - l - s : l
      , u = a + r
      , d = s + c
      , h = .4 * s;
    return c <= r ? r = Math.max(c - h, 0) : u <= d && (r = Math.min(r - (u - d - h), i - a)),
    r
}
const Yr = Symbol.for("vuetify:v-slide-group")
  , Wr = d({
    centerActive: Boolean,
    direction: {
        type: String,
        default: "horizontal"
    },
    symbol: {
        type: null,
        default: Yr
    },
    nextIcon: {
        type: me,
        default: "$next"
    },
    prevIcon: {
        type: me,
        default: "$prev"
    },
    showArrows: {
        type: [Boolean, String],
        validator: e => "boolean" == typeof e || ["always", "desktop", "mobile"].includes(e)
    },
    ...h(),
    ...Be(),
    ...ai(),
    ...hn({
        selectedClass: "v-slide-group-item--active"
    })
}, "VSlideGroup")
  , Gr = g()({
    name: "VSlideGroup",
    props: Wr(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {isRtl: i} = b()
          , {displayClasses: n, mobile: r} = Me(e)
          , o = gn(e, e.symbol)
          , s = j(!1)
          , l = j(0)
          , c = j(0)
          , u = j(0)
          , d = F(( () => "horizontal" === e.direction))
          , {resizeRef: h, contentRect: p} = we()
          , {resizeRef: v, contentRect: g} = we()
          , f = F(( () => o.selected.value.length ? o.items.value.findIndex((e => e.id === o.selected.value[0])) : -1))
          , m = F(( () => o.selected.value.length ? o.items.value.findIndex((e => e.id === o.selected.value[o.selected.value.length - 1])) : -1));
        if (Ae) {
            let t = -1;
            $(( () => [o.selected.value, p.value, g.value, d.value]), ( () => {
                cancelAnimationFrame(t),
                t = requestAnimationFrame(( () => {
                    if (p.value && g.value) {
                        const e = d.value ? "width" : "height";
                        c.value = p.value[e],
                        u.value = g.value[e],
                        s.value = c.value + 1 < u.value
                    }
                    if (f.value >= 0 && v.value) {
                        const t = v.value.children[m.value];
                        0 !== f.value && s.value ? e.centerActive ? l.value = function(e) {
                            let {selectedElement: t, containerSize: a, contentSize: i, isRtl: n, isHorizontal: r} = e;
                            const o = r ? t.clientWidth : t.clientHeight
                              , s = r ? t.offsetLeft : t.offsetTop
                              , l = n && r ? i - s - o / 2 - a / 2 : s + o / 2 - a / 2;
                            return Math.min(i - a, Math.max(0, l))
                        }({
                            selectedElement: t,
                            containerSize: c.value,
                            contentSize: u.value,
                            isRtl: i.value,
                            isHorizontal: d.value
                        }) : s.value && (l.value = Xr({
                            selectedElement: t,
                            containerSize: c.value,
                            contentSize: u.value,
                            isRtl: i.value,
                            currentScrollOffset: l.value,
                            isHorizontal: d.value
                        })) : l.value = 0
                    }
                }
                ))
            }
            ))
        }
        const w = j(!1);
        let k = 0
          , S = 0;
        function C(e) {
            const t = d.value ? "clientX" : "clientY"
              , a = i.value && d.value ? -1 : 1;
            S = a * l.value,
            k = e.touches[0][t],
            w.value = !0
        }
        function A(e) {
            if (!s.value)
                return;
            const t = d.value ? "clientX" : "clientY"
              , a = i.value && d.value ? -1 : 1;
            l.value = a * (S + k - e.touches[0][t])
        }
        function P(e) {
            const t = u.value - c.value;
            l.value < 0 || !s.value ? l.value = 0 : l.value >= t && (l.value = t),
            w.value = !1
        }
        function L() {
            h.value && (h.value[d.value ? "scrollLeft" : "scrollTop"] = 0)
        }
        const I = j(!1);
        function _(e) {
            if (I.value = !0,
            s.value && v.value)
                for (const t of e.composedPath())
                    for (const e of v.value.children)
                        if (e === t)
                            return void (l.value = Xr({
                                selectedElement: e,
                                containerSize: c.value,
                                contentSize: u.value,
                                isRtl: i.value,
                                currentScrollOffset: l.value,
                                isHorizontal: d.value
                            }))
        }
        function T(e) {
            I.value = !1
        }
        function E(e) {
            var t;
            I.value || e.relatedTarget && (null == (t = v.value) ? void 0 : t.contains(e.relatedTarget)) || V()
        }
        function O(e) {
            v.value && (d.value ? "ArrowRight" === e.key ? V(i.value ? "prev" : "next") : "ArrowLeft" === e.key && V(i.value ? "next" : "prev") : "ArrowDown" === e.key ? V("next") : "ArrowUp" === e.key && V("prev"),
            "Home" === e.key ? V("first") : "End" === e.key && V("last"))
        }
        function V(e) {
            var t, a, i, n, r;
            if (v.value)
                if (e)
                    if ("next" === e) {
                        const e = null == (a = v.value.querySelector(":focus")) ? void 0 : a.nextElementSibling;
                        e ? e.focus() : V("first")
                    } else if ("prev" === e) {
                        const e = null == (i = v.value.querySelector(":focus")) ? void 0 : i.previousElementSibling;
                        e ? e.focus() : V("last")
                    } else
                        "first" === e ? null == (n = v.value.firstElementChild) || n.focus() : "last" === e && (null == (r = v.value.lastElementChild) || r.focus());
                else {
                    null == (t = De(v.value)[0]) || t.focus()
                }
        }
        function B(e) {
            const t = l.value + ("prev" === e ? -1 : 1) * c.value;
            l.value = te(t, 0, u.value - c.value)
        }
        const M = F(( () => {
            let e = l.value > u.value - c.value ? -(u.value - c.value) + Hr(u.value - c.value - l.value) : -l.value;
            l.value <= 0 && (e = Hr(-l.value));
            const t = i.value && d.value ? -1 : 1;
            return {
                transform: `translate${d.value ? "X" : "Y"}(${t * e}px)`,
                transition: w.value ? "none" : "",
                willChange: w.value ? "transform" : ""
            }
        }
        ))
          , D = F(( () => ({
            next: o.next,
            prev: o.prev,
            select: o.select,
            isSelected: o.isSelected
        })))
          , R = F(( () => {
            switch (e.showArrows) {
            case "always":
                return !0;
            case "desktop":
                return !r.value;
            case !0:
                return s.value || Math.abs(l.value) > 0;
            case "mobile":
                return r.value || s.value || Math.abs(l.value) > 0;
            default:
                return !r.value && (s.value || Math.abs(l.value) > 0)
            }
        }
        ))
          , N = F(( () => Math.abs(l.value) > 0))
          , z = F(( () => u.value > Math.abs(l.value) + c.value));
        return x(( () => y(e.tag, {
            class: ["v-slide-group", {
                "v-slide-group--vertical": !d.value,
                "v-slide-group--has-affixes": R.value,
                "v-slide-group--is-overflowing": s.value
            }, n.value, e.class],
            style: e.style,
            tabindex: I.value || o.selected.value.length ? -1 : 0,
            onFocus: E
        }, {
            default: () => {
                var t, n, r;
                return [R.value && y("div", {
                    key: "prev",
                    class: ["v-slide-group__prev", {
                        "v-slide-group__prev--disabled": !N.value
                    }],
                    onClick: () => N.value && B("prev")
                }, [(null == (t = a.prev) ? void 0 : t.call(a, D.value)) ?? y(fi, null, {
                    default: () => [y(Cn, {
                        icon: i.value ? e.nextIcon : e.prevIcon
                    }, null)]
                })]), y("div", {
                    key: "container",
                    ref: h,
                    class: "v-slide-group__container",
                    onScroll: L
                }, [y("div", {
                    ref: v,
                    class: "v-slide-group__content",
                    style: M.value,
                    onTouchstartPassive: C,
                    onTouchmovePassive: A,
                    onTouchendPassive: P,
                    onFocusin: _,
                    onFocusout: T,
                    onKeydown: O
                }, [null == (n = a.default) ? void 0 : n.call(a, D.value)])]), R.value && y("div", {
                    key: "next",
                    class: ["v-slide-group__next", {
                        "v-slide-group__next--disabled": !z.value
                    }],
                    onClick: () => z.value && B("next")
                }, [(null == (r = a.next) ? void 0 : r.call(a, D.value)) ?? y(fi, null, {
                    default: () => [y(Cn, {
                        icon: i.value ? e.prevIcon : e.nextIcon
                    }, null)]
                })])]
            }
        }))),
        {
            selected: o.selected,
            scrollTo: B,
            scrollOffset: l,
            focus: V
        }
    }
})
  , jr = Symbol.for("vuetify:v-chip-group")
  , $r = d({
    column: Boolean,
    filter: Boolean,
    valueComparator: {
        type: Function,
        default: pe
    },
    ...Wr(),
    ...h(),
    ...hn({
        selectedClass: "v-chip--selected"
    }),
    ...ai(),
    ...v(),
    ...ln({
        variant: "tonal"
    })
}, "VChipGroup")
  , Ur = g()({
    name: "VChipGroup",
    props: $r(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {isSelected: n, select: r, next: o, prev: s, selected: l} = gn(e, jr);
        return V({
            VChip: {
                color: W(e, "color"),
                disabled: W(e, "disabled"),
                filter: W(e, "filter"),
                variant: W(e, "variant")
            }
        }),
        x(( () => {
            const t = Gr.filterProps(e);
            return y(Gr, A(t, {
                class: ["v-chip-group", {
                    "v-chip-group--column": e.column
                }, i.value, e.class],
                style: e.style
            }), {
                default: () => {
                    var e;
                    return [null == (e = a.default) ? void 0 : e.call(a, {
                        isSelected: n,
                        select: r,
                        next: o,
                        prev: s,
                        selected: l.value
                    })]
                }
            })
        }
        )),
        {}
    }
})
  , qr = d({
    activeClass: String,
    appendAvatar: String,
    appendIcon: me,
    closable: Boolean,
    closeIcon: {
        type: me,
        default: "$delete"
    },
    closeLabel: {
        type: String,
        default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
        type: String,
        default: "$complete"
    },
    label: Boolean,
    link: {
        type: Boolean,
        default: void 0
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: me,
    ripple: {
        type: [Boolean, Object],
        default: !0
    },
    text: String,
    modelValue: {
        type: Boolean,
        default: !0
    },
    onClick: Ee(),
    onClickOnce: Ee(),
    ...Gi(),
    ...h(),
    ...nn(),
    ...$i(),
    ...pn(),
    ...Di(),
    ...Hn(),
    ...wn(),
    ...ai({
        tag: "span"
    }),
    ...v(),
    ...ln({
        variant: "tonal"
    })
}, "VChip")
  , Zr = g()({
    name: "VChip",
    directives: {
        Ripple: rr
    },
    props: qr(),
    emits: {
        "click:close": e => !0,
        "update:modelValue": e => !0,
        "group:selected": e => !0,
        click: e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const {t: r} = Te()
          , {borderClasses: o} = ji(e)
          , {colorClasses: s, colorStyles: l, variantClasses: c} = cn(e)
          , {densityClasses: u} = rn(e)
          , {elevationClasses: d} = Ui(e)
          , {roundedClasses: h} = Ri(e)
          , {sizeClasses: p} = kn(e)
          , {themeClasses: v} = f(e)
          , g = re(e, "modelValue")
          , m = vn(e, jr, !1)
          , b = zn(e, a)
          , x = F(( () => !1 !== e.link && b.isLink.value))
          , w = F(( () => !e.disabled && !1 !== e.link && (!!m || e.link || b.isClickable.value)))
          , k = F(( () => ({
            "aria-label": r(e.closeLabel),
            onClick(e) {
                e.stopPropagation(),
                g.value = !1,
                i("click:close", e)
            }
        })));
        function S(e) {
            var t;
            i("click", e),
            w.value && (null == (t = b.navigate) || t.call(b, e),
            null == m || m.toggle())
        }
        function C(e) {
            "Enter" !== e.key && " " !== e.key || (e.preventDefault(),
            S(e))
        }
        return () => {
            const t = b.isLink.value ? "a" : e.tag
              , a = !(!e.appendIcon && !e.appendAvatar)
              , i = !(!a && !n.append)
              , r = !(!n.close && !e.closable)
              , f = !(!n.filter && !e.filter) && m
              , P = !(!e.prependIcon && !e.prependAvatar)
              , L = !(!P && !n.prepend)
              , I = !m || m.isSelected.value;
            return g.value && K(y(t, {
                class: ["v-chip", {
                    "v-chip--disabled": e.disabled,
                    "v-chip--label": e.label,
                    "v-chip--link": w.value,
                    "v-chip--filter": f,
                    "v-chip--pill": e.pill
                }, v.value, o.value, I ? s.value : void 0, u.value, d.value, h.value, p.value, c.value, null == m ? void 0 : m.selectedClass.value, e.class],
                style: [I ? l.value : void 0, e.style],
                disabled: e.disabled || void 0,
                draggable: e.draggable,
                href: b.href.value,
                tabindex: w.value ? 0 : void 0,
                onClick: S,
                onKeydown: w.value && !x.value && C
            }, {
                default: () => {
                    var t;
                    return [sn(w.value, "v-chip"), f && y(Li, {
                        key: "filter"
                    }, {
                        default: () => [K(y("div", {
                            class: "v-chip__filter"
                        }, [n.filter ? y(_i, {
                            key: "filter-defaults",
                            disabled: !e.filterIcon,
                            defaults: {
                                VIcon: {
                                    icon: e.filterIcon
                                }
                            }
                        }, n.filter) : y(Cn, {
                            key: "filter-icon",
                            icon: e.filterIcon
                        }, null)]), [[ee, m.isSelected.value]])]
                    }), L && y("div", {
                        key: "prepend",
                        class: "v-chip__prepend"
                    }, [n.prepend ? y(_i, {
                        key: "prepend-defaults",
                        disabled: !P,
                        defaults: {
                            VAvatar: {
                                image: e.prependAvatar,
                                start: !0
                            },
                            VIcon: {
                                icon: e.prependIcon,
                                start: !0
                            }
                        }
                    }, n.prepend) : y(Q, null, [e.prependIcon && y(Cn, {
                        key: "prepend-icon",
                        icon: e.prependIcon,
                        start: !0
                    }, null), e.prependAvatar && y(fr, {
                        key: "prepend-avatar",
                        image: e.prependAvatar,
                        start: !0
                    }, null)])]), y("div", {
                        class: "v-chip__content",
                        "data-no-activator": ""
                    }, [(null == (t = n.default) ? void 0 : t.call(n, {
                        isSelected: null == m ? void 0 : m.isSelected.value,
                        selectedClass: null == m ? void 0 : m.selectedClass.value,
                        select: null == m ? void 0 : m.select,
                        toggle: null == m ? void 0 : m.toggle,
                        value: null == m ? void 0 : m.value.value,
                        disabled: e.disabled
                    })) ?? e.text]), i && y("div", {
                        key: "append",
                        class: "v-chip__append"
                    }, [n.append ? y(_i, {
                        key: "append-defaults",
                        disabled: !a,
                        defaults: {
                            VAvatar: {
                                end: !0,
                                image: e.appendAvatar
                            },
                            VIcon: {
                                end: !0,
                                icon: e.appendIcon
                            }
                        }
                    }, n.append) : y(Q, null, [e.appendIcon && y(Cn, {
                        key: "append-icon",
                        end: !0,
                        icon: e.appendIcon
                    }, null), e.appendAvatar && y(fr, {
                        key: "append-avatar",
                        end: !0,
                        image: e.appendAvatar
                    }, null)])]), r && y("button", A({
                        key: "close",
                        class: "v-chip__close",
                        type: "button"
                    }, k.value), [n.close ? y(_i, {
                        key: "close-defaults",
                        defaults: {
                            VIcon: {
                                icon: e.closeIcon,
                                size: "x-small"
                            }
                        }
                    }, n.close) : y(Cn, {
                        key: "close-icon",
                        icon: e.closeIcon,
                        size: "x-small"
                    }, null)])]
                }
            }), [[J("ripple"), w.value && e.ripple, null]])
        }
    }
})
  , Kr = Symbol.for("vuetify:list");
function Jr() {
    const e = de(Kr, {
        hasPrepend: j(!1),
        updateHasPrepend: () => null
    })
      , t = {
        hasPrepend: j(!1),
        updateHasPrepend: e => {
            e && (t.hasPrepend.value = e)
        }
    };
    return ue(Kr, t),
    e
}
function Qr() {
    return de(Kr, null)
}
const eo = {
    open: e => {
        let {id: t, value: a, opened: i, parents: n} = e;
        if (a) {
            const e = new Set;
            e.add(t);
            let a = n.get(t);
            for (; null != a; )
                e.add(a),
                a = n.get(a);
            return e
        }
        return i.delete(t),
        i
    }
    ,
    select: () => null
}
  , to = {
    open: e => {
        let {id: t, value: a, opened: i, parents: n} = e;
        if (a) {
            let e = n.get(t);
            for (i.add(t); null != e && e !== t; )
                i.add(e),
                e = n.get(e);
            return i
        }
        return i.delete(t),
        i
    }
    ,
    select: () => null
}
  , ao = {
    open: to.open,
    select: e => {
        let {id: t, value: a, opened: i, parents: n} = e;
        if (!a)
            return i;
        const r = [];
        let o = n.get(t);
        for (; null != o; )
            r.push(o),
            o = n.get(o);
        return new Set(r)
    }
}
  , io = e => {
    const t = {
        select: t => {
            let {id: a, value: i, selected: n} = t;
            if (a = Re(a),
            e && !i) {
                const e = Array.from(n.entries()).reduce(( (e, t) => {
                    let[a,i] = t;
                    return "on" === i ? [...e, a] : e
                }
                ), []);
                if (1 === e.length && e[0] === a)
                    return n
            }
            return n.set(a, i ? "on" : "off"),
            n
        }
        ,
        in: (e, a, i) => {
            let n = new Map;
            for (const r of e || [])
                n = t.select({
                    id: r,
                    value: !0,
                    selected: new Map(n),
                    children: a,
                    parents: i
                });
            return n
        }
        ,
        out: e => {
            const t = [];
            for (const [a,i] of e.entries())
                "on" === i && t.push(a);
            return t
        }
    };
    return t
}
  , no = e => {
    const t = io(e);
    return {
        select: e => {
            let {selected: a, id: i, ...n} = e;
            i = Re(i);
            const r = a.has(i) ? new Map([[i, a.get(i)]]) : new Map;
            return t.select({
                ...n,
                id: i,
                selected: r
            })
        }
        ,
        in: (e, a, i) => {
            let n = new Map;
            return (null == e ? void 0 : e.length) && (n = t.in(e.slice(0, 1), a, i)),
            n
        }
        ,
        out: (e, a, i) => t.out(e, a, i)
    }
}
  , ro = Symbol.for("vuetify:nested")
  , oo = {
    id: j(),
    root: {
        register: () => null,
        unregister: () => null,
        parents: l(new Map),
        children: l(new Map),
        open: () => null,
        openOnSelect: () => null,
        select: () => null,
        opened: l(new Set),
        selected: l(new Map),
        selectedValues: l([])
    }
}
  , so = d({
    selectStrategy: [String, Function],
    openStrategy: [String, Object],
    opened: Array,
    selected: Array,
    mandatory: Boolean
}, "nested")
  , lo = e => {
    let t = !1;
    const a = l(new Map)
      , i = l(new Map)
      , n = re(e, "opened", e.opened, (e => new Set(e)), (e => [...e.values()]))
      , r = F(( () => {
        if ("object" == typeof e.selectStrategy)
            return e.selectStrategy;
        switch (e.selectStrategy) {
        case "single-leaf":
            return (e => {
                const t = no(e);
                return {
                    select: e => {
                        let {id: a, selected: i, children: n, ...r} = e;
                        return a = Re(a),
                        n.has(a) ? i : t.select({
                            id: a,
                            selected: i,
                            children: n,
                            ...r
                        })
                    }
                    ,
                    in: t.in,
                    out: t.out
                }
            }
            )(e.mandatory);
        case "leaf":
            return (e => {
                const t = io(e);
                return {
                    select: e => {
                        let {id: a, selected: i, children: n, ...r} = e;
                        return a = Re(a),
                        n.has(a) ? i : t.select({
                            id: a,
                            selected: i,
                            children: n,
                            ...r
                        })
                    }
                    ,
                    in: t.in,
                    out: t.out
                }
            }
            )(e.mandatory);
        case "independent":
            return io(e.mandatory);
        case "single-independent":
            return no(e.mandatory);
        default:
            return (e => {
                const t = {
                    select: t => {
                        let {id: a, value: i, selected: n, children: r, parents: o} = t;
                        a = Re(a);
                        const s = new Map(n)
                          , l = [a];
                        for (; l.length; ) {
                            const e = l.shift();
                            n.set(e, i ? "on" : "off"),
                            r.has(e) && l.push(...r.get(e))
                        }
                        let c = o.get(a);
                        for (; c; ) {
                            const e = r.get(c)
                              , t = e.every((e => "on" === n.get(e)))
                              , a = e.every((e => !n.has(e) || "off" === n.get(e)));
                            n.set(c, t ? "on" : a ? "off" : "indeterminate"),
                            c = o.get(c)
                        }
                        return e && !i && 0 === Array.from(n.entries()).reduce(( (e, t) => {
                            let[a,i] = t;
                            return "on" === i ? [...e, a] : e
                        }
                        ), []).length ? s : n
                    }
                    ,
                    in: (e, a, i) => {
                        let n = new Map;
                        for (const r of e || [])
                            n = t.select({
                                id: r,
                                value: !0,
                                selected: new Map(n),
                                children: a,
                                parents: i
                            });
                        return n
                    }
                    ,
                    out: (e, t) => {
                        const a = [];
                        for (const [i,n] of e.entries())
                            "on" !== n || t.has(i) || a.push(i);
                        return a
                    }
                };
                return t
            }
            )(e.mandatory)
        }
    }
    ))
      , o = F(( () => {
        if ("object" == typeof e.openStrategy)
            return e.openStrategy;
        switch (e.openStrategy) {
        case "list":
            return ao;
        case "single":
            return eo;
        default:
            return to
        }
    }
    ))
      , s = re(e, "selected", e.selected, (e => r.value.in(e, a.value, i.value)), (e => r.value.out(e, a.value, i.value)));
    function c(e) {
        const t = [];
        let a = e;
        for (; null != a; )
            t.unshift(a),
            a = i.value.get(a);
        return t
    }
    Z(( () => {
        t = !0
    }
    ));
    const u = G("nested")
      , d = {
        id: j(),
        root: {
            opened: n,
            selected: s,
            selectedValues: F(( () => {
                const e = [];
                for (const [t,a] of s.value.entries())
                    "on" === a && e.push(t);
                return e
            }
            )),
            register: (e, t, n) => {
                t && e !== t && i.value.set(e, t),
                n && a.value.set(e, []),
                null != t && a.value.set(t, [...a.value.get(t) || [], e])
            }
            ,
            unregister: e => {
                if (t)
                    return;
                a.value.delete(e);
                const r = i.value.get(e);
                if (r) {
                    const t = a.value.get(r) ?? [];
                    a.value.set(r, t.filter((t => t !== e)))
                }
                i.value.delete(e),
                n.value.delete(e)
            }
            ,
            open: (e, t, r) => {
                u.emit("click:open", {
                    id: e,
                    value: t,
                    path: c(e),
                    event: r
                });
                const s = o.value.open({
                    id: e,
                    value: t,
                    opened: new Set(n.value),
                    children: a.value,
                    parents: i.value,
                    event: r
                });
                s && (n.value = s)
            }
            ,
            openOnSelect: (e, t, r) => {
                const l = o.value.select({
                    id: e,
                    value: t,
                    selected: new Map(s.value),
                    opened: new Set(n.value),
                    children: a.value,
                    parents: i.value,
                    event: r
                });
                l && (n.value = l)
            }
            ,
            select: (e, t, n) => {
                u.emit("click:select", {
                    id: e,
                    value: t,
                    path: c(e),
                    event: n
                });
                const o = r.value.select({
                    id: e,
                    value: t,
                    selected: new Map(s.value),
                    children: a.value,
                    parents: i.value,
                    event: n
                });
                o && (s.value = o),
                d.root.openOnSelect(e, t, n)
            }
            ,
            children: a,
            parents: i
        }
    };
    return ue(ro, d),
    d.root
}
  , co = (e, t) => {
    const a = de(ro, oo)
      , i = Symbol(ce())
      , n = F(( () => void 0 !== e.value ? e.value : i))
      , r = {
        ...a,
        id: n,
        open: (e, t) => a.root.open(n.value, e, t),
        openOnSelect: (e, t) => a.root.openOnSelect(n.value, e, t),
        isOpen: F(( () => a.root.opened.value.has(n.value))),
        parent: F(( () => a.root.parents.value.get(n.value))),
        select: (e, t) => a.root.select(n.value, e, t),
        isSelected: F(( () => "on" === a.root.selected.value.get(Re(n.value)))),
        isIndeterminate: F(( () => "indeterminate" === a.root.selected.value.get(n.value))),
        isLeaf: F(( () => !a.root.children.value.get(n.value))),
        isGroupActivator: a.isGroupActivator
    };
    return !a.isGroupActivator && a.root.register(n.value, a.id.value, t),
    Z(( () => {
        !a.isGroupActivator && a.root.unregister(n.value)
    }
    )),
    t && ue(ro, r),
    r
}
  , uo = Ne({
    name: "VListGroupActivator",
    setup(e, t) {
        let {slots: a} = t;
        return ( () => {
            const e = de(ro, oo);
            ue(ro, {
                ...e,
                isGroupActivator: !0
            })
        }
        )(),
        () => {
            var e;
            return null == (e = a.default) ? void 0 : e.call(a)
        }
    }
})
  , ho = d({
    activeColor: String,
    baseColor: String,
    color: String,
    collapseIcon: {
        type: me,
        default: "$collapse"
    },
    expandIcon: {
        type: me,
        default: "$expand"
    },
    prependIcon: me,
    appendIcon: me,
    fluid: Boolean,
    subgroup: Boolean,
    title: String,
    value: null,
    ...h(),
    ...ai()
}, "VListGroup")
  , po = g()({
    name: "VListGroup",
    props: ho(),
    setup(e, t) {
        let {slots: a} = t;
        const {isOpen: i, open: n, id: r} = co(W(e, "value"), !0)
          , o = F(( () => `v-list-group--id-${String(r.value)}`))
          , s = Qr()
          , {isBooted: l} = Qi();
        function c(e) {
            n(!i.value, e)
        }
        const u = F(( () => ({
            onClick: c,
            class: "v-list-group__header",
            id: o.value
        })))
          , d = F(( () => i.value ? e.collapseIcon : e.expandIcon))
          , h = F(( () => ({
            VListItem: {
                active: i.value,
                activeColor: e.activeColor,
                baseColor: e.baseColor,
                color: e.color,
                prependIcon: e.prependIcon || e.subgroup && d.value,
                appendIcon: e.appendIcon || !e.subgroup && d.value,
                title: e.title,
                value: e.value
            }
        })));
        return x(( () => y(e.tag, {
            class: ["v-list-group", {
                "v-list-group--prepend": null == s ? void 0 : s.hasPrepend.value,
                "v-list-group--fluid": e.fluid,
                "v-list-group--subgroup": e.subgroup,
                "v-list-group--open": i.value
            }, e.class],
            style: e.style
        }, {
            default: () => [a.activator && y(_i, {
                defaults: h.value
            }, {
                default: () => [y(uo, null, {
                    default: () => [a.activator({
                        props: u.value,
                        isOpen: i.value
                    })]
                })]
            }), y(zi, {
                transition: {
                    component: Pi
                },
                disabled: !l.value
            }, {
                default: () => {
                    var e;
                    return [K(y("div", {
                        class: "v-list-group__items",
                        role: "group",
                        "aria-labelledby": o.value
                    }, [null == (e = a.default) ? void 0 : e.call(a)]), [[ee, i.value]])]
                }
            })]
        }))),
        {}
    }
})
  , vo = _e("v-list-item-subtitle")
  , go = _e("v-list-item-title")
  , fo = d({
    active: {
        type: Boolean,
        default: void 0
    },
    activeClass: String,
    activeColor: String,
    appendAvatar: String,
    appendIcon: me,
    baseColor: String,
    disabled: Boolean,
    lines: String,
    link: {
        type: Boolean,
        default: void 0
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: me,
    ripple: {
        type: [Boolean, Object],
        default: !0
    },
    slim: Boolean,
    subtitle: [String, Number],
    title: [String, Number],
    value: null,
    onClick: Ee(),
    onClickOnce: Ee(),
    ...Gi(),
    ...h(),
    ...nn(),
    ...Ti(),
    ...$i(),
    ...Di(),
    ...Hn(),
    ...ai(),
    ...v(),
    ...ln({
        variant: "text"
    })
}, "VListItem")
  , mo = g()({
    name: "VListItem",
    directives: {
        Ripple: rr
    },
    props: fo(),
    emits: {
        click: e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i, emit: n} = t;
        const r = zn(e, a)
          , o = F(( () => void 0 === e.value ? r.href.value : e.value))
          , {select: s, isSelected: l, isIndeterminate: c, isGroupActivator: u, root: d, parent: h, openOnSelect: p} = co(o, !1)
          , v = Qr()
          , g = F(( () => {
            var t;
            return !1 !== e.active && (e.active || (null == (t = r.isActive) ? void 0 : t.value) || l.value)
        }
        ))
          , m = F(( () => !1 !== e.link && r.isLink.value))
          , b = F(( () => !e.disabled && !1 !== e.link && (e.link || r.isClickable.value || null != e.value && !!v)))
          , w = F(( () => e.rounded || e.nav))
          , k = F(( () => e.color ?? e.activeColor))
          , S = F(( () => ({
            color: g.value ? k.value ?? e.baseColor : e.baseColor,
            variant: e.variant
        })));
        $(( () => {
            var e;
            return null == (e = r.isActive) ? void 0 : e.value
        }
        ), (e => {
            e && null != h.value && d.open(h.value, !0),
            e && p(e)
        }
        ), {
            immediate: !0
        });
        const {themeClasses: C} = f(e)
          , {borderClasses: A} = ji(e)
          , {colorClasses: P, colorStyles: L, variantClasses: I} = cn(S)
          , {densityClasses: _} = rn(e)
          , {dimensionStyles: T} = Ei(e)
          , {elevationClasses: E} = Ui(e)
          , {roundedClasses: O} = Ri(w)
          , V = F(( () => e.lines ? `v-list-item--${e.lines}-line` : void 0))
          , B = F(( () => ({
            isActive: g.value,
            select: s,
            isSelected: l.value,
            isIndeterminate: c.value
        })));
        function M(t) {
            var a;
            n("click", t),
            !u && b.value && (null == (a = r.navigate) || a.call(r, t),
            null != e.value && s(!l.value, t))
        }
        function D(e) {
            "Enter" !== e.key && " " !== e.key || (e.preventDefault(),
            M(e))
        }
        return x(( () => {
            const t = m.value ? "a" : e.tag
              , a = i.title || null != e.title
              , n = i.subtitle || null != e.subtitle
              , o = !(!e.appendAvatar && !e.appendIcon)
              , s = !(!o && !i.append)
              , l = !(!e.prependAvatar && !e.prependIcon)
              , c = !(!l && !i.prepend);
            return null == v || v.updateHasPrepend(c),
            e.activeColor && ze("active-color", ["color", "base-color"]),
            K(y(t, {
                class: ["v-list-item", {
                    "v-list-item--active": g.value,
                    "v-list-item--disabled": e.disabled,
                    "v-list-item--link": b.value,
                    "v-list-item--nav": e.nav,
                    "v-list-item--prepend": !c && (null == v ? void 0 : v.hasPrepend.value),
                    "v-list-item--slim": e.slim,
                    [`${e.activeClass}`]: e.activeClass && g.value
                }, C.value, A.value, P.value, _.value, E.value, V.value, O.value, I.value, e.class],
                style: [L.value, T.value, e.style],
                href: r.href.value,
                tabindex: b.value ? v ? -2 : 0 : void 0,
                onClick: M,
                onKeydown: b.value && !m.value && D
            }, {
                default: () => {
                    var t;
                    return [sn(b.value || g.value, "v-list-item"), c && y("div", {
                        key: "prepend",
                        class: "v-list-item__prepend"
                    }, [i.prepend ? y(_i, {
                        key: "prepend-defaults",
                        disabled: !l,
                        defaults: {
                            VAvatar: {
                                density: e.density,
                                image: e.prependAvatar
                            },
                            VIcon: {
                                density: e.density,
                                icon: e.prependIcon
                            },
                            VListItemAction: {
                                start: !0
                            }
                        }
                    }, {
                        default: () => {
                            var e;
                            return [null == (e = i.prepend) ? void 0 : e.call(i, B.value)]
                        }
                    }) : y(Q, null, [e.prependAvatar && y(fr, {
                        key: "prepend-avatar",
                        density: e.density,
                        image: e.prependAvatar
                    }, null), e.prependIcon && y(Cn, {
                        key: "prepend-icon",
                        density: e.density,
                        icon: e.prependIcon
                    }, null)]), y("div", {
                        class: "v-list-item__spacer"
                    }, null)]), y("div", {
                        class: "v-list-item__content",
                        "data-no-activator": ""
                    }, [a && y(go, {
                        key: "title"
                    }, {
                        default: () => {
                            var t;
                            return [(null == (t = i.title) ? void 0 : t.call(i, {
                                title: e.title
                            })) ?? e.title]
                        }
                    }), n && y(vo, {
                        key: "subtitle"
                    }, {
                        default: () => {
                            var t;
                            return [(null == (t = i.subtitle) ? void 0 : t.call(i, {
                                subtitle: e.subtitle
                            })) ?? e.subtitle]
                        }
                    }), null == (t = i.default) ? void 0 : t.call(i, B.value)]), s && y("div", {
                        key: "append",
                        class: "v-list-item__append"
                    }, [i.append ? y(_i, {
                        key: "append-defaults",
                        disabled: !o,
                        defaults: {
                            VAvatar: {
                                density: e.density,
                                image: e.appendAvatar
                            },
                            VIcon: {
                                density: e.density,
                                icon: e.appendIcon
                            },
                            VListItemAction: {
                                end: !0
                            }
                        }
                    }, {
                        default: () => {
                            var e;
                            return [null == (e = i.append) ? void 0 : e.call(i, B.value)]
                        }
                    }) : y(Q, null, [e.appendIcon && y(Cn, {
                        key: "append-icon",
                        density: e.density,
                        icon: e.appendIcon
                    }, null), e.appendAvatar && y(fr, {
                        key: "append-avatar",
                        density: e.density,
                        image: e.appendAvatar
                    }, null)]), y("div", {
                        class: "v-list-item__spacer"
                    }, null)])]
                }
            }), [[J("ripple"), b.value && e.ripple]])
        }
        )),
        {}
    }
})
  , bo = d({
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String,
    ...h(),
    ...ai()
}, "VListSubheader")
  , xo = g()({
    name: "VListSubheader",
    props: bo(),
    setup(e, t) {
        let {slots: a} = t;
        const {textColorClasses: i, textColorStyles: n} = Bi(W(e, "color"));
        return x(( () => {
            const t = !(!a.default && !e.title);
            return y(e.tag, {
                class: ["v-list-subheader", {
                    "v-list-subheader--inset": e.inset,
                    "v-list-subheader--sticky": e.sticky
                }, i.value, e.class],
                style: [{
                    textColorStyles: n
                }, e.style]
            }, {
                default: () => {
                    var i;
                    return [t && y("div", {
                        class: "v-list-subheader__text"
                    }, [(null == (i = a.default) ? void 0 : i.call(a)) ?? e.title])]
                }
            })
        }
        )),
        {}
    }
})
  , yo = d({
    color: String,
    inset: Boolean,
    length: [Number, String],
    thickness: [Number, String],
    vertical: Boolean,
    ...h(),
    ...v()
}, "VDivider")
  , wo = g()({
    name: "VDivider",
    props: yo(),
    setup(e, t) {
        let {attrs: a} = t;
        const {themeClasses: i} = f(e)
          , {textColorClasses: n, textColorStyles: r} = Bi(W(e, "color"))
          , o = F(( () => {
            const t = {};
            return e.length && (t[e.vertical ? "maxHeight" : "maxWidth"] = B(e.length)),
            e.thickness && (t[e.vertical ? "borderRightWidth" : "borderTopWidth"] = B(e.thickness)),
            t
        }
        ));
        return x(( () => y("hr", {
            class: [{
                "v-divider": !0,
                "v-divider--inset": e.inset,
                "v-divider--vertical": e.vertical
            }, i.value, n.value, e.class],
            style: [o.value, r.value, e.style],
            "aria-orientation": a.role && "separator" !== a.role ? void 0 : e.vertical ? "vertical" : "horizontal",
            role: `${a.role || "separator"}`
        }, null))),
        {}
    }
})
  , ko = d({
    items: Array,
    returnObject: Boolean
}, "VListChildren")
  , So = g()({
    name: "VListChildren",
    props: ko(),
    setup(e, t) {
        let {slots: a} = t;
        return Jr(),
        () => {
            var t, i;
            return (null == (t = a.default) ? void 0 : t.call(a)) ?? (null == (i = e.items) ? void 0 : i.map((t => {
                var i, n;
                let {children: r, props: o, type: s, raw: l} = t;
                if ("divider" === s)
                    return (null == (i = a.divider) ? void 0 : i.call(a, {
                        props: o
                    })) ?? y(wo, o, null);
                if ("subheader" === s)
                    return (null == (n = a.subheader) ? void 0 : n.call(a, {
                        props: o
                    })) ?? y(xo, o, null);
                const c = {
                    subtitle: a.subtitle ? e => {
                        var t;
                        return null == (t = a.subtitle) ? void 0 : t.call(a, {
                            ...e,
                            item: l
                        })
                    }
                    : void 0,
                    prepend: a.prepend ? e => {
                        var t;
                        return null == (t = a.prepend) ? void 0 : t.call(a, {
                            ...e,
                            item: l
                        })
                    }
                    : void 0,
                    append: a.append ? e => {
                        var t;
                        return null == (t = a.append) ? void 0 : t.call(a, {
                            ...e,
                            item: l
                        })
                    }
                    : void 0,
                    title: a.title ? e => {
                        var t;
                        return null == (t = a.title) ? void 0 : t.call(a, {
                            ...e,
                            item: l
                        })
                    }
                    : void 0
                }
                  , u = po.filterProps(o);
                return r ? y(po, A({
                    value: null == o ? void 0 : o.value
                }, u), {
                    activator: t => {
                        let {props: i} = t;
                        const n = {
                            ...o,
                            ...i,
                            value: e.returnObject ? l : o.value
                        };
                        return a.header ? a.header({
                            props: n
                        }) : y(mo, n, c)
                    }
                    ,
                    default: () => y(So, {
                        items: r
                    }, a)
                }) : a.item ? a.item({
                    props: o
                }) : y(mo, A(o, {
                    value: e.returnObject ? l : o.value
                }), c)
            }
            )))
        }
    }
})
  , Co = d({
    items: {
        type: Array,
        default: () => []
    },
    itemTitle: {
        type: [String, Array, Function],
        default: "title"
    },
    itemValue: {
        type: [String, Array, Function],
        default: "value"
    },
    itemChildren: {
        type: [Boolean, String, Array, Function],
        default: "children"
    },
    itemProps: {
        type: [Boolean, String, Array, Function],
        default: "props"
    },
    returnObject: Boolean,
    valueComparator: {
        type: Function,
        default: pe
    }
}, "list-items");
function Ao(e, t) {
    const a = He(t, e.itemTitle, t)
      , i = He(t, e.itemValue, a)
      , n = He(t, e.itemChildren)
      , r = {
        title: a,
        value: i,
        ...!0 === e.itemProps ? "object" != typeof t || null == t || Array.isArray(t) ? void 0 : "children"in t ? Fe(t, ["children"]) : t : He(t, e.itemProps)
    };
    return {
        title: String(r.title ?? ""),
        value: r.value,
        props: r,
        children: Array.isArray(n) ? Po(e, n) : void 0,
        raw: t
    }
}
function Po(e, t) {
    const a = [];
    for (const i of t)
        a.push(Ao(e, i));
    return a
}
function Lo(e) {
    const t = F(( () => Po(e, e.items)))
      , a = F(( () => t.value.some((e => null === e.value))));
    return {
        items: t,
        transformIn: function(i) {
            return a.value || (i = i.filter((e => null !== e))),
            i.map((a => e.returnObject && "string" == typeof a ? Ao(e, a) : t.value.find((t => e.valueComparator(a, t.value))) || Ao(e, a)))
        },
        transformOut: function(t) {
            return e.returnObject ? t.map((e => {
                let {raw: t} = e;
                return t
            }
            )) : t.map((e => {
                let {value: t} = e;
                return t
            }
            ))
        }
    }
}
function Io(e, t) {
    const a = He(t, e.itemType, "item")
      , i = function(e) {
        return "string" == typeof e || "number" == typeof e || "boolean" == typeof e
    }(t) ? t : He(t, e.itemTitle)
      , n = He(t, e.itemValue, void 0)
      , r = He(t, e.itemChildren)
      , o = {
        title: i,
        value: n,
        ...!0 === e.itemProps ? Fe(t, ["children"]) : He(t, e.itemProps)
    };
    return {
        type: a,
        title: o.title,
        value: o.value,
        props: o,
        children: "item" === a && r ? _o(e, r) : void 0,
        raw: t
    }
}
function _o(e, t) {
    const a = [];
    for (const i of t)
        a.push(Io(e, i));
    return a
}
const To = d({
    baseColor: String,
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    expandIcon: String,
    collapseIcon: String,
    lines: {
        type: [Boolean, String],
        default: "one"
    },
    slim: Boolean,
    nav: Boolean,
    ...so({
        selectStrategy: "single-leaf",
        openStrategy: "list"
    }),
    ...Gi(),
    ...h(),
    ...nn(),
    ...Ti(),
    ...$i(),
    itemType: {
        type: String,
        default: "type"
    },
    ...Co(),
    ...Di(),
    ...ai(),
    ...v(),
    ...ln({
        variant: "text"
    })
}, "VList")
  , Eo = g()({
    name: "VList",
    props: To(),
    emits: {
        "update:selected": e => !0,
        "update:opened": e => !0,
        "click:open": e => !0,
        "click:select": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {items: i} = function(e) {
            return {
                items: F(( () => _o(e, e.items)))
            }
        }(e)
          , {themeClasses: n} = f(e)
          , {backgroundColorClasses: r, backgroundColorStyles: o} = Mi(W(e, "bgColor"))
          , {borderClasses: s} = ji(e)
          , {densityClasses: c} = rn(e)
          , {dimensionStyles: u} = Ei(e)
          , {elevationClasses: d} = Ui(e)
          , {roundedClasses: h} = Ri(e)
          , {open: p, select: v} = lo(e)
          , g = F(( () => e.lines ? `v-list--${e.lines}-line` : void 0))
          , m = W(e, "activeColor")
          , b = W(e, "baseColor")
          , w = W(e, "color");
        Jr(),
        V({
            VListGroup: {
                activeColor: m,
                baseColor: b,
                color: w,
                expandIcon: W(e, "expandIcon"),
                collapseIcon: W(e, "collapseIcon")
            },
            VListItem: {
                activeClass: W(e, "activeClass"),
                activeColor: m,
                baseColor: b,
                color: w,
                density: W(e, "density"),
                disabled: W(e, "disabled"),
                lines: W(e, "lines"),
                nav: W(e, "nav"),
                slim: W(e, "slim"),
                variant: W(e, "variant")
            }
        });
        const k = j(!1)
          , S = l();
        function C(e) {
            k.value = !0
        }
        function A(e) {
            k.value = !1
        }
        function P(e) {
            var t;
            k.value || e.relatedTarget && (null == (t = S.value) ? void 0 : t.contains(e.relatedTarget)) || _()
        }
        function L(e) {
            if (S.value) {
                if ("ArrowDown" === e.key)
                    _("next");
                else if ("ArrowUp" === e.key)
                    _("prev");
                else if ("Home" === e.key)
                    _("first");
                else {
                    if ("End" !== e.key)
                        return;
                    _("last")
                }
                e.preventDefault()
            }
        }
        function I(e) {
            k.value = !0
        }
        function _(e) {
            if (S.value)
                return Xe(S.value, e)
        }
        return x(( () => y(e.tag, {
            ref: S,
            class: ["v-list", {
                "v-list--disabled": e.disabled,
                "v-list--nav": e.nav,
                "v-list--slim": e.slim
            }, n.value, r.value, s.value, c.value, d.value, g.value, h.value, e.class],
            style: [o.value, u.value, e.style],
            tabindex: e.disabled || k.value ? -1 : 0,
            role: "listbox",
            "aria-activedescendant": void 0,
            onFocusin: C,
            onFocusout: A,
            onFocus: P,
            onKeydown: L,
            onMousedown: I
        }, {
            default: () => [y(So, {
                items: i.value,
                returnObject: e.returnObject
            }, a)]
        }))),
        {
            open: p,
            select: v,
            focus: _
        }
    }
})
  , Oo = _e("v-list-img")
  , Vo = d({
    start: Boolean,
    end: Boolean,
    ...h(),
    ...ai()
}, "VListItemAction")
  , Fo = g()({
    name: "VListItemAction",
    props: Vo(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => y(e.tag, {
            class: ["v-list-item-action", {
                "v-list-item-action--start": e.start,
                "v-list-item-action--end": e.end
            }, e.class],
            style: e.style
        }, a))),
        {}
    }
})
  , Bo = d({
    start: Boolean,
    end: Boolean,
    ...h(),
    ...ai()
}, "VListItemMedia")
  , Mo = g()({
    name: "VListItemMedia",
    props: Bo(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => y(e.tag, {
            class: ["v-list-item-media", {
                "v-list-item-media--start": e.start,
                "v-list-item-media--end": e.end
            }, e.class],
            style: e.style
        }, a))),
        {}
    }
});
function Do(e, t) {
    return {
        x: e.x + t.x,
        y: e.y + t.y
    }
}
function Ro(e, t) {
    if ("top" === e.side || "bottom" === e.side) {
        const {side: a, align: i} = e;
        return Do({
            x: "left" === i ? 0 : "center" === i ? t.width / 2 : "right" === i ? t.width : i,
            y: "top" === a ? 0 : "bottom" === a ? t.height : a
        }, t)
    }
    if ("left" === e.side || "right" === e.side) {
        const {side: a, align: i} = e;
        return Do({
            x: "left" === a ? 0 : "right" === a ? t.width : a,
            y: "top" === i ? 0 : "center" === i ? t.height / 2 : "bottom" === i ? t.height : i
        }, t)
    }
    return Do({
        x: t.width / 2,
        y: t.height / 2
    }, t)
}
const No = {
    static: function() {},
    connected: function(e, t, a) {
        (Array.isArray(e.target.value) || Ye(e.target.value)) && Object.assign(a.value, {
            position: "fixed",
            top: 0,
            [e.isRtl.value ? "right" : "left"]: 0
        });
        const {preferredAnchor: i, preferredOrigin: n} = D(( () => {
            const a = ke(t.location, e.isRtl.value)
              , i = "overlap" === t.origin ? a : "auto" === t.origin ? We(a) : ke(t.origin, e.isRtl.value);
            return a.side === i.side && a.align === Ge(i).align ? {
                preferredAnchor: je(a),
                preferredOrigin: je(i)
            } : {
                preferredAnchor: a,
                preferredOrigin: i
            }
        }
        ))
          , [r,o,s,l] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((e => F(( () => {
            const a = parseFloat(t[e]);
            return isNaN(a) ? 1 / 0 : a
        }
        ))))
          , c = F(( () => {
            if (Array.isArray(t.offset))
                return t.offset;
            if ("string" == typeof t.offset) {
                const e = t.offset.split(" ").map(parseFloat);
                return e.length < 2 && e.push(0),
                e
            }
            return "number" == typeof t.offset ? [t.offset, 0] : [0, 0]
        }
        ));
        let u = !1;
        const d = new ResizeObserver(( () => {
            u && h()
        }
        ));
        function h() {
            if (u = !1,
            requestAnimationFrame(( () => u = !0)),
            !e.target.value || !e.contentEl.value)
                return;
            const t = T(e.target.value)
              , d = function(e, t) {
                t ? e.style.removeProperty("left") : e.style.removeProperty("right");
                const a = E(e);
                t ? a.x += parseFloat(e.style.right || 0) : a.x -= parseFloat(e.style.left || 0);
                return a.y -= parseFloat(e.style.top || 0),
                a
            }(e.contentEl.value, e.isRtl.value)
              , h = $e(e.contentEl.value);
            h.length || (h.push(document.documentElement),
            e.contentEl.value.style.top && e.contentEl.value.style.left || (d.x -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0),
            d.y -= parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0)));
            const p = h.reduce(( (e, t) => {
                const a = t.getBoundingClientRect()
                  , i = new Ue({
                    x: t === document.documentElement ? 0 : a.x,
                    y: t === document.documentElement ? 0 : a.y,
                    width: t.clientWidth,
                    height: t.clientHeight
                });
                return e ? new Ue({
                    x: Math.max(e.left, i.left),
                    y: Math.max(e.top, i.top),
                    width: Math.min(e.right, i.right) - Math.max(e.left, i.left),
                    height: Math.min(e.bottom, i.bottom) - Math.max(e.top, i.top)
                }) : i
            }
            ), void 0);
            p.x += 12,
            p.y += 12,
            p.width -= 24,
            p.height -= 24;
            let v = {
                anchor: i.value,
                origin: n.value
            };
            function g(e) {
                const a = new Ue(d)
                  , i = Ro(e.anchor, t)
                  , n = Ro(e.origin, a);
                let {x: r, y: o} = (h = n,
                {
                    x: (u = i).x - h.x,
                    y: u.y - h.y
                });
                var u, h;
                switch (e.anchor.side) {
                case "top":
                    o -= c.value[0];
                    break;
                case "bottom":
                    o += c.value[0];
                    break;
                case "left":
                    r -= c.value[0];
                    break;
                case "right":
                    r += c.value[0]
                }
                switch (e.anchor.align) {
                case "top":
                    o -= c.value[1];
                    break;
                case "bottom":
                    o += c.value[1];
                    break;
                case "left":
                    r -= c.value[1];
                    break;
                case "right":
                    r += c.value[1]
                }
                a.x += r,
                a.y += o,
                a.width = Math.min(a.width, s.value),
                a.height = Math.min(a.height, l.value);
                return {
                    overflows: Ze(a, p),
                    x: r,
                    y: o
                }
            }
            let f = 0
              , m = 0;
            const b = {
                x: 0,
                y: 0
            }
              , x = {
                x: !1,
                y: !1
            };
            let y = -1;
            for (; !(y++ > 10); ) {
                const {x: e, y: t, overflows: a} = g(v);
                f += e,
                m += t,
                d.x += e,
                d.y += t;
                {
                    const e = qe(v.anchor)
                      , t = a.x.before || a.x.after
                      , i = a.y.before || a.y.after;
                    let n = !1;
                    if (["x", "y"].forEach((r => {
                        if ("x" === r && t && !x.x || "y" === r && i && !x.y) {
                            const t = {
                                anchor: {
                                    ...v.anchor
                                },
                                origin: {
                                    ...v.origin
                                }
                            }
                              , i = "x" === r ? "y" === e ? Ge : We : "y" === e ? We : Ge;
                            t.anchor = i(t.anchor),
                            t.origin = i(t.origin);
                            const {overflows: o} = g(t);
                            (o[r].before <= a[r].before && o[r].after <= a[r].after || o[r].before + o[r].after < (a[r].before + a[r].after) / 2) && (v = t,
                            n = x[r] = !0)
                        }
                    }
                    )),
                    n)
                        continue
                }
                a.x.before && (f += a.x.before,
                d.x += a.x.before),
                a.x.after && (f -= a.x.after,
                d.x -= a.x.after),
                a.y.before && (m += a.y.before,
                d.y += a.y.before),
                a.y.after && (m -= a.y.after,
                d.y -= a.y.after);
                {
                    const e = Ze(d, p);
                    b.x = p.width - e.x.before - e.x.after,
                    b.y = p.height - e.y.before - e.y.after,
                    f += e.x.before,
                    d.x += e.x.before,
                    m += e.y.before,
                    d.y += e.y.before
                }
                break
            }
            const w = qe(v.anchor);
            return Object.assign(a.value, {
                "--v-overlay-anchor-origin": `${v.anchor.side} ${v.anchor.align}`,
                transformOrigin: `${v.origin.side} ${v.origin.align}`,
                top: B(Ho(m)),
                left: e.isRtl.value ? void 0 : B(Ho(f)),
                right: e.isRtl.value ? B(Ho(-f)) : void 0,
                minWidth: B("y" === w ? Math.min(r.value, t.width) : r.value),
                maxWidth: B(Xo(te(b.x, r.value === 1 / 0 ? 0 : r.value, s.value))),
                maxHeight: B(Xo(te(b.y, o.value === 1 / 0 ? 0 : o.value, l.value)))
            }),
            {
                available: b,
                contentBox: d
            }
        }
        return $([e.target, e.contentEl], ( (e, t) => {
            let[a,i] = e
              , [n,r] = t;
            n && !Array.isArray(n) && d.unobserve(n),
            a && !Array.isArray(a) && d.observe(a),
            r && d.unobserve(r),
            i && d.observe(i)
        }
        ), {
            immediate: !0
        }),
        Pe(( () => {
            d.disconnect()
        }
        )),
        $(( () => [i.value, n.value, t.offset, t.minWidth, t.minHeight, t.maxWidth, t.maxHeight]), ( () => h())),
        q(( () => {
            const e = h();
            if (!e)
                return;
            const {available: t, contentBox: a} = e;
            a.height > t.y && requestAnimationFrame(( () => {
                h(),
                requestAnimationFrame(( () => {
                    h()
                }
                ))
            }
            ))
        }
        )),
        {
            updateLocation: h
        }
    }
}
  , zo = d({
    locationStrategy: {
        type: [String, Function],
        default: "static",
        validator: e => "function" == typeof e || e in No
    },
    location: {
        type: String,
        default: "bottom"
    },
    origin: {
        type: String,
        default: "auto"
    },
    offset: [Number, String, Array]
}, "VOverlay-location-strategies");
function Ho(e) {
    return Math.round(e * devicePixelRatio) / devicePixelRatio
}
function Xo(e) {
    return Math.ceil(e * devicePixelRatio) / devicePixelRatio
}
let Yo = !0;
const Wo = [];
let Go = -1;
function jo() {
    cancelAnimationFrame(Go),
    Go = requestAnimationFrame(( () => {
        const e = Wo.shift();
        e && e(),
        Wo.length ? jo() : Yo = !0
    }
    ))
}
const $o = {
    none: null,
    close: function(e) {
        qo(e.targetEl.value ?? e.contentEl.value, (function(t) {
            e.isActive.value = !1
        }
        ))
    },
    block: function(e, t) {
        var a;
        const i = null == (a = e.root.value) ? void 0 : a.offsetParent
          , n = [...new Set([...$e(e.targetEl.value, t.contained ? i : void 0), ...$e(e.contentEl.value, t.contained ? i : void 0)])].filter((e => !e.classList.contains("v-overlay-scroll-blocked")))
          , r = window.innerWidth - document.documentElement.offsetWidth
          , o = (s = i || document.documentElement,
        Je(s) && s);
        var s;
        o && e.root.value.classList.add("v-overlay--scroll-blocked");
        n.forEach(( (e, t) => {
            e.style.setProperty("--v-body-scroll-x", B(-e.scrollLeft)),
            e.style.setProperty("--v-body-scroll-y", B(-e.scrollTop)),
            e !== document.documentElement && e.style.setProperty("--v-scrollbar-offset", B(r)),
            e.classList.add("v-overlay-scroll-blocked")
        }
        )),
        Pe(( () => {
            n.forEach(( (e, t) => {
                const a = parseFloat(e.style.getPropertyValue("--v-body-scroll-x"))
                  , i = parseFloat(e.style.getPropertyValue("--v-body-scroll-y"))
                  , n = e.style.scrollBehavior;
                e.style.scrollBehavior = "auto",
                e.style.removeProperty("--v-body-scroll-x"),
                e.style.removeProperty("--v-body-scroll-y"),
                e.style.removeProperty("--v-scrollbar-offset"),
                e.classList.remove("v-overlay-scroll-blocked"),
                e.scrollLeft = -a,
                e.scrollTop = -i,
                e.style.scrollBehavior = n
            }
            )),
            o && e.root.value.classList.remove("v-overlay--scroll-blocked")
        }
        ))
    },
    reposition: function(e, t, a) {
        let i = !1
          , n = -1
          , r = -1;
        function o(t) {
            var a;
            a = () => {
                var a, n;
                const r = performance.now();
                null == (n = (a = e.updateLocation).value) || n.call(a, t);
                const o = performance.now() - r;
                i = o / (1e3 / 60) > 2
            }
            ,
            !Yo || Wo.length ? (Wo.push(a),
            jo()) : (Yo = !1,
            a(),
            jo())
        }
        r = ("undefined" == typeof requestIdleCallback ? e => e() : requestIdleCallback)(( () => {
            a.run(( () => {
                qo(e.targetEl.value ?? e.contentEl.value, (e => {
                    i ? (cancelAnimationFrame(n),
                    n = requestAnimationFrame(( () => {
                        n = requestAnimationFrame(( () => {
                            o(e)
                        }
                        ))
                    }
                    ))) : o(e)
                }
                ))
            }
            ))
        }
        )),
        Pe(( () => {
            "undefined" != typeof cancelIdleCallback && cancelIdleCallback(r),
            cancelAnimationFrame(n)
        }
        ))
    }
}
  , Uo = d({
    scrollStrategy: {
        type: [String, Function],
        default: "block",
        validator: e => "function" == typeof e || e in $o
    }
}, "VOverlay-scroll-strategies");
function qo(e, t) {
    const a = [document, ...$e(e)];
    a.forEach((e => {
        e.addEventListener("scroll", t, {
            passive: !0
        })
    }
    )),
    Pe(( () => {
        a.forEach((e => {
            e.removeEventListener("scroll", t)
        }
        ))
    }
    ))
}
const Zo = Symbol.for("vuetify:v-menu")
  , Ko = d({
    closeDelay: [Number, String],
    openDelay: [Number, String]
}, "delay");
function Jo(e, t) {
    let a = () => {}
    ;
    function i(i) {
        null == a || a();
        const n = Number(i ? e.openDelay : e.closeDelay);
        return new Promise((e => {
            a = Qe(n, ( () => {
                null == t || t(i),
                e(i)
            }
            ))
        }
        ))
    }
    return {
        clearDelay: a,
        runOpenDelay: function() {
            return i(!0)
        },
        runCloseDelay: function() {
            return i(!1)
        }
    }
}
const Qo = d({
    target: [String, Object],
    activator: [String, Object],
    activatorProps: {
        type: Object,
        default: () => ({})
    },
    openOnClick: {
        type: Boolean,
        default: void 0
    },
    openOnHover: Boolean,
    openOnFocus: {
        type: Boolean,
        default: void 0
    },
    closeOnContentClick: Boolean,
    ...Ko()
}, "VOverlay-activator");
function es(e, t) {
    let {isActive: a, isTop: i} = t;
    const n = G("useActivator")
      , r = l();
    let o = !1
      , s = !1
      , c = !0;
    const u = F(( () => e.openOnFocus || null == e.openOnFocus && e.openOnHover))
      , d = F(( () => e.openOnClick || null == e.openOnClick && !e.openOnHover && !u.value))
      , {runOpenDelay: h, runCloseDelay: p} = Jo(e, (t => {
        t !== (e.openOnHover && o || u.value && s) || e.openOnHover && a.value && !i.value || (a.value !== t && (c = !0),
        a.value = t)
    }
    ))
      , v = l()
      , g = e => {
        e.stopPropagation(),
        r.value = e.currentTarget || e.target,
        a.value || (v.value = [e.clientX, e.clientY]),
        a.value = !a.value
    }
      , f = e => {
        var t;
        (null == (t = e.sourceCapabilities) ? void 0 : t.firesTouchEvents) || (o = !0,
        r.value = e.currentTarget || e.target,
        h())
    }
      , m = e => {
        o = !1,
        p()
    }
      , b = e => {
        !1 !== Ve(e.target, ":focus-visible") && (s = !0,
        e.stopPropagation(),
        r.value = e.currentTarget || e.target,
        h())
    }
      , x = e => {
        s = !1,
        e.stopPropagation(),
        p()
    }
      , y = F(( () => {
        const t = {};
        return d.value && (t.onClick = g),
        e.openOnHover && (t.onMouseenter = f,
        t.onMouseleave = m),
        u.value && (t.onFocus = b,
        t.onBlur = x),
        t
    }
    ))
      , w = F(( () => {
        const t = {};
        if (e.openOnHover && (t.onMouseenter = () => {
            o = !0,
            h()
        }
        ,
        t.onMouseleave = () => {
            o = !1,
            p()
        }
        ),
        u.value && (t.onFocusin = () => {
            s = !0,
            h()
        }
        ,
        t.onFocusout = () => {
            s = !1,
            p()
        }
        ),
        e.closeOnContentClick) {
            const e = de(Zo, null);
            t.onClick = () => {
                a.value = !1,
                null == e || e.closeParents()
            }
        }
        return t
    }
    ))
      , k = F(( () => {
        const t = {};
        return e.openOnHover && (t.onMouseenter = () => {
            c && (o = !0,
            c = !1,
            h())
        }
        ,
        t.onMouseleave = () => {
            o = !1,
            p()
        }
        ),
        t
    }
    ));
    $(i, (t => {
        !t || (!e.openOnHover || o || u.value && s) && (!u.value || s || e.openOnHover && o) || (a.value = !1)
    }
    )),
    $(a, (e => {
        e || setTimeout(( () => {
            v.value = void 0
        }
        ))
    }
    ), {
        flush: "post"
    });
    const S = l();
    le(( () => {
        S.value && q(( () => {
            r.value = et(S.value)
        }
        ))
    }
    ));
    const C = l()
      , P = F(( () => "cursor" === e.target && v.value ? v.value : C.value ? et(C.value) : ts(e.target, n) || r.value))
      , L = F(( () => Array.isArray(P.value) ? void 0 : P.value));
    let I;
    return $(( () => !!e.activator), (t => {
        t && Ae ? (I = Ke(),
        I.run(( () => {
            !function(e, t, a) {
                let {activatorEl: i, activatorEvents: n} = a;
                function r() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : s()
                      , a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.activatorProps;
                    t && tt(t, A(n.value, a))
                }
                function o() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : s()
                      , a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.activatorProps;
                    t && at(t, A(n.value, a))
                }
                function s() {
                    const a = ts(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : e.activator, t);
                    return i.value = (null == a ? void 0 : a.nodeType) === Node.ELEMENT_NODE ? a : void 0,
                    i.value
                }
                $(( () => e.activator), ( (e, t) => {
                    if (t && e !== t) {
                        const e = s(t);
                        e && o(e)
                    }
                    e && q(( () => r()))
                }
                ), {
                    immediate: !0
                }),
                $(( () => e.activatorProps), ( () => {
                    r()
                }
                )),
                Pe(( () => {
                    o()
                }
                ))
            }(e, n, {
                activatorEl: r,
                activatorEvents: y
            })
        }
        ))) : I && I.stop()
    }
    ), {
        flush: "post",
        immediate: !0
    }),
    Pe(( () => {
        null == I || I.stop()
    }
    )),
    {
        activatorEl: r,
        activatorRef: S,
        target: P,
        targetEl: L,
        targetRef: C,
        activatorEvents: y,
        contentEvents: w,
        scrimEvents: k
    }
}
function ts(e, t) {
    var a, i;
    if (!e)
        return;
    let n;
    if ("parent" === e) {
        let e = null == (i = null == (a = null == t ? void 0 : t.proxy) ? void 0 : a.$el) ? void 0 : i.parentNode;
        for (; null == e ? void 0 : e.hasAttribute("data-no-activator"); )
            e = e.parentNode;
        n = e
    } else
        n = "string" == typeof e ? document.querySelector(e) : "$el"in e ? e.$el : e;
    return n
}
function as() {
    if (!Ae)
        return j(!1);
    const {ssr: e} = Me();
    if (e) {
        const e = j(!1);
        return ae(( () => {
            e.value = !0
        }
        )),
        e
    }
    return j(!0)
}
const is = d({
    eager: Boolean
}, "lazy");
function ns(e, t) {
    const a = j(!1)
      , i = F(( () => a.value || e.eager || t.value));
    return $(t, ( () => a.value = !0)),
    {
        isBooted: a,
        hasContent: i,
        onAfterLeave: function() {
            e.eager || (a.value = !1)
        }
    }
}
function rs() {
    const e = G("useScopeId").vnode.scopeId;
    return {
        scopeId: e ? {
            [e]: ""
        } : void 0
    }
}
const os = Symbol.for("vuetify:stack")
  , ss = he([]);
function ls() {
    return !0
}
function cs(e, t, a) {
    if (!e || !1 === us(e, a))
        return !1;
    const i = it(t);
    if ("undefined" != typeof ShadowRoot && i instanceof ShadowRoot && i.host === e.target)
        return !1;
    const n = ("object" == typeof a.value && a.value.include || ( () => []))();
    return n.push(t),
    !n.some((t => null == t ? void 0 : t.contains(e.target)))
}
function us(e, t) {
    return ("object" == typeof t.value && t.value.closeConditional || ls)(e)
}
function ds(e, t) {
    const a = it(e);
    t(document),
    "undefined" != typeof ShadowRoot && a instanceof ShadowRoot && t(a)
}
const hs = {
    mounted(e, t) {
        const a = a => function(e, t, a) {
            const i = "function" == typeof a.value ? a.value : a.value.handler;
            t._clickOutside.lastMousedownWasOutside && cs(e, t, a) && setTimeout(( () => {
                us(e, a) && i && i(e)
            }
            ), 0)
        }(a, e, t)
          , i = a => {
            e._clickOutside.lastMousedownWasOutside = cs(a, e, t)
        }
        ;
        ds(e, (e => {
            e.addEventListener("click", a, !0),
            e.addEventListener("mousedown", i, !0)
        }
        )),
        e._clickOutside || (e._clickOutside = {
            lastMousedownWasOutside: !1
        }),
        e._clickOutside[t.instance.$.uid] = {
            onClick: a,
            onMousedown: i
        }
    },
    unmounted(e, t) {
        e._clickOutside && (ds(e, (a => {
            var i;
            if (!a || !(null == (i = e._clickOutside) ? void 0 : i[t.instance.$.uid]))
                return;
            const {onClick: n, onMousedown: r} = e._clickOutside[t.instance.$.uid];
            a.removeEventListener("click", n, !0),
            a.removeEventListener("mousedown", r, !0)
        }
        )),
        delete e._clickOutside[t.instance.$.uid])
    }
};
function ps(e) {
    const {modelValue: t, color: a, ...i} = e;
    return y(k, {
        name: "fade-transition",
        appear: !0
    }, {
        default: () => [e.modelValue && y("div", A({
            class: ["v-overlay__scrim", e.color.backgroundColorClasses.value],
            style: e.color.backgroundColorStyles.value
        }, i), null)]
    })
}
const vs = d({
    absolute: Boolean,
    attach: [Boolean, String, Object],
    closeOnBack: {
        type: Boolean,
        default: !0
    },
    contained: Boolean,
    contentClass: null,
    contentProps: null,
    disabled: Boolean,
    opacity: [Number, String],
    noClickAnimation: Boolean,
    modelValue: Boolean,
    persistent: Boolean,
    scrim: {
        type: [Boolean, String],
        default: !0
    },
    zIndex: {
        type: [Number, String],
        default: 2e3
    },
    ...Qo(),
    ...h(),
    ...Ti(),
    ...is(),
    ...zo(),
    ...Uo(),
    ...v(),
    ...Ni()
}, "VOverlay")
  , gs = g()({
    name: "VOverlay",
    directives: {
        ClickOutside: hs
    },
    inheritAttrs: !1,
    props: {
        _disableGlobalStack: Boolean,
        ...vs()
    },
    emits: {
        "click:outside": e => !0,
        "update:modelValue": e => !0,
        afterLeave: () => !0
    },
    setup(e, t) {
        let {slots: a, attrs: i, emit: n} = t;
        const r = re(e, "modelValue")
          , o = F({
            get: () => r.value,
            set: t => {
                t && e.disabled || (r.value = t)
            }
        })
          , {teleportTarget: s} = function(e) {
            return {
                teleportTarget: F(( () => {
                    const t = e.value;
                    if (!0 === t || !Ae)
                        return;
                    const a = !1 === t ? document.body : "string" == typeof t ? document.querySelector(t) : t;
                    if (null == a)
                        return;
                    let i = a.querySelector(":scope > .v-overlay-container");
                    return i || (i = document.createElement("div"),
                    i.className = "v-overlay-container",
                    a.appendChild(i)),
                    i
                }
                ))
            }
        }(F(( () => e.attach || e.contained)))
          , {themeClasses: c} = f(e)
          , {rtlClasses: u, isRtl: d} = b()
          , {hasContent: h, onAfterLeave: p} = ns(e, o)
          , v = Mi(F(( () => "string" == typeof e.scrim ? e.scrim : null)))
          , {globalTop: g, localTop: m, stackStyles: w} = function(e, t, a) {
            const i = G("useStack")
              , n = !a
              , r = de(os, void 0)
              , o = he({
                activeChildren: new Set
            });
            ue(os, o);
            const s = j(+t.value);
            oe(e, ( () => {
                var e;
                const a = null == (e = ss.at(-1)) ? void 0 : e[1];
                s.value = a ? a + 10 : +t.value,
                n && ss.push([i.uid, s.value]),
                null == r || r.activeChildren.add(i.uid),
                Pe(( () => {
                    if (n) {
                        const e = Re(ss).findIndex((e => e[0] === i.uid));
                        ss.splice(e, 1)
                    }
                    null == r || r.activeChildren.delete(i.uid)
                }
                ))
            }
            ));
            const l = j(!0);
            n && le(( () => {
                var e;
                const t = (null == (e = ss.at(-1)) ? void 0 : e[0]) === i.uid;
                setTimeout(( () => l.value = t))
            }
            ));
            const c = F(( () => !o.activeChildren.size));
            return {
                globalTop: ie(l),
                localTop: c,
                stackStyles: F(( () => ({
                    zIndex: s.value
                })))
            }
        }(o, W(e, "zIndex"), e._disableGlobalStack)
          , {activatorEl: k, activatorRef: S, target: C, targetEl: L, targetRef: _, activatorEvents: T, contentEvents: E, scrimEvents: O} = es(e, {
            isActive: o,
            isTop: m
        })
          , {dimensionStyles: V} = Ei(e)
          , M = as()
          , {scopeId: D} = rs();
        $(( () => e.disabled), (e => {
            e && (o.value = !1)
        }
        ));
        const R = l()
          , N = l()
          , {contentStyles: z, updateLocation: H} = function(e, t) {
            const a = l({})
              , i = l();
            function n(e) {
                var t;
                null == (t = i.value) || t.call(i, e)
            }
            return Ae && oe(( () => !(!t.isActive.value || !e.locationStrategy)), (r => {
                var o, s;
                $(( () => e.locationStrategy), r),
                Pe(( () => {
                    window.removeEventListener("resize", n),
                    i.value = void 0
                }
                )),
                window.addEventListener("resize", n, {
                    passive: !0
                }),
                "function" == typeof e.locationStrategy ? i.value = null == (o = e.locationStrategy(t, e, a)) ? void 0 : o.updateLocation : i.value = null == (s = No[e.locationStrategy](t, e, a)) ? void 0 : s.updateLocation
            }
            )),
            {
                contentStyles: a,
                updateLocation: i
            }
        }(e, {
            isRtl: d,
            contentEl: N,
            target: C,
            isActive: o
        });
        function X(t) {
            n("click:outside", t),
            e.persistent ? ne() : o.value = !1
        }
        function Y() {
            return o.value && g.value
        }
        function U(t) {
            var a, i;
            "Escape" === t.key && g.value && (e.persistent ? ne() : (o.value = !1,
            (null == (a = N.value) ? void 0 : a.contains(document.activeElement)) && (null == (i = k.value) || i.focus())))
        }
        !function(e, t) {
            if (!Ae)
                return;
            let a;
            le((async () => {
                null == a || a.stop(),
                t.isActive.value && e.scrollStrategy && (a = Ke(),
                await q(),
                a.active && a.run(( () => {
                    var i;
                    "function" == typeof e.scrollStrategy ? e.scrollStrategy(t, e, a) : null == (i = $o[e.scrollStrategy]) || i.call($o, t, e, a)
                }
                )))
            }
            )),
            Pe(( () => {
                null == a || a.stop()
            }
            ))
        }(e, {
            root: R,
            contentEl: N,
            targetEl: L,
            isActive: o,
            updateLocation: H
        }),
        Ae && $(o, (e => {
            e ? window.addEventListener("keydown", U) : window.removeEventListener("keydown", U)
        }
        ), {
            immediate: !0
        }),
        Z(( () => {
            Ae && window.removeEventListener("keydown", U)
        }
        ));
        const te = Nn();
        oe(( () => e.closeOnBack), ( () => {
            !function(e, t) {
                let a, i, n = !1;
                function r(e) {
                    var t;
                    (null == (t = e.state) ? void 0 : t.replaced) || (n = !0,
                    setTimeout(( () => n = !1)))
                }
                Ae && (q(( () => {
                    window.addEventListener("popstate", r),
                    a = null == e ? void 0 : e.beforeEach(( (e, a, i) => {
                        Xn ? n ? t(i) : i() : setTimeout(( () => n ? t(i) : i())),
                        Xn = !0
                    }
                    )),
                    i = null == e ? void 0 : e.afterEach(( () => {
                        Xn = !1
                    }
                    ))
                }
                )),
                Pe(( () => {
                    window.removeEventListener("popstate", r),
                    null == a || a(),
                    null == i || i()
                }
                )))
            }(te, (t => {
                g.value && o.value ? (t(!1),
                e.persistent ? ne() : o.value = !1) : t()
            }
            ))
        }
        ));
        const ae = l();
        function ne() {
            e.noClickAnimation || N.value && P(N.value, [{
                transformOrigin: "center"
            }, {
                transform: "scale(1.03)"
            }, {
                transformOrigin: "center"
            }], {
                duration: 150,
                easing: I
            })
        }
        function se() {
            p(),
            n("afterLeave")
        }
        return $(( () => o.value && (e.absolute || e.contained) && null == s.value), (e => {
            if (e) {
                const e = nt(R.value);
                e && e !== document.scrollingElement && (ae.value = e.scrollTop)
            }
        }
        )),
        x(( () => {
            var t;
            return y(Q, null, [null == (t = a.activator) ? void 0 : t.call(a, {
                isActive: o.value,
                props: A({
                    ref: S,
                    targetRef: _
                }, T.value, e.activatorProps)
            }), M.value && h.value && y(rt, {
                disabled: !s.value,
                to: s.value
            }, {
                default: () => [y("div", A({
                    class: ["v-overlay", {
                        "v-overlay--absolute": e.absolute || e.contained,
                        "v-overlay--active": o.value,
                        "v-overlay--contained": e.contained
                    }, c.value, u.value, e.class],
                    style: [w.value, {
                        "--v-overlay-opacity": e.opacity,
                        top: B(ae.value)
                    }, e.style],
                    ref: R
                }, D, i), [y(ps, A({
                    color: v,
                    modelValue: o.value && !!e.scrim
                }, O.value), null), y(zi, {
                    appear: !0,
                    persisted: !0,
                    transition: e.transition,
                    target: C.value,
                    onAfterLeave: se
                }, {
                    default: () => {
                        var t;
                        return [K(y("div", A({
                            ref: N,
                            class: ["v-overlay__content", e.contentClass],
                            style: [V.value, z.value]
                        }, E.value, e.contentProps), [null == (t = a.default) ? void 0 : t.call(a, {
                            isActive: o
                        })]), [[ee, o.value], [J("click-outside"), {
                            handler: X,
                            closeConditional: Y,
                            include: () => [k.value]
                        }]])]
                    }
                })])]
            })])
        }
        )),
        {
            activatorEl: k,
            target: C,
            animateClick: ne,
            contentEl: N,
            globalTop: g,
            localTop: m,
            updateLocation: H
        }
    }
})
  , fs = Symbol("Forwarded refs");
function ms(e, t) {
    let a = e;
    for (; a; ) {
        const e = Reflect.getOwnPropertyDescriptor(a, t);
        if (e)
            return e;
        a = Object.getPrototypeOf(a)
    }
}
function bs(e) {
    for (var t = arguments.length, a = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
        a[i - 1] = arguments[i];
    return e[fs] = a,
    new Proxy(e,{
        get(e, t) {
            if (Reflect.has(e, t))
                return Reflect.get(e, t);
            if ("symbol" != typeof t && !t.startsWith("$") && !t.startsWith("__"))
                for (const i of a)
                    if (i.value && Reflect.has(i.value, t)) {
                        const e = Reflect.get(i.value, t);
                        return "function" == typeof e ? e.bind(i.value) : e
                    }
        },
        has(e, t) {
            if (Reflect.has(e, t))
                return !0;
            if ("symbol" == typeof t || t.startsWith("$") || t.startsWith("__"))
                return !1;
            for (const i of a)
                if (i.value && Reflect.has(i.value, t))
                    return !0;
            return !1
        },
        set(e, t, i) {
            if (Reflect.has(e, t))
                return Reflect.set(e, t, i);
            if ("symbol" == typeof t || t.startsWith("$") || t.startsWith("__"))
                return !1;
            for (const n of a)
                if (n.value && Reflect.has(n.value, t))
                    return Reflect.set(n.value, t, i);
            return !1
        },
        getOwnPropertyDescriptor(e, t) {
            var i;
            const n = Reflect.getOwnPropertyDescriptor(e, t);
            if (n)
                return n;
            if ("symbol" != typeof t && !t.startsWith("$") && !t.startsWith("__")) {
                for (const e of a) {
                    if (!e.value)
                        continue;
                    const a = ms(e.value, t) ?? ("_"in e.value ? ms(null == (i = e.value._) ? void 0 : i.setupState, t) : void 0);
                    if (a)
                        return a
                }
                for (const e of a) {
                    const a = e.value && e.value[fs];
                    if (!a)
                        continue;
                    const i = a.slice();
                    for (; i.length; ) {
                        const e = i.shift()
                          , a = ms(e.value, t);
                        if (a)
                            return a;
                        const n = e.value && e.value[fs];
                        n && i.push(...n)
                    }
                }
            }
        }
    })
}
const xs = d({
    id: String,
    ...Fe(vs({
        closeDelay: 250,
        closeOnContentClick: !0,
        locationStrategy: "connected",
        openDelay: 300,
        scrim: !1,
        scrollStrategy: "reposition",
        transition: {
            component: ui
        }
    }), ["absolute"])
}, "VMenu")
  , ys = g()({
    name: "VMenu",
    props: xs(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , {scopeId: n} = rs()
          , r = ce()
          , o = F(( () => e.id || `v-menu-${r}`))
          , s = l()
          , c = de(Zo, null)
          , u = j(0);
        async function d(e) {
            var t, a, n;
            const r = e.relatedTarget
              , o = e.target;
            if (await q(),
            i.value && r !== o && (null == (t = s.value) ? void 0 : t.contentEl) && (null == (a = s.value) ? void 0 : a.globalTop) && ![document, s.value.contentEl].includes(o) && !s.value.contentEl.contains(o)) {
                null == (n = De(s.value.contentEl)[0]) || n.focus()
            }
        }
        function h(e) {
            null == c || c.closeParents(e)
        }
        function p(t) {
            var a, n, r;
            if (!e.disabled && "Tab" === t.key) {
                st(De(null == (a = s.value) ? void 0 : a.contentEl, !1), t.shiftKey ? "prev" : "next", (e => e.tabIndex >= 0)) || (i.value = !1,
                null == (r = null == (n = s.value) ? void 0 : n.activatorEl) || r.focus())
            }
        }
        function v(t) {
            var a;
            if (e.disabled)
                return;
            const n = null == (a = s.value) ? void 0 : a.contentEl;
            n && i.value ? "ArrowDown" === t.key ? (t.preventDefault(),
            Xe(n, "next")) : "ArrowUp" === t.key && (t.preventDefault(),
            Xe(n, "prev")) : ["ArrowDown", "ArrowUp"].includes(t.key) && (i.value = !0,
            t.preventDefault(),
            setTimeout(( () => setTimeout(( () => v(t))))))
        }
        ue(Zo, {
            register() {
                ++u.value
            },
            unregister() {
                --u.value
            },
            closeParents(e) {
                setTimeout(( () => {
                    u.value || null != e && (!e || ot(e, s.value.contentEl)) || (i.value = !1,
                    null == c || c.closeParents())
                }
                ), 40)
            }
        }),
        $(i, (e => {
            e ? (null == c || c.register(),
            document.addEventListener("focusin", d, {
                once: !0
            })) : (null == c || c.unregister(),
            document.removeEventListener("focusin", d))
        }
        ));
        const g = F(( () => A({
            "aria-haspopup": "menu",
            "aria-expanded": String(i.value),
            "aria-owns": o.value,
            onKeydown: v
        }, e.activatorProps)));
        return x(( () => {
            const t = gs.filterProps(e);
            return y(gs, A({
                ref: s,
                id: o.value,
                class: ["v-menu", e.class],
                style: e.style
            }, t, {
                modelValue: i.value,
                "onUpdate:modelValue": e => i.value = e,
                absolute: !0,
                activatorProps: g.value,
                "onClick:outside": h,
                onKeydown: p
            }, n), {
                activator: a.activator,
                default: function() {
                    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                        t[i] = arguments[i];
                    return y(_i, {
                        root: "VMenu"
                    }, {
                        default: () => {
                            var e;
                            return [null == (e = a.default) ? void 0 : e.call(a, ...t)]
                        }
                    })
                }
            })
        }
        )),
        bs({
            id: o,
            "openChildren": u
        }, s)
    }
})
  , ws = d({
    active: Boolean,
    max: [Number, String],
    value: {
        type: [Number, String],
        default: 0
    },
    ...h(),
    ...Ni({
        transition: {
            component: Ci
        }
    })
}, "VCounter")
  , ks = g()({
    name: "VCounter",
    functional: !0,
    props: ws(),
    setup(e, t) {
        let {slots: a} = t;
        const i = F(( () => e.max ? `${e.value} / ${e.max}` : String(e.value)));
        return x(( () => y(zi, {
            transition: e.transition
        }, {
            default: () => [K(y("div", {
                class: ["v-counter", e.class],
                style: e.style
            }, [a.default ? a.default({
                counter: i.value,
                max: e.max,
                value: e.value
            }) : i.value]), [[ee, e.active]])]
        }))),
        {}
    }
})
  , Ss = d({
    floating: Boolean,
    ...h()
}, "VFieldLabel")
  , Cs = g()({
    name: "VFieldLabel",
    props: Ss(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => y(br, {
            class: ["v-field-label", {
                "v-field-label--floating": e.floating
            }, e.class],
            style: e.style,
            "aria-hidden": e.floating || void 0
        }, a))),
        {}
    }
})
  , As = ["underlined", "outlined", "filled", "solo", "solo-inverted", "solo-filled", "plain"]
  , Ps = d({
    appendInnerIcon: me,
    bgColor: String,
    clearable: Boolean,
    clearIcon: {
        type: me,
        default: "$clear"
    },
    active: Boolean,
    centerAffix: {
        type: Boolean,
        default: void 0
    },
    color: String,
    baseColor: String,
    dirty: Boolean,
    disabled: {
        type: Boolean,
        default: null
    },
    error: Boolean,
    flat: Boolean,
    label: String,
    persistentClear: Boolean,
    prependInnerIcon: me,
    reverse: Boolean,
    singleLine: Boolean,
    variant: {
        type: String,
        default: "filled",
        validator: e => As.includes(e)
    },
    "onClick:clear": Ee(),
    "onClick:appendInner": Ee(),
    "onClick:prependInner": Ee(),
    ...h(),
    ...Vn(),
    ...Di(),
    ...v()
}, "VField")
  , Ls = g()({
    name: "VField",
    inheritAttrs: !1,
    props: {
        id: String,
        ...Tr(),
        ...Ps()
    },
    emits: {
        "update:focused": e => !0,
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const {themeClasses: r} = f(e)
          , {loaderClasses: o} = Fn(e)
          , {focusClasses: s, isFocused: c, focus: u, blur: d} = Er(e)
          , {InputIcon: h} = Lr(e)
          , {roundedClasses: p} = Ri(e)
          , {rtlClasses: v} = b()
          , g = F(( () => e.dirty || e.active))
          , m = F(( () => !(e.singleLine || !e.label && !n.label)))
          , w = ce()
          , k = F(( () => e.id || `input-${w}`))
          , S = F(( () => `${k.value}-messages`))
          , C = l()
          , L = l()
          , _ = l()
          , T = F(( () => ["plain", "underlined"].includes(e.variant)))
          , {backgroundColorClasses: O, backgroundColorStyles: V} = Mi(W(e, "bgColor"))
          , {textColorClasses: M, textColorStyles: D} = Bi(F(( () => e.error || e.disabled ? void 0 : g.value && c.value ? e.color : e.baseColor)));
        $(g, (e => {
            if (m.value) {
                const t = C.value.$el
                  , a = L.value.$el;
                requestAnimationFrame(( () => {
                    const i = E(t)
                      , n = a.getBoundingClientRect()
                      , r = n.x - i.x
                      , o = n.y - i.y - (i.height / 2 - n.height / 2)
                      , s = n.width / .75
                      , l = Math.abs(s - i.width) > 1 ? {
                        maxWidth: B(s)
                    } : void 0
                      , c = getComputedStyle(t)
                      , u = getComputedStyle(a)
                      , d = 1e3 * parseFloat(c.transitionDuration) || 150
                      , h = parseFloat(u.getPropertyValue("--v-field-label-scale"))
                      , p = u.getPropertyValue("color");
                    t.style.visibility = "visible",
                    a.style.visibility = "hidden",
                    P(t, {
                        transform: `translate(${r}px, ${o}px) scale(${h})`,
                        color: p,
                        ...l
                    }, {
                        duration: d,
                        easing: I,
                        direction: e ? "normal" : "reverse"
                    }).finished.then(( () => {
                        t.style.removeProperty("visibility"),
                        a.style.removeProperty("visibility")
                    }
                    ))
                }
                ))
            }
        }
        ), {
            flush: "post"
        });
        const R = F(( () => ({
            isActive: g,
            isFocused: c,
            controlRef: _,
            blur: d,
            focus: u
        })));
        function N(e) {
            e.target !== document.activeElement && e.preventDefault()
        }
        return x(( () => {
            var t, i, l;
            const c = "outlined" === e.variant
              , f = n["prepend-inner"] || e.prependInnerIcon
              , b = !(!e.clearable && !n.clear)
              , x = !!(n["append-inner"] || e.appendInnerIcon || b)
              , w = () => n.label ? n.label({
                ...R.value,
                label: e.label,
                props: {
                    for: k.value
                }
            }) : e.label;
            return y("div", A({
                class: ["v-field", {
                    "v-field--active": g.value,
                    "v-field--appended": x,
                    "v-field--center-affix": e.centerAffix ?? !T.value,
                    "v-field--disabled": e.disabled,
                    "v-field--dirty": e.dirty,
                    "v-field--error": e.error,
                    "v-field--flat": e.flat,
                    "v-field--has-background": !!e.bgColor,
                    "v-field--persistent-clear": e.persistentClear,
                    "v-field--prepended": f,
                    "v-field--reverse": e.reverse,
                    "v-field--single-line": e.singleLine,
                    "v-field--no-label": !w(),
                    [`v-field--variant-${e.variant}`]: !0
                }, r.value, O.value, s.value, o.value, p.value, v.value, e.class],
                style: [V.value, e.style],
                onClick: N
            }, a), [y("div", {
                class: "v-field__overlay"
            }, null), y(Bn, {
                name: "v-field",
                active: !!e.loading,
                color: e.error ? "error" : "string" == typeof e.loading ? e.loading : e.color
            }, {
                default: n.loader
            }), f && y("div", {
                key: "prepend",
                class: "v-field__prepend-inner"
            }, [e.prependInnerIcon && y(h, {
                key: "prepend-icon",
                name: "prependInner"
            }, null), null == (t = n["prepend-inner"]) ? void 0 : t.call(n, R.value)]), y("div", {
                class: "v-field__field",
                "data-no-activator": ""
            }, [["filled", "solo", "solo-inverted", "solo-filled"].includes(e.variant) && m.value && y(Cs, {
                key: "floating-label",
                ref: L,
                class: [M.value],
                floating: !0,
                for: k.value,
                style: D.value
            }, {
                default: () => [w()]
            }), y(Cs, {
                ref: C,
                for: k.value
            }, {
                default: () => [w()]
            }), null == (i = n.default) ? void 0 : i.call(n, {
                ...R.value,
                props: {
                    id: k.value,
                    class: "v-field__input",
                    "aria-describedby": S.value
                },
                focus: u,
                blur: d
            })]), b && y(Li, {
                key: "clear"
            }, {
                default: () => [K(y("div", {
                    class: "v-field__clearable",
                    onMousedown: e => {
                        e.preventDefault(),
                        e.stopPropagation()
                    }
                }, [n.clear ? n.clear() : y(h, {
                    name: "clear"
                }, null)]), [[ee, e.dirty]])]
            }), x && y("div", {
                key: "append",
                class: "v-field__append-inner"
            }, [null == (l = n["append-inner"]) ? void 0 : l.call(n, R.value), e.appendInnerIcon && y(h, {
                key: "append-icon",
                name: "appendInner"
            }, null)]), y("div", {
                class: ["v-field__outline", M.value],
                style: D.value
            }, [c && y(Q, null, [y("div", {
                class: "v-field__outline__start"
            }, null), m.value && y("div", {
                class: "v-field__outline__notch"
            }, [y(Cs, {
                ref: L,
                floating: !0,
                for: k.value
            }, {
                default: () => [w()]
            })]), y("div", {
                class: "v-field__outline__end"
            }, null)]), T.value && m.value && y(Cs, {
                ref: L,
                floating: !0,
                for: k.value
            }, {
                default: () => [w()]
            })])])
        }
        )),
        {
            controlRef: _
        }
    }
});
function Is(e) {
    const t = Object.keys(Ls.props).filter((e => !lt(e) && "class" !== e && "style" !== e));
    return ct(e, t)
}
const _s = ["color", "file", "time", "date", "datetime-local", "week", "month"]
  , Ts = d({
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: [Number, Function],
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    suffix: String,
    role: String,
    type: {
        type: String,
        default: "text"
    },
    modelModifiers: Object,
    ...Dr(),
    ...Ps()
}, "VTextField")
  , Es = g()({
    name: "VTextField",
    directives: {
        Intersect: Xi
    },
    inheritAttrs: !1,
    props: Ts(),
    emits: {
        "click:control": e => !0,
        "mousedown:control": e => !0,
        "update:focused": e => !0,
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const r = re(e, "modelValue")
          , {isFocused: o, focus: s, blur: c} = Er(e)
          , u = F(( () => "function" == typeof e.counterValue ? e.counterValue(r.value) : "number" == typeof e.counterValue ? e.counterValue : (r.value ?? "").toString().length))
          , d = F(( () => a.maxlength ? a.maxlength : !e.counter || "number" != typeof e.counter && "string" != typeof e.counter ? void 0 : e.counter))
          , h = F(( () => ["plain", "underlined"].includes(e.variant)));
        function p(t, a) {
            var i, n;
            e.autofocus && t && (null == (n = null == (i = a[0].target) ? void 0 : i.focus) || n.call(i))
        }
        const v = l()
          , g = l()
          , f = l()
          , m = F(( () => _s.includes(e.type) || e.persistentPlaceholder || o.value || e.active));
        function b() {
            var e;
            f.value !== document.activeElement && (null == (e = f.value) || e.focus()),
            o.value || s()
        }
        function w(e) {
            i("mousedown:control", e),
            e.target !== f.value && (b(),
            e.preventDefault())
        }
        function k(e) {
            b(),
            i("click:control", e)
        }
        function S(t) {
            t.stopPropagation(),
            b(),
            q(( () => {
                r.value = null,
                dt(e["onClick:clear"], t)
            }
            ))
        }
        function C(t) {
            var a;
            const i = t.target;
            if (r.value = i.value,
            (null == (a = e.modelModifiers) ? void 0 : a.trim) && ["text", "search", "password", "tel", "url"].includes(e.type)) {
                const e = [i.selectionStart, i.selectionEnd];
                q(( () => {
                    i.selectionStart = e[0],
                    i.selectionEnd = e[1]
                }
                ))
            }
        }
        return x(( () => {
            const t = !!(n.counter || !1 !== e.counter && null != e.counter)
              , i = !(!t && !n.details)
              , [s,l] = Oe(a)
              , {modelValue: x, ...P} = Rr.filterProps(e)
              , L = Is(e);
            return y(Rr, A({
                ref: v,
                modelValue: r.value,
                "onUpdate:modelValue": e => r.value = e,
                class: ["v-text-field", {
                    "v-text-field--prefixed": e.prefix,
                    "v-text-field--suffixed": e.suffix,
                    "v-input--plain-underlined": h.value
                }, e.class],
                style: e.style
            }, s, P, {
                centerAffix: !h.value,
                focused: o.value
            }), {
                ...n,
                default: t => {
                    let {id: a, isDisabled: i, isDirty: s, isReadonly: u, isValid: d} = t;
                    return y(Ls, A({
                        ref: g,
                        onMousedown: w,
                        onClick: k,
                        "onClick:clear": S,
                        "onClick:prependInner": e["onClick:prependInner"],
                        "onClick:appendInner": e["onClick:appendInner"],
                        role: e.role
                    }, L, {
                        id: a.value,
                        active: m.value || s.value,
                        dirty: s.value || e.dirty,
                        disabled: i.value,
                        focused: o.value,
                        error: !1 === d.value
                    }), {
                        ...n,
                        default: t => {
                            let {props: {class: a, ...o}} = t;
                            const s = K(y("input", A({
                                ref: f,
                                value: r.value,
                                onInput: C,
                                autofocus: e.autofocus,
                                readonly: u.value,
                                disabled: i.value,
                                name: e.name,
                                placeholder: e.placeholder,
                                size: 1,
                                type: e.type,
                                onFocus: b,
                                onBlur: c
                            }, o, l), null), [[J("intersect"), {
                                handler: p
                            }, null, {
                                once: !0
                            }]]);
                            return y(Q, null, [e.prefix && y("span", {
                                class: "v-text-field__prefix"
                            }, [y("span", {
                                class: "v-text-field__prefix__text"
                            }, [e.prefix])]), n.default ? y("div", {
                                class: a,
                                "data-no-activator": ""
                            }, [n.default(), s]) : ut(s, {
                                class: a
                            }), e.suffix && y("span", {
                                class: "v-text-field__suffix"
                            }, [y("span", {
                                class: "v-text-field__suffix__text"
                            }, [e.suffix])])])
                        }
                    })
                }
                ,
                details: i ? a => {
                    var i;
                    return y(Q, null, [null == (i = n.details) ? void 0 : i.call(n, a), t && y(Q, null, [y("span", null, null), y(ks, {
                        active: e.persistentCounter || o.value,
                        value: u.value,
                        max: d.value
                    }, n.counter)])])
                }
                : void 0
            })
        }
        )),
        bs({}, v, g, f)
    }
})
  , Os = d({
    renderless: Boolean,
    ...h()
}, "VVirtualScrollItem")
  , Vs = g()({
    name: "VVirtualScrollItem",
    inheritAttrs: !1,
    props: Os(),
    emits: {
        "update:height": e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const {resizeRef: r, contentRect: o} = we(void 0, "border");
        $(( () => {
            var e;
            return null == (e = o.value) ? void 0 : e.height
        }
        ), (e => {
            null != e && i("update:height", e)
        }
        )),
        x(( () => {
            var t, i;
            return e.renderless ? y(Q, null, [null == (t = n.default) ? void 0 : t.call(n, {
                itemRef: r
            })]) : y("div", A({
                ref: r,
                class: ["v-virtual-scroll__item", e.class],
                style: e.style
            }, a), [null == (i = n.default) ? void 0 : i.call(n)])
        }
        ))
    }
})
  , Fs = d({
    itemHeight: {
        type: [Number, String],
        default: null
    },
    height: [Number, String]
}, "virtual");
function Bs(e, t) {
    const a = Me()
      , i = j(0);
    le(( () => {
        i.value = parseFloat(e.itemHeight || 0)
    }
    ));
    const n = j(0)
      , r = j(Math.ceil((parseInt(e.height) || a.height.value) / (i.value || 16)) || 1)
      , o = j(0)
      , s = j(0)
      , c = l()
      , u = l();
    let d = 0;
    const {resizeRef: h, contentRect: p} = we();
    le(( () => {
        h.value = c.value
    }
    ));
    const v = F(( () => {
        var t;
        return c.value === document.documentElement ? a.height.value : (null == (t = p.value) ? void 0 : t.height) || parseInt(e.height) || 0
    }
    ))
      , g = F(( () => !!(c.value && u.value && v.value && i.value)));
    let f = Array.from({
        length: t.value.length
    })
      , m = Array.from({
        length: t.value.length
    });
    const b = j(0);
    let x = -1;
    const y = ht(( () => {
        const e = performance.now();
        m[0] = 0;
        const a = t.value.length;
        for (let t = 1; t <= a - 1; t++)
            m[t] = (m[t - 1] || 0) + (f[t - 1] || i.value);
        b.value = Math.max(b.value, performance.now() - e)
    }
    ), b)
      , w = $(g, (e => {
        e && (w(),
        d = u.value.offsetTop,
        y.immediate(),
        I(),
        ~x && q(( () => {
            Ae && window.requestAnimationFrame(( () => {
                T(x),
                x = -1
            }
            ))
        }
        )))
    }
    ));
    function k(e) {
        return e = te(e, 0, t.value.length - 1),
        m[e] || 0
    }
    function S(e) {
        return function(e, t) {
            let a = e.length - 1
              , i = 0
              , n = 0
              , r = null
              , o = -1;
            if (e[a] < t)
                return a;
            for (; i <= a; )
                if (n = i + a >> 1,
                r = e[n],
                r > t)
                    a = n - 1;
                else {
                    if (!(r < t))
                        return r === t ? n : i;
                    o = n,
                    i = n + 1
                }
            return o
        }(m, e)
    }
    Pe(( () => {
        y.clear()
    }
    ));
    let C = 0
      , A = 0
      , P = 0;
    $(v, ( (e, t) => {
        t && (I(),
        e < t && requestAnimationFrame(( () => {
            A = 0,
            I()
        }
        )))
    }
    ));
    let L = -1;
    function I() {
        cancelAnimationFrame(L),
        L = requestAnimationFrame(_)
    }
    function _() {
        if (!c.value || !v.value)
            return;
        const e = C - d
          , a = Math.sign(A)
          , i = Math.max(0, e - 100)
          , l = te(S(i), 0, t.value.length)
          , u = e + v.value + 100
          , h = te(S(u) + 1, l + 1, t.value.length);
        if ((-1 !== a || l < n.value) && (1 !== a || h > r.value)) {
            const e = k(n.value) - k(l)
              , a = k(h) - k(r.value);
            Math.max(e, a) > 100 ? (n.value = l,
            r.value = h) : (l <= 0 && (n.value = l),
            h >= t.value.length && (r.value = h))
        }
        o.value = k(n.value),
        s.value = k(t.value.length) - k(r.value)
    }
    function T(e) {
        const t = k(e);
        !c.value || e && !t ? x = e : c.value.scrollTop = t
    }
    const E = F(( () => t.value.slice(n.value, r.value).map(( (e, t) => ({
        raw: e,
        index: t + n.value
    })))));
    return $(t, ( () => {
        f = Array.from({
            length: t.value.length
        }),
        m = Array.from({
            length: t.value.length
        }),
        y.immediate(),
        I()
    }
    ), {
        deep: !0
    }),
    {
        containerRef: c,
        markerRef: u,
        computedItems: E,
        paddingTop: o,
        paddingBottom: s,
        scrollToIndex: T,
        handleScroll: function() {
            if (!c.value || !u.value)
                return;
            const e = c.value.scrollTop
              , t = performance.now();
            t - P > 500 ? (A = Math.sign(e - C),
            d = u.value.offsetTop) : A = e - C,
            C = e,
            P = t,
            I()
        },
        handleScrollend: function() {
            c.value && u.value && (A = 0,
            P = 0,
            I())
        },
        handleItemResize: function(e, t) {
            const a = f[e]
              , n = i.value;
            i.value = n ? Math.min(i.value, t) : t,
            a === t && n === i.value || (f[e] = t,
            y())
        }
    }
}
const Ms = d({
    items: {
        type: Array,
        default: () => []
    },
    renderless: Boolean,
    ...Fs(),
    ...h(),
    ...Ti()
}, "VVirtualScroll")
  , Ds = g()({
    name: "VVirtualScroll",
    props: Ms(),
    setup(e, t) {
        let {slots: a} = t;
        const i = G("VVirtualScroll")
          , {dimensionStyles: n} = Ei(e)
          , {containerRef: r, markerRef: o, handleScroll: s, handleScrollend: l, handleItemResize: c, scrollToIndex: u, paddingTop: d, paddingBottom: h, computedItems: p} = Bs(e, W(e, "items"));
        return oe(( () => e.renderless), ( () => {
            function e() {
                var e, t;
                const a = arguments.length > 0 && void 0 !== arguments[0] && arguments[0] ? "addEventListener" : "removeEventListener";
                r.value === document.documentElement ? (document[a]("scroll", s, {
                    passive: !0
                }),
                document[a]("scrollend", l)) : (null == (e = r.value) || e[a]("scroll", s, {
                    passive: !0
                }),
                null == (t = r.value) || t[a]("scrollend", l))
            }
            ae(( () => {
                r.value = nt(i.vnode.el, !0),
                e(!0)
            }
            )),
            Pe(e)
        }
        )),
        x(( () => {
            const t = p.value.map((t => y(Vs, {
                key: t.index,
                renderless: e.renderless,
                "onUpdate:height": e => c(t.index, e)
            }, {
                default: e => {
                    var i;
                    return null == (i = a.default) ? void 0 : i.call(a, {
                        item: t.raw,
                        index: t.index,
                        ...e
                    })
                }
            })));
            return e.renderless ? y(Q, null, [y("div", {
                ref: o,
                class: "v-virtual-scroll__spacer",
                style: {
                    paddingTop: B(d.value)
                }
            }, null), t, y("div", {
                class: "v-virtual-scroll__spacer",
                style: {
                    paddingBottom: B(h.value)
                }
            }, null)]) : y("div", {
                ref: r,
                class: ["v-virtual-scroll", e.class],
                onScrollPassive: s,
                onScrollend: l,
                style: [n.value, e.style]
            }, [y("div", {
                ref: o,
                class: "v-virtual-scroll__container",
                style: {
                    paddingTop: B(d.value),
                    paddingBottom: B(h.value)
                }
            }, [t])])
        }
        )),
        {
            scrollToIndex: u
        }
    }
});
function Rs(e, t) {
    const a = j(!1);
    let i;
    return {
        onListScroll: function(e) {
            cancelAnimationFrame(i),
            a.value = !0,
            i = requestAnimationFrame(( () => {
                i = requestAnimationFrame(( () => {
                    a.value = !1
                }
                ))
            }
            ))
        },
        onListKeydown: async function(i) {
            var n, r;
            if ("Tab" === i.key && (null == (n = t.value) || n.focus()),
            !["PageDown", "PageUp", "Home", "End"].includes(i.key))
                return;
            const o = null == (r = e.value) ? void 0 : r.$el;
            if (!o)
                return;
            "Home" !== i.key && "End" !== i.key || o.scrollTo({
                top: "Home" === i.key ? 0 : o.scrollHeight,
                behavior: "smooth"
            }),
            await async function() {
                await new Promise((e => requestAnimationFrame(e))),
                await new Promise((e => requestAnimationFrame(e))),
                await new Promise((e => requestAnimationFrame(e))),
                await new Promise((e => {
                    if (a.value) {
                        const t = $(a, ( () => {
                            t(),
                            e()
                        }
                        ))
                    } else
                        e()
                }
                ))
            }();
            const s = o.querySelectorAll(":scope > :not(.v-virtual-scroll__spacer)");
            if ("PageDown" === i.key || "Home" === i.key) {
                const e = o.getBoundingClientRect().top;
                for (const t of s)
                    if (t.getBoundingClientRect().top >= e) {
                        t.focus();
                        break
                    }
            } else {
                const e = o.getBoundingClientRect().bottom;
                for (const t of [...s].reverse())
                    if (t.getBoundingClientRect().bottom <= e) {
                        t.focus();
                        break
                    }
            }
        }
    }
}
const Ns = d({
    chips: Boolean,
    closableChips: Boolean,
    closeText: {
        type: String,
        default: "$vuetify.close"
    },
    openText: {
        type: String,
        default: "$vuetify.open"
    },
    eager: Boolean,
    hideNoData: Boolean,
    hideSelected: Boolean,
    listProps: {
        type: Object
    },
    menu: Boolean,
    menuIcon: {
        type: me,
        default: "$dropdown"
    },
    menuProps: {
        type: Object
    },
    multiple: Boolean,
    noDataText: {
        type: String,
        default: "$vuetify.noDataText"
    },
    openOnClear: Boolean,
    itemColor: String,
    ...Co({
        itemChildren: !1
    })
}, "Select")
  , zs = d({
    ...Ns(),
    ...Fe(Ts({
        modelValue: null,
        role: "combobox"
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...Ni({
        transition: {
            component: ui
        }
    })
}, "VSelect")
  , Hs = g()({
    name: "VSelect",
    props: zs(),
    emits: {
        "update:focused": e => !0,
        "update:modelValue": e => !0,
        "update:menu": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {t: i} = Te()
          , n = l()
          , r = l()
          , o = l()
          , s = re(e, "menu")
          , c = F({
            get: () => s.value,
            set: e => {
                var t;
                s.value && !e && (null == (t = r.value) ? void 0 : t.openChildren) || (s.value = e)
            }
        })
          , {items: u, transformIn: d, transformOut: h} = Lo(e)
          , p = re(e, "modelValue", [], (e => d(null === e ? [null] : ve(e))), (t => {
            const a = h(t);
            return e.multiple ? a : a[0] ?? null
        }
        ))
          , v = F(( () => "function" == typeof e.counterValue ? e.counterValue(p.value) : "number" == typeof e.counterValue ? e.counterValue : p.value.length))
          , g = Fr()
          , f = F(( () => p.value.map((e => e.value))))
          , m = j(!1)
          , b = F(( () => c.value ? e.closeText : e.openText));
        let w, k = "";
        const S = F(( () => e.hideSelected ? u.value.filter((e => !p.value.some((t => t === e)))) : u.value))
          , C = F(( () => e.hideNoData && !S.value.length || e.readonly || (null == g ? void 0 : g.isReadonly.value)))
          , P = F(( () => {
            var t;
            return {
                ...e.menuProps,
                activatorProps: {
                    ...(null == (t = e.menuProps) ? void 0 : t.activatorProps) || {},
                    "aria-haspopup": "listbox"
                }
            }
        }
        ))
          , L = l()
          , {onListScroll: I, onListKeydown: _} = Rs(L, n);
        function T(t) {
            e.openOnClear && (c.value = !0)
        }
        function E() {
            C.value || (c.value = !c.value)
        }
        function O(t) {
            var a, i;
            if (!t.key || e.readonly || (null == g ? void 0 : g.isReadonly.value))
                return;
            ["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(t.key) && t.preventDefault(),
            ["Enter", "ArrowDown", " "].includes(t.key) && (c.value = !0),
            ["Escape", "Tab"].includes(t.key) && (c.value = !1),
            "Home" === t.key ? null == (a = L.value) || a.focus("first") : "End" === t.key && (null == (i = L.value) || i.focus("last"));
            if (e.multiple || !function(e) {
                const t = 1 === e.key.length
                  , a = !e.ctrlKey && !e.metaKey && !e.altKey;
                return t && a
            }(t))
                return;
            const n = performance.now();
            n - w > 1e3 && (k = ""),
            k += t.key.toLowerCase(),
            w = n;
            const r = u.value.find((e => e.title.toLowerCase().startsWith(k)));
            void 0 !== r && (p.value = [r])
        }
        function V(t) {
            let a = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.multiple) {
                const i = p.value.findIndex((a => e.valueComparator(a.value, t.value)));
                if (a = -1 === i,
                a)
                    p.value = [...p.value, t];
                else {
                    const e = [...p.value];
                    e.splice(i, 1),
                    p.value = e
                }
            } else
                p.value = a ? [t] : [],
                c.value = !1
        }
        function B(e) {
            var t;
            (null == (t = L.value) ? void 0 : t.$el.contains(e.relatedTarget)) || (c.value = !1)
        }
        function M() {
            var e;
            m.value && (null == (e = n.value) || e.focus())
        }
        function D(e) {
            m.value = !0
        }
        function R(e) {
            if (null == e)
                p.value = [];
            else if (Ve(n.value, ":autofill") || Ve(n.value, ":-webkit-autofill")) {
                const t = u.value.find((t => t.title === e));
                t && V(t)
            } else
                n.value && (n.value.value = "")
        }
        return $(c, ( () => {
            if (!e.hideSelected && c.value && p.value.length) {
                const t = S.value.findIndex((t => p.value.some((a => e.valueComparator(a.value, t.value)))));
                Ae && window.requestAnimationFrame(( () => {
                    var e;
                    t >= 0 && (null == (e = o.value) || e.scrollToIndex(t))
                }
                ))
            }
        }
        )),
        $(S, ( (t, a) => {
            m.value && (!t.length && e.hideNoData && (c.value = !1),
            !a.length && t.length && (c.value = !0))
        }
        )),
        x(( () => {
            const t = !(!e.chips && !a.chip)
              , s = !!(!e.hideNoData || S.value.length || a["prepend-item"] || a["append-item"] || a["no-data"])
              , l = p.value.length > 0
              , u = Es.filterProps(e)
              , d = l || !m.value && e.label && !e.persistentPlaceholder ? void 0 : e.placeholder;
            return y(Es, A({
                ref: n
            }, u, {
                modelValue: p.value.map((e => e.props.value)).join(", "),
                "onUpdate:modelValue": R,
                focused: m.value,
                "onUpdate:focused": e => m.value = e,
                validationValue: p.externalValue,
                counterValue: v.value,
                dirty: l,
                class: ["v-select", {
                    "v-select--active-menu": c.value,
                    "v-select--chips": !!e.chips,
                    ["v-select--" + (e.multiple ? "multiple" : "single")]: !0,
                    "v-select--selected": p.value.length,
                    "v-select--selection-slot": !!a.selection
                }, e.class],
                style: e.style,
                inputmode: "none",
                placeholder: d,
                "onClick:clear": T,
                "onMousedown:control": E,
                onBlur: B,
                onKeydown: O,
                "aria-label": i(b.value),
                title: i(b.value)
            }), {
                ...a,
                default: () => y(Q, null, [y(ys, A({
                    ref: r,
                    modelValue: c.value,
                    "onUpdate:modelValue": e => c.value = e,
                    activator: "parent",
                    contentClass: "v-select__content",
                    disabled: C.value,
                    eager: e.eager,
                    maxHeight: 310,
                    openOnClick: !1,
                    closeOnContentClick: !1,
                    transition: e.transition,
                    onAfterLeave: M
                }, P.value), {
                    default: () => [s && y(Eo, A({
                        ref: L,
                        selected: f.value,
                        selectStrategy: e.multiple ? "independent" : "single-independent",
                        onMousedown: e => e.preventDefault(),
                        onKeydown: _,
                        onFocusin: D,
                        onScrollPassive: I,
                        tabindex: "-1",
                        "aria-live": "polite",
                        color: e.itemColor ?? e.color
                    }, e.listProps), {
                        default: () => {
                            var t, n, r;
                            return [null == (t = a["prepend-item"]) ? void 0 : t.call(a), !S.value.length && !e.hideNoData && ((null == (n = a["no-data"]) ? void 0 : n.call(a)) ?? y(mo, {
                                title: i(e.noDataText)
                            }, null)), y(Ds, {
                                ref: o,
                                renderless: !0,
                                items: S.value
                            }, {
                                default: t => {
                                    var i;
                                    let {item: n, index: r, itemRef: o} = t;
                                    const s = A(n.props, {
                                        ref: o,
                                        key: r,
                                        onClick: () => V(n)
                                    });
                                    return (null == (i = a.item) ? void 0 : i.call(a, {
                                        item: n,
                                        index: r,
                                        props: s
                                    })) ?? y(mo, A(s, {
                                        role: "option"
                                    }), {
                                        prepend: t => {
                                            let {isSelected: a} = t;
                                            return y(Q, null, [e.multiple && !e.hideSelected ? y(Pr, {
                                                key: n.value,
                                                modelValue: a,
                                                ripple: !1,
                                                tabindex: "-1"
                                            }, null) : void 0, n.props.prependAvatar && y(fr, {
                                                image: n.props.prependAvatar
                                            }, null), n.props.prependIcon && y(Cn, {
                                                icon: n.props.prependIcon
                                            }, null)])
                                        }
                                    })
                                }
                            }), null == (r = a["append-item"]) ? void 0 : r.call(a)]
                        }
                    })]
                }), p.value.map(( (i, n) => {
                    const r = {
                        "onClick:close": function(e) {
                            e.stopPropagation(),
                            e.preventDefault(),
                            V(i, !1)
                        },
                        onMousedown(e) {
                            e.preventDefault(),
                            e.stopPropagation()
                        },
                        modelValue: !0,
                        "onUpdate:modelValue": void 0
                    }
                      , o = t ? !!a.chip : !!a.selection
                      , s = o ? pt(t ? a.chip({
                        item: i,
                        index: n,
                        props: r
                    }) : a.selection({
                        item: i,
                        index: n
                    })) : void 0;
                    if (!o || s)
                        return y("div", {
                            key: i.value,
                            class: "v-select__selection"
                        }, [t ? a.chip ? y(_i, {
                            key: "chip-defaults",
                            defaults: {
                                VChip: {
                                    closable: e.closableChips,
                                    size: "small",
                                    text: i.title
                                }
                            }
                        }, {
                            default: () => [s]
                        }) : y(Zr, A({
                            key: "chip",
                            closable: e.closableChips,
                            size: "small",
                            text: i.title,
                            disabled: i.props.disabled
                        }, r), null) : s ?? y("span", {
                            class: "v-select__selection-text"
                        }, [i.title, e.multiple && n < p.value.length - 1 && y("span", {
                            class: "v-select__selection-comma"
                        }, [vt(",")])])])
                }
                ))]),
                "append-inner": function() {
                    for (var t, i = arguments.length, n = new Array(i), r = 0; r < i; r++)
                        n[r] = arguments[r];
                    return y(Q, null, [null == (t = a["append-inner"]) ? void 0 : t.call(a, ...n), e.menuIcon ? y(Cn, {
                        class: "v-select__menu-icon",
                        icon: e.menuIcon
                    }, null) : void 0])
                }
            })
        }
        )),
        bs({
            isFocused: m,
            menu: c,
            select: V
        }, n)
    }
})
  , Xs = (e, t, a) => null == e || null == t ? -1 : e.toString().toLocaleLowerCase().indexOf(t.toString().toLocaleLowerCase())
  , Ys = d({
    customFilter: Function,
    customKeyFilter: Object,
    filterKeys: [Array, String],
    filterMode: {
        type: String,
        default: "intersection"
    },
    noFilter: Boolean
}, "filter");
function Ws(e, t, a, i) {
    const n = l([])
      , o = l(new Map)
      , s = F(( () => (null == i ? void 0 : i.transform) ? r(t).map((e => [e, i.transform(e)])) : r(t)));
    return le(( () => {
        const l = "function" == typeof a ? a() : r(a)
          , c = "string" != typeof l && "number" != typeof l ? "" : String(l)
          , u = function(e, t, a) {
            var i;
            const n = []
              , r = (null == a ? void 0 : a.default) ?? Xs
              , o = !!(null == a ? void 0 : a.filterKeys) && ve(a.filterKeys)
              , s = Object.keys((null == a ? void 0 : a.customKeyFilter) ?? {}).length;
            if (!(null == e ? void 0 : e.length))
                return n;
            e: for (let l = 0; l < e.length; l++) {
                const [c,u=c] = ve(e[l])
                  , d = {}
                  , h = {};
                let p = -1;
                if (t && !(null == a ? void 0 : a.noFilter)) {
                    if ("object" == typeof c) {
                        const e = o || Object.keys(u);
                        for (const n of e) {
                            const e = He(u, n)
                              , o = null == (i = null == a ? void 0 : a.customKeyFilter) ? void 0 : i[n];
                            if (p = o ? o(e, t, c) : r(e, t, c),
                            -1 !== p && !1 !== p)
                                o ? d[n] = p : h[n] = p;
                            else if ("every" === (null == a ? void 0 : a.filterMode))
                                continue e
                        }
                    } else
                        p = r(c, t, c),
                        -1 !== p && !1 !== p && (h.title = p);
                    const e = Object.keys(h).length
                      , n = Object.keys(d).length;
                    if (!e && !n)
                        continue;
                    if ("union" === (null == a ? void 0 : a.filterMode) && n !== s && !e)
                        continue;
                    if ("intersection" === (null == a ? void 0 : a.filterMode) && (n !== s || !e))
                        continue
                }
                n.push({
                    index: l,
                    matches: {
                        ...h,
                        ...d
                    }
                })
            }
            return n
        }(s.value, c, {
            customKeyFilter: {
                ...e.customKeyFilter,
                ...r(null == i ? void 0 : i.customKeyFilter)
            },
            default: e.customFilter,
            filterKeys: e.filterKeys,
            filterMode: e.filterMode,
            noFilter: e.noFilter
        })
          , d = r(t)
          , h = []
          , p = new Map;
        u.forEach((e => {
            let {index: t, matches: a} = e;
            const i = d[t];
            h.push(i),
            p.set(i.value, a)
        }
        )),
        n.value = h,
        o.value = p
    }
    )),
    {
        filteredItems: n,
        filteredMatches: o,
        getMatches: function(e) {
            return o.value.get(e.value)
        }
    }
}
const Gs = d({
    autoSelectFirst: {
        type: [Boolean, String]
    },
    clearOnSelect: Boolean,
    search: String,
    ...Ys({
        filterKeys: ["title"]
    }),
    ...Ns(),
    ...Fe(Ts({
        modelValue: null,
        role: "combobox"
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...Ni({
        transition: !1
    })
}, "VAutocomplete")
  , js = g()({
    name: "VAutocomplete",
    props: Gs(),
    emits: {
        "update:focused": e => !0,
        "update:search": e => !0,
        "update:modelValue": e => !0,
        "update:menu": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {t: i} = Te()
          , n = l()
          , r = j(!1)
          , o = j(!0)
          , s = j(!1)
          , c = l()
          , u = l()
          , d = re(e, "menu")
          , h = F({
            get: () => d.value,
            set: e => {
                var t;
                d.value && !e && (null == (t = c.value) ? void 0 : t.openChildren) || (d.value = e)
            }
        })
          , p = j(-1)
          , v = F(( () => {
            var e;
            return null == (e = n.value) ? void 0 : e.color
        }
        ))
          , g = F(( () => h.value ? e.closeText : e.openText))
          , {items: f, transformIn: m, transformOut: b} = Lo(e)
          , {textColorClasses: w, textColorStyles: k} = Bi(v)
          , S = re(e, "search", "")
          , C = re(e, "modelValue", [], (e => m(null === e ? [null] : ve(e))), (t => {
            const a = b(t);
            return e.multiple ? a : a[0] ?? null
        }
        ))
          , P = F(( () => "function" == typeof e.counterValue ? e.counterValue(C.value) : "number" == typeof e.counterValue ? e.counterValue : C.value.length))
          , L = Fr()
          , {filteredItems: I, getMatches: _} = Ws(e, f, ( () => o.value ? "" : S.value))
          , T = F(( () => e.hideSelected ? I.value.filter((e => !C.value.some((t => t.value === e.value)))) : I.value))
          , E = F(( () => C.value.map((e => e.props.value))))
          , O = F(( () => {
            var t;
            return (!0 === e.autoSelectFirst || "exact" === e.autoSelectFirst && S.value === (null == (t = T.value[0]) ? void 0 : t.title)) && T.value.length > 0 && !o.value && !s.value
        }
        ))
          , V = F(( () => e.hideNoData && !T.value.length || e.readonly || (null == L ? void 0 : L.isReadonly.value)))
          , B = l()
          , {onListScroll: M, onListKeydown: D} = Rs(B, n);
        function R(t) {
            e.openOnClear && (h.value = !0),
            S.value = ""
        }
        function N() {
            V.value || (h.value = !0)
        }
        function z(e) {
            V.value || (r.value && (e.preventDefault(),
            e.stopPropagation()),
            h.value = !h.value)
        }
        function H(t) {
            var a, i, r;
            if (e.readonly || (null == L ? void 0 : L.isReadonly.value))
                return;
            const o = n.value.selectionStart
              , s = C.value.length;
            if ((p.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(t.key)) && t.preventDefault(),
            ["Enter", "ArrowDown"].includes(t.key) && (h.value = !0),
            ["Escape"].includes(t.key) && (h.value = !1),
            O.value && ["Enter", "Tab"].includes(t.key) && K(T.value[0]),
            "ArrowDown" === t.key && O.value && (null == (a = B.value) || a.focus("next")),
            e.multiple) {
                if (["Backspace", "Delete"].includes(t.key)) {
                    if (p.value < 0)
                        return void ("Backspace" !== t.key || S.value || (p.value = s - 1));
                    const e = p.value
                      , a = C.value[p.value];
                    a && !a.props.disabled && K(a),
                    p.value = e >= s - 1 ? s - 2 : e
                }
                if ("ArrowLeft" === t.key) {
                    if (p.value < 0 && o > 0)
                        return;
                    const e = p.value > -1 ? p.value - 1 : s - 1;
                    C.value[e] ? p.value = e : (p.value = -1,
                    n.value.setSelectionRange(null == (i = S.value) ? void 0 : i.length, null == (r = S.value) ? void 0 : r.length))
                }
                if ("ArrowRight" === t.key) {
                    if (p.value < 0)
                        return;
                    const e = p.value + 1;
                    C.value[e] ? p.value = e : (p.value = -1,
                    n.value.setSelectionRange(0, 0))
                }
            }
        }
        function X(e) {
            if (Ve(n.value, ":autofill") || Ve(n.value, ":-webkit-autofill")) {
                const t = f.value.find((t => t.title === e.target.value));
                t && K(t)
            }
        }
        function Y() {
            var e;
            r.value && (o.value = !0,
            null == (e = n.value) || e.focus())
        }
        function W(e) {
            r.value = !0,
            setTimeout(( () => {
                s.value = !0
            }
            ))
        }
        function G(e) {
            s.value = !1
        }
        function U(t) {
            (null == t || "" === t && !e.multiple) && (C.value = [])
        }
        const Z = j(!1);
        function K(t) {
            let a = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (!t.props.disabled)
                if (e.multiple) {
                    const i = C.value.findIndex((a => e.valueComparator(a.value, t.value)));
                    if (a = -1 === i,
                    a)
                        C.value = [...C.value, t];
                    else {
                        const e = [...C.value];
                        e.splice(i, 1),
                        C.value = e
                    }
                    e.clearOnSelect && (S.value = "")
                } else
                    C.value = a ? [t] : [],
                    Z.value = !0,
                    S.value = a ? t.title : "",
                    h.value = !1,
                    o.value = !0,
                    q(( () => Z.value = !1))
        }
        return $(r, ( (t, a) => {
            var i;
            t !== a && (t ? (Z.value = !0,
            S.value = e.multiple ? "" : String((null == (i = C.value.at(-1)) ? void 0 : i.props.title) ?? ""),
            o.value = !0,
            q(( () => Z.value = !1))) : (e.multiple || null != S.value ? !O.value || s.value || C.value.some((e => {
                let {value: t} = e;
                return t === T.value[0].value
            }
            )) || K(T.value[0]) : C.value = [],
            h.value = !1,
            S.value = "",
            p.value = -1))
        }
        )),
        $(S, (e => {
            r.value && !Z.value && (e && (h.value = !0),
            o.value = !e)
        }
        )),
        $(h, ( () => {
            if (!e.hideSelected && h.value && C.value.length) {
                const e = T.value.findIndex((e => C.value.some((t => e.value === t.value))));
                Ae && window.requestAnimationFrame(( () => {
                    var t;
                    e >= 0 && (null == (t = u.value) || t.scrollToIndex(e))
                }
                ))
            }
        }
        )),
        $(T, ( (t, a) => {
            r.value && (!t.length && e.hideNoData && (h.value = !1),
            !a.length && t.length && (h.value = !0))
        }
        )),
        x(( () => {
            const t = !(!e.chips && !a.chip)
              , s = !!(!e.hideNoData || T.value.length || a["prepend-item"] || a["append-item"] || a["no-data"])
              , l = C.value.length > 0
              , d = Es.filterProps(e);
            return y(Es, A({
                ref: n
            }, d, {
                modelValue: S.value,
                "onUpdate:modelValue": [e => S.value = e, U],
                focused: r.value,
                "onUpdate:focused": e => r.value = e,
                validationValue: C.externalValue,
                counterValue: P.value,
                dirty: l,
                onChange: X,
                class: ["v-autocomplete", "v-autocomplete--" + (e.multiple ? "multiple" : "single"), {
                    "v-autocomplete--active-menu": h.value,
                    "v-autocomplete--chips": !!e.chips,
                    "v-autocomplete--selection-slot": !!a.selection,
                    "v-autocomplete--selecting-index": p.value > -1
                }, e.class],
                style: e.style,
                readonly: e.readonly,
                placeholder: l ? void 0 : e.placeholder,
                "onClick:clear": R,
                "onMousedown:control": N,
                onKeydown: H
            }), {
                ...a,
                default: () => y(Q, null, [y(ys, A({
                    ref: c,
                    modelValue: h.value,
                    "onUpdate:modelValue": e => h.value = e,
                    activator: "parent",
                    contentClass: "v-autocomplete__content",
                    disabled: V.value,
                    eager: e.eager,
                    maxHeight: 310,
                    openOnClick: !1,
                    closeOnContentClick: !1,
                    transition: e.transition,
                    onAfterLeave: Y
                }, e.menuProps), {
                    default: () => [s && y(Eo, A({
                        ref: B,
                        selected: E.value,
                        selectStrategy: e.multiple ? "independent" : "single-independent",
                        onMousedown: e => e.preventDefault(),
                        onKeydown: D,
                        onFocusin: W,
                        onFocusout: G,
                        onScrollPassive: M,
                        tabindex: "-1",
                        "aria-live": "polite",
                        color: e.itemColor ?? e.color
                    }, e.listProps), {
                        default: () => {
                            var t, n, r;
                            return [null == (t = a["prepend-item"]) ? void 0 : t.call(a), !T.value.length && !e.hideNoData && ((null == (n = a["no-data"]) ? void 0 : n.call(a)) ?? y(mo, {
                                title: i(e.noDataText)
                            }, null)), y(Ds, {
                                ref: u,
                                renderless: !0,
                                items: T.value
                            }, {
                                default: t => {
                                    var i;
                                    let {item: n, index: r, itemRef: s} = t;
                                    const l = A(n.props, {
                                        ref: s,
                                        key: r,
                                        active: !(!O.value || 0 !== r) || void 0,
                                        onClick: () => K(n)
                                    });
                                    return (null == (i = a.item) ? void 0 : i.call(a, {
                                        item: n,
                                        index: r,
                                        props: l
                                    })) ?? y(mo, A(l, {
                                        role: "option"
                                    }), {
                                        prepend: t => {
                                            let {isSelected: a} = t;
                                            return y(Q, null, [e.multiple && !e.hideSelected ? y(Pr, {
                                                key: n.value,
                                                modelValue: a,
                                                ripple: !1,
                                                tabindex: "-1"
                                            }, null) : void 0, n.props.prependAvatar && y(fr, {
                                                image: n.props.prependAvatar
                                            }, null), n.props.prependIcon && y(Cn, {
                                                icon: n.props.prependIcon
                                            }, null)])
                                        }
                                        ,
                                        title: () => {
                                            var e, t;
                                            return o.value ? n.title : function(e, t, a) {
                                                if (null == t)
                                                    return e;
                                                if (Array.isArray(t))
                                                    throw new Error("Multiple matches is not implemented");
                                                return "number" == typeof t && ~t ? y(Q, null, [y("span", {
                                                    class: "v-autocomplete__unmask"
                                                }, [e.substr(0, t)]), y("span", {
                                                    class: "v-autocomplete__mask"
                                                }, [e.substr(t, a)]), y("span", {
                                                    class: "v-autocomplete__unmask"
                                                }, [e.substr(t + a)])]) : e
                                            }(n.title, null == (e = _(n)) ? void 0 : e.title, (null == (t = S.value) ? void 0 : t.length) ?? 0)
                                        }
                                    })
                                }
                            }), null == (r = a["append-item"]) ? void 0 : r.call(a)]
                        }
                    })]
                }), C.value.map(( (i, n) => {
                    const r = {
                        "onClick:close": function(e) {
                            e.stopPropagation(),
                            e.preventDefault(),
                            K(i, !1)
                        },
                        onMousedown(e) {
                            e.preventDefault(),
                            e.stopPropagation()
                        },
                        modelValue: !0,
                        "onUpdate:modelValue": void 0
                    }
                      , o = t ? !!a.chip : !!a.selection
                      , s = o ? pt(t ? a.chip({
                        item: i,
                        index: n,
                        props: r
                    }) : a.selection({
                        item: i,
                        index: n
                    })) : void 0;
                    if (!o || s)
                        return y("div", {
                            key: i.value,
                            class: ["v-autocomplete__selection", n === p.value && ["v-autocomplete__selection--selected", w.value]],
                            style: n === p.value ? k.value : {}
                        }, [t ? a.chip ? y(_i, {
                            key: "chip-defaults",
                            defaults: {
                                VChip: {
                                    closable: e.closableChips,
                                    size: "small",
                                    text: i.title
                                }
                            }
                        }, {
                            default: () => [s]
                        }) : y(Zr, A({
                            key: "chip",
                            closable: e.closableChips,
                            size: "small",
                            text: i.title,
                            disabled: i.props.disabled
                        }, r), null) : s ?? y("span", {
                            class: "v-autocomplete__selection-text"
                        }, [i.title, e.multiple && n < C.value.length - 1 && y("span", {
                            class: "v-autocomplete__selection-comma"
                        }, [vt(",")])])])
                }
                ))]),
                "append-inner": function() {
                    for (var t, n = arguments.length, r = new Array(n), o = 0; o < n; o++)
                        r[o] = arguments[o];
                    return y(Q, null, [null == (t = a["append-inner"]) ? void 0 : t.call(a, ...r), e.menuIcon ? y(Cn, {
                        class: "v-autocomplete__menu-icon",
                        icon: e.menuIcon,
                        onMousedown: z,
                        onClick: gt,
                        "aria-label": i(g.value),
                        title: i(g.value)
                    }, null) : void 0])
                }
            })
        }
        )),
        bs({
            isFocused: r,
            isPristine: o,
            menu: h,
            search: S,
            filteredItems: I,
            select: K
        }, n)
    }
})
  , $s = d({
    bordered: Boolean,
    color: String,
    content: [Number, String],
    dot: Boolean,
    floating: Boolean,
    icon: me,
    inline: Boolean,
    label: {
        type: String,
        default: "$vuetify.badge"
    },
    max: [Number, String],
    modelValue: {
        type: Boolean,
        default: !0
    },
    offsetX: [Number, String],
    offsetY: [Number, String],
    textColor: String,
    ...h(),
    ..._n({
        location: "top end"
    }),
    ...Di(),
    ...ai(),
    ...v(),
    ...Ni({
        transition: "scale-rotate-transition"
    })
}, "VBadge")
  , Us = g()({
    name: "VBadge",
    inheritAttrs: !1,
    props: $s(),
    setup(e, t) {
        const {backgroundColorClasses: a, backgroundColorStyles: i} = Mi(W(e, "color"))
          , {roundedClasses: n} = Ri(e)
          , {t: r} = Te()
          , {textColorClasses: o, textColorStyles: s} = Bi(W(e, "textColor"))
          , {themeClasses: l} = ft()
          , {locationStyles: c} = Tn(e, !0, (t => (e.floating ? e.dot ? 2 : 4 : e.dot ? 8 : 12) + (["top", "bottom"].includes(t) ? +(e.offsetY ?? 0) : ["left", "right"].includes(t) ? +(e.offsetX ?? 0) : 0)));
        return x(( () => {
            const u = Number(e.content)
              , d = !e.max || isNaN(u) ? e.content : u <= +e.max ? u : `${e.max}+`
              , [h,p] = mt(t.attrs, ["aria-atomic", "aria-label", "aria-live", "role", "title"]);
            return y(e.tag, A({
                class: ["v-badge", {
                    "v-badge--bordered": e.bordered,
                    "v-badge--dot": e.dot,
                    "v-badge--floating": e.floating,
                    "v-badge--inline": e.inline
                }, e.class]
            }, p, {
                style: e.style
            }), {
                default: () => {
                    var p, v;
                    return [y("div", {
                        class: "v-badge__wrapper"
                    }, [null == (v = (p = t.slots).default) ? void 0 : v.call(p), y(zi, {
                        transition: e.transition
                    }, {
                        default: () => {
                            var p, v;
                            return [K(y("span", A({
                                class: ["v-badge__badge", l.value, a.value, n.value, o.value],
                                style: [i.value, s.value, e.inline ? {} : c.value],
                                "aria-atomic": "true",
                                "aria-label": r(e.label, u),
                                "aria-live": "polite",
                                role: "status"
                            }, h), [e.dot ? void 0 : t.slots.badge ? null == (v = (p = t.slots).badge) ? void 0 : v.call(p) : e.icon ? y(Cn, {
                                icon: e.icon
                            }, null) : d]), [[ee, e.modelValue]])]
                        }
                    })])]
                }
            })
        }
        )),
        {}
    }
})
  , qs = d({
    color: String,
    density: String,
    ...h()
}, "VBannerActions")
  , Zs = g()({
    name: "VBannerActions",
    props: qs(),
    setup(e, t) {
        let {slots: a} = t;
        return V({
            VBtn: {
                color: e.color,
                density: e.density,
                slim: !0,
                variant: "text"
            }
        }),
        x(( () => {
            var t;
            return y("div", {
                class: ["v-banner-actions", e.class],
                style: e.style
            }, [null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {}
    }
})
  , Ks = _e("v-banner-text")
  , Js = d({
    avatar: String,
    bgColor: String,
    color: String,
    icon: me,
    lines: String,
    stacked: Boolean,
    sticky: Boolean,
    text: String,
    ...Gi(),
    ...h(),
    ...nn(),
    ...Ti(),
    ...Be(),
    ...$i(),
    ..._n(),
    ...Dn(),
    ...Di(),
    ...ai(),
    ...v()
}, "VBanner")
  , Qs = g()({
    name: "VBanner",
    props: Js(),
    setup(e, t) {
        let {slots: a} = t;
        const {backgroundColorClasses: i, backgroundColorStyles: n} = Mi(e, "bgColor")
          , {borderClasses: r} = ji(e)
          , {densityClasses: o} = rn(e)
          , {displayClasses: s, mobile: l} = Me(e)
          , {dimensionStyles: c} = Ei(e)
          , {elevationClasses: u} = Ui(e)
          , {locationStyles: d} = Tn(e)
          , {positionClasses: h} = Rn(e)
          , {roundedClasses: p} = Ri(e)
          , {themeClasses: v} = f(e)
          , g = W(e, "color")
          , m = W(e, "density");
        V({
            VBannerActions: {
                color: g,
                density: m
            }
        }),
        x(( () => {
            const t = !(!e.text && !a.text)
              , f = !(!e.avatar && !e.icon)
              , b = !(!f && !a.prepend);
            return y(e.tag, {
                class: ["v-banner", {
                    "v-banner--stacked": e.stacked || l.value,
                    "v-banner--sticky": e.sticky,
                    [`v-banner--${e.lines}-line`]: !!e.lines
                }, v.value, i.value, r.value, o.value, s.value, u.value, h.value, p.value, e.class],
                style: [n.value, c.value, d.value, e.style],
                role: "banner"
            }, {
                default: () => {
                    var i;
                    return [b && y("div", {
                        key: "prepend",
                        class: "v-banner__prepend"
                    }, [a.prepend ? y(_i, {
                        key: "prepend-defaults",
                        disabled: !f,
                        defaults: {
                            VAvatar: {
                                color: g.value,
                                density: m.value,
                                icon: e.icon,
                                image: e.avatar
                            }
                        }
                    }, a.prepend) : y(fr, {
                        key: "prepend-avatar",
                        color: g.value,
                        density: m.value,
                        icon: e.icon,
                        image: e.avatar
                    }, null)]), y("div", {
                        class: "v-banner__content"
                    }, [t && y(Ks, {
                        key: "text"
                    }, {
                        default: () => {
                            var t;
                            return [(null == (t = a.text) ? void 0 : t.call(a)) ?? e.text]
                        }
                    }), null == (i = a.default) ? void 0 : i.call(a)]), a.actions && y(Zs, {
                        key: "actions"
                    }, a.actions)]
                }
            })
        }
        ))
    }
})
  , el = d({
    bgColor: String,
    color: String,
    grow: Boolean,
    mode: {
        type: String,
        validator: e => !e || ["horizontal", "shift"].includes(e)
    },
    height: {
        type: [Number, String],
        default: 56
    },
    active: {
        type: Boolean,
        default: !0
    },
    ...Gi(),
    ...h(),
    ...nn(),
    ...$i(),
    ...Di(),
    ...ne({
        name: "bottom-navigation"
    }),
    ...ai({
        tag: "header"
    }),
    ...hn({
        modelValue: !0,
        selectedClass: "v-btn--selected"
    }),
    ...v()
}, "VBottomNavigation")
  , tl = g()({
    name: "VBottomNavigation",
    props: el(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = ft()
          , {borderClasses: n} = ji(e)
          , {backgroundColorClasses: r, backgroundColorStyles: o} = Mi(W(e, "bgColor"))
          , {densityClasses: s} = rn(e)
          , {elevationClasses: l} = Ui(e)
          , {roundedClasses: c} = Ri(e)
          , {ssrBootStyles: u} = Qi()
          , d = F(( () => Number(e.height) - ("comfortable" === e.density ? 8 : 0) - ("compact" === e.density ? 16 : 0)))
          , h = W(e, "active")
          , {layoutItemStyles: p} = se({
            id: e.name,
            order: F(( () => parseInt(e.order, 10))),
            position: F(( () => "bottom")),
            layoutSize: F(( () => h.value ? d.value : 0)),
            elementSize: d,
            active: h,
            absolute: W(e, "absolute")
        });
        return gn(e, mn),
        V({
            VBtn: {
                color: W(e, "color"),
                density: W(e, "density"),
                stacked: F(( () => "horizontal" !== e.mode)),
                variant: "text"
            }
        }, {
            scoped: !0
        }),
        x(( () => y(e.tag, {
            class: ["v-bottom-navigation", {
                "v-bottom-navigation--active": h.value,
                "v-bottom-navigation--grow": e.grow,
                "v-bottom-navigation--shift": "shift" === e.mode
            }, i.value, r.value, n.value, s.value, l.value, c.value, e.class],
            style: [o.value, p.value, {
                height: B(d.value),
                transform: `translateY(${B(h.value ? 0 : 100, "%")})`
            }, u.value, e.style]
        }, {
            default: () => [a.default && y("div", {
                class: "v-bottom-navigation__content"
            }, [a.default()])]
        }))),
        {}
    }
})
  , al = d({
    fullscreen: Boolean,
    retainFocus: {
        type: Boolean,
        default: !0
    },
    scrollable: Boolean,
    ...vs({
        origin: "center center",
        scrollStrategy: "block",
        transition: {
            component: ui
        },
        zIndex: 2400
    })
}, "VDialog")
  , il = g()({
    name: "VDialog",
    props: al(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , {scopeId: n} = rs()
          , r = l();
        function o(e) {
            var t, a;
            const i = e.relatedTarget
              , n = e.target;
            if (i !== n && (null == (t = r.value) ? void 0 : t.contentEl) && (null == (a = r.value) ? void 0 : a.globalTop) && ![document, r.value.contentEl].includes(n) && !r.value.contentEl.contains(n)) {
                const e = De(r.value.contentEl);
                if (!e.length)
                    return;
                const t = e[0]
                  , a = e[e.length - 1];
                i === t ? a.focus() : t.focus()
            }
        }
        Ae && $(( () => i.value && e.retainFocus), (e => {
            e ? document.addEventListener("focusin", o) : document.removeEventListener("focusin", o)
        }
        ), {
            immediate: !0
        }),
        $(i, (async e => {
            var t, a;
            await q(),
            e ? null == (t = r.value.contentEl) || t.focus({
                preventScroll: !0
            }) : null == (a = r.value.activatorEl) || a.focus({
                preventScroll: !0
            })
        }
        ));
        const s = F(( () => A({
            "aria-haspopup": "dialog",
            "aria-expanded": String(i.value)
        }, e.activatorProps)));
        return x(( () => {
            const t = gs.filterProps(e);
            return y(gs, A({
                ref: r,
                class: ["v-dialog", {
                    "v-dialog--fullscreen": e.fullscreen,
                    "v-dialog--scrollable": e.scrollable
                }, e.class],
                style: e.style
            }, t, {
                modelValue: i.value,
                "onUpdate:modelValue": e => i.value = e,
                "aria-modal": "true",
                activatorProps: s.value,
                role: "dialog"
            }, n), {
                activator: a.activator,
                default: function() {
                    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
                        t[i] = arguments[i];
                    return y(_i, {
                        root: "VDialog"
                    }, {
                        default: () => {
                            var e;
                            return [null == (e = a.default) ? void 0 : e.call(a, ...t)]
                        }
                    })
                }
            })
        }
        )),
        bs({}, r)
    }
})
  , nl = d({
    inset: Boolean,
    ...al({
        transition: "bottom-sheet-transition"
    })
}, "VBottomSheet")
  , rl = g()({
    name: "VBottomSheet",
    props: nl(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue");
        return x(( () => {
            const t = il.filterProps(e);
            return y(il, A(t, {
                contentClass: ["v-bottom-sheet__content", e.contentClass],
                modelValue: i.value,
                "onUpdate:modelValue": e => i.value = e,
                class: ["v-bottom-sheet", {
                    "v-bottom-sheet--inset": e.inset
                }, e.class],
                style: e.style
            }), a)
        }
        )),
        {}
    }
})
  , ol = d({
    divider: [Number, String],
    ...h()
}, "VBreadcrumbsDivider")
  , sl = g()({
    name: "VBreadcrumbsDivider",
    props: ol(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => {
            var t;
            return y("li", {
                class: ["v-breadcrumbs-divider", e.class],
                style: e.style
            }, [(null == (t = null == a ? void 0 : a.default) ? void 0 : t.call(a)) ?? e.divider])
        }
        )),
        {}
    }
})
  , ll = d({
    active: Boolean,
    activeClass: String,
    activeColor: String,
    color: String,
    disabled: Boolean,
    title: String,
    ...h(),
    ...Hn(),
    ...ai({
        tag: "li"
    })
}, "VBreadcrumbsItem")
  , cl = g()({
    name: "VBreadcrumbsItem",
    props: ll(),
    setup(e, t) {
        let {slots: a, attrs: i} = t;
        const n = zn(e, i)
          , r = F(( () => {
            var t;
            return e.active || (null == (t = n.isActive) ? void 0 : t.value)
        }
        ))
          , o = F(( () => r.value ? e.activeColor : e.color))
          , {textColorClasses: s, textColorStyles: l} = Bi(o);
        return x(( () => y(e.tag, {
            class: ["v-breadcrumbs-item", {
                "v-breadcrumbs-item--active": r.value,
                "v-breadcrumbs-item--disabled": e.disabled,
                [`${e.activeClass}`]: r.value && e.activeClass
            }, s.value, e.class],
            style: [l.value, e.style],
            "aria-current": r.value ? "page" : void 0
        }, {
            default: () => {
                var t, i;
                return [n.isLink.value ? y("a", {
                    class: "v-breadcrumbs-item--link",
                    href: n.href.value,
                    "aria-current": r.value ? "page" : void 0,
                    onClick: n.navigate
                }, [(null == (i = a.default) ? void 0 : i.call(a)) ?? e.title]) : (null == (t = a.default) ? void 0 : t.call(a)) ?? e.title]
            }
        }))),
        {}
    }
})
  , ul = d({
    activeClass: String,
    activeColor: String,
    bgColor: String,
    color: String,
    disabled: Boolean,
    divider: {
        type: String,
        default: "/"
    },
    icon: me,
    items: {
        type: Array,
        default: () => []
    },
    ...h(),
    ...nn(),
    ...Di(),
    ...ai({
        tag: "ul"
    })
}, "VBreadcrumbs")
  , dl = g()({
    name: "VBreadcrumbs",
    props: ul(),
    setup(e, t) {
        let {slots: a} = t;
        const {backgroundColorClasses: i, backgroundColorStyles: n} = Mi(W(e, "bgColor"))
          , {densityClasses: r} = rn(e)
          , {roundedClasses: o} = Ri(e);
        V({
            VBreadcrumbsDivider: {
                divider: W(e, "divider")
            },
            VBreadcrumbsItem: {
                activeClass: W(e, "activeClass"),
                activeColor: W(e, "activeColor"),
                color: W(e, "color"),
                disabled: W(e, "disabled")
            }
        });
        const s = F(( () => e.items.map((e => "string" == typeof e ? {
            item: {
                title: e
            },
            raw: e
        } : {
            item: e,
            raw: e
        }))));
        return x(( () => {
            const t = !(!a.prepend && !e.icon);
            return y(e.tag, {
                class: ["v-breadcrumbs", i.value, r.value, o.value, e.class],
                style: [n.value, e.style]
            }, {
                default: () => {
                    var i;
                    return [t && y("li", {
                        key: "prepend",
                        class: "v-breadcrumbs__prepend"
                    }, [a.prepend ? y(_i, {
                        key: "prepend-defaults",
                        disabled: !e.icon,
                        defaults: {
                            VIcon: {
                                icon: e.icon,
                                start: !0
                            }
                        }
                    }, a.prepend) : y(Cn, {
                        key: "prepend-icon",
                        start: !0,
                        icon: e.icon
                    }, null)]), s.value.map(( (e, t, i) => {
                        var n;
                        let {item: r, raw: o} = e;
                        return y(Q, null, [(null == (n = a.item) ? void 0 : n.call(a, {
                            item: r,
                            index: t
                        })) ?? y(cl, A({
                            key: t,
                            disabled: t >= i.length - 1
                        }, "string" == typeof r ? {
                            title: r
                        } : r), {
                            default: a.title ? () => {
                                var e;
                                return null == (e = a.title) ? void 0 : e.call(a, {
                                    item: r,
                                    index: t
                                })
                            }
                            : void 0
                        }), t < i.length - 1 && y(sl, null, {
                            default: a.divider ? () => {
                                var e;
                                return null == (e = a.divider) ? void 0 : e.call(a, {
                                    item: o,
                                    index: t
                                })
                            }
                            : void 0
                        })])
                    }
                    )), null == (i = a.default) ? void 0 : i.call(a)]
                }
            })
        }
        )),
        {}
    }
})
  , hl = g()({
    name: "VCardActions",
    props: h(),
    setup(e, t) {
        let {slots: a} = t;
        return V({
            VBtn: {
                slim: !0,
                variant: "text"
            }
        }),
        x(( () => {
            var t;
            return y("div", {
                class: ["v-card-actions", e.class],
                style: e.style
            }, [null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {}
    }
})
  , pl = _e("v-card-subtitle")
  , vl = _e("v-card-title")
  , gl = d({
    appendAvatar: String,
    appendIcon: me,
    prependAvatar: String,
    prependIcon: me,
    subtitle: [String, Number],
    title: [String, Number],
    ...h(),
    ...nn()
}, "VCardItem")
  , fl = g()({
    name: "VCardItem",
    props: gl(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => {
            var t;
            const i = !(!e.prependAvatar && !e.prependIcon)
              , n = !(!i && !a.prepend)
              , r = !(!e.appendAvatar && !e.appendIcon)
              , o = !(!r && !a.append)
              , s = !(null == e.title && !a.title)
              , l = !(null == e.subtitle && !a.subtitle);
            return y("div", {
                class: ["v-card-item", e.class],
                style: e.style
            }, [n && y("div", {
                key: "prepend",
                class: "v-card-item__prepend"
            }, [a.prepend ? y(_i, {
                key: "prepend-defaults",
                disabled: !i,
                defaults: {
                    VAvatar: {
                        density: e.density,
                        image: e.prependAvatar
                    },
                    VIcon: {
                        density: e.density,
                        icon: e.prependIcon
                    }
                }
            }, a.prepend) : y(Q, null, [e.prependAvatar && y(fr, {
                key: "prepend-avatar",
                density: e.density,
                image: e.prependAvatar
            }, null), e.prependIcon && y(Cn, {
                key: "prepend-icon",
                density: e.density,
                icon: e.prependIcon
            }, null)])]), y("div", {
                class: "v-card-item__content"
            }, [s && y(vl, {
                key: "title"
            }, {
                default: () => {
                    var t;
                    return [(null == (t = a.title) ? void 0 : t.call(a)) ?? e.title]
                }
            }), l && y(pl, {
                key: "subtitle"
            }, {
                default: () => {
                    var t;
                    return [(null == (t = a.subtitle) ? void 0 : t.call(a)) ?? e.subtitle]
                }
            }), null == (t = a.default) ? void 0 : t.call(a)]), o && y("div", {
                key: "append",
                class: "v-card-item__append"
            }, [a.append ? y(_i, {
                key: "append-defaults",
                disabled: !r,
                defaults: {
                    VAvatar: {
                        density: e.density,
                        image: e.appendAvatar
                    },
                    VIcon: {
                        density: e.density,
                        icon: e.appendIcon
                    }
                }
            }, a.append) : y(Q, null, [e.appendIcon && y(Cn, {
                key: "append-icon",
                density: e.density,
                icon: e.appendIcon
            }, null), e.appendAvatar && y(fr, {
                key: "append-avatar",
                density: e.density,
                image: e.appendAvatar
            }, null)])])])
        }
        )),
        {}
    }
})
  , ml = _e("v-card-text")
  , bl = d({
    appendAvatar: String,
    appendIcon: me,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: {
        type: Boolean,
        default: void 0
    },
    prependAvatar: String,
    prependIcon: me,
    ripple: {
        type: [Boolean, Object],
        default: !0
    },
    subtitle: [String, Number],
    text: [String, Number],
    title: [String, Number],
    ...Gi(),
    ...h(),
    ...nn(),
    ...Ti(),
    ...$i(),
    ...Vn(),
    ..._n(),
    ...Dn(),
    ...Di(),
    ...Hn(),
    ...ai(),
    ...v(),
    ...ln({
        variant: "elevated"
    })
}, "VCard")
  , xl = g()({
    name: "VCard",
    directives: {
        Ripple: rr
    },
    props: bl(),
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const {themeClasses: n} = f(e)
          , {borderClasses: r} = ji(e)
          , {colorClasses: o, colorStyles: s, variantClasses: l} = cn(e)
          , {densityClasses: c} = rn(e)
          , {dimensionStyles: u} = Ei(e)
          , {elevationClasses: d} = Ui(e)
          , {loaderClasses: h} = Fn(e)
          , {locationStyles: p} = Tn(e)
          , {positionClasses: v} = Rn(e)
          , {roundedClasses: g} = Ri(e)
          , m = zn(e, a)
          , b = F(( () => !1 !== e.link && m.isLink.value))
          , w = F(( () => !e.disabled && !1 !== e.link && (e.link || m.isClickable.value)));
        return x(( () => {
            const t = b.value ? "a" : e.tag
              , a = !(!i.title && null == e.title)
              , f = !(!i.subtitle && null == e.subtitle)
              , x = a || f
              , k = !!(i.append || e.appendAvatar || e.appendIcon)
              , S = !!(i.prepend || e.prependAvatar || e.prependIcon)
              , C = !(!i.image && !e.image)
              , A = x || S || k
              , P = !(!i.text && null == e.text);
            return K(y(t, {
                class: ["v-card", {
                    "v-card--disabled": e.disabled,
                    "v-card--flat": e.flat,
                    "v-card--hover": e.hover && !(e.disabled || e.flat),
                    "v-card--link": w.value
                }, n.value, r.value, o.value, c.value, d.value, h.value, v.value, g.value, l.value, e.class],
                style: [s.value, u.value, p.value, e.style],
                href: m.href.value,
                onClick: w.value && m.navigate,
                tabindex: e.disabled ? -1 : void 0
            }, {
                default: () => {
                    var t;
                    return [C && y("div", {
                        key: "image",
                        class: "v-card__image"
                    }, [i.image ? y(_i, {
                        key: "image-defaults",
                        disabled: !e.image,
                        defaults: {
                            VImg: {
                                cover: !0,
                                src: e.image
                            }
                        }
                    }, i.image) : y(Wi, {
                        key: "image-img",
                        cover: !0,
                        src: e.image
                    }, null)]), y(Bn, {
                        name: "v-card",
                        active: !!e.loading,
                        color: "boolean" == typeof e.loading ? void 0 : e.loading
                    }, {
                        default: i.loader
                    }), A && y(fl, {
                        key: "item",
                        prependAvatar: e.prependAvatar,
                        prependIcon: e.prependIcon,
                        title: e.title,
                        subtitle: e.subtitle,
                        appendAvatar: e.appendAvatar,
                        appendIcon: e.appendIcon
                    }, {
                        default: i.item,
                        prepend: i.prepend,
                        title: i.title,
                        subtitle: i.subtitle,
                        append: i.append
                    }), P && y(ml, {
                        key: "text"
                    }, {
                        default: () => {
                            var t;
                            return [(null == (t = i.text) ? void 0 : t.call(i)) ?? e.text]
                        }
                    }), null == (t = i.default) ? void 0 : t.call(i), i.actions && y(hl, null, {
                        default: i.actions
                    }), sn(w.value, "v-card")]
                }
            }), [[J("ripple"), w.value && e.ripple]])
        }
        )),
        {}
    }
});
function yl(e, t) {
    var a;
    const i = e.changedTouches[0];
    t.touchendX = i.clientX,
    t.touchendY = i.clientY,
    null == (a = t.end) || a.call(t, {
        originalEvent: e,
        ...t
    }),
    (e => {
        const {touchstartX: t, touchendX: a, touchstartY: i, touchendY: n} = e;
        e.offsetX = a - t,
        e.offsetY = n - i,
        Math.abs(e.offsetY) < .5 * Math.abs(e.offsetX) && (e.left && a < t - 16 && e.left(e),
        e.right && a > t + 16 && e.right(e)),
        Math.abs(e.offsetX) < .5 * Math.abs(e.offsetY) && (e.up && n < i - 16 && e.up(e),
        e.down && n > i + 16 && e.down(e))
    }
    )(t)
}
const wl = {
    mounted: function(e, t) {
        var a;
        const i = t.value
          , n = (null == i ? void 0 : i.parent) ? e.parentElement : e
          , r = (null == i ? void 0 : i.options) ?? {
            passive: !0
        }
          , o = null == (a = t.instance) ? void 0 : a.$.uid;
        if (!n || !o)
            return;
        const s = function() {
            let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            const t = {
                touchstartX: 0,
                touchstartY: 0,
                touchendX: 0,
                touchendY: 0,
                touchmoveX: 0,
                touchmoveY: 0,
                offsetX: 0,
                offsetY: 0,
                left: e.left,
                right: e.right,
                up: e.up,
                down: e.down,
                start: e.start,
                move: e.move,
                end: e.end
            };
            return {
                touchstart: e => function(e, t) {
                    var a;
                    const i = e.changedTouches[0];
                    t.touchstartX = i.clientX,
                    t.touchstartY = i.clientY,
                    null == (a = t.start) || a.call(t, {
                        originalEvent: e,
                        ...t
                    })
                }(e, t),
                touchend: e => yl(e, t),
                touchmove: e => function(e, t) {
                    var a;
                    const i = e.changedTouches[0];
                    t.touchmoveX = i.clientX,
                    t.touchmoveY = i.clientY,
                    null == (a = t.move) || a.call(t, {
                        originalEvent: e,
                        ...t
                    })
                }(e, t)
            }
        }(t.value);
        n._touchHandlers = n._touchHandlers ?? Object.create(null),
        n._touchHandlers[o] = s,
        bt(s).forEach((e => {
            n.addEventListener(e, s[e], r)
        }
        ))
    },
    unmounted: function(e, t) {
        var a, i;
        const n = (null == (a = t.value) ? void 0 : a.parent) ? e.parentElement : e
          , r = null == (i = t.instance) ? void 0 : i.$.uid;
        if (!(null == n ? void 0 : n._touchHandlers) || !r)
            return;
        const o = n._touchHandlers[r];
        bt(o).forEach((e => {
            n.removeEventListener(e, o[e])
        }
        )),
        delete n._touchHandlers[r]
    }
}
  , kl = wl
  , Sl = Symbol.for("vuetify:v-window")
  , Cl = Symbol.for("vuetify:v-window-group")
  , Al = d({
    continuous: Boolean,
    nextIcon: {
        type: [Boolean, String, Function, Object],
        default: "$next"
    },
    prevIcon: {
        type: [Boolean, String, Function, Object],
        default: "$prev"
    },
    reverse: Boolean,
    showArrows: {
        type: [Boolean, String],
        validator: e => "boolean" == typeof e || "hover" === e
    },
    touch: {
        type: [Object, Boolean],
        default: void 0
    },
    direction: {
        type: String,
        default: "horizontal"
    },
    modelValue: null,
    disabled: Boolean,
    selectedClass: {
        type: String,
        default: "v-window-item--active"
    },
    mandatory: {
        type: [Boolean, String],
        default: "force"
    },
    ...h(),
    ...ai(),
    ...v()
}, "VWindow")
  , Pl = g()({
    name: "VWindow",
    directives: {
        Touch: wl
    },
    props: Al(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {isRtl: n} = b()
          , {t: r} = Te()
          , o = gn(e, Cl)
          , s = l()
          , c = F(( () => n.value ? !e.reverse : e.reverse))
          , u = j(!1)
          , d = F(( () => `v-window-${"vertical" === e.direction ? "y" : "x"}${(c.value ? !u.value : u.value) ? "-reverse" : ""}-transition`))
          , h = j(0)
          , p = l(void 0)
          , v = F(( () => o.items.value.findIndex((e => o.selected.value.includes(e.id)))));
        $(v, ( (e, t) => {
            const a = o.items.value.length
              , i = a - 1;
            u.value = a <= 2 ? e < t : e === i && 0 === t || (0 !== e || t !== i) && e < t
        }
        )),
        ue(Sl, {
            transition: d,
            isReversed: u,
            transitionCount: h,
            transitionHeight: p,
            rootRef: s
        });
        const g = F(( () => e.continuous || 0 !== v.value))
          , m = F(( () => e.continuous || v.value !== o.items.value.length - 1));
        function w() {
            g.value && o.prev()
        }
        function k() {
            m.value && o.next()
        }
        const S = F(( () => {
            const t = []
              , i = {
                icon: n.value ? e.nextIcon : e.prevIcon,
                class: "v-window__" + (c.value ? "right" : "left"),
                onClick: o.prev,
                "aria-label": r("$vuetify.carousel.prev")
            };
            t.push(g.value ? a.prev ? a.prev({
                props: i
            }) : y(sr, i, null) : y("div", null, null));
            const s = {
                icon: n.value ? e.prevIcon : e.nextIcon,
                class: "v-window__" + (c.value ? "left" : "right"),
                onClick: o.next,
                "aria-label": r("$vuetify.carousel.next")
            };
            return t.push(m.value ? a.next ? a.next({
                props: s
            }) : y(sr, s, null) : y("div", null, null)),
            t
        }
        ))
          , C = F(( () => {
            if (!1 === e.touch)
                return e.touch;
            return {
                ...{
                    left: () => {
                        c.value ? w() : k()
                    }
                    ,
                    right: () => {
                        c.value ? k() : w()
                    }
                    ,
                    start: e => {
                        let {originalEvent: t} = e;
                        t.stopPropagation()
                    }
                },
                ...!0 === e.touch ? {} : e.touch
            }
        }
        ));
        return x(( () => K(y(e.tag, {
            ref: s,
            class: ["v-window", {
                "v-window--show-arrows-on-hover": "hover" === e.showArrows
            }, i.value, e.class],
            style: e.style
        }, {
            default: () => {
                var t, i;
                return [y("div", {
                    class: "v-window__container",
                    style: {
                        height: p.value
                    }
                }, [null == (t = a.default) ? void 0 : t.call(a, {
                    group: o
                }), !1 !== e.showArrows && y("div", {
                    class: "v-window__controls"
                }, [S.value])]), null == (i = a.additional) ? void 0 : i.call(a, {
                    group: o
                })]
            }
        }), [[J("touch"), C.value]]))),
        {
            group: o
        }
    }
})
  , Ll = d({
    color: String,
    cycle: Boolean,
    delimiterIcon: {
        type: me,
        default: "$delimiter"
    },
    height: {
        type: [Number, String],
        default: 500
    },
    hideDelimiters: Boolean,
    hideDelimiterBackground: Boolean,
    interval: {
        type: [Number, String],
        default: 6e3,
        validator: e => Number(e) > 0
    },
    progress: [Boolean, String],
    verticalDelimiters: [Boolean, String],
    ...Al({
        continuous: !0,
        mandatory: "force",
        showArrows: !0
    })
}, "VCarousel")
  , Il = g()({
    name: "VCarousel",
    props: Ll(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , {t: n} = Te()
          , r = l();
        let o = -1;
        function s() {
            e.cycle && r.value && (o = window.setTimeout(r.value.group.next, +e.interval > 0 ? +e.interval : 6e3))
        }
        function c() {
            window.clearTimeout(o),
            window.requestAnimationFrame(s)
        }
        return $(i, c),
        $(( () => e.interval), c),
        $(( () => e.cycle), (e => {
            e ? c() : window.clearTimeout(o)
        }
        )),
        ae(s),
        x(( () => {
            const t = Pl.filterProps(e);
            return y(Pl, A({
                ref: r
            }, t, {
                modelValue: i.value,
                "onUpdate:modelValue": e => i.value = e,
                class: ["v-carousel", {
                    "v-carousel--hide-delimiter-background": e.hideDelimiterBackground,
                    "v-carousel--vertical-delimiters": e.verticalDelimiters
                }, e.class],
                style: [{
                    height: B(e.height)
                }, e.style]
            }), {
                default: a.default,
                additional: t => {
                    let {group: r} = t;
                    return y(Q, null, [!e.hideDelimiters && y("div", {
                        class: "v-carousel__controls",
                        style: {
                            left: "left" === e.verticalDelimiters && e.verticalDelimiters ? 0 : "auto",
                            right: "right" === e.verticalDelimiters ? 0 : "auto"
                        }
                    }, [r.items.value.length > 0 && y(_i, {
                        defaults: {
                            VBtn: {
                                color: e.color,
                                icon: e.delimiterIcon,
                                size: "x-small",
                                variant: "text"
                            }
                        },
                        scoped: !0
                    }, {
                        default: () => [r.items.value.map(( (e, t) => {
                            const i = {
                                id: `carousel-item-${e.id}`,
                                "aria-label": n("$vuetify.carousel.ariaLabel.delimiter", t + 1, r.items.value.length),
                                class: ["v-carousel__controls__item", r.isSelected(e.id) && "v-btn--active"],
                                onClick: () => r.select(e.id, !0)
                            };
                            return a.item ? a.item({
                                props: i,
                                item: e
                            }) : y(sr, A(e, i), null)
                        }
                        ))]
                    })]), e.progress && y(On, {
                        class: "v-carousel__progress",
                        color: "string" == typeof e.progress ? e.progress : void 0,
                        modelValue: (r.getItemIndex(i.value) + 1) / r.items.value.length * 100
                    }, null)])
                }
                ,
                prev: a.prev,
                next: a.next
            })
        }
        )),
        {}
    }
})
  , _l = d({
    reverseTransition: {
        type: [Boolean, String],
        default: void 0
    },
    transition: {
        type: [Boolean, String],
        default: void 0
    },
    ...h(),
    ...pn(),
    ...is()
}, "VWindowItem")
  , Tl = g()({
    name: "VWindowItem",
    directives: {
        Touch: kl
    },
    props: _l(),
    emits: {
        "group:selected": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = de(Sl)
          , n = vn(e, Cl)
          , {isBooted: r} = Qi();
        if (!i || !n)
            throw new Error("[Vuetify] VWindowItem must be used inside VWindow");
        const o = j(!1)
          , s = F(( () => r.value && (i.isReversed.value ? !1 !== e.reverseTransition : !1 !== e.transition)));
        function l() {
            o.value && i && (o.value = !1,
            i.transitionCount.value > 0 && (i.transitionCount.value -= 1,
            0 === i.transitionCount.value && (i.transitionHeight.value = void 0)))
        }
        function c() {
            var e;
            !o.value && i && (o.value = !0,
            0 === i.transitionCount.value && (i.transitionHeight.value = B(null == (e = i.rootRef.value) ? void 0 : e.clientHeight)),
            i.transitionCount.value += 1)
        }
        function u() {
            l()
        }
        function d(e) {
            o.value && q(( () => {
                s.value && o.value && i && (i.transitionHeight.value = B(e.clientHeight))
            }
            ))
        }
        const h = F(( () => {
            const t = i.isReversed.value ? e.reverseTransition : e.transition;
            return !!s.value && {
                name: "string" != typeof t ? i.transition.value : t,
                onBeforeEnter: c,
                onAfterEnter: l,
                onEnterCancelled: u,
                onBeforeLeave: c,
                onAfterLeave: l,
                onLeaveCancelled: u,
                onEnter: d
            }
        }
        ))
          , {hasContent: p} = ns(e, n.isSelected);
        return x(( () => y(zi, {
            transition: h.value,
            disabled: !r.value
        }, {
            default: () => {
                var t;
                return [K(y("div", {
                    class: ["v-window-item", n.selectedClass.value, e.class],
                    style: e.style
                }, [p.value && (null == (t = a.default) ? void 0 : t.call(a))]), [[ee, n.isSelected.value]])]
            }
        }))),
        {
            groupItem: n
        }
    }
})
  , El = d({
    ...Yi(),
    ..._l()
}, "VCarouselItem")
  , Ol = g()({
    name: "VCarouselItem",
    inheritAttrs: !1,
    props: El(),
    setup(e, t) {
        let {slots: a, attrs: i} = t;
        x(( () => {
            const t = Wi.filterProps(e)
              , n = Tl.filterProps(e);
            return y(Tl, A({
                class: "v-carousel-item"
            }, n), {
                default: () => [y(Wi, A(i, t), a)]
            })
        }
        ))
    }
})
  , Vl = _e("v-code")
  , Fl = Ne({
    name: "VColorPickerCanvas",
    props: d({
        color: {
            type: Object
        },
        disabled: Boolean,
        dotSize: {
            type: [Number, String],
            default: 10
        },
        height: {
            type: [Number, String],
            default: 150
        },
        width: {
            type: [Number, String],
            default: 300
        },
        ...h()
    }, "VColorPickerCanvas")(),
    emits: {
        "update:color": e => !0,
        "update:position": e => !0
    },
    setup(e, t) {
        let {emit: a} = t;
        const i = j(!1)
          , n = l()
          , r = j(parseFloat(e.width))
          , o = j(parseFloat(e.height))
          , s = l({
            x: 0,
            y: 0
        })
          , c = F({
            get: () => s.value,
            set(t) {
                var i, l;
                if (!n.value)
                    return;
                const {x: c, y: u} = t;
                s.value = t,
                a("update:color", {
                    h: (null == (i = e.color) ? void 0 : i.h) ?? 0,
                    s: te(c, 0, r.value) / r.value,
                    v: 1 - te(u, 0, o.value) / o.value,
                    a: (null == (l = e.color) ? void 0 : l.a) ?? 1
                })
            }
        })
          , u = F(( () => {
            const {x: t, y: a} = c.value
              , i = parseInt(e.dotSize, 10) / 2;
            return {
                width: B(e.dotSize),
                height: B(e.dotSize),
                transform: `translate(${B(t - i)}, ${B(a - i)})`
            }
        }
        ))
          , {resizeRef: d} = we((e => {
            var t;
            if (!(null == (t = d.value) ? void 0 : t.offsetParent))
                return;
            const {width: a, height: i} = e[0].contentRect;
            r.value = a,
            o.value = i
        }
        ));
        function h(t) {
            "mousedown" === t.type && t.preventDefault(),
            e.disabled || (p(t),
            window.addEventListener("mousemove", p),
            window.addEventListener("mouseup", v),
            window.addEventListener("touchmove", p),
            window.addEventListener("touchend", v))
        }
        function p(t) {
            if (e.disabled || !n.value)
                return;
            i.value = !0;
            const a = xt(t);
            !function(e, t, a) {
                const {left: i, top: n, width: r, height: o} = a;
                c.value = {
                    x: te(e - i, 0, r),
                    y: te(t - n, 0, o)
                }
            }(a.clientX, a.clientY, n.value.getBoundingClientRect())
        }
        function v() {
            window.removeEventListener("mousemove", p),
            window.removeEventListener("mouseup", v),
            window.removeEventListener("touchmove", p),
            window.removeEventListener("touchend", v)
        }
        function g() {
            var t;
            if (!n.value)
                return;
            const a = n.value
              , i = a.getContext("2d");
            if (!i)
                return;
            const r = i.createLinearGradient(0, 0, a.width, 0);
            r.addColorStop(0, "hsla(0, 0%, 100%, 1)"),
            r.addColorStop(1, `hsla(${(null == (t = e.color) ? void 0 : t.h) ?? 0}, 100%, 50%, 1)`),
            i.fillStyle = r,
            i.fillRect(0, 0, a.width, a.height);
            const o = i.createLinearGradient(0, 0, 0, a.height);
            o.addColorStop(0, "hsla(0, 0%, 0%, 0)"),
            o.addColorStop(1, "hsla(0, 0%, 0%, 1)"),
            i.fillStyle = o,
            i.fillRect(0, 0, a.width, a.height)
        }
        return $(( () => {
            var t;
            return null == (t = e.color) ? void 0 : t.h
        }
        ), g, {
            immediate: !0
        }),
        $(( () => [r.value, o.value]), ( (e, t) => {
            g(),
            s.value = {
                x: c.value.x * e[0] / t[0],
                y: c.value.y * e[1] / t[1]
            }
        }
        ), {
            flush: "post"
        }),
        $(( () => e.color), ( () => {
            i.value ? i.value = !1 : s.value = e.color ? {
                x: e.color.s * r.value,
                y: (1 - e.color.v) * o.value
            } : {
                x: 0,
                y: 0
            }
        }
        ), {
            deep: !0,
            immediate: !0
        }),
        ae(( () => g())),
        x(( () => y("div", {
            ref: d,
            class: ["v-color-picker-canvas", e.class],
            style: e.style,
            onMousedown: h,
            onTouchstartPassive: h
        }, [y("canvas", {
            ref: n,
            width: r.value,
            height: o.value
        }, null), e.color && y("div", {
            class: ["v-color-picker-canvas__dot", {
                "v-color-picker-canvas__dot--disabled": e.disabled
            }],
            style: u.value
        }, null)]))),
        {}
    }
});
const Bl = {
    h: 0,
    s: 0,
    v: 0,
    a: 1
}
  , Ml = {
    inputProps: {
        type: "number",
        min: 0
    },
    inputs: [{
        label: "R",
        max: 255,
        step: 1,
        getValue: e => Math.round(e.r),
        getColor: (e, t) => ({
            ...e,
            r: Number(t)
        })
    }, {
        label: "G",
        max: 255,
        step: 1,
        getValue: e => Math.round(e.g),
        getColor: (e, t) => ({
            ...e,
            g: Number(t)
        })
    }, {
        label: "B",
        max: 255,
        step: 1,
        getValue: e => Math.round(e.b),
        getColor: (e, t) => ({
            ...e,
            b: Number(t)
        })
    }, {
        label: "A",
        max: 1,
        step: .01,
        getValue: e => {
            let {a: t} = e;
            return null != t ? Math.round(100 * t) / 100 : 1
        }
        ,
        getColor: (e, t) => ({
            ...e,
            a: Number(t)
        })
    }],
    to: kt,
    from: Ct
}
  , Dl = {
    ...Ml,
    inputs: null == (e = Ml.inputs) ? void 0 : e.slice(0, 3)
}
  , Rl = {
    inputProps: {
        type: "number",
        min: 0
    },
    inputs: [{
        label: "H",
        max: 360,
        step: 1,
        getValue: e => Math.round(e.h),
        getColor: (e, t) => ({
            ...e,
            h: Number(t)
        })
    }, {
        label: "S",
        max: 1,
        step: .01,
        getValue: e => Math.round(100 * e.s) / 100,
        getColor: (e, t) => ({
            ...e,
            s: Number(t)
        })
    }, {
        label: "L",
        max: 1,
        step: .01,
        getValue: e => Math.round(100 * e.l) / 100,
        getColor: (e, t) => ({
            ...e,
            l: Number(t)
        })
    }, {
        label: "A",
        max: 1,
        step: .01,
        getValue: e => {
            let {a: t} = e;
            return null != t ? Math.round(100 * t) / 100 : 1
        }
        ,
        getColor: (e, t) => ({
            ...e,
            a: Number(t)
        })
    }],
    to: St,
    from: At
}
  , Nl = {
    ...Rl,
    inputs: Rl.inputs.slice(0, 3)
}
  , zl = {
    inputProps: {
        type: "text"
    },
    inputs: [{
        label: "HEXA",
        getValue: e => e,
        getColor: (e, t) => t
    }],
    to: yt,
    from: Pt
}
  , Hl = {
    rgb: Dl,
    rgba: Ml,
    hsl: Nl,
    hsla: Rl,
    hex: {
        ...zl,
        inputs: [{
            label: "HEX",
            getValue: e => e.slice(0, 7),
            getColor: (e, t) => t
        }]
    },
    hexa: zl
}
  , Xl = e => {
    let {label: t, ...a} = e;
    return y("div", {
        class: "v-color-picker-edit__input"
    }, [y("input", a, null), y("span", null, [t])])
}
  , Yl = Ne({
    name: "VColorPickerEdit",
    props: d({
        color: Object,
        disabled: Boolean,
        mode: {
            type: String,
            default: "rgba",
            validator: e => Object.keys(Hl).includes(e)
        },
        modes: {
            type: Array,
            default: () => Object.keys(Hl),
            validator: e => Array.isArray(e) && e.every((e => Object.keys(Hl).includes(e)))
        },
        ...h()
    }, "VColorPickerEdit")(),
    emits: {
        "update:color": e => !0,
        "update:mode": e => !0
    },
    setup(e, t) {
        let {emit: a} = t;
        const i = F(( () => e.modes.map((e => ({
            ...Hl[e],
            name: e
        })))))
          , n = F(( () => {
            var t;
            const n = i.value.find((t => t.name === e.mode));
            if (!n)
                return [];
            const r = e.color ? n.to(e.color) : null;
            return null == (t = n.inputs) ? void 0 : t.map((t => {
                let {getValue: i, getColor: o, ...s} = t;
                return {
                    ...n.inputProps,
                    ...s,
                    disabled: e.disabled,
                    value: r && i(r),
                    onChange: e => {
                        const t = e.target;
                        t && a("update:color", n.from(o(r ?? n.to(Bl), t.value)))
                    }
                }
            }
            ))
        }
        ));
        return x(( () => {
            var t;
            return y("div", {
                class: ["v-color-picker-edit", e.class],
                style: e.style
            }, [null == (t = n.value) ? void 0 : t.map((e => y(Xl, e, null))), i.value.length > 1 && y(sr, {
                icon: "$unfold",
                size: "x-small",
                variant: "plain",
                onClick: () => {
                    const t = i.value.findIndex((t => t.name === e.mode));
                    a("update:mode", i.value[(t + 1) % i.value.length].name)
                }
            }, null)])
        }
        )),
        {}
    }
})
  , Wl = Symbol.for("vuetify:v-slider");
function Gl(e, t, a) {
    const i = "vertical" === a
      , n = t.getBoundingClientRect()
      , r = "touches"in e ? e.touches[0] : e;
    return i ? r.clientY - (n.top + n.height / 2) : r.clientX - (n.left + n.width / 2)
}
const jl = d({
    disabled: {
        type: Boolean,
        default: null
    },
    error: Boolean,
    readonly: {
        type: Boolean,
        default: null
    },
    max: {
        type: [Number, String],
        default: 100
    },
    min: {
        type: [Number, String],
        default: 0
    },
    step: {
        type: [Number, String],
        default: 0
    },
    thumbColor: String,
    thumbLabel: {
        type: [Boolean, String],
        default: void 0,
        validator: e => "boolean" == typeof e || "always" === e
    },
    thumbSize: {
        type: [Number, String],
        default: 20
    },
    showTicks: {
        type: [Boolean, String],
        default: !1,
        validator: e => "boolean" == typeof e || "always" === e
    },
    ticks: {
        type: [Array, Object]
    },
    tickSize: {
        type: [Number, String],
        default: 2
    },
    color: String,
    trackColor: String,
    trackFillColor: String,
    trackSize: {
        type: [Number, String],
        default: 4
    },
    direction: {
        type: String,
        default: "horizontal",
        validator: e => ["vertical", "horizontal"].includes(e)
    },
    reverse: Boolean,
    ...Di(),
    ...$i({
        elevation: 2
    }),
    ripple: {
        type: Boolean,
        default: !0
    }
}, "Slider")
  , $l = e => {
    const t = F(( () => parseFloat(e.min)))
      , a = F(( () => parseFloat(e.max)))
      , i = F(( () => +e.step > 0 ? parseFloat(e.step) : 0))
      , n = F(( () => Math.max(Lt(i.value), Lt(t.value))));
    return {
        min: t,
        max: a,
        step: i,
        decimals: n,
        roundValue: function(e) {
            if (e = parseFloat(e),
            i.value <= 0)
                return e;
            const r = te(e, t.value, a.value)
              , o = t.value % i.value
              , s = Math.round((r - o) / i.value) * i.value + o;
            return parseFloat(Math.min(s, a.value).toFixed(n.value))
        }
    }
}
  , Ul = e => {
    let {props: t, steps: a, onSliderStart: i, onSliderMove: n, onSliderEnd: r, getActiveThumb: o} = e;
    const {isRtl: s} = b()
      , c = W(t, "reverse")
      , u = F(( () => "vertical" === t.direction))
      , d = F(( () => u.value !== c.value))
      , {min: h, max: p, step: v, decimals: g, roundValue: f} = a
      , m = F(( () => parseInt(t.thumbSize, 10)))
      , x = F(( () => parseInt(t.tickSize, 10)))
      , y = F(( () => parseInt(t.trackSize, 10)))
      , w = F(( () => (p.value - h.value) / v.value))
      , k = W(t, "disabled")
      , S = F(( () => t.error || t.disabled ? void 0 : t.thumbColor ?? t.color))
      , C = F(( () => t.error || t.disabled ? void 0 : t.trackColor ?? t.color))
      , A = F(( () => t.error || t.disabled ? void 0 : t.trackFillColor ?? t.color))
      , P = j(!1)
      , L = j(0)
      , I = l()
      , _ = l();
    function T(e) {
        var a;
        const i = "vertical" === t.direction
          , n = i ? "top" : "left"
          , r = i ? "height" : "width"
          , o = i ? "clientY" : "clientX"
          , {[n]: l, [r]: c} = null == (a = I.value) ? void 0 : a.$el.getBoundingClientRect()
          , u = function(e, t) {
            return "touches"in e && e.touches.length ? e.touches[0][t] : "changedTouches"in e && e.changedTouches.length ? e.changedTouches[0][t] : e[t]
        }(e, o);
        let v = Math.min(Math.max((u - l - L.value) / c, 0), 1) || 0;
        return (i ? d.value : d.value !== s.value) && (v = 1 - v),
        f(h.value + v * (p.value - h.value))
    }
    const E = e => {
        r({
            value: T(e)
        }),
        P.value = !1,
        L.value = 0
    }
      , O = e => {
        _.value = o(e),
        _.value && (_.value.focus(),
        P.value = !0,
        _.value.contains(e.target) ? L.value = Gl(e, _.value, t.direction) : (L.value = 0,
        n({
            value: T(e)
        })),
        i({
            value: T(e)
        }))
    }
      , V = {
        passive: !0,
        capture: !0
    };
    function B(e) {
        n({
            value: T(e)
        })
    }
    function M(e) {
        e.stopPropagation(),
        e.preventDefault(),
        E(e),
        window.removeEventListener("mousemove", B, V),
        window.removeEventListener("mouseup", M)
    }
    function D(e) {
        var t;
        E(e),
        window.removeEventListener("touchmove", B, V),
        null == (t = e.target) || t.removeEventListener("touchend", D)
    }
    const R = e => {
        const t = (e - h.value) / (p.value - h.value) * 100;
        return te(isNaN(t) ? 0 : t, 0, 100)
    }
      , N = W(t, "showTicks")
      , z = F(( () => N.value ? t.ticks ? Array.isArray(t.ticks) ? t.ticks.map((e => ({
        value: e,
        position: R(e),
        label: e.toString()
    }))) : Object.keys(t.ticks).map((e => ({
        value: parseFloat(e),
        position: R(parseFloat(e)),
        label: t.ticks[e]
    }))) : w.value !== 1 / 0 ? It(w.value + 1).map((e => {
        const t = h.value + e * v.value;
        return {
            value: t,
            position: R(t)
        }
    }
    )) : [] : []))
      , H = F(( () => z.value.some((e => {
        let {label: t} = e;
        return !!t
    }
    ))))
      , X = {
        activeThumbRef: _,
        color: W(t, "color"),
        decimals: g,
        disabled: k,
        direction: W(t, "direction"),
        elevation: W(t, "elevation"),
        hasLabels: H,
        isReversed: c,
        indexFromEnd: d,
        min: h,
        max: p,
        mousePressed: P,
        numTicks: w,
        onSliderMousedown: function(e) {
            e.preventDefault(),
            O(e),
            window.addEventListener("mousemove", B, V),
            window.addEventListener("mouseup", M, {
                passive: !1
            })
        },
        onSliderTouchstart: function(e) {
            var t;
            O(e),
            window.addEventListener("touchmove", B, V),
            null == (t = e.target) || t.addEventListener("touchend", D, {
                passive: !1
            })
        },
        parsedTicks: z,
        parseMouseMove: T,
        position: R,
        readonly: W(t, "readonly"),
        rounded: W(t, "rounded"),
        roundValue: f,
        showTicks: N,
        startOffset: L,
        step: v,
        thumbSize: m,
        thumbColor: S,
        thumbLabel: W(t, "thumbLabel"),
        ticks: W(t, "ticks"),
        tickSize: x,
        trackColor: C,
        trackContainerRef: I,
        trackFillColor: A,
        trackSize: y,
        vertical: u
    };
    return ue(Wl, X),
    X
}
  , ql = d({
    focused: Boolean,
    max: {
        type: Number,
        required: !0
    },
    min: {
        type: Number,
        required: !0
    },
    modelValue: {
        type: Number,
        required: !0
    },
    position: {
        type: Number,
        required: !0
    },
    ripple: {
        type: [Boolean, Object],
        default: !0
    },
    ...h()
}, "VSliderThumb")
  , Zl = g()({
    name: "VSliderThumb",
    directives: {
        Ripple: rr
    },
    props: ql(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a, emit: i} = t;
        const n = de(Wl)
          , {isRtl: r, rtlClasses: o} = b();
        if (!n)
            throw new Error("[Vuetify] v-slider-thumb must be used inside v-slider or v-range-slider");
        const {thumbColor: s, step: l, disabled: c, thumbSize: u, thumbLabel: d, direction: h, isReversed: p, vertical: v, readonly: g, elevation: f, mousePressed: m, decimals: w, indexFromEnd: k} = n
          , S = F(( () => c.value ? void 0 : f.value))
          , {elevationClasses: C} = Ui(S)
          , {textColorClasses: A, textColorStyles: P} = Bi(s)
          , {pageup: L, pagedown: I, end: _, home: T, left: E, right: O, down: V, up: M} = _t
          , D = [L, I, _, T, E, O, V, M]
          , R = F(( () => l.value ? [1, 2, 3] : [1, 5, 10]));
        function N(t) {
            const a = function(t, a) {
                if (!D.includes(t.key))
                    return;
                t.preventDefault();
                const i = l.value || .1
                  , n = (e.max - e.min) / i;
                if ([E, O, V, M].includes(t.key)) {
                    const e = (v.value ? [r.value ? E : O, p.value ? V : M] : k.value !== r.value ? [E, M] : [O, M]).includes(t.key) ? 1 : -1
                      , n = t.shiftKey ? 2 : t.ctrlKey ? 1 : 0;
                    a += e * i * R.value[n]
                } else
                    t.key === T ? a = e.min : t.key === _ ? a = e.max : a -= (t.key === I ? 1 : -1) * i * (n > 100 ? n / 10 : 10);
                return Math.max(e.min, Math.min(e.max, a))
            }(t, e.modelValue);
            null != a && i("update:modelValue", a)
        }
        return x(( () => {
            const t = B(k.value ? 100 - e.position : e.position, "%");
            return y("div", {
                class: ["v-slider-thumb", {
                    "v-slider-thumb--focused": e.focused,
                    "v-slider-thumb--pressed": e.focused && m.value
                }, e.class, o.value],
                style: [{
                    "--v-slider-thumb-position": t,
                    "--v-slider-thumb-size": B(u.value)
                }, e.style],
                role: "slider",
                tabindex: c.value ? -1 : 0,
                "aria-valuemin": e.min,
                "aria-valuemax": e.max,
                "aria-valuenow": e.modelValue,
                "aria-readonly": !!g.value,
                "aria-orientation": h.value,
                onKeydown: g.value ? void 0 : N
            }, [y("div", {
                class: ["v-slider-thumb__surface", A.value, C.value],
                style: {
                    ...P.value
                }
            }, null), K(y("div", {
                class: ["v-slider-thumb__ripple", A.value],
                style: P.value
            }, null), [[J("ripple"), e.ripple, null, {
                circle: !0,
                center: !0
            }]]), y(mi, {
                origin: "bottom center"
            }, {
                default: () => {
                    var t;
                    return [K(y("div", {
                        class: "v-slider-thumb__label-container"
                    }, [y("div", {
                        class: ["v-slider-thumb__label"]
                    }, [y("div", null, [(null == (t = a["thumb-label"]) ? void 0 : t.call(a, {
                        modelValue: e.modelValue
                    })) ?? e.modelValue.toFixed(l.value ? w.value : 1)])])]), [[ee, d.value && e.focused || "always" === d.value]])]
                }
            })])
        }
        )),
        {}
    }
})
  , Kl = d({
    start: {
        type: Number,
        required: !0
    },
    stop: {
        type: Number,
        required: !0
    },
    ...h()
}, "VSliderTrack")
  , Jl = g()({
    name: "VSliderTrack",
    props: Kl(),
    emits: {},
    setup(e, t) {
        let {slots: a} = t;
        const i = de(Wl);
        if (!i)
            throw new Error("[Vuetify] v-slider-track must be inside v-slider or v-range-slider");
        const {color: n, parsedTicks: r, rounded: o, showTicks: s, tickSize: l, trackColor: c, trackFillColor: u, trackSize: d, vertical: h, min: p, max: v, indexFromEnd: g} = i
          , {roundedClasses: f} = Ri(o)
          , {backgroundColorClasses: m, backgroundColorStyles: b} = Mi(u)
          , {backgroundColorClasses: w, backgroundColorStyles: k} = Mi(c)
          , S = F(( () => `inset-${h.value ? "block" : "inline"}-${g.value ? "end" : "start"}`))
          , C = F(( () => h.value ? "height" : "width"))
          , A = F(( () => ({
            [S.value]: "0%",
            [C.value]: "100%"
        })))
          , P = F(( () => e.stop - e.start))
          , L = F(( () => ({
            [S.value]: B(e.start, "%"),
            [C.value]: B(P.value, "%")
        })))
          , I = F(( () => {
            if (!s.value)
                return [];
            return (h.value ? r.value.slice().reverse() : r.value).map(( (t, i) => {
                var n;
                const r = t.value !== p.value && t.value !== v.value ? B(t.position, "%") : void 0;
                return y("div", {
                    key: t.value,
                    class: ["v-slider-track__tick", {
                        "v-slider-track__tick--filled": t.position >= e.start && t.position <= e.stop,
                        "v-slider-track__tick--first": t.value === p.value,
                        "v-slider-track__tick--last": t.value === v.value
                    }],
                    style: {
                        [S.value]: r
                    }
                }, [(t.label || a["tick-label"]) && y("div", {
                    class: "v-slider-track__tick-label"
                }, [(null == (n = a["tick-label"]) ? void 0 : n.call(a, {
                    tick: t,
                    index: i
                })) ?? t.label])])
            }
            ))
        }
        ));
        return x(( () => y("div", {
            class: ["v-slider-track", f.value, e.class],
            style: [{
                "--v-slider-track-size": B(d.value),
                "--v-slider-tick-size": B(l.value)
            }, e.style]
        }, [y("div", {
            class: ["v-slider-track__background", w.value, {
                "v-slider-track__background--opacity": !!n.value || !u.value
            }],
            style: {
                ...A.value,
                ...k.value
            }
        }, null), y("div", {
            class: ["v-slider-track__fill", m.value],
            style: {
                ...L.value,
                ...b.value
            }
        }, null), s.value && y("div", {
            class: ["v-slider-track__ticks", {
                "v-slider-track__ticks--always-show": "always" === s.value
            }]
        }, [I.value])]))),
        {}
    }
})
  , Ql = d({
    ...Tr(),
    ...jl(),
    ...Dr(),
    modelValue: {
        type: [Number, String],
        default: 0
    }
}, "VSlider")
  , ec = g()({
    name: "VSlider",
    props: Ql(),
    emits: {
        "update:focused": e => !0,
        "update:modelValue": e => !0,
        start: e => !0,
        end: e => !0
    },
    setup(e, t) {
        let {slots: a, emit: i} = t;
        const n = l()
          , {rtlClasses: r} = b()
          , o = $l(e)
          , s = re(e, "modelValue", void 0, (e => o.roundValue(null == e ? o.min.value : e)))
          , {min: c, max: u, mousePressed: d, roundValue: h, onSliderMousedown: p, onSliderTouchstart: v, trackContainerRef: g, position: f, hasLabels: m, readonly: w} = Ul({
            props: e,
            steps: o,
            onSliderStart: () => {
                i("start", s.value)
            }
            ,
            onSliderEnd: e => {
                let {value: t} = e;
                const a = h(t);
                s.value = a,
                i("end", a)
            }
            ,
            onSliderMove: e => {
                let {value: t} = e;
                return s.value = h(t)
            }
            ,
            getActiveThumb: () => {
                var e;
                return null == (e = n.value) ? void 0 : e.$el
            }
        })
          , {isFocused: k, focus: S, blur: C} = Er(e)
          , P = F(( () => f(s.value)));
        return x(( () => {
            const t = Rr.filterProps(e)
              , i = !!(e.label || a.label || a.prepend);
            return y(Rr, A({
                class: ["v-slider", {
                    "v-slider--has-labels": !!a["tick-label"] || m.value,
                    "v-slider--focused": k.value,
                    "v-slider--pressed": d.value,
                    "v-slider--disabled": e.disabled
                }, r.value, e.class],
                style: e.style
            }, t, {
                focused: k.value
            }), {
                ...a,
                prepend: i ? t => {
                    var i, n;
                    return y(Q, null, [(null == (i = a.label) ? void 0 : i.call(a, t)) ?? (e.label ? y(br, {
                        id: t.id.value,
                        class: "v-slider__label",
                        text: e.label
                    }, null) : void 0), null == (n = a.prepend) ? void 0 : n.call(a, t)])
                }
                : void 0,
                default: t => {
                    let {id: i, messagesId: r} = t;
                    return y("div", {
                        class: "v-slider__container",
                        onMousedown: w.value ? void 0 : p,
                        onTouchstartPassive: w.value ? void 0 : v
                    }, [y("input", {
                        id: i.value,
                        name: e.name || i.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: "-1",
                        value: s.value
                    }, null), y(Jl, {
                        ref: g,
                        start: 0,
                        stop: P.value
                    }, {
                        "tick-label": a["tick-label"]
                    }), y(Zl, {
                        ref: n,
                        "aria-describedby": r.value,
                        focused: k.value,
                        min: c.value,
                        max: u.value,
                        modelValue: s.value,
                        "onUpdate:modelValue": e => s.value = e,
                        position: P.value,
                        elevation: e.elevation,
                        onFocus: S,
                        onBlur: C,
                        ripple: e.ripple
                    }, {
                        "thumb-label": a["thumb-label"]
                    })])
                }
            })
        }
        )),
        {}
    }
})
  , tc = Ne({
    name: "VColorPickerPreview",
    props: d({
        color: {
            type: Object
        },
        disabled: Boolean,
        hideAlpha: Boolean,
        ...h()
    }, "VColorPickerPreview")(),
    emits: {
        "update:color": e => !0
    },
    setup(e, t) {
        let {emit: a} = t;
        const i = new AbortController;
        async function n() {
            if (!Et)
                return;
            const t = new window.EyeDropper;
            try {
                const n = await t.open({
                    signal: i.signal
                })
                  , r = Pt(n.sRGBHex);
                a("update:color", {
                    ...e.color ?? Bl,
                    ...r
                })
            } catch (n) {}
        }
        return Tt(( () => i.abort())),
        x(( () => {
            var t, i;
            return y("div", {
                class: ["v-color-picker-preview", {
                    "v-color-picker-preview--hide-alpha": e.hideAlpha
                }, e.class],
                style: e.style
            }, [Et && y("div", {
                class: "v-color-picker-preview__eye-dropper",
                key: "eyeDropper"
            }, [y(sr, {
                onClick: n,
                icon: "$eyeDropper",
                variant: "plain",
                density: "comfortable"
            }, null)]), y("div", {
                class: "v-color-picker-preview__dot"
            }, [y("div", {
                style: {
                    background: Ot(e.color ?? Bl)
                }
            }, null)]), y("div", {
                class: "v-color-picker-preview__sliders"
            }, [y(ec, {
                class: "v-color-picker-preview__track v-color-picker-preview__hue",
                modelValue: null == (t = e.color) ? void 0 : t.h,
                "onUpdate:modelValue": t => a("update:color", {
                    ...e.color ?? Bl,
                    h: t
                }),
                step: 0,
                min: 0,
                max: 360,
                disabled: e.disabled,
                thumbSize: 14,
                trackSize: 8,
                trackFillColor: "white",
                hideDetails: !0
            }, null), !e.hideAlpha && y(ec, {
                class: "v-color-picker-preview__track v-color-picker-preview__alpha",
                modelValue: (null == (i = e.color) ? void 0 : i.a) ?? 1,
                "onUpdate:modelValue": t => a("update:color", {
                    ...e.color ?? Bl,
                    a: t
                }),
                step: 1 / 256,
                min: 0,
                max: 1,
                disabled: e.disabled,
                thumbSize: 14,
                trackSize: 8,
                trackFillColor: "white",
                hideDetails: !0
            }, null)])])
        }
        )),
        {}
    }
})
  , ac = {
    red: {
        base: "#f44336",
        lighten5: "#ffebee",
        lighten4: "#ffcdd2",
        lighten3: "#ef9a9a",
        lighten2: "#e57373",
        lighten1: "#ef5350",
        darken1: "#e53935",
        darken2: "#d32f2f",
        darken3: "#c62828",
        darken4: "#b71c1c",
        accent1: "#ff8a80",
        accent2: "#ff5252",
        accent3: "#ff1744",
        accent4: "#d50000"
    },
    pink: {
        base: "#e91e63",
        lighten5: "#fce4ec",
        lighten4: "#f8bbd0",
        lighten3: "#f48fb1",
        lighten2: "#f06292",
        lighten1: "#ec407a",
        darken1: "#d81b60",
        darken2: "#c2185b",
        darken3: "#ad1457",
        darken4: "#880e4f",
        accent1: "#ff80ab",
        accent2: "#ff4081",
        accent3: "#f50057",
        accent4: "#c51162"
    },
    purple: {
        base: "#9c27b0",
        lighten5: "#f3e5f5",
        lighten4: "#e1bee7",
        lighten3: "#ce93d8",
        lighten2: "#ba68c8",
        lighten1: "#ab47bc",
        darken1: "#8e24aa",
        darken2: "#7b1fa2",
        darken3: "#6a1b9a",
        darken4: "#4a148c",
        accent1: "#ea80fc",
        accent2: "#e040fb",
        accent3: "#d500f9",
        accent4: "#aa00ff"
    },
    deepPurple: {
        base: "#673ab7",
        lighten5: "#ede7f6",
        lighten4: "#d1c4e9",
        lighten3: "#b39ddb",
        lighten2: "#9575cd",
        lighten1: "#7e57c2",
        darken1: "#5e35b1",
        darken2: "#512da8",
        darken3: "#4527a0",
        darken4: "#311b92",
        accent1: "#b388ff",
        accent2: "#7c4dff",
        accent3: "#651fff",
        accent4: "#6200ea"
    },
    indigo: {
        base: "#3f51b5",
        lighten5: "#e8eaf6",
        lighten4: "#c5cae9",
        lighten3: "#9fa8da",
        lighten2: "#7986cb",
        lighten1: "#5c6bc0",
        darken1: "#3949ab",
        darken2: "#303f9f",
        darken3: "#283593",
        darken4: "#1a237e",
        accent1: "#8c9eff",
        accent2: "#536dfe",
        accent3: "#3d5afe",
        accent4: "#304ffe"
    },
    blue: {
        base: "#2196f3",
        lighten5: "#e3f2fd",
        lighten4: "#bbdefb",
        lighten3: "#90caf9",
        lighten2: "#64b5f6",
        lighten1: "#42a5f5",
        darken1: "#1e88e5",
        darken2: "#1976d2",
        darken3: "#1565c0",
        darken4: "#0d47a1",
        accent1: "#82b1ff",
        accent2: "#448aff",
        accent3: "#2979ff",
        accent4: "#2962ff"
    },
    lightBlue: {
        base: "#03a9f4",
        lighten5: "#e1f5fe",
        lighten4: "#b3e5fc",
        lighten3: "#81d4fa",
        lighten2: "#4fc3f7",
        lighten1: "#29b6f6",
        darken1: "#039be5",
        darken2: "#0288d1",
        darken3: "#0277bd",
        darken4: "#01579b",
        accent1: "#80d8ff",
        accent2: "#40c4ff",
        accent3: "#00b0ff",
        accent4: "#0091ea"
    },
    cyan: {
        base: "#00bcd4",
        lighten5: "#e0f7fa",
        lighten4: "#b2ebf2",
        lighten3: "#80deea",
        lighten2: "#4dd0e1",
        lighten1: "#26c6da",
        darken1: "#00acc1",
        darken2: "#0097a7",
        darken3: "#00838f",
        darken4: "#006064",
        accent1: "#84ffff",
        accent2: "#18ffff",
        accent3: "#00e5ff",
        accent4: "#00b8d4"
    },
    teal: {
        base: "#009688",
        lighten5: "#e0f2f1",
        lighten4: "#b2dfdb",
        lighten3: "#80cbc4",
        lighten2: "#4db6ac",
        lighten1: "#26a69a",
        darken1: "#00897b",
        darken2: "#00796b",
        darken3: "#00695c",
        darken4: "#004d40",
        accent1: "#a7ffeb",
        accent2: "#64ffda",
        accent3: "#1de9b6",
        accent4: "#00bfa5"
    },
    green: {
        base: "#4caf50",
        lighten5: "#e8f5e9",
        lighten4: "#c8e6c9",
        lighten3: "#a5d6a7",
        lighten2: "#81c784",
        lighten1: "#66bb6a",
        darken1: "#43a047",
        darken2: "#388e3c",
        darken3: "#2e7d32",
        darken4: "#1b5e20",
        accent1: "#b9f6ca",
        accent2: "#69f0ae",
        accent3: "#00e676",
        accent4: "#00c853"
    },
    lightGreen: {
        base: "#8bc34a",
        lighten5: "#f1f8e9",
        lighten4: "#dcedc8",
        lighten3: "#c5e1a5",
        lighten2: "#aed581",
        lighten1: "#9ccc65",
        darken1: "#7cb342",
        darken2: "#689f38",
        darken3: "#558b2f",
        darken4: "#33691e",
        accent1: "#ccff90",
        accent2: "#b2ff59",
        accent3: "#76ff03",
        accent4: "#64dd17"
    },
    lime: {
        base: "#cddc39",
        lighten5: "#f9fbe7",
        lighten4: "#f0f4c3",
        lighten3: "#e6ee9c",
        lighten2: "#dce775",
        lighten1: "#d4e157",
        darken1: "#c0ca33",
        darken2: "#afb42b",
        darken3: "#9e9d24",
        darken4: "#827717",
        accent1: "#f4ff81",
        accent2: "#eeff41",
        accent3: "#c6ff00",
        accent4: "#aeea00"
    },
    yellow: {
        base: "#ffeb3b",
        lighten5: "#fffde7",
        lighten4: "#fff9c4",
        lighten3: "#fff59d",
        lighten2: "#fff176",
        lighten1: "#ffee58",
        darken1: "#fdd835",
        darken2: "#fbc02d",
        darken3: "#f9a825",
        darken4: "#f57f17",
        accent1: "#ffff8d",
        accent2: "#ffff00",
        accent3: "#ffea00",
        accent4: "#ffd600"
    },
    amber: {
        base: "#ffc107",
        lighten5: "#fff8e1",
        lighten4: "#ffecb3",
        lighten3: "#ffe082",
        lighten2: "#ffd54f",
        lighten1: "#ffca28",
        darken1: "#ffb300",
        darken2: "#ffa000",
        darken3: "#ff8f00",
        darken4: "#ff6f00",
        accent1: "#ffe57f",
        accent2: "#ffd740",
        accent3: "#ffc400",
        accent4: "#ffab00"
    },
    orange: {
        base: "#ff9800",
        lighten5: "#fff3e0",
        lighten4: "#ffe0b2",
        lighten3: "#ffcc80",
        lighten2: "#ffb74d",
        lighten1: "#ffa726",
        darken1: "#fb8c00",
        darken2: "#f57c00",
        darken3: "#ef6c00",
        darken4: "#e65100",
        accent1: "#ffd180",
        accent2: "#ffab40",
        accent3: "#ff9100",
        accent4: "#ff6d00"
    },
    deepOrange: {
        base: "#ff5722",
        lighten5: "#fbe9e7",
        lighten4: "#ffccbc",
        lighten3: "#ffab91",
        lighten2: "#ff8a65",
        lighten1: "#ff7043",
        darken1: "#f4511e",
        darken2: "#e64a19",
        darken3: "#d84315",
        darken4: "#bf360c",
        accent1: "#ff9e80",
        accent2: "#ff6e40",
        accent3: "#ff3d00",
        accent4: "#dd2c00"
    },
    brown: {
        base: "#795548",
        lighten5: "#efebe9",
        lighten4: "#d7ccc8",
        lighten3: "#bcaaa4",
        lighten2: "#a1887f",
        lighten1: "#8d6e63",
        darken1: "#6d4c41",
        darken2: "#5d4037",
        darken3: "#4e342e",
        darken4: "#3e2723"
    },
    blueGrey: {
        base: "#607d8b",
        lighten5: "#eceff1",
        lighten4: "#cfd8dc",
        lighten3: "#b0bec5",
        lighten2: "#90a4ae",
        lighten1: "#78909c",
        darken1: "#546e7a",
        darken2: "#455a64",
        darken3: "#37474f",
        darken4: "#263238"
    },
    grey: {
        base: "#9e9e9e",
        lighten5: "#fafafa",
        lighten4: "#f5f5f5",
        lighten3: "#eeeeee",
        lighten2: "#e0e0e0",
        lighten1: "#bdbdbd",
        darken1: "#757575",
        darken2: "#616161",
        darken3: "#424242",
        darken4: "#212121"
    },
    shades: {
        black: "#000000",
        white: "#ffffff",
        transparent: "#ffffff00"
    }
};
const ic = Ne({
    name: "VColorPickerSwatches",
    props: d({
        swatches: {
            type: Array,
            default: () => {
                return e = ac,
                Object.keys(e).map((t => {
                    const a = e[t];
                    return a.base ? [a.base, a.darken4, a.darken3, a.darken2, a.darken1, a.lighten1, a.lighten2, a.lighten3, a.lighten4, a.lighten5] : [a.black, a.white, a.transparent]
                }
                ));
                var e
            }
        },
        disabled: Boolean,
        color: Object,
        maxHeight: [Number, String],
        ...h()
    }, "VColorPickerSwatches")(),
    emits: {
        "update:color": e => !0
    },
    setup(e, t) {
        let {emit: a} = t;
        return x(( () => y("div", {
            class: ["v-color-picker-swatches", e.class],
            style: [{
                maxHeight: B(e.maxHeight)
            }, e.style]
        }, [y("div", null, [e.swatches.map((t => y("div", {
            class: "v-color-picker-swatches__swatch"
        }, [t.map((t => {
            const i = z(t)
              , n = Ct(i)
              , r = Vt(i);
            return y("div", {
                class: "v-color-picker-swatches__color",
                onClick: () => n && a("update:color", n)
            }, [y("div", {
                style: {
                    background: r
                }
            }, [e.color && pe(e.color, n) ? y(Cn, {
                size: "x-small",
                icon: "$success",
                color: Ft(t, "#FFFFFF") > 2 ? "white" : "black"
            }, null) : void 0])])
        }
        ))])))])]))),
        {}
    }
})
  , nc = d({
    color: String,
    ...Gi(),
    ...h(),
    ...Ti(),
    ...$i(),
    ..._n(),
    ...Dn(),
    ...Di(),
    ...ai(),
    ...v()
}, "VSheet")
  , rc = g()({
    name: "VSheet",
    props: nc(),
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(W(e, "color"))
          , {borderClasses: o} = ji(e)
          , {dimensionStyles: s} = Ei(e)
          , {elevationClasses: l} = Ui(e)
          , {locationStyles: c} = Tn(e)
          , {positionClasses: u} = Rn(e)
          , {roundedClasses: d} = Ri(e);
        return x(( () => y(e.tag, {
            class: ["v-sheet", i.value, n.value, o.value, l.value, u.value, d.value, e.class],
            style: [r.value, s.value, c.value, e.style]
        }, a))),
        {}
    }
})
  , oc = Ne({
    name: "VColorPicker",
    props: d({
        canvasHeight: {
            type: [String, Number],
            default: 150
        },
        disabled: Boolean,
        dotSize: {
            type: [Number, String],
            default: 10
        },
        hideCanvas: Boolean,
        hideSliders: Boolean,
        hideInputs: Boolean,
        mode: {
            type: String,
            default: "rgba",
            validator: e => Object.keys(Hl).includes(e)
        },
        modes: {
            type: Array,
            default: () => Object.keys(Hl),
            validator: e => Array.isArray(e) && e.every((e => Object.keys(Hl).includes(e)))
        },
        showSwatches: Boolean,
        swatches: Array,
        swatchesMaxHeight: {
            type: [Number, String],
            default: 150
        },
        modelValue: {
            type: [Object, String]
        },
        ...Fe(nc({
            width: 300
        }), ["height", "location", "minHeight", "maxHeight", "minWidth", "maxWidth"])
    }, "VColorPicker")(),
    emits: {
        "update:modelValue": e => !0,
        "update:mode": e => !0
    },
    setup(e) {
        const t = re(e, "mode")
          , a = l(null)
          , i = re(e, "modelValue", void 0, (e => {
            if (null == e || "" === e)
                return null;
            let t;
            try {
                t = Ct(z(e))
            } catch (a) {
                return null
            }
            return t
        }
        ), (t => t ? function(e, t) {
            if (null == t || "string" == typeof t) {
                const t = yt(e);
                return 1 === e.a ? t.slice(0, 7) : t
            }
            if ("object" == typeof t) {
                let a;
                return wt(t, ["r", "g", "b"]) ? a = kt(e) : wt(t, ["h", "s", "l"]) ? a = St(e) : wt(t, ["h", "s", "v"]) && (a = e),
                function(e, t) {
                    if (t) {
                        const {a: t, ...a} = e;
                        return a
                    }
                    return e
                }(a, !wt(t, ["a"]) && 1 === e.a)
            }
            return e
        }(t, e.modelValue) : null))
          , n = F(( () => i.value ? {
            ...i.value,
            h: a.value ?? i.value.h
        } : null))
          , {rtlClasses: r} = b();
        let o = !0;
        $(i, (e => {
            o ? e && (a.value = e.h) : o = !0
        }
        ), {
            immediate: !0
        });
        const s = e => {
            o = !1,
            a.value = e.h,
            i.value = e
        }
        ;
        return ae(( () => {
            e.modes.includes(t.value) || (t.value = e.modes[0])
        }
        )),
        V({
            VSlider: {
                color: void 0,
                trackColor: void 0,
                trackFillColor: void 0
            }
        }),
        x(( () => {
            const a = rc.filterProps(e);
            return y(rc, A({
                rounded: e.rounded,
                elevation: e.elevation,
                theme: e.theme,
                class: ["v-color-picker", r.value, e.class],
                style: [{
                    "--v-color-picker-color-hsv": Ot({
                        ...n.value ?? Bl,
                        a: 1
                    })
                }, e.style]
            }, a, {
                maxWidth: e.width
            }), {
                default: () => [!e.hideCanvas && y(Fl, {
                    key: "canvas",
                    color: n.value,
                    "onUpdate:color": s,
                    disabled: e.disabled,
                    dotSize: e.dotSize,
                    width: e.width,
                    height: e.canvasHeight
                }, null), (!e.hideSliders || !e.hideInputs) && y("div", {
                    key: "controls",
                    class: "v-color-picker__controls"
                }, [!e.hideSliders && y(tc, {
                    key: "preview",
                    color: n.value,
                    "onUpdate:color": s,
                    hideAlpha: !t.value.endsWith("a"),
                    disabled: e.disabled
                }, null), !e.hideInputs && y(Yl, {
                    key: "edit",
                    modes: e.modes,
                    mode: t.value,
                    "onUpdate:mode": e => t.value = e,
                    color: n.value,
                    "onUpdate:color": s,
                    disabled: e.disabled
                }, null)]), e.showSwatches && y(ic, {
                    key: "swatches",
                    color: n.value,
                    "onUpdate:color": s,
                    maxHeight: e.swatchesMaxHeight,
                    swatches: e.swatches,
                    disabled: e.disabled
                }, null)]
            })
        }
        )),
        {}
    }
});
const sc = d({
    autoSelectFirst: {
        type: [Boolean, String]
    },
    clearOnSelect: {
        type: Boolean,
        default: !0
    },
    delimiters: Array,
    ...Ys({
        filterKeys: ["title"]
    }),
    ...Ns({
        hideNoData: !0,
        returnObject: !0
    }),
    ...Fe(Ts({
        modelValue: null,
        role: "combobox"
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...Ni({
        transition: !1
    })
}, "VCombobox")
  , lc = g()({
    name: "VCombobox",
    props: sc(),
    emits: {
        "update:focused": e => !0,
        "update:modelValue": e => !0,
        "update:search": e => !0,
        "update:menu": e => !0
    },
    setup(e, t) {
        var a;
        let {emit: i, slots: n} = t;
        const {t: r} = Te()
          , o = l()
          , s = j(!1)
          , c = j(!0)
          , u = j(!1)
          , d = l()
          , h = l()
          , p = re(e, "menu")
          , v = F({
            get: () => p.value,
            set: e => {
                var t;
                p.value && !e && (null == (t = d.value) ? void 0 : t.openChildren) || (p.value = e)
            }
        })
          , g = j(-1);
        let f = !1;
        const m = F(( () => {
            var e;
            return null == (e = o.value) ? void 0 : e.color
        }
        ))
          , b = F(( () => v.value ? e.closeText : e.openText))
          , {items: w, transformIn: k, transformOut: S} = Lo(e)
          , {textColorClasses: C, textColorStyles: P} = Bi(m)
          , L = re(e, "modelValue", [], (e => k(ve(e))), (t => {
            const a = S(t);
            return e.multiple ? a : a[0] ?? null
        }
        ))
          , I = Fr()
          , _ = j(e.multiple ? "" : (null == (a = L.value[0]) ? void 0 : a.title) ?? "")
          , T = F({
            get: () => _.value,
            set: t => {
                var a;
                if (_.value = t ?? "",
                e.multiple || (L.value = [Ao(e, t)]),
                t && e.multiple && (null == (a = e.delimiters) ? void 0 : a.length)) {
                    const a = t.split(new RegExp(`(?:${e.delimiters.join("|")})+`));
                    a.length > 1 && (a.forEach((t => {
                        (t = t.trim()) && Z(Ao(e, t))
                    }
                    )),
                    _.value = "")
                }
                t || (g.value = -1),
                c.value = !t
            }
        })
          , E = F(( () => "function" == typeof e.counterValue ? e.counterValue(L.value) : "number" == typeof e.counterValue ? e.counterValue : e.multiple ? L.value.length : T.value.length));
        $(_, (e => {
            f ? q(( () => f = !1)) : s.value && !v.value && (v.value = !0),
            i("update:search", e)
        }
        )),
        $(L, (t => {
            var a;
            e.multiple || (_.value = (null == (a = t[0]) ? void 0 : a.title) ?? "")
        }
        ));
        const {filteredItems: O, getMatches: V} = Ws(e, w, ( () => c.value ? "" : T.value))
          , B = F(( () => e.hideSelected ? O.value.filter((e => !L.value.some((t => t.value === e.value)))) : O.value))
          , M = F(( () => L.value.map((e => e.value))))
          , D = F(( () => {
            var t;
            return (!0 === e.autoSelectFirst || "exact" === e.autoSelectFirst && T.value === (null == (t = B.value[0]) ? void 0 : t.title)) && B.value.length > 0 && !c.value && !u.value
        }
        ))
          , R = F(( () => e.hideNoData && !B.value.length || e.readonly || (null == I ? void 0 : I.isReadonly.value)))
          , N = l()
          , {onListScroll: z, onListKeydown: H} = Rs(N, o);
        function X(t) {
            f = !0,
            e.openOnClear && (v.value = !0)
        }
        function Y() {
            R.value || (v.value = !0)
        }
        function W(e) {
            R.value || (s.value && (e.preventDefault(),
            e.stopPropagation()),
            v.value = !v.value)
        }
        function G(t) {
            var a;
            if (Bt(t) || e.readonly || (null == I ? void 0 : I.isReadonly.value))
                return;
            const i = o.value.selectionStart
              , n = L.value.length;
            if ((g.value > -1 || ["Enter", "ArrowDown", "ArrowUp"].includes(t.key)) && t.preventDefault(),
            ["Enter", "ArrowDown"].includes(t.key) && (v.value = !0),
            ["Escape"].includes(t.key) && (v.value = !1),
            ["Enter", "Escape", "Tab"].includes(t.key) && (D.value && ["Enter", "Tab"].includes(t.key) && Z(O.value[0]),
            c.value = !0),
            "ArrowDown" === t.key && D.value && (null == (a = N.value) || a.focus("next")),
            e.multiple) {
                if (["Backspace", "Delete"].includes(t.key)) {
                    if (g.value < 0)
                        return void ("Backspace" !== t.key || T.value || (g.value = n - 1));
                    const e = g.value
                      , a = L.value[g.value];
                    a && !a.props.disabled && Z(a, !1),
                    g.value = e >= n - 1 ? n - 2 : e
                }
                if ("ArrowLeft" === t.key) {
                    if (g.value < 0 && i > 0)
                        return;
                    const e = g.value > -1 ? g.value - 1 : n - 1;
                    L.value[e] ? g.value = e : (g.value = -1,
                    o.value.setSelectionRange(T.value.length, T.value.length))
                }
                if ("ArrowRight" === t.key) {
                    if (g.value < 0)
                        return;
                    const e = g.value + 1;
                    L.value[e] ? g.value = e : (g.value = -1,
                    o.value.setSelectionRange(0, 0))
                }
                "Enter" === t.key && T.value && (Z(Ao(e, T.value)),
                T.value = "")
            }
        }
        function U() {
            var e;
            s.value && (c.value = !0,
            null == (e = o.value) || e.focus())
        }
        function Z(t) {
            let a = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (e.multiple) {
                const i = L.value.findIndex((a => e.valueComparator(a.value, t.value)))
                  , n = null == a ? !~i : a;
                if (~i) {
                    const e = n ? [...L.value, t] : [...L.value];
                    e.splice(i, 1),
                    L.value = e
                } else
                    n && (L.value = [...L.value, t]);
                e.clearOnSelect && (T.value = "")
            } else {
                const e = !1 !== a;
                L.value = e ? [t] : [],
                _.value = e ? t.title : "",
                q(( () => {
                    v.value = !1,
                    c.value = !0
                }
                ))
            }
        }
        function K(e) {
            s.value = !0,
            setTimeout(( () => {
                u.value = !0
            }
            ))
        }
        function J(e) {
            u.value = !1
        }
        function ee(t) {
            (null == t || "" === t && !e.multiple) && (L.value = [])
        }
        return $(s, ( (t, a) => {
            t || t === a || (g.value = -1,
            v.value = !1,
            !D.value || u.value || L.value.some((e => {
                let {value: t} = e;
                return t === B.value[0].value
            }
            )) ? e.multiple && T.value && Z(Ao(e, T.value)) : Z(B.value[0]))
        }
        )),
        $(v, ( () => {
            if (!e.hideSelected && v.value && L.value.length) {
                const t = B.value.findIndex((t => L.value.some((a => e.valueComparator(a.value, t.value)))));
                Ae && window.requestAnimationFrame(( () => {
                    var e;
                    t >= 0 && (null == (e = h.value) || e.scrollToIndex(t))
                }
                ))
            }
        }
        )),
        $(B, ( (t, a) => {
            s.value && (!t.length && e.hideNoData && (v.value = !1),
            !a.length && t.length && (v.value = !0))
        }
        )),
        x(( () => {
            const t = !(!e.chips && !n.chip)
              , a = !!(!e.hideNoData || B.value.length || n["prepend-item"] || n["append-item"] || n["no-data"])
              , i = L.value.length > 0
              , l = Es.filterProps(e);
            return y(Es, A({
                ref: o
            }, l, {
                modelValue: T.value,
                "onUpdate:modelValue": [e => T.value = e, ee],
                focused: s.value,
                "onUpdate:focused": e => s.value = e,
                validationValue: L.externalValue,
                counterValue: E.value,
                dirty: i,
                class: ["v-combobox", {
                    "v-combobox--active-menu": v.value,
                    "v-combobox--chips": !!e.chips,
                    "v-combobox--selection-slot": !!n.selection,
                    "v-combobox--selecting-index": g.value > -1,
                    ["v-combobox--" + (e.multiple ? "multiple" : "single")]: !0
                }, e.class],
                style: e.style,
                readonly: e.readonly,
                placeholder: i ? void 0 : e.placeholder,
                "onClick:clear": X,
                "onMousedown:control": Y,
                onKeydown: G
            }), {
                ...n,
                default: () => y(Q, null, [y(ys, A({
                    ref: d,
                    modelValue: v.value,
                    "onUpdate:modelValue": e => v.value = e,
                    activator: "parent",
                    contentClass: "v-combobox__content",
                    disabled: R.value,
                    eager: e.eager,
                    maxHeight: 310,
                    openOnClick: !1,
                    closeOnContentClick: !1,
                    transition: e.transition,
                    onAfterLeave: U
                }, e.menuProps), {
                    default: () => [a && y(Eo, A({
                        ref: N,
                        selected: M.value,
                        selectStrategy: e.multiple ? "independent" : "single-independent",
                        onMousedown: e => e.preventDefault(),
                        onKeydown: H,
                        onFocusin: K,
                        onFocusout: J,
                        onScrollPassive: z,
                        tabindex: "-1",
                        "aria-live": "polite",
                        color: e.itemColor ?? e.color
                    }, e.listProps), {
                        default: () => {
                            var t, a, i;
                            return [null == (t = n["prepend-item"]) ? void 0 : t.call(n), !B.value.length && !e.hideNoData && ((null == (a = n["no-data"]) ? void 0 : a.call(n)) ?? y(mo, {
                                title: r(e.noDataText)
                            }, null)), y(Ds, {
                                ref: h,
                                renderless: !0,
                                items: B.value
                            }, {
                                default: t => {
                                    var a;
                                    let {item: i, index: r, itemRef: o} = t;
                                    const s = A(i.props, {
                                        ref: o,
                                        key: r,
                                        active: !(!D.value || 0 !== r) || void 0,
                                        onClick: () => Z(i, null)
                                    });
                                    return (null == (a = n.item) ? void 0 : a.call(n, {
                                        item: i,
                                        index: r,
                                        props: s
                                    })) ?? y(mo, A(s, {
                                        role: "option"
                                    }), {
                                        prepend: t => {
                                            let {isSelected: a} = t;
                                            return y(Q, null, [e.multiple && !e.hideSelected ? y(Pr, {
                                                key: i.value,
                                                modelValue: a,
                                                ripple: !1,
                                                tabindex: "-1"
                                            }, null) : void 0, i.props.prependAvatar && y(fr, {
                                                image: i.props.prependAvatar
                                            }, null), i.props.prependIcon && y(Cn, {
                                                icon: i.props.prependIcon
                                            }, null)])
                                        }
                                        ,
                                        title: () => {
                                            var e, t;
                                            return c.value ? i.title : function(e, t, a) {
                                                if (null == t)
                                                    return e;
                                                if (Array.isArray(t))
                                                    throw new Error("Multiple matches is not implemented");
                                                return "number" == typeof t && ~t ? y(Q, null, [y("span", {
                                                    class: "v-combobox__unmask"
                                                }, [e.substr(0, t)]), y("span", {
                                                    class: "v-combobox__mask"
                                                }, [e.substr(t, a)]), y("span", {
                                                    class: "v-combobox__unmask"
                                                }, [e.substr(t + a)])]) : e
                                            }(i.title, null == (e = V(i)) ? void 0 : e.title, (null == (t = T.value) ? void 0 : t.length) ?? 0)
                                        }
                                    })
                                }
                            }), null == (i = n["append-item"]) ? void 0 : i.call(n)]
                        }
                    })]
                }), L.value.map(( (a, i) => {
                    const r = {
                        "onClick:close": function(e) {
                            e.stopPropagation(),
                            e.preventDefault(),
                            Z(a, !1)
                        },
                        onMousedown(e) {
                            e.preventDefault(),
                            e.stopPropagation()
                        },
                        modelValue: !0,
                        "onUpdate:modelValue": void 0
                    }
                      , o = t ? !!n.chip : !!n.selection
                      , s = o ? pt(t ? n.chip({
                        item: a,
                        index: i,
                        props: r
                    }) : n.selection({
                        item: a,
                        index: i
                    })) : void 0;
                    if (!o || s)
                        return y("div", {
                            key: a.value,
                            class: ["v-combobox__selection", i === g.value && ["v-combobox__selection--selected", C.value]],
                            style: i === g.value ? P.value : {}
                        }, [t ? n.chip ? y(_i, {
                            key: "chip-defaults",
                            defaults: {
                                VChip: {
                                    closable: e.closableChips,
                                    size: "small",
                                    text: a.title
                                }
                            }
                        }, {
                            default: () => [s]
                        }) : y(Zr, A({
                            key: "chip",
                            closable: e.closableChips,
                            size: "small",
                            text: a.title,
                            disabled: a.props.disabled
                        }, r), null) : s ?? y("span", {
                            class: "v-combobox__selection-text"
                        }, [a.title, e.multiple && i < L.value.length - 1 && y("span", {
                            class: "v-combobox__selection-comma"
                        }, [vt(",")])])])
                }
                ))]),
                "append-inner": function() {
                    for (var t, a = arguments.length, i = new Array(a), o = 0; o < a; o++)
                        i[o] = arguments[o];
                    return y(Q, null, [null == (t = n["append-inner"]) ? void 0 : t.call(n, ...i), e.hideNoData && !e.items.length || !e.menuIcon ? void 0 : y(Cn, {
                        class: "v-combobox__menu-icon",
                        icon: e.menuIcon,
                        onMousedown: W,
                        onClick: gt,
                        "aria-label": r(b.value),
                        title: r(b.value)
                    }, null)])
                }
            })
        }
        )),
        bs({
            isFocused: s,
            isPristine: c,
            menu: v,
            search: T,
            selectionIndex: g,
            filteredItems: O,
            select: Z
        }, o)
    }
})
  , cc = d({
    expandOnClick: Boolean,
    showExpand: Boolean,
    expanded: {
        type: Array,
        default: () => []
    }
}, "DataTable-expand")
  , uc = Symbol.for("vuetify:datatable:expanded");
function dc(e) {
    const t = W(e, "expandOnClick")
      , a = re(e, "expanded", e.expanded, (e => new Set(e)), (e => [...e.values()]));
    function i(e, t) {
        const i = new Set(a.value);
        t ? i.add(e.value) : i.delete(e.value),
        a.value = i
    }
    function n(e) {
        return a.value.has(e.value)
    }
    const r = {
        expand: i,
        expanded: a,
        expandOnClick: t,
        isExpanded: n,
        toggleExpand: function(e) {
            i(e, !n(e))
        }
    };
    return ue(uc, r),
    r
}
function hc() {
    const e = de(uc);
    if (!e)
        throw new Error("foo");
    return e
}
const pc = d({
    groupBy: {
        type: Array,
        default: () => []
    }
}, "DataTable-group")
  , vc = Symbol.for("vuetify:data-table-group");
function gc(e) {
    return {
        groupBy: re(e, "groupBy")
    }
}
function fc(e) {
    const {groupBy: t, sortBy: a} = e
      , i = l(new Set);
    function n(e) {
        return i.value.has(e.id)
    }
    const r = {
        sortByWithGroups: F(( () => t.value.map((e => ({
            ...e,
            order: e.order ?? !1
        }))).concat(a.value))),
        toggleGroup: function(e) {
            const t = new Set(i.value);
            n(e) ? t.delete(e.id) : t.add(e.id),
            i.value = t
        },
        opened: i,
        groupBy: t,
        extractRows: function(e) {
            return function e(t) {
                const a = [];
                for (const i of t.items)
                    "type"in i && "group" === i.type ? a.push(...e(i)) : a.push(i);
                return a
            }({
                type: "group",
                items: e,
                id: "dummy",
                key: "dummy",
                value: "dummy",
                depth: 0
            })
        },
        isGroupOpen: n
    };
    return ue(vc, r),
    r
}
function mc() {
    const e = de(vc);
    if (!e)
        throw new Error("Missing group!");
    return e
}
function bc(e, t) {
    let a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
      , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "root";
    if (!t.length)
        return [];
    const n = function(e, t) {
        if (!e.length)
            return [];
        const a = new Map;
        for (const i of e) {
            const e = Mt(i.raw, t);
            a.has(e) || a.set(e, []),
            a.get(e).push(i)
        }
        return a
    }(e, t[0])
      , r = []
      , o = t.slice(1);
    return n.forEach(( (e, n) => {
        const s = t[0]
          , l = `${i}_${s}_${n}`;
        r.push({
            depth: a,
            id: l,
            key: s,
            value: n,
            items: o.length ? bc(e, o, a + 1, l) : e,
            type: "group"
        })
    }
    )),
    r
}
function xc(e, t) {
    const a = [];
    for (const i of e)
        "type"in i && "group" === i.type ? (null != i.value && a.push(i),
        (t.has(i.id) || null == i.value) && a.push(...xc(i.items, t))) : a.push(i);
    return a
}
function yc(e, t, a) {
    return {
        flatItems: F(( () => {
            if (!t.value.length)
                return e.value;
            return xc(bc(e.value, t.value.map((e => e.key))), a.value)
        }
        ))
    }
}
function wc(e) {
    let {page: t, itemsPerPage: a, sortBy: i, groupBy: n, search: r} = e;
    const o = G("VDataTable")
      , s = F(( () => ({
        page: t.value,
        itemsPerPage: a.value,
        sortBy: i.value,
        groupBy: n.value,
        search: r.value
    })));
    let l = null;
    $(s, ( () => {
        pe(l, s.value) || ((null == l ? void 0 : l.search) !== s.value.search && (t.value = 1),
        o.emit("update:options", s.value),
        l = s.value)
    }
    ), {
        deep: !0,
        immediate: !0
    })
}
const kc = d({
    page: {
        type: [Number, String],
        default: 1
    },
    itemsPerPage: {
        type: [Number, String],
        default: 10
    }
}, "DataTable-paginate")
  , Sc = Symbol.for("vuetify:data-table-pagination");
function Cc(e) {
    return {
        page: re(e, "page", void 0, (e => +(e ?? 1))),
        itemsPerPage: re(e, "itemsPerPage", void 0, (e => +(e ?? 10)))
    }
}
function Ac(e) {
    const {page: t, itemsPerPage: a, itemsLength: i} = e
      , n = F(( () => -1 === a.value ? 0 : a.value * (t.value - 1)))
      , r = F(( () => -1 === a.value ? i.value : Math.min(i.value, n.value + a.value)))
      , o = F(( () => -1 === a.value || 0 === i.value ? 1 : Math.ceil(i.value / a.value)));
    le(( () => {
        t.value > o.value && (t.value = o.value)
    }
    ));
    const s = {
        page: t,
        itemsPerPage: a,
        startIndex: n,
        stopIndex: r,
        pageCount: o,
        itemsLength: i,
        nextPage: function() {
            t.value = te(t.value + 1, 1, o.value)
        },
        prevPage: function() {
            t.value = te(t.value - 1, 1, o.value)
        },
        setPage: function(e) {
            t.value = te(e, 1, o.value)
        },
        setItemsPerPage: function(e) {
            a.value = e,
            t.value = 1
        }
    };
    return ue(Sc, s),
    s
}
function Pc(e) {
    const t = G("usePaginatedItems")
      , {items: a, startIndex: i, stopIndex: n, itemsPerPage: r} = e
      , o = F(( () => r.value <= 0 ? a.value : a.value.slice(i.value, n.value)));
    return $(o, (e => {
        t.emit("update:currentItems", e)
    }
    )),
    {
        paginatedItems: o
    }
}
const Lc = {
    showSelectAll: !1,
    allSelected: () => [],
    select: e => {
        var t;
        let {items: a, value: i} = e;
        return new Set(i ? [null == (t = a[0]) ? void 0 : t.value] : [])
    }
    ,
    selectAll: e => {
        let {selected: t} = e;
        return t
    }
}
  , Ic = {
    showSelectAll: !0,
    allSelected: e => {
        let {currentPage: t} = e;
        return t
    }
    ,
    select: e => {
        let {items: t, value: a, selected: i} = e;
        for (const n of t)
            a ? i.add(n.value) : i.delete(n.value);
        return i
    }
    ,
    selectAll: e => {
        let {value: t, currentPage: a, selected: i} = e;
        return Ic.select({
            items: a,
            value: t,
            selected: i
        })
    }
}
  , _c = {
    showSelectAll: !0,
    allSelected: e => {
        let {allItems: t} = e;
        return t
    }
    ,
    select: e => {
        let {items: t, value: a, selected: i} = e;
        for (const n of t)
            a ? i.add(n.value) : i.delete(n.value);
        return i
    }
    ,
    selectAll: e => {
        let {value: t, allItems: a, selected: i} = e;
        return _c.select({
            items: a,
            value: t,
            selected: i
        })
    }
}
  , Tc = d({
    showSelect: Boolean,
    selectStrategy: {
        type: [String, Object],
        default: "page"
    },
    modelValue: {
        type: Array,
        default: () => []
    },
    valueComparator: {
        type: Function,
        default: pe
    }
}, "DataTable-select")
  , Ec = Symbol.for("vuetify:data-table-selection");
function Oc(e, t) {
    let {allItems: a, currentPage: i} = t;
    const n = re(e, "modelValue", e.modelValue, (t => new Set(ve(t).map((t => {
        var i;
        return (null == (i = a.value.find((a => e.valueComparator(t, a.value)))) ? void 0 : i.value) ?? t
    }
    )))), (e => [...e.values()]))
      , r = F(( () => a.value.filter((e => e.selectable))))
      , o = F(( () => i.value.filter((e => e.selectable))))
      , s = F(( () => {
        if ("object" == typeof e.selectStrategy)
            return e.selectStrategy;
        switch (e.selectStrategy) {
        case "single":
            return Lc;
        case "all":
            return _c;
        default:
            return Ic
        }
    }
    ));
    function l(e) {
        return ve(e).every((e => n.value.has(e.value)))
    }
    function c(e, t) {
        const a = s.value.select({
            items: e,
            value: t,
            selected: new Set(n.value)
        });
        n.value = a
    }
    const u = F(( () => n.value.size > 0))
      , d = F(( () => {
        const e = s.value.allSelected({
            allItems: r.value,
            currentPage: o.value
        });
        return !!e.length && l(e)
    }
    ))
      , h = {
        toggleSelect: function(e) {
            c([e], !l([e]))
        },
        select: c,
        selectAll: function(e) {
            const t = s.value.selectAll({
                value: e,
                allItems: r.value,
                currentPage: o.value,
                selected: new Set(n.value)
            });
            n.value = t
        },
        isSelected: l,
        isSomeSelected: function(e) {
            return ve(e).some((e => n.value.has(e.value)))
        },
        someSelected: u,
        allSelected: d,
        showSelectAll: s.value.showSelectAll
    };
    return ue(Ec, h),
    h
}
function Vc() {
    const e = de(Ec);
    if (!e)
        throw new Error("Missing selection!");
    return e
}
const Fc = d({
    sortBy: {
        type: Array,
        default: () => []
    },
    customKeySort: Object,
    multiSort: Boolean,
    mustSort: Boolean
}, "DataTable-sort")
  , Bc = Symbol.for("vuetify:data-table-sort");
function Mc(e) {
    return {
        sortBy: re(e, "sortBy"),
        mustSort: W(e, "mustSort"),
        multiSort: W(e, "multiSort")
    }
}
function Dc(e) {
    const {sortBy: t, mustSort: a, multiSort: i, page: n} = e;
    const r = {
        sortBy: t,
        toggleSort: e => {
            if (null == e.key)
                return;
            let r = t.value.map((e => ({
                ...e
            }))) ?? [];
            const o = r.find((t => t.key === e.key));
            o ? "desc" === o.order ? a.value ? o.order = "asc" : r = r.filter((t => t.key !== e.key)) : o.order = "desc" : r = i.value ? [...r, {
                key: e.key,
                order: "asc"
            }] : [{
                key: e.key,
                order: "asc"
            }],
            t.value = r,
            n && (n.value = 1)
        }
        ,
        isSorted: function(e) {
            return !!t.value.find((t => t.key === e.key))
        }
    };
    return ue(Bc, r),
    r
}
function Rc(e, t, a, i, n) {
    const r = Te()
      , o = F(( () => a.value.length ? function(e, t, a, i, n) {
        const r = new Intl.Collator(a,{
            sensitivity: "accent",
            usage: "sort"
        });
        return [...e].sort(( (e, a) => {
            for (let o = 0; o < t.length; o++) {
                const s = t[o].key
                  , l = t[o].order ?? "asc";
                if (!1 === l)
                    continue;
                let c = Mt(e.raw, s)
                  , u = Mt(a.raw, s)
                  , d = e.raw
                  , h = a.raw;
                if ("desc" === l && ([c,u] = [u, c],
                [d,h] = [h, d]),
                null == n ? void 0 : n[s]) {
                    const e = n[s](d, h);
                    if (!e)
                        continue;
                    return e
                }
                if (null == i ? void 0 : i[s]) {
                    const e = i[s](c, u);
                    if (!e)
                        continue;
                    return e
                }
                if (c instanceof Date && u instanceof Date)
                    return c.getTime() - u.getTime();
                if ([c,u] = [c, u].map((e => null != e ? e.toString().toLocaleLowerCase() : e)),
                c !== u)
                    return Dt(c) && Dt(u) ? 0 : Dt(c) ? -1 : Dt(u) ? 1 : isNaN(c) || isNaN(u) ? r.compare(c, u) : Number(c) - Number(u)
            }
            return 0
        }
        ))
    }(t.value, a.value, r.current.value, {
        ...e.customKeySort,
        ...null == i ? void 0 : i.value
    }, null == n ? void 0 : n.value) : t.value));
    return {
        sortedItems: o
    }
}
const Nc = d({
    items: {
        type: Array,
        default: () => []
    },
    itemValue: {
        type: [String, Array, Function],
        default: "id"
    },
    itemSelectable: {
        type: [String, Array, Function],
        default: null
    },
    returnObject: Boolean
}, "DataIterator-items");
function zc(e, t) {
    return {
        type: "item",
        value: e.returnObject ? t : He(t, e.itemValue),
        selectable: He(t, e.itemSelectable, !0),
        raw: t
    }
}
function Hc(e) {
    const t = F(( () => function(e, t) {
        const a = [];
        for (const i of t)
            a.push(zc(e, i));
        return a
    }(e, e.items)));
    return {
        items: t
    }
}
const Xc = d({
    search: String,
    loading: Boolean,
    ...h(),
    ...Nc(),
    ...Tc(),
    ...Fc(),
    ...kc({
        itemsPerPage: 5
    }),
    ...cc(),
    ...pc(),
    ...Ys(),
    ...ai()
}, "VDataIterator")
  , Yc = g()({
    name: "VDataIterator",
    props: Xc(),
    emits: {
        "update:modelValue": e => !0,
        "update:groupBy": e => !0,
        "update:page": e => !0,
        "update:itemsPerPage": e => !0,
        "update:sortBy": e => !0,
        "update:options": e => !0,
        "update:expanded": e => !0,
        "update:currentItems": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "groupBy")
          , n = W(e, "search")
          , {items: r} = Hc(e)
          , {filteredItems: o} = Ws(e, r, n, {
            transform: e => e.raw
        })
          , {sortBy: s, multiSort: l, mustSort: c} = Mc(e)
          , {page: u, itemsPerPage: d} = Cc(e)
          , {toggleSort: h} = Dc({
            sortBy: s,
            multiSort: l,
            mustSort: c,
            page: u
        })
          , {sortByWithGroups: p, opened: v, extractRows: g, isGroupOpen: f, toggleGroup: m} = fc({
            groupBy: i,
            sortBy: s
        })
          , {sortedItems: b} = Rc(e, o, p)
          , {flatItems: w} = yc(b, i, v)
          , k = F(( () => w.value.length))
          , {startIndex: S, stopIndex: C, pageCount: A, prevPage: P, nextPage: L, setItemsPerPage: I, setPage: _} = Ac({
            page: u,
            itemsPerPage: d,
            itemsLength: k
        })
          , {paginatedItems: T} = Pc({
            items: w,
            startIndex: S,
            stopIndex: C,
            itemsPerPage: d
        })
          , E = F(( () => g(T.value)))
          , {isSelected: O, select: V, selectAll: B, toggleSelect: M} = Oc(e, {
            allItems: r,
            currentPage: E
        })
          , {isExpanded: D, toggleExpand: R} = dc(e);
        wc({
            page: u,
            itemsPerPage: d,
            sortBy: s,
            groupBy: i,
            search: n
        });
        const N = F(( () => ({
            page: u.value,
            itemsPerPage: d.value,
            sortBy: s.value,
            pageCount: A.value,
            toggleSort: h,
            prevPage: P,
            nextPage: L,
            setPage: _,
            setItemsPerPage: I,
            isSelected: O,
            select: V,
            selectAll: B,
            toggleSelect: M,
            isExpanded: D,
            toggleExpand: R,
            isGroupOpen: f,
            toggleGroup: m,
            items: E.value,
            groupedItems: T.value
        })));
        return x(( () => y(e.tag, {
            class: ["v-data-iterator", e.class],
            style: e.style
        }, {
            default: () => {
                var e, t, i, n;
                return [null == (e = a.header) ? void 0 : e.call(a, N.value), T.value.length ? null == (i = a.default) ? void 0 : i.call(a, N.value) : null == (t = a["no-data"]) ? void 0 : t.call(a), null == (n = a.footer) ? void 0 : n.call(a, N.value)]
            }
        }))),
        {}
    }
});
const Wc = d({
    activeColor: String,
    start: {
        type: [Number, String],
        default: 1
    },
    modelValue: {
        type: Number,
        default: e => e.start
    },
    disabled: Boolean,
    length: {
        type: [Number, String],
        default: 1,
        validator: e => e % 1 == 0
    },
    totalVisible: [Number, String],
    firstIcon: {
        type: me,
        default: "$first"
    },
    prevIcon: {
        type: me,
        default: "$prev"
    },
    nextIcon: {
        type: me,
        default: "$next"
    },
    lastIcon: {
        type: me,
        default: "$last"
    },
    ariaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.root"
    },
    pageAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.page"
    },
    currentPageAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.currentPage"
    },
    firstAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.first"
    },
    previousAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.previous"
    },
    nextAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.next"
    },
    lastAriaLabel: {
        type: String,
        default: "$vuetify.pagination.ariaLabel.last"
    },
    ellipsis: {
        type: String,
        default: "..."
    },
    showFirstLastPage: Boolean,
    ...Gi(),
    ...h(),
    ...nn(),
    ...$i(),
    ...Di(),
    ...wn(),
    ...ai({
        tag: "nav"
    }),
    ...v(),
    ...ln({
        variant: "text"
    })
}, "VPagination")
  , Gc = g()({
    name: "VPagination",
    props: Wc(),
    emits: {
        "update:modelValue": e => !0,
        first: e => !0,
        prev: e => !0,
        next: e => !0,
        last: e => !0
    },
    setup(e, t) {
        let {slots: a, emit: i} = t;
        const n = re(e, "modelValue")
          , {t: r, n: o} = Te()
          , {isRtl: s} = b()
          , {themeClasses: c} = f(e)
          , {width: u} = Me()
          , d = j(-1);
        V(void 0, {
            scoped: !0
        });
        const {resizeRef: h} = we((e => {
            if (!e.length)
                return;
            const {target: t, contentRect: a} = e[0]
              , i = t.querySelector(".v-pagination__list > *");
            if (!i)
                return;
            const n = a.width
              , r = i.offsetWidth + 2 * parseFloat(getComputedStyle(i).marginRight);
            d.value = m(n, r)
        }
        ))
          , p = F(( () => parseInt(e.length, 10)))
          , v = F(( () => parseInt(e.start, 10)))
          , g = F(( () => null != e.totalVisible ? parseInt(e.totalVisible, 10) : d.value >= 0 ? d.value : m(u.value, 58)));
        function m(t, a) {
            const i = e.showFirstLastPage ? 5 : 3;
            return Math.max(0, Math.floor(+((t - a * i) / a).toFixed(2)))
        }
        const w = F(( () => {
            if (p.value <= 0 || isNaN(p.value) || p.value > Number.MAX_SAFE_INTEGER)
                return [];
            if (g.value <= 0)
                return [];
            if (1 === g.value)
                return [n.value];
            if (p.value <= g.value)
                return It(p.value, v.value);
            const t = g.value % 2 == 0
              , a = t ? g.value / 2 : Math.floor(g.value / 2)
              , i = t ? a : a + 1
              , r = p.value - a;
            if (i - n.value >= 0)
                return [...It(Math.max(1, g.value - 1), v.value), e.ellipsis, p.value];
            if (n.value - r >= (t ? 1 : 0)) {
                const t = g.value - 1
                  , a = p.value - t + v.value;
                return [v.value, e.ellipsis, ...It(t, a)]
            }
            {
                const t = Math.max(1, g.value - 3)
                  , a = 1 === t ? n.value : n.value - Math.ceil(t / 2) + v.value;
                return [v.value, e.ellipsis, ...It(t, a), e.ellipsis, p.value]
            }
        }
        ));
        function k(e, t, a) {
            e.preventDefault(),
            n.value = t,
            a && i(a, t)
        }
        const {refs: S, updateRef: C} = function() {
            const e = l([]);
            return Rt(( () => e.value = [])),
            {
                refs: e,
                updateRef: function(t, a) {
                    e.value[a] = t
                }
            }
        }();
        V({
            VPaginationBtn: {
                color: W(e, "color"),
                border: W(e, "border"),
                density: W(e, "density"),
                size: W(e, "size"),
                variant: W(e, "variant"),
                rounded: W(e, "rounded"),
                elevation: W(e, "elevation")
            }
        });
        const P = F(( () => w.value.map(( (t, a) => {
            const i = e => C(e, a);
            if ("string" == typeof t)
                return {
                    isActive: !1,
                    key: `ellipsis-${a}`,
                    page: t,
                    props: {
                        ref: i,
                        ellipsis: !0,
                        icon: !0,
                        disabled: !0
                    }
                };
            {
                const a = t === n.value;
                return {
                    isActive: a,
                    key: t,
                    page: o(t),
                    props: {
                        ref: i,
                        ellipsis: !1,
                        icon: !0,
                        disabled: !!e.disabled || +e.length < 2,
                        color: a ? e.activeColor : e.color,
                        "aria-current": a,
                        "aria-label": r(a ? e.currentPageAriaLabel : e.pageAriaLabel, t),
                        onClick: e => k(e, t)
                    }
                }
            }
        }
        ))))
          , L = F(( () => {
            const t = !!e.disabled || n.value <= v.value
              , a = !!e.disabled || n.value >= v.value + p.value - 1;
            return {
                first: e.showFirstLastPage ? {
                    icon: s.value ? e.lastIcon : e.firstIcon,
                    onClick: e => k(e, v.value, "first"),
                    disabled: t,
                    "aria-label": r(e.firstAriaLabel),
                    "aria-disabled": t
                } : void 0,
                prev: {
                    icon: s.value ? e.nextIcon : e.prevIcon,
                    onClick: e => k(e, n.value - 1, "prev"),
                    disabled: t,
                    "aria-label": r(e.previousAriaLabel),
                    "aria-disabled": t
                },
                next: {
                    icon: s.value ? e.prevIcon : e.nextIcon,
                    onClick: e => k(e, n.value + 1, "next"),
                    disabled: a,
                    "aria-label": r(e.nextAriaLabel),
                    "aria-disabled": a
                },
                last: e.showFirstLastPage ? {
                    icon: s.value ? e.firstIcon : e.lastIcon,
                    onClick: e => k(e, v.value + p.value - 1, "last"),
                    disabled: a,
                    "aria-label": r(e.lastAriaLabel),
                    "aria-disabled": a
                } : void 0
            }
        }
        ));
        function I() {
            var e;
            const t = n.value - v.value;
            null == (e = S.value[t]) || e.$el.focus()
        }
        function _(t) {
            t.key === _t.left && !e.disabled && n.value > +e.start ? (n.value = n.value - 1,
            q(I)) : t.key === _t.right && !e.disabled && n.value < v.value + p.value - 1 && (n.value = n.value + 1,
            q(I))
        }
        return x(( () => y(e.tag, {
            ref: h,
            class: ["v-pagination", c.value, e.class],
            style: e.style,
            role: "navigation",
            "aria-label": r(e.ariaLabel),
            onKeydown: _,
            "data-test": "v-pagination-root"
        }, {
            default: () => [y("ul", {
                class: "v-pagination__list"
            }, [e.showFirstLastPage && y("li", {
                key: "first",
                class: "v-pagination__first",
                "data-test": "v-pagination-first"
            }, [a.first ? a.first(L.value.first) : y(sr, A({
                _as: "VPaginationBtn"
            }, L.value.first), null)]), y("li", {
                key: "prev",
                class: "v-pagination__prev",
                "data-test": "v-pagination-prev"
            }, [a.prev ? a.prev(L.value.prev) : y(sr, A({
                _as: "VPaginationBtn"
            }, L.value.prev), null)]), P.value.map(( (e, t) => y("li", {
                key: e.key,
                class: ["v-pagination__item", {
                    "v-pagination__item--is-active": e.isActive
                }],
                "data-test": "v-pagination-item"
            }, [a.item ? a.item(e) : y(sr, A({
                _as: "VPaginationBtn"
            }, e.props), {
                default: () => [e.page]
            })]))), y("li", {
                key: "next",
                class: "v-pagination__next",
                "data-test": "v-pagination-next"
            }, [a.next ? a.next(L.value.next) : y(sr, A({
                _as: "VPaginationBtn"
            }, L.value.next), null)]), e.showFirstLastPage && y("li", {
                key: "last",
                class: "v-pagination__last",
                "data-test": "v-pagination-last"
            }, [a.last ? a.last(L.value.last) : y(sr, A({
                _as: "VPaginationBtn"
            }, L.value.last), null)])])]
        }))),
        {}
    }
})
  , jc = d({
    prevIcon: {
        type: String,
        default: "$prev"
    },
    nextIcon: {
        type: String,
        default: "$next"
    },
    firstIcon: {
        type: String,
        default: "$first"
    },
    lastIcon: {
        type: String,
        default: "$last"
    },
    itemsPerPageText: {
        type: String,
        default: "$vuetify.dataFooter.itemsPerPageText"
    },
    pageText: {
        type: String,
        default: "$vuetify.dataFooter.pageText"
    },
    firstPageLabel: {
        type: String,
        default: "$vuetify.dataFooter.firstPage"
    },
    prevPageLabel: {
        type: String,
        default: "$vuetify.dataFooter.prevPage"
    },
    nextPageLabel: {
        type: String,
        default: "$vuetify.dataFooter.nextPage"
    },
    lastPageLabel: {
        type: String,
        default: "$vuetify.dataFooter.lastPage"
    },
    itemsPerPageOptions: {
        type: Array,
        default: () => [{
            value: 10,
            title: "10"
        }, {
            value: 25,
            title: "25"
        }, {
            value: 50,
            title: "50"
        }, {
            value: 100,
            title: "100"
        }, {
            value: -1,
            title: "$vuetify.dataFooter.itemsPerPageAll"
        }]
    },
    showCurrentPage: Boolean
}, "VDataTableFooter")
  , $c = g()({
    name: "VDataTableFooter",
    props: jc(),
    setup(e, t) {
        let {slots: a} = t;
        const {t: i} = Te()
          , {page: n, pageCount: r, startIndex: o, stopIndex: s, itemsLength: l, itemsPerPage: c, setItemsPerPage: u} = function() {
            const e = de(Sc);
            if (!e)
                throw new Error("Missing pagination!");
            return e
        }()
          , d = F(( () => e.itemsPerPageOptions.map((e => "number" == typeof e ? {
            value: e,
            title: -1 === e ? i("$vuetify.dataFooter.itemsPerPageAll") : String(e)
        } : {
            ...e,
            title: i(e.title)
        }))));
        return x(( () => {
            var t;
            const h = Gc.filterProps(e);
            return y("div", {
                class: "v-data-table-footer"
            }, [null == (t = a.prepend) ? void 0 : t.call(a), y("div", {
                class: "v-data-table-footer__items-per-page"
            }, [y("span", null, [i(e.itemsPerPageText)]), y(Hs, {
                items: d.value,
                modelValue: c.value,
                "onUpdate:modelValue": e => u(Number(e)),
                density: "compact",
                variant: "outlined",
                "hide-details": !0
            }, null)]), y("div", {
                class: "v-data-table-footer__info"
            }, [y("div", null, [i(e.pageText, l.value ? o.value + 1 : 0, s.value, l.value)])]), y("div", {
                class: "v-data-table-footer__pagination"
            }, [y(Gc, A({
                modelValue: n.value,
                "onUpdate:modelValue": e => n.value = e,
                density: "comfortable",
                "first-aria-label": e.firstPageLabel,
                "last-aria-label": e.lastPageLabel,
                length: r.value,
                "next-aria-label": e.nextPageLabel,
                "previous-aria-label": e.prevPageLabel,
                rounded: !0,
                "show-first-last-page": !0,
                "total-visible": e.showCurrentPage ? 1 : 0,
                variant: "plain"
            }, h), null)])])
        }
        )),
        {}
    }
})
  , Uc = Nt({
    align: {
        type: String,
        default: "start"
    },
    fixed: Boolean,
    fixedOffset: [Number, String],
    height: [Number, String],
    lastFixed: Boolean,
    noPadding: Boolean,
    tag: String,
    width: [Number, String]
}, ( (e, t) => {
    let {slots: a} = t;
    const i = e.tag ?? "td";
    return y(i, {
        class: ["v-data-table__td", {
            "v-data-table-column--fixed": e.fixed,
            "v-data-table-column--last-fixed": e.lastFixed,
            "v-data-table-column--no-padding": e.noPadding
        }, `v-data-table-column--align-${e.align}`],
        style: {
            height: B(e.height),
            width: B(e.width),
            left: B(e.fixedOffset || null)
        }
    }, {
        default: () => {
            var e;
            return [null == (e = a.default) ? void 0 : e.call(a)]
        }
    })
}
))
  , qc = d({
    headers: Array
}, "DataTable-header")
  , Zc = Symbol.for("vuetify:data-table-headers")
  , Kc = {
    title: "",
    sortable: !1
}
  , Jc = {
    ...Kc,
    width: 48
};
function Qc(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
    if (e.children)
        for (const a of e.children)
            Qc(a, t);
    else
        t.push(e);
    return t
}
function eu(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Set;
    for (const a of e)
        a.key && t.add(a.key),
        a.children && eu(a.children, t);
    return t
}
function tu(e) {
    if (e.key)
        return "data-table-group" === e.key ? Kc : ["data-table-expand", "data-table-select"].includes(e.key) ? Jc : void 0
}
function au(e) {
    let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
    return e.children ? Math.max(t, ...e.children.map((e => au(e, t + 1)))) : t
}
function iu(e, t) {
    const a = [];
    let i = 0;
    const n = function() {
        const e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []).map((e => ({
            element: e,
            priority: 0
        })));
        return {
            enqueue: (t, a) => {
                let i = !1;
                for (let n = 0; n < e.length; n++)
                    if (e[n].priority > a) {
                        e.splice(n, 0, {
                            element: t,
                            priority: a
                        }),
                        i = !0;
                        break
                    }
                i || e.push({
                    element: t,
                    priority: a
                })
            }
            ,
            size: () => e.length,
            count: () => {
                let t = 0;
                if (!e.length)
                    return 0;
                const a = Math.floor(e[0].priority);
                for (let i = 0; i < e.length; i++)
                    Math.floor(e[i].priority) === a && (t += 1);
                return t
            }
            ,
            dequeue: () => e.shift()
        }
    }(e);
    for (; n.size() > 0; ) {
        let e = n.count();
        const r = [];
        let o = 1;
        for (; e > 0; ) {
            const {element: a, priority: s} = n.dequeue()
              , l = t - i - au(a);
            if (r.push({
                ...a,
                rowspan: l ?? 1,
                colspan: a.children ? Qc(a).length : 1
            }),
            a.children)
                for (const e of a.children) {
                    const t = s % 1 + o / Math.pow(10, i + 2);
                    n.enqueue(e, i + l + t)
                }
            o += 1,
            e -= 1
        }
        i += 1,
        a.push(r)
    }
    return {
        columns: e.map((e => Qc(e))).flat(),
        headers: a
    }
}
function nu(e) {
    const t = [];
    for (const a of e) {
        const e = {
            ...tu(a),
            ...a
        }
          , i = e.key ?? ("string" == typeof e.value ? e.value : null)
          , n = e.value ?? i ?? null
          , r = {
            ...e,
            key: i,
            value: n,
            sortable: e.sortable ?? (null != e.key || !!e.sort),
            children: e.children ? nu(e.children) : void 0
        };
        t.push(r)
    }
    return t
}
function ru(e, t) {
    const a = l([])
      , i = l([])
      , n = l({})
      , r = l({})
      , o = l({});
    le(( () => {
        var s, l, c;
        const u = (e.headers || Object.keys(e.items[0] ?? {}).map((e => ({
            key: e,
            title: zt(e)
        })))).slice()
          , d = eu(u);
        (null == (s = null == t ? void 0 : t.groupBy) ? void 0 : s.value.length) && !d.has("data-table-group") && u.unshift({
            key: "data-table-group",
            title: "Group"
        }),
        (null == (l = null == t ? void 0 : t.showSelect) ? void 0 : l.value) && !d.has("data-table-select") && u.unshift({
            key: "data-table-select"
        }),
        (null == (c = null == t ? void 0 : t.showExpand) ? void 0 : c.value) && !d.has("data-table-expand") && u.push({
            key: "data-table-expand"
        });
        const h = nu(u);
        !function(e) {
            let t = !1;
            function a(e) {
                if (e)
                    if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1] && (e.fixed = !0),
                    e.fixed)
                        if (e.children)
                            for (let t = e.children.length - 1; t >= 0; t--)
                                a(e.children[t], !0);
                        else
                            t ? isNaN(+e.width) && Ht(`Multiple fixed columns should have a static width (key: ${e.key})`) : e.lastFixed = !0,
                            t = !0;
                    else if (e.children)
                        for (let t = e.children.length - 1; t >= 0; t--)
                            a(e.children[t]);
                    else
                        t = !1
            }
            for (let r = e.length - 1; r >= 0; r--)
                a(e[r]);
            function i(e) {
                let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                if (!e)
                    return t;
                if (e.children) {
                    e.fixedOffset = t;
                    for (const a of e.children)
                        t = i(a, t)
                } else
                    e.fixed && (e.fixedOffset = t,
                    t += parseFloat(e.width || "0") || 0);
                return t
            }
            let n = 0;
            for (const r of e)
                n = i(r, n)
        }(h);
        const p = Math.max(...h.map((e => au(e)))) + 1
          , v = iu(h, p);
        a.value = v.headers,
        i.value = v.columns;
        const g = v.headers.flat(1);
        for (const e of g)
            e.key && (e.sortable && (e.sort && (n.value[e.key] = e.sort),
            e.sortRaw && (r.value[e.key] = e.sortRaw)),
            e.filter && (o.value[e.key] = e.filter))
    }
    ));
    const s = {
        headers: a,
        columns: i,
        sortFunctions: n,
        sortRawFunctions: r,
        filterFunctions: o
    };
    return ue(Zc, s),
    s
}
function ou() {
    const e = de(Zc);
    if (!e)
        throw new Error("Missing headers!");
    return e
}
const su = d({
    color: String,
    sticky: Boolean,
    multiSort: Boolean,
    sortAscIcon: {
        type: me,
        default: "$sortAsc"
    },
    sortDescIcon: {
        type: me,
        default: "$sortDesc"
    },
    headerProps: {
        type: Object
    },
    ...Vn()
}, "VDataTableHeaders")
  , lu = g()({
    name: "VDataTableHeaders",
    props: su(),
    setup(e, t) {
        let {slots: a} = t;
        const {toggleSort: i, sortBy: n, isSorted: r} = function() {
            const e = de(Bc);
            if (!e)
                throw new Error("Missing sort!");
            return e
        }()
          , {someSelected: o, allSelected: s, selectAll: l, showSelectAll: c} = Vc()
          , {columns: u, headers: d} = ou()
          , {loaderClasses: h} = Fn(e);
        function p(t, a) {
            if (e.sticky || t.fixed)
                return {
                    position: "sticky",
                    left: t.fixed ? B(t.fixedOffset) : void 0,
                    top: e.sticky ? `calc(var(--v-table-header-height) * ${a})` : void 0
                }
        }
        function v(t) {
            const a = n.value.find((e => e.key === t.key));
            return a ? "asc" === a.order ? e.sortAscIcon : e.sortDescIcon : e.sortAscIcon
        }
        const {backgroundColorClasses: g, backgroundColorStyles: f} = Mi(e, "color")
          , m = F(( () => ({
            headers: d.value,
            columns: u.value,
            toggleSort: i,
            isSorted: r,
            sortBy: n.value,
            someSelected: o.value,
            allSelected: s.value,
            selectAll: l,
            getSortIcon: v
        })))
          , b = t => {
            let {column: u, x: d, y: m} = t;
            const b = "data-table-select" === u.key || "data-table-expand" === u.key
              , x = A(e.headerProps ?? {}, u.headerProps ?? {});
            return y(Uc, A({
                tag: "th",
                align: u.align,
                class: ["v-data-table__th", {
                    "v-data-table__th--sortable": u.sortable,
                    "v-data-table__th--sorted": r(u),
                    "v-data-table__th--fixed": u.fixed,
                    "v-data-table__th--sticky": e.sticky
                }, h.value],
                style: {
                    width: B(u.width),
                    minWidth: B(u.minWidth),
                    ...p(u, m)
                },
                colspan: u.colspan,
                rowspan: u.rowspan,
                onClick: u.sortable ? () => i(u) : void 0,
                fixed: u.fixed,
                lastFixed: u.lastFixed,
                noPadding: b
            }, x), {
                default: () => {
                    var t;
                    const d = `header.${u.key}`
                      , h = {
                        column: u,
                        selectAll: l,
                        isSorted: r,
                        toggleSort: i,
                        sortBy: n.value,
                        someSelected: o.value,
                        allSelected: s.value,
                        getSortIcon: v
                    };
                    return a[d] ? a[d](h) : "data-table-select" === u.key ? (null == (t = a["header.data-table-select"]) ? void 0 : t.call(a, h)) ?? (c && y(Pr, {
                        modelValue: s.value,
                        indeterminate: o.value && !s.value,
                        "onUpdate:modelValue": l
                    }, null)) : y("div", {
                        class: "v-data-table-header__content"
                    }, [y("span", null, [u.title]), u.sortable && y(Cn, {
                        key: "icon",
                        class: "v-data-table-header__sort-icon",
                        icon: v(u)
                    }, null), e.multiSort && r(u) && y("div", {
                        key: "badge",
                        class: ["v-data-table-header__sort-badge", ...g.value],
                        style: f.value
                    }, [n.value.findIndex((e => e.key === u.key)) + 1])])
                }
            })
        }
        ;
        x(( () => y(Q, null, [a.headers ? a.headers(m.value) : d.value.map(( (e, t) => y("tr", null, [e.map(( (e, a) => y(b, {
            column: e,
            x: a,
            y: t
        }, null)))]))), e.loading && y("tr", {
            class: "v-data-table-progress"
        }, [y("th", {
            colspan: u.value.length
        }, [y(Bn, {
            name: "v-data-table-progress",
            absolute: !0,
            active: !0,
            color: "boolean" == typeof e.loading ? void 0 : e.loading,
            indeterminate: !0
        }, {
            default: a.loader
        })])])])))
    }
})
  , cu = d({
    item: {
        type: Object,
        required: !0
    }
}, "VDataTableGroupHeaderRow")
  , uu = g()({
    name: "VDataTableGroupHeaderRow",
    props: cu(),
    setup(e, t) {
        let {slots: a} = t;
        const {isGroupOpen: i, toggleGroup: n, extractRows: r} = mc()
          , {isSelected: o, isSomeSelected: s, select: l} = Vc()
          , {columns: c} = ou()
          , u = F(( () => r([e.item])));
        return () => y("tr", {
            class: "v-data-table-group-header-row",
            style: {
                "--v-data-table-group-header-row-depth": e.item.depth
            }
        }, [c.value.map((t => {
            var r, c;
            if ("data-table-group" === t.key) {
                const t = i(e.item) ? "$expand" : "$next"
                  , o = () => n(e.item);
                return (null == (r = a["data-table-group"]) ? void 0 : r.call(a, {
                    item: e.item,
                    count: u.value.length,
                    props: {
                        icon: t,
                        onClick: o
                    }
                })) ?? y(Uc, {
                    class: "v-data-table-group-header-row__column"
                }, {
                    default: () => [y(sr, {
                        size: "small",
                        variant: "text",
                        icon: t,
                        onClick: o
                    }, null), y("span", null, [e.item.value]), y("span", null, [vt("("), u.value.length, vt(")")])]
                })
            }
            if ("data-table-select" === t.key) {
                const e = o(u.value)
                  , t = s(u.value) && !e
                  , i = e => l(u.value, e);
                return (null == (c = a["data-table-select"]) ? void 0 : c.call(a, {
                    props: {
                        modelValue: e,
                        indeterminate: t,
                        "onUpdate:modelValue": i
                    }
                })) ?? y("td", null, [y(Pr, {
                    modelValue: e,
                    indeterminate: t,
                    "onUpdate:modelValue": i
                }, null)])
            }
            return y("td", null, null)
        }
        ))])
    }
})
  , du = d({
    index: Number,
    item: Object,
    cellProps: [Object, Function],
    onClick: Ee(),
    onContextmenu: Ee(),
    onDblclick: Ee()
}, "VDataTableRow")
  , hu = g()({
    name: "VDataTableRow",
    props: du(),
    setup(e, t) {
        let {slots: a} = t;
        const {isSelected: i, toggleSelect: n} = Vc()
          , {isExpanded: r, toggleExpand: o} = hc()
          , {columns: s} = ou();
        x(( () => y("tr", {
            class: ["v-data-table__tr", {
                "v-data-table__tr--clickable": !!(e.onClick || e.onContextmenu || e.onDblclick)
            }],
            onClick: e.onClick,
            onContextmenu: e.onContextmenu,
            onDblclick: e.onDblclick
        }, [e.item && s.value.map(( (t, s) => {
            const l = e.item
              , c = `item.${t.key}`
              , u = {
                index: e.index,
                item: l.raw,
                internalItem: l,
                value: Mt(l.columns, t.key),
                column: t,
                isSelected: i,
                toggleSelect: n,
                isExpanded: r,
                toggleExpand: o
            }
              , d = "function" == typeof e.cellProps ? e.cellProps({
                index: u.index,
                item: u.item,
                internalItem: u.internalItem,
                value: u.value,
                column: t
            }) : e.cellProps
              , h = "function" == typeof t.cellProps ? t.cellProps({
                index: u.index,
                item: u.item,
                internalItem: u.internalItem,
                value: u.value
            }) : t.cellProps;
            return y(Uc, A({
                align: t.align,
                fixed: t.fixed,
                fixedOffset: t.fixedOffset,
                lastFixed: t.lastFixed,
                noPadding: "data-table-select" === t.key || "data-table-expand" === t.key,
                width: t.width
            }, d, h), {
                default: () => {
                    var e, s;
                    return a[c] ? a[c](u) : "data-table-select" === t.key ? (null == (e = a["item.data-table-select"]) ? void 0 : e.call(a, u)) ?? y(Pr, {
                        disabled: !l.selectable,
                        modelValue: i([l]),
                        onClick: Xt(( () => n(l)), ["stop"])
                    }, null) : "data-table-expand" === t.key ? (null == (s = a["item.data-table-expand"]) ? void 0 : s.call(a, u)) ?? y(sr, {
                        icon: r(l) ? "$collapse" : "$expand",
                        size: "small",
                        variant: "text",
                        onClick: Xt(( () => o(l)), ["stop"])
                    }, null) : Yt(u.value)
                }
            })
        }
        ))])))
    }
})
  , pu = d({
    loading: [Boolean, String],
    loadingText: {
        type: String,
        default: "$vuetify.dataIterator.loadingText"
    },
    hideNoData: Boolean,
    items: {
        type: Array,
        default: () => []
    },
    noDataText: {
        type: String,
        default: "$vuetify.noDataText"
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function]
}, "VDataTableRows")
  , vu = g()({
    name: "VDataTableRows",
    inheritAttrs: !1,
    props: pu(),
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const {columns: n} = ou()
          , {expandOnClick: r, toggleExpand: o, isExpanded: s} = hc()
          , {isSelected: l, toggleSelect: c} = Vc()
          , {toggleGroup: u, isGroupOpen: d} = mc()
          , {t: h} = Te();
        return x(( () => {
            var t, p;
            return !e.loading || e.items.length && !i.loading ? e.loading || e.items.length || e.hideNoData ? y(Q, null, [e.items.map(( (t, h) => {
                var p;
                if ("group" === t.type) {
                    const e = {
                        index: h,
                        item: t,
                        columns: n.value,
                        isExpanded: s,
                        toggleExpand: o,
                        isSelected: l,
                        toggleSelect: c,
                        toggleGroup: u,
                        isGroupOpen: d
                    };
                    return i["group-header"] ? i["group-header"](e) : y(uu, A({
                        key: `group-header_${t.id}`,
                        item: t
                    }, Wt(a, ":group-header", ( () => e))), i)
                }
                const v = {
                    index: h,
                    item: t.raw,
                    internalItem: t,
                    columns: n.value,
                    isExpanded: s,
                    toggleExpand: o,
                    isSelected: l,
                    toggleSelect: c
                }
                  , g = {
                    ...v,
                    props: A({
                        key: `item_${t.key ?? t.index}`,
                        onClick: r.value ? () => {
                            o(t)
                        }
                        : void 0,
                        index: h,
                        item: t,
                        cellProps: e.cellProps
                    }, Wt(a, ":row", ( () => v)), "function" == typeof e.rowProps ? e.rowProps({
                        item: v.item,
                        index: v.index,
                        internalItem: v.internalItem
                    }) : e.rowProps)
                };
                return y(Q, {
                    key: g.props.key
                }, [i.item ? i.item(g) : y(hu, g.props, i), s(t) && (null == (p = i["expanded-row"]) ? void 0 : p.call(i, v))])
            }
            ))]) : y("tr", {
                class: "v-data-table-rows-no-data",
                key: "no-data"
            }, [y("td", {
                colspan: n.value.length
            }, [(null == (p = i["no-data"]) ? void 0 : p.call(i)) ?? h(e.noDataText)])]) : y("tr", {
                class: "v-data-table-rows-loading",
                key: "loading"
            }, [y("td", {
                colspan: n.value.length
            }, [(null == (t = i.loading) ? void 0 : t.call(i)) ?? h(e.loadingText)])])
        }
        )),
        {}
    }
})
  , gu = d({
    fixedHeader: Boolean,
    fixedFooter: Boolean,
    height: [Number, String],
    hover: Boolean,
    ...h(),
    ...nn(),
    ...ai(),
    ...v()
}, "VTable")
  , fu = g()({
    name: "VTable",
    props: gu(),
    setup(e, t) {
        let {slots: a, emit: i} = t;
        const {themeClasses: n} = f(e)
          , {densityClasses: r} = rn(e);
        return x(( () => y(e.tag, {
            class: ["v-table", {
                "v-table--fixed-height": !!e.height,
                "v-table--fixed-header": e.fixedHeader,
                "v-table--fixed-footer": e.fixedFooter,
                "v-table--has-top": !!a.top,
                "v-table--has-bottom": !!a.bottom,
                "v-table--hover": e.hover
            }, n.value, r.value, e.class],
            style: e.style
        }, {
            default: () => {
                var t, i, n;
                return [null == (t = a.top) ? void 0 : t.call(a), a.default ? y("div", {
                    class: "v-table__wrapper",
                    style: {
                        height: B(e.height)
                    }
                }, [y("table", null, [a.default()])]) : null == (i = a.wrapper) ? void 0 : i.call(a), null == (n = a.bottom) ? void 0 : n.call(a)]
            }
        }))),
        {}
    }
})
  , mu = d({
    items: {
        type: Array,
        default: () => []
    },
    itemValue: {
        type: [String, Array, Function],
        default: "id"
    },
    itemSelectable: {
        type: [String, Array, Function],
        default: null
    },
    rowProps: [Object, Function],
    cellProps: [Object, Function],
    returnObject: Boolean
}, "DataTable-items");
function bu(e, t, a) {
    return t.map(( (t, i) => function(e, t, a, i) {
        const n = e.returnObject ? t : He(t, e.itemValue)
          , r = He(t, e.itemSelectable, !0)
          , o = i.reduce(( (e, a) => (null != a.key && (e[a.key] = He(t, a.value)),
        e)), {});
        return {
            type: "item",
            key: e.returnObject ? He(t, e.itemValue) : n,
            index: a,
            value: n,
            selectable: r,
            columns: o,
            raw: t
        }
    }(e, t, i, a)))
}
function xu(e, t) {
    return {
        items: F(( () => bu(e, e.items, t.value)))
    }
}
const yu = d({
    ...pu(),
    width: [String, Number],
    search: String,
    ...cc(),
    ...pc(),
    ...qc(),
    ...mu(),
    ...Tc(),
    ...Fc(),
    ...su(),
    ...gu()
}, "DataTable")
  , wu = d({
    ...kc(),
    ...yu(),
    ...Ys(),
    ...jc()
}, "VDataTable")
  , ku = g()({
    name: "VDataTable",
    props: wu(),
    emits: {
        "update:modelValue": e => !0,
        "update:page": e => !0,
        "update:itemsPerPage": e => !0,
        "update:sortBy": e => !0,
        "update:options": e => !0,
        "update:groupBy": e => !0,
        "update:expanded": e => !0,
        "update:currentItems": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const {groupBy: n} = gc(e)
          , {sortBy: r, multiSort: o, mustSort: s} = Mc(e)
          , {page: l, itemsPerPage: c} = Cc(e)
          , {columns: u, headers: d, sortFunctions: h, sortRawFunctions: p, filterFunctions: v} = ru(e, {
            groupBy: n,
            showSelect: W(e, "showSelect"),
            showExpand: W(e, "showExpand")
        })
          , {items: g} = xu(e, u)
          , f = W(e, "search")
          , {filteredItems: m} = Ws(e, g, f, {
            transform: e => e.columns,
            customKeyFilter: v
        })
          , {toggleSort: b} = Dc({
            sortBy: r,
            multiSort: o,
            mustSort: s,
            page: l
        })
          , {sortByWithGroups: w, opened: k, extractRows: S, isGroupOpen: C, toggleGroup: P} = fc({
            groupBy: n,
            sortBy: r
        })
          , {sortedItems: L} = Rc(e, m, w, h, p)
          , {flatItems: I} = yc(L, n, k)
          , _ = F(( () => I.value.length))
          , {startIndex: T, stopIndex: E, pageCount: O, setItemsPerPage: B} = Ac({
            page: l,
            itemsPerPage: c,
            itemsLength: _
        })
          , {paginatedItems: M} = Pc({
            items: I,
            startIndex: T,
            stopIndex: E,
            itemsPerPage: c
        })
          , D = F(( () => S(M.value)))
          , {isSelected: R, select: N, selectAll: z, toggleSelect: H, someSelected: X, allSelected: Y} = Oc(e, {
            allItems: g,
            currentPage: D
        })
          , {isExpanded: G, toggleExpand: j} = dc(e);
        wc({
            page: l,
            itemsPerPage: c,
            sortBy: r,
            groupBy: n,
            search: f
        }),
        V({
            VDataTableRows: {
                hideNoData: W(e, "hideNoData"),
                noDataText: W(e, "noDataText"),
                loading: W(e, "loading"),
                loadingText: W(e, "loadingText")
            }
        });
        const $ = F(( () => ({
            page: l.value,
            itemsPerPage: c.value,
            sortBy: r.value,
            pageCount: O.value,
            toggleSort: b,
            setItemsPerPage: B,
            someSelected: X.value,
            allSelected: Y.value,
            isSelected: R,
            select: N,
            selectAll: z,
            toggleSelect: H,
            isExpanded: G,
            toggleExpand: j,
            isGroupOpen: C,
            toggleGroup: P,
            items: D.value.map((e => e.raw)),
            internalItems: D.value,
            groupedItems: M.value,
            columns: u.value,
            headers: d.value
        })));
        return x(( () => {
            const t = $c.filterProps(e)
              , n = lu.filterProps(e)
              , r = vu.filterProps(e)
              , o = fu.filterProps(e);
            return y(fu, A({
                class: ["v-data-table", {
                    "v-data-table--show-select": e.showSelect,
                    "v-data-table--loading": e.loading
                }, e.class],
                style: e.style
            }, o), {
                top: () => {
                    var e;
                    return null == (e = i.top) ? void 0 : e.call(i, $.value)
                }
                ,
                default: () => {
                    var e, t, o, s, l, c;
                    return i.default ? i.default($.value) : y(Q, null, [null == (e = i.colgroup) ? void 0 : e.call(i, $.value), y("thead", null, [y(lu, n, i)]), null == (t = i.thead) ? void 0 : t.call(i, $.value), y("tbody", null, [null == (o = i["body.prepend"]) ? void 0 : o.call(i, $.value), i.body ? i.body($.value) : y(vu, A(a, r, {
                        items: M.value
                    }), i), null == (s = i["body.append"]) ? void 0 : s.call(i, $.value)]), null == (l = i.tbody) ? void 0 : l.call(i, $.value), null == (c = i.tfoot) ? void 0 : c.call(i, $.value)])
                }
                ,
                bottom: () => i.bottom ? i.bottom($.value) : y(Q, null, [y(wo, null, null), y($c, t, {
                    prepend: i["footer.prepend"]
                })])
            })
        }
        )),
        {}
    }
})
  , Su = d({
    ...yu(),
    ...pc(),
    ...Fs(),
    ...Ys()
}, "VDataTableVirtual")
  , Cu = g()({
    name: "VDataTableVirtual",
    props: Su(),
    emits: {
        "update:modelValue": e => !0,
        "update:sortBy": e => !0,
        "update:options": e => !0,
        "update:groupBy": e => !0,
        "update:expanded": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const {groupBy: n} = gc(e)
          , {sortBy: r, multiSort: o, mustSort: s} = Mc(e)
          , {columns: l, headers: c, filterFunctions: u, sortFunctions: d, sortRawFunctions: h} = ru(e, {
            groupBy: n,
            showSelect: W(e, "showSelect"),
            showExpand: W(e, "showExpand")
        })
          , {items: p} = xu(e, l)
          , v = W(e, "search")
          , {filteredItems: g} = Ws(e, p, v, {
            transform: e => e.columns,
            customKeyFilter: u
        })
          , {toggleSort: f} = Dc({
            sortBy: r,
            multiSort: o,
            mustSort: s
        })
          , {sortByWithGroups: m, opened: b, extractRows: w, isGroupOpen: k, toggleGroup: S} = fc({
            groupBy: n,
            sortBy: r
        })
          , {sortedItems: C} = Rc(e, g, m, d, h)
          , {flatItems: P} = yc(C, n, b)
          , L = F(( () => w(P.value)))
          , {isSelected: I, select: _, selectAll: T, toggleSelect: E, someSelected: O, allSelected: M} = Oc(e, {
            allItems: L,
            currentPage: L
        })
          , {isExpanded: D, toggleExpand: R} = dc(e)
          , {containerRef: N, markerRef: z, paddingTop: H, paddingBottom: X, computedItems: Y, handleItemResize: G, handleScroll: $, handleScrollend: U} = Bs(e, P)
          , q = F(( () => Y.value.map((e => e.raw))));
        wc({
            sortBy: r,
            page: j(1),
            itemsPerPage: j(-1),
            groupBy: n,
            search: v
        }),
        V({
            VDataTableRows: {
                hideNoData: W(e, "hideNoData"),
                noDataText: W(e, "noDataText"),
                loading: W(e, "loading"),
                loadingText: W(e, "loadingText")
            }
        });
        const Z = F(( () => ({
            sortBy: r.value,
            toggleSort: f,
            someSelected: O.value,
            allSelected: M.value,
            isSelected: I,
            select: _,
            selectAll: T,
            toggleSelect: E,
            isExpanded: D,
            toggleExpand: R,
            isGroupOpen: k,
            toggleGroup: S,
            items: L.value.map((e => e.raw)),
            internalItems: L.value,
            groupedItems: P.value,
            columns: l.value,
            headers: c.value
        })));
        x(( () => {
            const t = lu.filterProps(e)
              , n = vu.filterProps(e)
              , r = fu.filterProps(e);
            return y(fu, A({
                class: ["v-data-table", {
                    "v-data-table--loading": e.loading
                }, e.class],
                style: e.style
            }, r), {
                top: () => {
                    var e;
                    return null == (e = i.top) ? void 0 : e.call(i, Z.value)
                }
                ,
                wrapper: () => {
                    var r, o, s;
                    return y("div", {
                        ref: N,
                        onScrollPassive: $,
                        onScrollend: U,
                        class: "v-table__wrapper",
                        style: {
                            height: B(e.height)
                        }
                    }, [y("table", null, [null == (r = i.colgroup) ? void 0 : r.call(i, Z.value), y("thead", null, [y(lu, A(t, {
                        sticky: e.fixedHeader
                    }), i)]), y("tbody", null, [y("tr", {
                        ref: z,
                        style: {
                            height: B(H.value),
                            border: 0
                        }
                    }, [y("td", {
                        colspan: l.value.length,
                        style: {
                            height: 0,
                            border: 0
                        }
                    }, null)]), null == (o = i["body.prepend"]) ? void 0 : o.call(i, Z.value), y(vu, A(a, n, {
                        items: q.value
                    }), {
                        ...i,
                        item: e => y(Vs, {
                            key: e.internalItem.index,
                            renderless: !0,
                            "onUpdate:height": t => G(e.internalItem.index, t)
                        }, {
                            default: t => {
                                var a;
                                let {itemRef: n} = t;
                                return (null == (a = i.item) ? void 0 : a.call(i, {
                                    ...e,
                                    itemRef: n
                                })) ?? y(hu, A(e.props, {
                                    ref: n,
                                    key: e.internalItem.index,
                                    index: e.internalItem.index
                                }), i)
                            }
                        })
                    }), null == (s = i["body.append"]) ? void 0 : s.call(i, Z.value), y("tr", {
                        style: {
                            height: B(X.value),
                            border: 0
                        }
                    }, [y("td", {
                        colspan: l.value.length,
                        style: {
                            height: 0,
                            border: 0
                        }
                    }, null)])])])])
                }
                ,
                bottom: () => {
                    var e;
                    return null == (e = i.bottom) ? void 0 : e.call(i, Z.value)
                }
            })
        }
        ))
    }
})
  , Au = d({
    itemsLength: {
        type: [Number, String],
        required: !0
    },
    ...kc(),
    ...yu(),
    ...jc()
}, "VDataTableServer")
  , Pu = g()({
    name: "VDataTableServer",
    props: Au(),
    emits: {
        "update:modelValue": e => !0,
        "update:page": e => !0,
        "update:itemsPerPage": e => !0,
        "update:sortBy": e => !0,
        "update:options": e => !0,
        "update:expanded": e => !0,
        "update:groupBy": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const {groupBy: n} = gc(e)
          , {sortBy: r, multiSort: o, mustSort: s} = Mc(e)
          , {page: l, itemsPerPage: c} = Cc(e)
          , u = F(( () => parseInt(e.itemsLength, 10)))
          , {columns: d, headers: h} = ru(e, {
            groupBy: n,
            showSelect: W(e, "showSelect"),
            showExpand: W(e, "showExpand")
        })
          , {items: p} = xu(e, d)
          , {toggleSort: v} = Dc({
            sortBy: r,
            multiSort: o,
            mustSort: s,
            page: l
        })
          , {opened: g, isGroupOpen: f, toggleGroup: m, extractRows: b} = fc({
            groupBy: n,
            sortBy: r
        })
          , {pageCount: w, setItemsPerPage: k} = Ac({
            page: l,
            itemsPerPage: c,
            itemsLength: u
        })
          , {flatItems: S} = yc(p, n, g)
          , {isSelected: C, select: P, selectAll: L, toggleSelect: I, someSelected: _, allSelected: T} = Oc(e, {
            allItems: p,
            currentPage: p
        })
          , {isExpanded: E, toggleExpand: O} = dc(e)
          , B = F(( () => b(p.value)));
        wc({
            page: l,
            itemsPerPage: c,
            sortBy: r,
            groupBy: n,
            search: W(e, "search")
        }),
        ue("v-data-table", {
            toggleSort: v,
            sortBy: r
        }),
        V({
            VDataTableRows: {
                hideNoData: W(e, "hideNoData"),
                noDataText: W(e, "noDataText"),
                loading: W(e, "loading"),
                loadingText: W(e, "loadingText")
            }
        });
        const M = F(( () => ({
            page: l.value,
            itemsPerPage: c.value,
            sortBy: r.value,
            pageCount: w.value,
            toggleSort: v,
            setItemsPerPage: k,
            someSelected: _.value,
            allSelected: T.value,
            isSelected: C,
            select: P,
            selectAll: L,
            toggleSelect: I,
            isExpanded: E,
            toggleExpand: O,
            isGroupOpen: f,
            toggleGroup: m,
            items: B.value.map((e => e.raw)),
            internalItems: B.value,
            groupedItems: S.value,
            columns: d.value,
            headers: h.value
        })));
        x(( () => {
            const t = $c.filterProps(e)
              , n = lu.filterProps(e)
              , r = vu.filterProps(e)
              , o = fu.filterProps(e);
            return y(fu, A({
                class: ["v-data-table", {
                    "v-data-table--loading": e.loading
                }, e.class],
                style: e.style
            }, o), {
                top: () => {
                    var e;
                    return null == (e = i.top) ? void 0 : e.call(i, M.value)
                }
                ,
                default: () => {
                    var t, o, s, l, c, u;
                    return i.default ? i.default(M.value) : y(Q, null, [null == (t = i.colgroup) ? void 0 : t.call(i, M.value), y("thead", {
                        class: "v-data-table__thead",
                        role: "rowgroup"
                    }, [y(lu, A(n, {
                        sticky: e.fixedHeader
                    }), i)]), null == (o = i.thead) ? void 0 : o.call(i, M.value), y("tbody", {
                        class: "v-data-table__tbody",
                        role: "rowgroup"
                    }, [null == (s = i["body.prepend"]) ? void 0 : s.call(i, M.value), i.body ? i.body(M.value) : y(vu, A(a, r, {
                        items: S.value
                    }), i), null == (l = i["body.append"]) ? void 0 : l.call(i, M.value)]), null == (c = i.tbody) ? void 0 : c.call(i, M.value), null == (u = i.tfoot) ? void 0 : u.call(i, M.value)])
                }
                ,
                bottom: () => i.bottom ? i.bottom(M.value) : y($c, t, {
                    prepend: i["footer.prepend"]
                })
            })
        }
        ))
    }
})
  , Lu = d({
    fluid: {
        type: Boolean,
        default: !1
    },
    ...h(),
    ...ai()
}, "VContainer")
  , Iu = g()({
    name: "VContainer",
    props: Lu(),
    setup(e, t) {
        let {slots: a} = t;
        const {rtlClasses: i} = b();
        return x(( () => y(e.tag, {
            class: ["v-container", {
                "v-container--fluid": e.fluid
            }, i.value, e.class],
            style: e.style
        }, a))),
        {}
    }
})
  , _u = Gt.reduce(( (e, t) => (e[t] = {
    type: [Boolean, String, Number],
    default: !1
},
e)), {})
  , Tu = Gt.reduce(( (e, t) => (e["offset" + zt(t)] = {
    type: [String, Number],
    default: null
},
e)), {})
  , Eu = Gt.reduce(( (e, t) => (e["order" + zt(t)] = {
    type: [String, Number],
    default: null
},
e)), {})
  , Ou = {
    col: Object.keys(_u),
    offset: Object.keys(Tu),
    order: Object.keys(Eu)
};
function Vu(e, t, a) {
    let i = e;
    if (null != a && !1 !== a) {
        if (t) {
            i += `-${t.replace(e, "")}`
        }
        return "col" === e && (i = "v-" + i),
        "col" !== e || "" !== a && !0 !== a ? (i += `-${a}`,
        i.toLowerCase()) : i.toLowerCase()
    }
}
const Fu = ["auto", "start", "end", "center", "baseline", "stretch"]
  , Bu = d({
    cols: {
        type: [Boolean, String, Number],
        default: !1
    },
    ..._u,
    offset: {
        type: [String, Number],
        default: null
    },
    ...Tu,
    order: {
        type: [String, Number],
        default: null
    },
    ...Eu,
    alignSelf: {
        type: String,
        default: null,
        validator: e => Fu.includes(e)
    },
    ...h(),
    ...ai()
}, "VCol")
  , Mu = g()({
    name: "VCol",
    props: Bu(),
    setup(e, t) {
        let {slots: a} = t;
        const i = F(( () => {
            const t = [];
            let a;
            for (a in Ou)
                Ou[a].forEach((i => {
                    const n = e[i]
                      , r = Vu(a, i, n);
                    r && t.push(r)
                }
                ));
            const i = t.some((e => e.startsWith("v-col-")));
            return t.push({
                "v-col": !i || !e.cols,
                [`v-col-${e.cols}`]: e.cols,
                [`offset-${e.offset}`]: e.offset,
                [`order-${e.order}`]: e.order,
                [`align-self-${e.alignSelf}`]: e.alignSelf
            }),
            t
        }
        ));
        return () => {
            var t;
            return S(e.tag, {
                class: [i.value, e.class],
                style: e.style
            }, null == (t = a.default) ? void 0 : t.call(a))
        }
    }
})
  , Du = ["start", "end", "center"]
  , Ru = ["space-between", "space-around", "space-evenly"];
function Nu(e, t) {
    return Gt.reduce(( (a, i) => (a[e + zt(i)] = t(),
    a)), {})
}
const zu = [...Du, "baseline", "stretch"]
  , Hu = e => zu.includes(e)
  , Xu = Nu("align", ( () => ({
    type: String,
    default: null,
    validator: Hu
})))
  , Yu = [...Du, ...Ru]
  , Wu = e => Yu.includes(e)
  , Gu = Nu("justify", ( () => ({
    type: String,
    default: null,
    validator: Wu
})))
  , ju = [...Du, ...Ru, "stretch"]
  , $u = e => ju.includes(e)
  , Uu = Nu("alignContent", ( () => ({
    type: String,
    default: null,
    validator: $u
})))
  , qu = {
    align: Object.keys(Xu),
    justify: Object.keys(Gu),
    alignContent: Object.keys(Uu)
}
  , Zu = {
    align: "align",
    justify: "justify",
    alignContent: "align-content"
};
function Ku(e, t, a) {
    let i = Zu[e];
    if (null != a) {
        if (t) {
            i += `-${t.replace(e, "")}`
        }
        return i += `-${a}`,
        i.toLowerCase()
    }
}
const Ju = d({
    dense: Boolean,
    noGutters: Boolean,
    align: {
        type: String,
        default: null,
        validator: Hu
    },
    ...Xu,
    justify: {
        type: String,
        default: null,
        validator: Wu
    },
    ...Gu,
    alignContent: {
        type: String,
        default: null,
        validator: $u
    },
    ...Uu,
    ...h(),
    ...ai()
}, "VRow")
  , Qu = g()({
    name: "VRow",
    props: Ju(),
    setup(e, t) {
        let {slots: a} = t;
        const i = F(( () => {
            const t = [];
            let a;
            for (a in qu)
                qu[a].forEach((i => {
                    const n = e[i]
                      , r = Ku(a, i, n);
                    r && t.push(r)
                }
                ));
            return t.push({
                "v-row--no-gutters": e.noGutters,
                "v-row--dense": e.dense,
                [`align-${e.align}`]: e.align,
                [`justify-${e.justify}`]: e.justify,
                [`align-content-${e.alignContent}`]: e.alignContent
            }),
            t
        }
        ));
        return () => {
            var t;
            return S(e.tag, {
                class: ["v-row", i.value, e.class],
                style: e.style
            }, null == (t = a.default) ? void 0 : t.call(a))
        }
    }
})
  , ed = _e("v-spacer", "div", "VSpacer")
  , td = d({
    active: {
        type: [String, Array],
        default: void 0
    },
    disabled: {
        type: [Boolean, String, Array],
        default: !1
    },
    nextIcon: {
        type: [String],
        default: "$next"
    },
    prevIcon: {
        type: [String],
        default: "$prev"
    },
    modeIcon: {
        type: [String],
        default: "$subgroup"
    },
    text: String,
    viewMode: {
        type: String,
        default: "month"
    }
}, "VDatePickerControls")
  , ad = g()({
    name: "VDatePickerControls",
    props: td(),
    emits: {
        "click:year": () => !0,
        "click:month": () => !0,
        "click:prev": () => !0,
        "click:next": () => !0,
        "click:text": () => !0
    },
    setup(e, t) {
        let {emit: a} = t;
        const i = F(( () => Array.isArray(e.disabled) ? e.disabled.includes("text") : !!e.disabled))
          , n = F(( () => Array.isArray(e.disabled) ? e.disabled.includes("mode") : !!e.disabled))
          , r = F(( () => Array.isArray(e.disabled) ? e.disabled.includes("prev") : !!e.disabled))
          , o = F(( () => Array.isArray(e.disabled) ? e.disabled.includes("next") : !!e.disabled));
        function s() {
            a("click:prev")
        }
        function l() {
            a("click:next")
        }
        function c() {
            a("click:year")
        }
        function u() {
            a("click:month")
        }
        return x(( () => y("div", {
            class: ["v-date-picker-controls"]
        }, [y(sr, {
            class: "v-date-picker-controls__month-btn",
            disabled: i.value,
            text: e.text,
            variant: "text",
            rounded: !0,
            onClick: u
        }, null), y(sr, {
            key: "mode-btn",
            class: "v-date-picker-controls__mode-btn",
            disabled: n.value,
            density: "comfortable",
            icon: e.modeIcon,
            variant: "text",
            onClick: c
        }, null), y(ed, {
            key: "mode-spacer"
        }, null), y("div", {
            key: "month-buttons",
            class: "v-date-picker-controls__month"
        }, [y(sr, {
            disabled: r.value,
            icon: e.prevIcon,
            variant: "text",
            onClick: s
        }, null), y(sr, {
            disabled: o.value,
            icon: e.nextIcon,
            variant: "text",
            onClick: l
        }, null)])]))),
        {}
    }
})
  , id = d({
    appendIcon: String,
    color: String,
    header: String,
    transition: String,
    onClick: Ee()
}, "VDatePickerHeader")
  , nd = g()({
    name: "VDatePickerHeader",
    props: id(),
    emits: {
        click: () => !0,
        "click:append": () => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(e, "color");
        function o() {
            a("click")
        }
        function s() {
            a("click:append")
        }
        return x(( () => {
            const t = !(!i.default && !e.header)
              , a = !(!i.append && !e.appendIcon);
            return y("div", {
                class: ["v-date-picker-header", {
                    "v-date-picker-header--clickable": !!e.onClick
                }, n.value],
                style: r.value,
                onClick: o
            }, [i.prepend && y("div", {
                key: "prepend",
                class: "v-date-picker-header__prepend"
            }, [i.prepend()]), t && y(zi, {
                key: "content",
                name: e.transition
            }, {
                default: () => {
                    var t;
                    return [y("div", {
                        key: e.header,
                        class: "v-date-picker-header__content"
                    }, [(null == (t = i.default) ? void 0 : t.call(i)) ?? e.header])]
                }
            }), a && y("div", {
                class: "v-date-picker-header__append"
            }, [i.append ? y(_i, {
                key: "append-defaults",
                disabled: !e.appendIcon,
                defaults: {
                    VBtn: {
                        icon: e.appendIcon,
                        variant: "text"
                    }
                }
            }, {
                default: () => {
                    var e;
                    return [null == (e = i.append) ? void 0 : e.call(i)]
                }
            }) : y(sr, {
                key: "append-btn",
                icon: e.appendIcon,
                variant: "text",
                onClick: s
            }, null)])])
        }
        )),
        {}
    }
})
  , rd = d({
    allowedDates: [Array, Function],
    disabled: Boolean,
    displayValue: null,
    modelValue: Array,
    month: [Number, String],
    max: null,
    min: null,
    showAdjacentMonths: Boolean,
    year: [Number, String],
    weekdays: {
        type: Array,
        default: () => [0, 1, 2, 3, 4, 5, 6]
    }
}, "calendar");
const od = d({
    color: String,
    hideWeekdays: Boolean,
    multiple: [Boolean, Number, String],
    showWeek: Boolean,
    ...rd()
}, "VDatePickerMonth")
  , sd = g()({
    name: "VDatePickerMonth",
    props: od(),
    emits: {
        "update:modelValue": e => !0,
        "update:month": e => !0,
        "update:year": e => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const n = l()
          , {daysInMonth: r, model: o, weekNumbers: s} = function(e) {
            const t = jt()
              , a = re(e, "modelValue", [], (e => ve(e)))
              , i = F(( () => e.displayValue ? t.date(e.displayValue) : a.value.length > 0 ? t.date(a.value[0]) : e.min ? t.date(e.min) : Array.isArray(e.allowedDates) ? t.date(e.allowedDates[0]) : t.date()))
              , n = re(e, "year", void 0, (e => {
                const a = null != e ? Number(e) : t.getYear(i.value);
                return t.startOfYear(t.setYear(t.date(), a))
            }
            ), (e => t.getYear(e)))
              , r = re(e, "month", void 0, (e => {
                const a = null != e ? Number(e) : t.getMonth(i.value)
                  , r = t.setYear(t.startOfMonth(t.date()), t.getYear(n.value));
                return t.setMonth(r, a)
            }
            ), (e => t.getMonth(e)))
              , o = F(( () => {
                const e = t.getWeekArray(r.value)
                  , a = e.flat();
                if (a.length < 42) {
                    const i = a[a.length - 1];
                    let n = [];
                    for (let r = 1; r <= 42 - a.length; r++)
                        n.push(t.addDays(i, r)),
                        r % 7 == 0 && (e.push(n),
                        n = [])
                }
                return e
            }
            ));
            function s(i, n) {
                return i.filter((a => e.weekdays.includes(t.toJsDate(a).getDay()))).map(( (i, o) => {
                    const s = t.toISO(i)
                      , l = !t.isSameMonth(i, r.value)
                      , c = t.isSameDay(i, t.startOfMonth(r.value))
                      , u = t.isSameDay(i, t.endOfMonth(r.value))
                      , h = t.isSameDay(i, r.value);
                    return {
                        date: i,
                        isoDate: s,
                        formatted: t.format(i, "keyboardDate"),
                        year: t.getYear(i),
                        month: t.getMonth(i),
                        isDisabled: d(i),
                        isWeekStart: o % 7 == 0,
                        isWeekEnd: o % 7 == 6,
                        isToday: t.isSameDay(i, n),
                        isAdjacent: l,
                        isHidden: l && !e.showAdjacentMonths,
                        isStart: c,
                        isSelected: a.value.some((e => t.isSameDay(i, e))),
                        isEnd: u,
                        isSame: h,
                        localized: t.format(i, "dayOfMonth")
                    }
                }
                ))
            }
            const l = F(( () => {
                const e = t.startOfWeek(a.value)
                  , i = [];
                for (let a = 0; a <= 6; a++)
                    i.push(t.addDays(e, a));
                return s(i, t.date())
            }
            ))
              , c = F(( () => s(o.value.flat(), t.date())))
              , u = F(( () => o.value.map((e => e.length ? $t(t, e[0]) : null))));
            function d(a) {
                if (e.disabled)
                    return !0;
                const i = t.date(a);
                return !((!e.min || !t.isAfter(t.date(e.min), i)) && (!e.max || !t.isAfter(i, t.date(e.max))) && (Array.isArray(e.allowedDates) && e.allowedDates.length > 0 ? e.allowedDates.some((e => t.isSameDay(t.date(e), i))) : "function" != typeof e.allowedDates || e.allowedDates(i)))
            }
            return {
                displayValue: i,
                daysInMonth: c,
                daysInWeek: l,
                genDays: s,
                model: a,
                weeksInMonth: o,
                weekNumbers: u
            }
        }(e)
          , c = jt()
          , u = j()
          , d = j()
          , h = F(( () => {
            const t = ["number", "string"].includes(typeof e.multiple) ? Number(e.multiple) : 1 / 0;
            return o.value.length >= t
        }
        ));
        function p(t) {
            "range" === e.multiple ? function(e) {
                const t = c.startOfDay(e);
                if (u.value)
                    if (d.value)
                        u.value = e,
                        d.value = void 0,
                        o.value = [u.value];
                    else {
                        if (c.isSameDay(e, u.value))
                            return u.value = void 0,
                            void (o.value = []);
                        c.isBefore(e, u.value) ? (d.value = u.value,
                        u.value = t) : d.value = t;
                        const a = c.getDiff(d.value, u.value)
                          , i = [u.value];
                        for (let e = 1; e < a; e++) {
                            const t = c.addDays(u.value, e);
                            i.push(t)
                        }
                        i.push(d.value),
                        o.value = i
                    }
                else
                    u.value = t,
                    o.value = [u.value]
            }(t) : e.multiple ? function(e) {
                const t = o.value.findIndex((t => c.isSameDay(t, e)));
                if (-1 === t)
                    o.value = [...o.value, e];
                else {
                    const e = [...o.value];
                    e.splice(t, 1),
                    o.value = e
                }
            }(t) : o.value = [t]
        }
        return () => y("div", {
            class: "v-date-picker-month"
        }, [e.showWeek && y("div", {
            key: "weeks",
            class: "v-date-picker-month__weeks"
        }, [!e.hideWeekdays && y("div", {
            key: "hide-week-days",
            class: "v-date-picker-month__day"
        }, [vt("")]), s.value.map((e => y("div", {
            class: ["v-date-picker-month__day", "v-date-picker-month__day--adjacent"]
        }, [e])))]), y("div", {
            ref: n,
            class: "v-date-picker-month__days"
        }, [!e.hideWeekdays && c.getWeekdays().map((e => y("div", {
            class: ["v-date-picker-month__day", "v-date-picker-month__weekday"]
        }, [e]))), r.value.map(( (t, a) => {
            const n = {
                props: {
                    onClick: () => p(t.date)
                },
                item: t,
                i: a
            };
            return h.value && !t.isSelected && (t.isDisabled = !0),
            y("div", {
                class: ["v-date-picker-month__day", {
                    "v-date-picker-month__day--adjacent": t.isAdjacent,
                    "v-date-picker-month__day--hide-adjacent": t.isHidden,
                    "v-date-picker-month__day--selected": t.isSelected,
                    "v-date-picker-month__day--week-end": t.isWeekEnd,
                    "v-date-picker-month__day--week-start": t.isWeekStart
                }],
                "data-v-date": t.isDisabled ? void 0 : t.isoDate
            }, [(e.showAdjacentMonths || !t.isAdjacent) && y(_i, {
                defaults: {
                    VBtn: {
                        class: "v-date-picker-month__day-btn",
                        color: !t.isSelected && !t.isToday || t.isDisabled ? void 0 : e.color,
                        disabled: t.isDisabled,
                        icon: !0,
                        ripple: !1,
                        text: t.localized,
                        variant: t.isDisabled ? t.isToday ? "outlined" : "text" : t.isToday && !t.isSelected ? "outlined" : "flat",
                        onClick: () => p(t.date)
                    }
                }
            }, {
                default: () => {
                    var e;
                    return [(null == (e = i.day) ? void 0 : e.call(i, n)) ?? y(sr, n.props, null)]
                }
            })])
        }
        ))])])
    }
})
  , ld = d({
    color: String,
    height: [String, Number],
    modelValue: Number
}, "VDatePickerMonths")
  , cd = g()({
    name: "VDatePickerMonths",
    props: ld(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const n = jt()
          , r = re(e, "modelValue")
          , o = F(( () => {
            let e = n.startOfYear(n.date());
            return It(12).map((t => {
                const a = n.format(e, "monthShort");
                return e = n.getNextMonth(e),
                {
                    text: a,
                    value: t
                }
            }
            ))
        }
        ));
        return le(( () => {
            r.value = r.value ?? n.getMonth(n.date())
        }
        )),
        x(( () => y("div", {
            class: "v-date-picker-months",
            style: {
                height: B(e.height)
            }
        }, [y("div", {
            class: "v-date-picker-months__content"
        }, [o.value.map(( (t, n) => {
            var o;
            const s = {
                active: r.value === n,
                color: r.value === n ? e.color : void 0,
                rounded: !0,
                text: t.text,
                variant: r.value === t.value ? "flat" : "text",
                onClick: () => function(e) {
                    if (r.value === e)
                        return void a("update:modelValue", r.value);
                    r.value = e
                }(n)
            };
            return (null == (o = i.month) ? void 0 : o.call(i, {
                month: t,
                i: n,
                props: s
            })) ?? y(sr, A({
                key: "month"
            }, s), null)
        }
        ))])]))),
        {}
    }
})
  , ud = d({
    color: String,
    height: [String, Number],
    min: null,
    max: null,
    modelValue: Number
}, "VDatePickerYears")
  , dd = g()({
    name: "VDatePickerYears",
    props: ud(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const n = jt()
          , r = re(e, "modelValue")
          , o = F(( () => {
            const t = n.getYear(n.date());
            let a = t - 100
              , i = t + 52;
            e.min && (a = n.getYear(n.date(e.min))),
            e.max && (i = n.getYear(n.date(e.max)));
            let r = n.startOfYear(n.date());
            return r = n.setYear(r, a),
            It(i - a + 1, a).map((e => {
                const t = n.format(r, "year");
                return r = n.setYear(r, n.getYear(r) + 1),
                {
                    text: t,
                    value: e
                }
            }
            ))
        }
        ));
        le(( () => {
            r.value = r.value ?? n.getYear(n.date())
        }
        ));
        const s = l();
        return ae((async () => {
            var e;
            await q(),
            null == (e = s.value) || e.$el.scrollIntoView({
                block: "center"
            })
        }
        )),
        x(( () => y("div", {
            class: "v-date-picker-years",
            style: {
                height: B(e.height)
            }
        }, [y("div", {
            class: "v-date-picker-years__content"
        }, [o.value.map(( (t, n) => {
            var o;
            const l = {
                ref: r.value === t.value ? s : void 0,
                active: r.value === t.value,
                color: r.value === t.value ? e.color : void 0,
                rounded: !0,
                text: t.text,
                variant: r.value === t.value ? "flat" : "text",
                onClick: () => {
                    r.value !== t.value ? r.value = t.value : a("update:modelValue", r.value)
                }
            };
            return (null == (o = i.year) ? void 0 : o.call(i, {
                year: t,
                i: n,
                props: l
            })) ?? y(sr, A({
                key: "month"
            }, l), null)
        }
        ))])]))),
        {}
    }
})
  , hd = _e("v-picker-title")
  , pd = d({
    bgColor: String,
    landscape: Boolean,
    title: String,
    hideHeader: Boolean,
    ...nc()
}, "VPicker")
  , vd = g()({
    name: "VPicker",
    props: pd(),
    setup(e, t) {
        let {slots: a} = t;
        const {backgroundColorClasses: i, backgroundColorStyles: n} = Mi(W(e, "color"));
        return x(( () => {
            const t = rc.filterProps(e)
              , r = !(!e.title && !a.title);
            return y(rc, A(t, {
                color: e.bgColor,
                class: ["v-picker", {
                    "v-picker--landscape": e.landscape,
                    "v-picker--with-actions": !!a.actions
                }, e.class],
                style: e.style
            }), {
                default: () => {
                    var t;
                    return [!e.hideHeader && y("div", {
                        key: "header",
                        class: [i.value],
                        style: [n.value]
                    }, [r && y(hd, {
                        key: "picker-title"
                    }, {
                        default: () => {
                            var t;
                            return [(null == (t = a.title) ? void 0 : t.call(a)) ?? e.title]
                        }
                    }), a.header && y("div", {
                        class: "v-picker__header"
                    }, [a.header()])]), y("div", {
                        class: "v-picker__body"
                    }, [null == (t = a.default) ? void 0 : t.call(a)]), a.actions && y(_i, {
                        defaults: {
                            VBtn: {
                                slim: !0,
                                variant: "text"
                            }
                        }
                    }, {
                        default: () => [y("div", {
                            class: "v-picker__actions"
                        }, [a.actions()])]
                    })]
                }
            })
        }
        )),
        {}
    }
})
  , gd = d({
    header: {
        type: String,
        default: "$vuetify.datePicker.header"
    },
    ...td(),
    ...od(),
    ...Fe(ld(), ["modelValue"]),
    ...Fe(ud(), ["modelValue"]),
    ...pd({
        title: "$vuetify.datePicker.title"
    }),
    modelValue: null
}, "VDatePicker")
  , fd = g()({
    name: "VDatePicker",
    props: gd(),
    emits: {
        "update:modelValue": e => !0,
        "update:month": e => !0,
        "update:year": e => !0,
        "update:viewMode": e => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const n = jt()
          , {t: r} = Te()
          , o = re(e, "modelValue", void 0, (e => ve(e)), (t => e.multiple ? t : t[0]))
          , s = re(e, "viewMode")
          , c = F(( () => {
            var e;
            const t = n.date(null == (e = o.value) ? void 0 : e[0]);
            return t && n.isValid(t) ? t : n.date()
        }
        ))
          , u = l(Number(e.month ?? n.getMonth(n.startOfMonth(c.value))))
          , d = l(Number(e.year ?? n.getYear(n.startOfYear(n.setMonth(c.value, u.value)))))
          , h = j(!1)
          , p = F(( () => e.multiple && o.value.length > 1 ? r("$vuetify.datePicker.itemsSelected", o.value.length) : o.value[0] && n.isValid(o.value[0]) ? n.format(o.value[0], "normalDateWithWeekday") : r(e.header)))
          , v = F(( () => n.format(n.date(new Date(d.value,u.value,1)), "monthAndYear")))
          , g = F(( () => `date-picker-header${h.value ? "-reverse" : ""}-transition`))
          , f = F(( () => {
            const t = n.date(e.min);
            return e.min && n.isValid(t) ? t : null
        }
        ))
          , m = F(( () => {
            const t = n.date(e.max);
            return e.max && n.isValid(t) ? t : null
        }
        ))
          , b = F(( () => {
            if (e.disabled)
                return !0;
            const t = [];
            if ("month" !== s.value)
                t.push("prev", "next");
            else {
                let e = n.date();
                if (e = n.setYear(e, d.value),
                e = n.setMonth(e, u.value),
                f.value) {
                    const a = n.addDays(n.startOfMonth(e), -1);
                    n.isAfter(f.value, a) && t.push("prev")
                }
                if (m.value) {
                    const a = n.addDays(n.endOfMonth(e), 1);
                    n.isAfter(a, m.value) && t.push("next")
                }
            }
            return t
        }
        ));
        function w() {
            u.value < 11 ? u.value++ : (d.value++,
            u.value = 0,
            I(d.value)),
            L(u.value)
        }
        function k() {
            u.value > 0 ? u.value-- : (d.value--,
            u.value = 11,
            I(d.value)),
            L(u.value)
        }
        function S() {
            s.value = "month"
        }
        function C() {
            s.value = "months" === s.value ? "month" : "months"
        }
        function P() {
            s.value = "year" === s.value ? "month" : "year"
        }
        function L(e) {
            "months" === s.value && C(),
            a("update:month", e)
        }
        function I(e) {
            "year" === s.value && P(),
            a("update:year", e)
        }
        return $(o, ( (e, t) => {
            const a = n.date(ve(e)[0])
              , i = n.date(ve(t)[0]);
            h.value = n.isBefore(a, i)
        }
        )),
        x(( () => {
            const t = vd.filterProps(e)
              , a = ad.filterProps(e)
              , n = nd.filterProps(e)
              , l = sd.filterProps(e)
              , c = Fe(cd.filterProps(e), ["modelValue"])
              , h = Fe(dd.filterProps(e), ["modelValue"])
              , x = {
                header: p.value,
                transition: g.value
            };
            return y(vd, A(t, {
                class: ["v-date-picker", `v-date-picker--${s.value}`, {
                    "v-date-picker--show-week": e.showWeek
                }, e.class],
                style: e.style
            }), {
                title: () => {
                    var t;
                    return (null == (t = i.title) ? void 0 : t.call(i)) ?? y("div", {
                        class: "v-date-picker__title"
                    }, [r(e.title)])
                }
                ,
                header: () => i.header ? y(_i, {
                    defaults: {
                        VDatePickerHeader: {
                            ...x
                        }
                    }
                }, {
                    default: () => {
                        var e;
                        return [null == (e = i.header) ? void 0 : e.call(i, x)]
                    }
                }) : y(nd, A({
                    key: "header"
                }, n, x, {
                    onClick: "month" !== s.value ? S : void 0
                }), {
                    ...i,
                    default: void 0
                }),
                default: () => y(Q, null, [y(ad, A(a, {
                    disabled: b.value,
                    text: v.value,
                    "onClick:next": w,
                    "onClick:prev": k,
                    "onClick:month": C,
                    "onClick:year": P
                }), null), y(fi, {
                    hideOnLeave: !0
                }, {
                    default: () => ["months" === s.value ? y(cd, A({
                        key: "date-picker-months"
                    }, c, {
                        modelValue: u.value,
                        "onUpdate:modelValue": [e => u.value = e, L],
                        min: f.value,
                        max: m.value
                    }), null) : "year" === s.value ? y(dd, A({
                        key: "date-picker-years"
                    }, h, {
                        modelValue: d.value,
                        "onUpdate:modelValue": [e => d.value = e, I],
                        min: f.value,
                        max: m.value
                    }), null) : y(sd, A({
                        key: "date-picker-month"
                    }, l, {
                        modelValue: o.value,
                        "onUpdate:modelValue": e => o.value = e,
                        month: u.value,
                        "onUpdate:month": [e => u.value = e, L],
                        year: d.value,
                        "onUpdate:year": [e => d.value = e, I],
                        min: f.value,
                        max: m.value
                    }), null)]
                })]),
                actions: i.actions
            })
        }
        )),
        {}
    }
})
  , md = Symbol.for("vuetify:v-expansion-panel")
  , bd = ["default", "accordion", "inset", "popout"]
  , xd = d({
    color: String,
    flat: Boolean,
    focusable: Boolean,
    static: Boolean,
    tile: Boolean,
    variant: {
        type: String,
        default: "default",
        validator: e => bd.includes(e)
    },
    readonly: Boolean,
    ...h(),
    ...hn(),
    ...ai(),
    ...v()
}, "VExpansionPanels")
  , yd = g()({
    name: "VExpansionPanels",
    props: xd(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        gn(e, md);
        const {themeClasses: i} = f(e)
          , n = F(( () => e.variant && `v-expansion-panels--variant-${e.variant}`));
        return V({
            VExpansionPanel: {
                color: W(e, "color"),
                readonly: W(e, "readonly")
            },
            VExpansionPanelTitle: {
                focusable: W(e, "focusable"),
                static: W(e, "static")
            }
        }),
        x(( () => y(e.tag, {
            class: ["v-expansion-panels", {
                "v-expansion-panels--flat": e.flat,
                "v-expansion-panels--tile": e.tile
            }, i.value, n.value, e.class],
            style: e.style
        }, a))),
        {}
    }
})
  , wd = d({
    ...h(),
    ...is()
}, "VExpansionPanelText")
  , kd = g()({
    name: "VExpansionPanelText",
    props: wd(),
    setup(e, t) {
        let {slots: a} = t;
        const i = de(md);
        if (!i)
            throw new Error("[Vuetify] v-expansion-panel-text needs to be placed inside v-expansion-panel");
        const {hasContent: n, onAfterLeave: r} = ns(e, i.isSelected);
        return x(( () => y(Pi, {
            onAfterLeave: r
        }, {
            default: () => {
                var t;
                return [K(y("div", {
                    class: ["v-expansion-panel-text", e.class],
                    style: e.style
                }, [a.default && n.value && y("div", {
                    class: "v-expansion-panel-text__wrapper"
                }, [null == (t = a.default) ? void 0 : t.call(a)])]), [[ee, i.isSelected.value]])]
            }
        }))),
        {}
    }
})
  , Sd = d({
    color: String,
    expandIcon: {
        type: me,
        default: "$expand"
    },
    collapseIcon: {
        type: me,
        default: "$collapse"
    },
    hideActions: Boolean,
    focusable: Boolean,
    static: Boolean,
    ripple: {
        type: [Boolean, Object],
        default: !1
    },
    readonly: Boolean,
    ...h()
}, "VExpansionPanelTitle")
  , Cd = g()({
    name: "VExpansionPanelTitle",
    directives: {
        Ripple: rr
    },
    props: Sd(),
    setup(e, t) {
        let {slots: a} = t;
        const i = de(md);
        if (!i)
            throw new Error("[Vuetify] v-expansion-panel-title needs to be placed inside v-expansion-panel");
        const {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(e, "color")
          , o = F(( () => ({
            collapseIcon: e.collapseIcon,
            disabled: i.disabled.value,
            expanded: i.isSelected.value,
            expandIcon: e.expandIcon,
            readonly: e.readonly
        })));
        return x(( () => {
            var t;
            return K(y("button", {
                class: ["v-expansion-panel-title", {
                    "v-expansion-panel-title--active": i.isSelected.value,
                    "v-expansion-panel-title--focusable": e.focusable,
                    "v-expansion-panel-title--static": e.static
                }, n.value, e.class],
                style: [r.value, e.style],
                type: "button",
                tabindex: i.disabled.value ? -1 : void 0,
                disabled: i.disabled.value,
                "aria-expanded": i.isSelected.value,
                onClick: e.readonly ? void 0 : i.toggle
            }, [y("span", {
                class: "v-expansion-panel-title__overlay"
            }, null), null == (t = a.default) ? void 0 : t.call(a, o.value), !e.hideActions && y("span", {
                class: "v-expansion-panel-title__icon"
            }, [a.actions ? a.actions(o.value) : y(Cn, {
                icon: i.isSelected.value ? e.collapseIcon : e.expandIcon
            }, null)])]), [[J("ripple"), e.ripple]])
        }
        )),
        {}
    }
})
  , Ad = d({
    title: String,
    text: String,
    bgColor: String,
    ...h(),
    ...$i(),
    ...pn(),
    ...is(),
    ...Di(),
    ...ai(),
    ...Sd()
}, "VExpansionPanel")
  , Pd = g()({
    name: "VExpansionPanel",
    props: Ad(),
    emits: {
        "group:selected": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = vn(e, md)
          , {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(e, "bgColor")
          , {elevationClasses: o} = Ui(e)
          , {roundedClasses: s} = Ri(e)
          , l = F(( () => (null == i ? void 0 : i.disabled.value) || e.disabled))
          , c = F(( () => i.group.items.value.reduce(( (e, t, a) => (i.group.selected.value.includes(t.id) && e.push(a),
        e)), [])))
          , u = F(( () => {
            const e = i.group.items.value.findIndex((e => e.id === i.id));
            return !i.isSelected.value && c.value.some((t => t - e == 1))
        }
        ))
          , d = F(( () => {
            const e = i.group.items.value.findIndex((e => e.id === i.id));
            return !i.isSelected.value && c.value.some((t => t - e == -1))
        }
        ));
        return ue(md, i),
        V({
            VExpansionPanelText: {
                eager: W(e, "eager")
            },
            VExpansionPanelTitle: {
                readonly: W(e, "readonly")
            }
        }),
        x(( () => {
            const t = !(!a.text && !e.text)
              , c = !(!a.title && !e.title);
            return y(e.tag, {
                class: ["v-expansion-panel", {
                    "v-expansion-panel--active": i.isSelected.value,
                    "v-expansion-panel--before-active": u.value,
                    "v-expansion-panel--after-active": d.value,
                    "v-expansion-panel--disabled": l.value
                }, s.value, n.value, e.class],
                style: [r.value, e.style]
            }, {
                default: () => {
                    var i;
                    return [y("div", {
                        class: ["v-expansion-panel__shadow", ...o.value]
                    }, null), c && y(Cd, {
                        key: "title",
                        collapseIcon: e.collapseIcon,
                        color: e.color,
                        expandIcon: e.expandIcon,
                        hideActions: e.hideActions,
                        ripple: e.ripple
                    }, {
                        default: () => [a.title ? a.title() : e.title]
                    }), t && y(kd, {
                        key: "text"
                    }, {
                        default: () => [a.text ? a.text() : e.text]
                    }), null == (i = a.default) ? void 0 : i.call(a)]
                }
            })
        }
        )),
        {}
    }
})
  , Ld = d({
    chips: Boolean,
    counter: Boolean,
    counterSizeString: {
        type: String,
        default: "$vuetify.fileInput.counterSize"
    },
    counterString: {
        type: String,
        default: "$vuetify.fileInput.counter"
    },
    multiple: Boolean,
    showSize: {
        type: [Boolean, Number, String],
        default: !1,
        validator: e => "boolean" == typeof e || [1e3, 1024].includes(Number(e))
    },
    ...Dr({
        prependIcon: "$file"
    }),
    modelValue: {
        type: Array,
        default: () => [],
        validator: e => ve(e).every((e => null != e && "object" == typeof e))
    },
    ...Ps({
        clearable: !0
    })
}, "VFileInput")
  , Id = g()({
    name: "VFileInput",
    inheritAttrs: !1,
    props: Ld(),
    emits: {
        "click:control": e => !0,
        "mousedown:control": e => !0,
        "update:focused": e => !0,
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const {t: r} = Te()
          , o = re(e, "modelValue")
          , {isFocused: s, focus: c, blur: u} = Er(e)
          , d = F(( () => "boolean" != typeof e.showSize ? e.showSize : void 0))
          , h = F(( () => (o.value ?? []).reduce(( (e, t) => {
            let {size: a=0} = t;
            return e + a
        }
        ), 0)))
          , p = F(( () => Ut(h.value, d.value)))
          , v = F(( () => (o.value ?? []).map((t => {
            const {name: a="", size: i=0} = t;
            return e.showSize ? `${a} (${Ut(i, d.value)})` : a
        }
        ))))
          , g = F(( () => {
            var t;
            const a = (null == (t = o.value) ? void 0 : t.length) ?? 0;
            return e.showSize ? r(e.counterSizeString, a, p.value) : r(e.counterString, a)
        }
        ))
          , f = l()
          , m = l()
          , b = l()
          , w = F(( () => s.value || e.active))
          , k = F(( () => ["plain", "underlined"].includes(e.variant)));
        function S() {
            var e;
            b.value !== document.activeElement && (null == (e = b.value) || e.focus()),
            s.value || c()
        }
        function C(e) {
            var t;
            null == (t = b.value) || t.click()
        }
        function P(e) {
            i("mousedown:control", e)
        }
        function L(e) {
            var t;
            null == (t = b.value) || t.click(),
            i("click:control", e)
        }
        function I(t) {
            t.stopPropagation(),
            S(),
            q(( () => {
                o.value = [],
                dt(e["onClick:clear"], t)
            }
            ))
        }
        return $(o, (e => {
            (!Array.isArray(e) || !e.length) && b.value && (b.value.value = "")
        }
        )),
        x(( () => {
            const t = !(!n.counter && !e.counter)
              , i = !(!t && !n.details)
              , [r,l] = Oe(a)
              , {modelValue: c, ...d} = Rr.filterProps(e)
              , x = Is(e);
            return y(Rr, A({
                ref: f,
                modelValue: o.value,
                "onUpdate:modelValue": e => o.value = e,
                class: ["v-file-input", {
                    "v-file-input--chips": !!e.chips,
                    "v-input--plain-underlined": k.value
                }, e.class],
                style: e.style,
                "onClick:prepend": C
            }, r, d, {
                centerAffix: !k.value,
                focused: s.value
            }), {
                ...n,
                default: t => {
                    let {id: a, isDisabled: i, isDirty: r, isReadonly: c, isValid: d} = t;
                    return y(Ls, A({
                        ref: m,
                        "prepend-icon": e.prependIcon,
                        onMousedown: P,
                        onClick: L,
                        "onClick:clear": I,
                        "onClick:prependInner": e["onClick:prependInner"],
                        "onClick:appendInner": e["onClick:appendInner"]
                    }, x, {
                        id: a.value,
                        active: w.value || r.value,
                        dirty: r.value,
                        disabled: i.value,
                        focused: s.value,
                        error: !1 === d.value
                    }), {
                        ...n,
                        default: t => {
                            var a;
                            let {props: {class: r, ...s}} = t;
                            return y(Q, null, [y("input", A({
                                ref: b,
                                type: "file",
                                readonly: c.value,
                                disabled: i.value,
                                multiple: e.multiple,
                                name: e.name,
                                onClick: e => {
                                    e.stopPropagation(),
                                    c.value && e.preventDefault(),
                                    S()
                                }
                                ,
                                onChange: e => {
                                    if (!e.target)
                                        return;
                                    const t = e.target;
                                    o.value = [...t.files ?? []]
                                }
                                ,
                                onFocus: S,
                                onBlur: u
                            }, s, l), null), y("div", {
                                class: r
                            }, [!!(null == (a = o.value) ? void 0 : a.length) && (n.selection ? n.selection({
                                fileNames: v.value,
                                totalBytes: h.value,
                                totalBytesReadable: p.value
                            }) : e.chips ? v.value.map((t => y(Zr, {
                                key: t,
                                size: "small",
                                color: e.color
                            }, {
                                default: () => [t]
                            }))) : v.value.join(", "))])])
                        }
                    })
                }
                ,
                details: i ? e => {
                    var a, i;
                    return y(Q, null, [null == (a = n.details) ? void 0 : a.call(n, e), t && y(Q, null, [y("span", null, null), y(ks, {
                        active: !!(null == (i = o.value) ? void 0 : i.length),
                        value: g.value
                    }, n.counter)])])
                }
                : void 0
            })
        }
        )),
        bs({}, f, m, b)
    }
})
  , _d = d({
    app: Boolean,
    color: String,
    height: {
        type: [Number, String],
        default: "auto"
    },
    ...Gi(),
    ...h(),
    ...$i(),
    ...ne(),
    ...Di(),
    ...ai({
        tag: "footer"
    }),
    ...v()
}, "VFooter")
  , Td = g()({
    name: "VFooter",
    props: _d(),
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(W(e, "color"))
          , {borderClasses: o} = ji(e)
          , {elevationClasses: s} = Ui(e)
          , {roundedClasses: l} = Ri(e)
          , c = j(32)
          , {resizeRef: u} = we((e => {
            e.length && (c.value = e[0].target.clientHeight)
        }
        ))
          , d = F(( () => "auto" === e.height ? c.value : parseInt(e.height, 10)))
          , {layoutItemStyles: h} = se({
            id: e.name,
            order: F(( () => parseInt(e.order, 10))),
            position: F(( () => "bottom")),
            layoutSize: d,
            elementSize: F(( () => "auto" === e.height ? void 0 : d.value)),
            active: F(( () => e.app)),
            absolute: W(e, "absolute")
        });
        return x(( () => y(e.tag, {
            ref: u,
            class: ["v-footer", i.value, n.value, o.value, s.value, l.value, e.class],
            style: [r.value, e.app ? h.value : {
                height: B(e.height)
            }, e.style]
        }, a))),
        {}
    }
})
  , Ed = d({
    ...h(),
    ...Vr()
}, "VForm")
  , Od = g()({
    name: "VForm",
    props: Ed(),
    emits: {
        "update:modelValue": e => !0,
        submit: e => !0
    },
    setup(e, t) {
        let {slots: a, emit: i} = t;
        const n = function(e) {
            const t = re(e, "modelValue")
              , a = F(( () => e.disabled))
              , i = F(( () => e.readonly))
              , n = j(!1)
              , r = l([])
              , o = l([]);
            return $(r, ( () => {
                let e = 0
                  , a = 0;
                const i = [];
                for (const t of r.value)
                    !1 === t.isValid ? (a++,
                    i.push({
                        id: t.id,
                        errorMessages: t.errorMessages
                    })) : !0 === t.isValid && e++;
                o.value = i,
                t.value = !(a > 0) && (e === r.value.length || null)
            }
            ), {
                deep: !0,
                flush: "post"
            }),
            ue(Or, {
                register: e => {
                    let {id: t, validate: a, reset: i, resetValidation: n} = e;
                    r.value.some((e => e.id === t)),
                    r.value.push({
                        id: t,
                        validate: a,
                        reset: i,
                        resetValidation: n,
                        isValid: null,
                        errorMessages: []
                    })
                }
                ,
                unregister: e => {
                    r.value = r.value.filter((t => t.id !== e))
                }
                ,
                update: (e, t, a) => {
                    const i = r.value.find((t => t.id === e));
                    i && (i.isValid = t,
                    i.errorMessages = a)
                }
                ,
                isDisabled: a,
                isReadonly: i,
                isValidating: n,
                isValid: t,
                items: r,
                validateOn: W(e, "validateOn")
            }),
            {
                errors: o,
                isDisabled: a,
                isReadonly: i,
                isValidating: n,
                isValid: t,
                items: r,
                validate: async function() {
                    const t = [];
                    let a = !0;
                    o.value = [],
                    n.value = !0;
                    for (const i of r.value) {
                        const n = await i.validate();
                        if (n.length > 0 && (a = !1,
                        t.push({
                            id: i.id,
                            errorMessages: n
                        })),
                        !a && e.fastFail)
                            break
                    }
                    return o.value = t,
                    n.value = !1,
                    {
                        valid: a,
                        errors: o.value
                    }
                },
                reset: function() {
                    r.value.forEach((e => e.reset()))
                },
                resetValidation: function() {
                    r.value.forEach((e => e.resetValidation()))
                }
            }
        }(e)
          , r = l();
        function o(e) {
            e.preventDefault(),
            n.reset()
        }
        function s(e) {
            const t = e
              , a = n.validate();
            t.then = a.then.bind(a),
            t.catch = a.catch.bind(a),
            t.finally = a.finally.bind(a),
            i("submit", t),
            t.defaultPrevented || a.then((e => {
                var t;
                let {valid: a} = e;
                a && (null == (t = r.value) || t.submit())
            }
            )),
            t.preventDefault()
        }
        return x(( () => {
            var t;
            return y("form", {
                ref: r,
                class: ["v-form", e.class],
                style: e.style,
                novalidate: !0,
                onReset: o,
                onSubmit: s
            }, [null == (t = a.default) ? void 0 : t.call(a, n)])
        }
        )),
        bs(n, r)
    }
})
  , Vd = d({
    disabled: Boolean,
    modelValue: {
        type: Boolean,
        default: void 0
    },
    ...Ko()
}, "VHover")
  , Fd = g()({
    name: "VHover",
    props: Vd(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , {runOpenDelay: n, runCloseDelay: r} = Jo(e, (t => !e.disabled && (i.value = t)));
        return () => {
            var e;
            return null == (e = a.default) ? void 0 : e.call(a, {
                isHovering: i.value,
                props: {
                    onMouseenter: n,
                    onMouseleave: r
                }
            })
        }
    }
})
  , Bd = d({
    color: String,
    direction: {
        type: String,
        default: "vertical",
        validator: e => ["vertical", "horizontal"].includes(e)
    },
    side: {
        type: String,
        default: "end",
        validator: e => ["start", "end", "both"].includes(e)
    },
    mode: {
        type: String,
        default: "intersect",
        validator: e => ["intersect", "manual"].includes(e)
    },
    margin: [Number, String],
    loadMoreText: {
        type: String,
        default: "$vuetify.infiniteScroll.loadMore"
    },
    emptyText: {
        type: String,
        default: "$vuetify.infiniteScroll.empty"
    },
    ...Ti(),
    ...ai()
}, "VInfiniteScroll")
  , Md = Ne({
    name: "VInfiniteScrollIntersect",
    props: {
        side: {
            type: String,
            required: !0
        },
        rootRef: null,
        rootMargin: String
    },
    emits: {
        intersect: (e, t) => !0
    },
    setup(e, t) {
        let {emit: a} = t;
        const {intersectionRef: i, isIntersecting: n} = An((e => {}
        ), e.rootMargin ? {
            rootMargin: e.rootMargin
        } : void 0);
        return $(n, (async t => {
            a("intersect", e.side, t)
        }
        )),
        x(( () => y("div", {
            class: "v-infinite-scroll-intersect",
            ref: i
        }, [vt("")]))),
        {}
    }
})
  , Dd = g()({
    name: "VInfiniteScroll",
    props: Bd(),
    emits: {
        load: e => !0
    },
    setup(e, t) {
        let {slots: a, emit: i} = t;
        const n = l()
          , r = j("ok")
          , o = j("ok")
          , s = F(( () => B(e.margin)))
          , c = j(!1);
        function u(t) {
            if (!n.value)
                return;
            const a = "vertical" === e.direction ? "scrollTop" : "scrollLeft";
            n.value[a] = t
        }
        function d() {
            if (!n.value)
                return 0;
            const t = "vertical" === e.direction ? "scrollHeight" : "scrollWidth";
            return n.value[t]
        }
        function h(e, t) {
            "start" === e ? r.value = t : "end" === e && (o.value = t)
        }
        ae(( () => {
            n.value && ("start" === e.side ? u(d()) : "both" === e.side && u(d() / 2 - function() {
                if (!n.value)
                    return 0;
                const t = "vertical" === e.direction ? "clientHeight" : "clientWidth";
                return n.value[t]
            }() / 2))
        }
        ));
        let p = 0;
        function v(e, t) {
            c.value = t,
            c.value && g(e)
        }
        function g(t) {
            if ("manual" !== e.mode && !c.value)
                return;
            const a = function(e) {
                return "start" === e ? r.value : o.value
            }(t);
            n.value && "loading" !== a && (p = d(),
            h(t, "loading"),
            i("load", {
                side: t,
                done: function(a) {
                    h(t, a),
                    q(( () => {
                        "empty" !== a && "error" !== a && ("ok" === a && "start" === t && u(d() - p + function() {
                            if (!n.value)
                                return 0;
                            const t = "vertical" === e.direction ? "scrollTop" : "scrollLeft";
                            return n.value[t]
                        }()),
                        "manual" !== e.mode && q(( () => {
                            window.requestAnimationFrame(( () => {
                                window.requestAnimationFrame(( () => {
                                    window.requestAnimationFrame(( () => {
                                        g(t)
                                    }
                                    ))
                                }
                                ))
                            }
                            ))
                        }
                        )))
                    }
                    ))
                }
            }))
        }
        const {t: f} = Te();
        function m(t, i) {
            var n, r, o, s, l;
            if (e.side !== t && "both" !== e.side)
                return;
            const c = () => g(t)
              , u = {
                side: t,
                props: {
                    onClick: c,
                    color: e.color
                }
            };
            return "error" === i ? null == (n = a.error) ? void 0 : n.call(a, u) : "empty" === i ? (null == (r = a.empty) ? void 0 : r.call(a, u)) ?? y("div", null, [f(e.emptyText)]) : "manual" === e.mode ? "loading" === i ? (null == (o = a.loading) ? void 0 : o.call(a, u)) ?? y(Ln, {
                indeterminate: !0,
                color: e.color
            }, null) : (null == (s = a["load-more"]) ? void 0 : s.call(a, u)) ?? y(sr, {
                variant: "outlined",
                color: e.color,
                onClick: c
            }, {
                default: () => [f(e.loadMoreText)]
            }) : (null == (l = a.loading) ? void 0 : l.call(a, u)) ?? y(Ln, {
                indeterminate: !0,
                color: e.color
            }, null)
        }
        const {dimensionStyles: b} = Ei(e);
        x(( () => {
            const t = e.tag
              , i = "start" === e.side || "both" === e.side
              , l = "end" === e.side || "both" === e.side
              , c = "intersect" === e.mode;
            return y(t, {
                ref: n,
                class: ["v-infinite-scroll", `v-infinite-scroll--${e.direction}`, {
                    "v-infinite-scroll--start": i,
                    "v-infinite-scroll--end": l
                }],
                style: b.value
            }, {
                default: () => {
                    var e;
                    return [y("div", {
                        class: "v-infinite-scroll__side"
                    }, [m("start", r.value)]), n.value && i && c && y(Md, {
                        key: "start",
                        side: "start",
                        onIntersect: v,
                        rootRef: n.value,
                        rootMargin: s.value
                    }, null), null == (e = a.default) ? void 0 : e.call(a), n.value && l && c && y(Md, {
                        key: "end",
                        side: "end",
                        onIntersect: v,
                        rootRef: n.value,
                        rootMargin: s.value
                    }, null), y("div", {
                        class: "v-infinite-scroll__side"
                    }, [m("end", o.value)])]
                }
            })
        }
        ))
    }
})
  , Rd = Symbol.for("vuetify:v-item-group")
  , Nd = d({
    ...h(),
    ...hn({
        selectedClass: "v-item--selected"
    }),
    ...ai(),
    ...v()
}, "VItemGroup")
  , zd = g()({
    name: "VItemGroup",
    props: Nd(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {isSelected: n, select: r, next: o, prev: s, selected: l} = gn(e, Rd);
        return () => y(e.tag, {
            class: ["v-item-group", i.value, e.class],
            style: e.style
        }, {
            default: () => {
                var e;
                return [null == (e = a.default) ? void 0 : e.call(a, {
                    isSelected: n,
                    select: r,
                    next: o,
                    prev: s,
                    selected: l.value
                })]
            }
        })
    }
})
  , Hd = g()({
    name: "VItem",
    props: pn(),
    emits: {
        "group:selected": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {isSelected: i, select: n, toggle: r, selectedClass: o, value: s, disabled: l} = vn(e, Rd);
        return () => {
            var e;
            return null == (e = a.default) ? void 0 : e.call(a, {
                isSelected: i.value,
                selectedClass: o.value,
                select: n,
                toggle: r,
                value: s.value,
                disabled: l.value
            })
        }
    }
})
  , Xd = _e("v-kbd")
  , Yd = d({
    ...h(),
    ...p()
}, "VLayout")
  , Wd = g()({
    name: "VLayout",
    props: Yd(),
    setup(e, t) {
        let {slots: a} = t;
        const {layoutClasses: i, layoutStyles: n, getLayoutItem: r, items: o, layoutRef: s} = m(e);
        return x(( () => {
            var t;
            return y("div", {
                ref: s,
                class: [i.value, e.class],
                style: [n.value, e.style]
            }, [null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {
            getLayoutItem: r,
            items: o
        }
    }
})
  , Gd = d({
    position: {
        type: String,
        required: !0
    },
    size: {
        type: [Number, String],
        default: 300
    },
    modelValue: Boolean,
    ...h(),
    ...ne()
}, "VLayoutItem")
  , jd = g()({
    name: "VLayoutItem",
    props: Gd(),
    setup(e, t) {
        let {slots: a} = t;
        const {layoutItemStyles: i} = se({
            id: e.name,
            order: F(( () => parseInt(e.order, 10))),
            position: W(e, "position"),
            elementSize: W(e, "size"),
            layoutSize: W(e, "size"),
            active: W(e, "modelValue"),
            absolute: W(e, "absolute")
        });
        return () => {
            var t;
            return y("div", {
                class: ["v-layout-item", e.class],
                style: [i.value, e.style]
            }, [null == (t = a.default) ? void 0 : t.call(a)])
        }
    }
})
  , $d = d({
    modelValue: Boolean,
    options: {
        type: Object,
        default: () => ({
            root: void 0,
            rootMargin: void 0,
            threshold: void 0
        })
    },
    ...h(),
    ...Ti(),
    ...ai(),
    ...Ni({
        transition: "fade-transition"
    })
}, "VLazy")
  , Ud = g()({
    name: "VLazy",
    directives: {
        intersect: Xi
    },
    props: $d(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {dimensionStyles: i} = Ei(e)
          , n = re(e, "modelValue");
        function r(e) {
            n.value || (n.value = e)
        }
        return x(( () => K(y(e.tag, {
            class: ["v-lazy", e.class],
            style: [i.value, e.style]
        }, {
            default: () => [n.value && y(zi, {
                transition: e.transition,
                appear: !0
            }, {
                default: () => {
                    var e;
                    return [null == (e = a.default) ? void 0 : e.call(a)]
                }
            })]
        }), [[J("intersect"), {
            handler: r,
            options: e.options
        }, null]]))),
        {}
    }
})
  , qd = d({
    locale: String,
    fallbackLocale: String,
    messages: Object,
    rtl: {
        type: Boolean,
        default: void 0
    },
    ...h()
}, "VLocaleProvider")
  , Zd = g()({
    name: "VLocaleProvider",
    props: qd(),
    setup(e, t) {
        let {slots: a} = t;
        const {rtlClasses: i} = qt(e);
        return x(( () => {
            var t;
            return y("div", {
                class: ["v-locale-provider", i.value, e.class],
                style: e.style
            }, [null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {}
    }
})
  , Kd = d({
    scrollable: Boolean,
    ...h(),
    ...ai({
        tag: "main"
    })
}, "VMain")
  , Jd = g()({
    name: "VMain",
    props: Kd(),
    setup(e, t) {
        let {slots: a} = t;
        const {mainStyles: i} = Zt()
          , {ssrBootStyles: n} = Qi();
        return x(( () => y(e.tag, {
            class: ["v-main", {
                "v-main--scrollable": e.scrollable
            }, e.class],
            style: [i.value, n.value, e.style]
        }, {
            default: () => {
                var t, i;
                return [e.scrollable ? y("div", {
                    class: "v-main__scroller"
                }, [null == (t = a.default) ? void 0 : t.call(a)]) : null == (i = a.default) ? void 0 : i.call(a)]
            }
        }))),
        {}
    }
});
function Qd(e) {
    return (e < 0 ? -1 : 1) * Math.sqrt(Math.abs(e)) * 1.41421356237
}
function eh(e) {
    if (e.length < 2)
        return 0;
    if (2 === e.length)
        return e[1].t === e[0].t ? 0 : (e[1].d - e[0].d) / (e[1].t - e[0].t);
    let t = 0;
    for (let a = e.length - 1; a > 0; a--) {
        if (e[a].t === e[a - 1].t)
            continue;
        const i = Qd(t)
          , n = (e[a].d - e[a - 1].d) / (e[a].t - e[a - 1].t);
        t += (n - i) * Math.abs(n),
        a === e.length - 1 && (t *= .5)
    }
    return 1e3 * Qd(t)
}
function th() {
    const e = {};
    return {
        addMovement: function(t) {
            Array.from(t.changedTouches).forEach((a => {
                (e[a.identifier] ?? (e[a.identifier] = new Kt(20))).push([t.timeStamp, a])
            }
            ))
        },
        endTouch: function(t) {
            Array.from(t.changedTouches).forEach((t => {
                delete e[t.identifier]
            }
            ))
        },
        getVelocity: function(t) {
            var a;
            const i = null == (a = e[t]) ? void 0 : a.values().reverse();
            if (!i)
                throw new Error(`No samples for touch id ${t}`);
            const n = i[0]
              , r = []
              , o = [];
            for (const e of i) {
                if (n[0] - e[0] > 100)
                    break;
                r.push({
                    t: e[0],
                    d: e[1].clientX
                }),
                o.push({
                    t: e[0],
                    d: e[1].clientY
                })
            }
            return {
                x: eh(r),
                y: eh(o),
                get direction() {
                    const {x: e, y: t} = this
                      , [a,i] = [Math.abs(e), Math.abs(t)];
                    return a > i && e >= 0 ? "right" : a > i && e <= 0 ? "left" : i > a && t >= 0 ? "down" : i > a && t <= 0 ? "up" : function() {
                        throw new Error
                    }()
                }
            }
        }
    }
}
function ah() {
    throw new Error
}
const ih = ["start", "end", "left", "right", "top", "bottom"]
  , nh = d({
    color: String,
    disableResizeWatcher: Boolean,
    disableRouteWatcher: Boolean,
    expandOnHover: Boolean,
    floating: Boolean,
    modelValue: {
        type: Boolean,
        default: null
    },
    permanent: Boolean,
    rail: {
        type: Boolean,
        default: null
    },
    railWidth: {
        type: [Number, String],
        default: 56
    },
    scrim: {
        type: [Boolean, String],
        default: !0
    },
    image: String,
    temporary: Boolean,
    touchless: Boolean,
    width: {
        type: [Number, String],
        default: 256
    },
    location: {
        type: String,
        default: "start",
        validator: e => ih.includes(e)
    },
    sticky: Boolean,
    ...Gi(),
    ...h(),
    ...Be(),
    ...$i(),
    ...ne(),
    ...Di(),
    ...ai({
        tag: "nav"
    }),
    ...v()
}, "VNavigationDrawer")
  , rh = g()({
    name: "VNavigationDrawer",
    props: nh(),
    emits: {
        "update:modelValue": e => !0,
        "update:rail": e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const {isRtl: r} = b()
          , {themeClasses: o} = f(e)
          , {borderClasses: s} = ji(e)
          , {backgroundColorClasses: c, backgroundColorStyles: u} = Mi(W(e, "color"))
          , {elevationClasses: d} = Ui(e)
          , {displayClasses: h, mobile: p} = Me(e)
          , {roundedClasses: v} = Ri(e)
          , g = Nn()
          , m = re(e, "modelValue", null, (e => !!e))
          , {ssrBootStyles: w} = Qi()
          , {scopeId: S} = rs()
          , C = l()
          , P = j(!1)
          , L = F(( () => e.rail && e.expandOnHover && P.value ? Number(e.width) : Number(e.rail ? e.railWidth : e.width)))
          , I = F(( () => Jt(e.location, r.value)))
          , _ = F(( () => !e.permanent && (p.value || e.temporary)))
          , T = F(( () => e.sticky && !_.value && "bottom" !== I.value));
        oe(( () => e.expandOnHover && null != e.rail), ( () => {
            $(P, (e => i("update:rail", !e)))
        }
        )),
        oe(( () => !e.disableResizeWatcher), ( () => {
            $(_, (t => !e.permanent && q(( () => m.value = !t))))
        }
        )),
        oe(( () => !e.disableRouteWatcher && !!g), ( () => {
            $(g.currentRoute, ( () => _.value && (m.value = !1)))
        }
        )),
        $(( () => e.permanent), (e => {
            e && (m.value = !0)
        }
        )),
        U(( () => {
            null != e.modelValue || _.value || (m.value = e.permanent || !p.value)
        }
        ));
        const {isDragging: E, dragProgress: O, dragStyles: M} = function(e) {
            let {isActive: t, isTemporary: a, width: i, touchless: n, position: r} = e;
            ae(( () => {
                window.addEventListener("touchstart", m, {
                    passive: !0
                }),
                window.addEventListener("touchmove", b, {
                    passive: !1
                }),
                window.addEventListener("touchend", x, {
                    passive: !0
                })
            }
            )),
            Z(( () => {
                window.removeEventListener("touchstart", m),
                window.removeEventListener("touchmove", b),
                window.removeEventListener("touchend", x)
            }
            ));
            const o = F(( () => ["left", "right"].includes(r.value)))
              , {addMovement: s, endTouch: l, getVelocity: c} = th();
            let u = !1;
            const d = j(!1)
              , h = j(0)
              , p = j(0);
            let v;
            function g(e, t) {
                return ("left" === r.value ? e : "right" === r.value ? document.documentElement.clientWidth - e : "top" === r.value ? e : "bottom" === r.value ? document.documentElement.clientHeight - e : ah()) - (t ? i.value : 0)
            }
            function f(e) {
                let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                const a = "left" === r.value ? (e - p.value) / i.value : "right" === r.value ? (document.documentElement.clientWidth - e - p.value) / i.value : "top" === r.value ? (e - p.value) / i.value : "bottom" === r.value ? (document.documentElement.clientHeight - e - p.value) / i.value : ah();
                return t ? Math.max(0, Math.min(1, a)) : a
            }
            function m(e) {
                if (n.value)
                    return;
                const c = e.changedTouches[0].clientX
                  , d = e.changedTouches[0].clientY
                  , m = "left" === r.value ? c < 25 : "right" === r.value ? c > document.documentElement.clientWidth - 25 : "top" === r.value ? d < 25 : "bottom" === r.value ? d > document.documentElement.clientHeight - 25 : ah()
                  , b = t.value && ("left" === r.value ? c < i.value : "right" === r.value ? c > document.documentElement.clientWidth - i.value : "top" === r.value ? d < i.value : "bottom" === r.value ? d > document.documentElement.clientHeight - i.value : ah());
                (m || b || t.value && a.value) && (u = !0,
                v = [c, d],
                p.value = g(o.value ? c : d, t.value),
                h.value = f(o.value ? c : d),
                l(e),
                s(e))
            }
            function b(e) {
                const t = e.changedTouches[0].clientX
                  , a = e.changedTouches[0].clientY;
                if (u) {
                    if (!e.cancelable)
                        return void (u = !1);
                    const i = Math.abs(t - v[0])
                      , n = Math.abs(a - v[1]);
                    (o.value ? i > n && i > 3 : n > i && n > 3) ? (d.value = !0,
                    u = !1) : (o.value ? n : i) > 3 && (u = !1)
                }
                if (!d.value)
                    return;
                e.preventDefault(),
                s(e);
                const i = f(o.value ? t : a, !1);
                h.value = Math.max(0, Math.min(1, i)),
                i > 1 ? p.value = g(o.value ? t : a, !0) : i < 0 && (p.value = g(o.value ? t : a, !1))
            }
            function x(e) {
                if (u = !1,
                !d.value)
                    return;
                s(e),
                d.value = !1;
                const a = c(e.changedTouches[0].identifier)
                  , i = Math.abs(a.x)
                  , n = Math.abs(a.y)
                  , l = o.value ? i > n && i > 400 : n > i && n > 3;
                t.value = l ? a.direction === ({
                    left: "right",
                    right: "left",
                    top: "down",
                    bottom: "up"
                }[r.value] || ah()) : h.value > .5
            }
            const y = F(( () => d.value ? {
                transform: "left" === r.value ? `translateX(calc(-100% + ${h.value * i.value}px))` : "right" === r.value ? `translateX(calc(100% - ${h.value * i.value}px))` : "top" === r.value ? `translateY(calc(-100% + ${h.value * i.value}px))` : "bottom" === r.value ? `translateY(calc(100% - ${h.value * i.value}px))` : ah(),
                transition: "none"
            } : void 0));
            return {
                isDragging: d,
                dragProgress: h,
                dragStyles: y
            }
        }({
            isActive: m,
            isTemporary: _,
            width: L,
            touchless: W(e, "touchless"),
            position: I
        })
          , D = F(( () => {
            const t = _.value ? 0 : e.rail && e.expandOnHover ? Number(e.railWidth) : L.value;
            return E.value ? t * O.value : t
        }
        ))
          , {layoutItemStyles: R, layoutItemScrimStyles: N} = se({
            id: e.name,
            order: F(( () => parseInt(e.order, 10))),
            position: I,
            layoutSize: D,
            elementSize: L,
            active: F(( () => m.value || E.value)),
            disableTransitions: F(( () => E.value)),
            absolute: F(( () => e.absolute || T.value && "string" != typeof z.value))
        })
          , {isStuck: z, stickyStyles: H} = function(e) {
            let {rootEl: t, isSticky: a, layoutItemStyles: i} = e;
            const n = j(!1)
              , r = j(0)
              , o = F(( () => {
                const e = "boolean" == typeof n.value ? "top" : n.value;
                return [a.value ? {
                    top: "auto",
                    bottom: "auto",
                    height: void 0
                } : void 0, n.value ? {
                    [e]: B(r.value)
                } : {
                    top: i.value.top
                }]
            }
            ));
            ae(( () => {
                $(a, (e => {
                    e ? window.addEventListener("scroll", l, {
                        passive: !0
                    }) : window.removeEventListener("scroll", l)
                }
                ), {
                    immediate: !0
                })
            }
            )),
            Z(( () => {
                window.removeEventListener("scroll", l)
            }
            ));
            let s = 0;
            function l() {
                const e = s > window.scrollY ? "up" : "down"
                  , a = t.value.getBoundingClientRect()
                  , o = parseFloat(i.value.top ?? 0)
                  , l = window.scrollY - Math.max(0, r.value - o)
                  , c = a.height + Math.max(r.value, o) - window.scrollY - window.innerHeight
                  , u = parseFloat(getComputedStyle(t.value).getPropertyValue("--v-body-scroll-y")) || 0;
                a.height < window.innerHeight - o ? (n.value = "top",
                r.value = o) : "up" === e && "bottom" === n.value || "down" === e && "top" === n.value ? (r.value = window.scrollY + a.top - u,
                n.value = !0) : "down" === e && c <= 0 ? (r.value = 0,
                n.value = "bottom") : "up" === e && l <= 0 && (u ? "top" !== n.value && (r.value = -l + u + o,
                n.value = "top") : (r.value = a.top + l,
                n.value = "top")),
                s = window.scrollY
            }
            return {
                isStuck: n,
                stickyStyles: o
            }
        }({
            rootEl: C,
            isSticky: T,
            layoutItemStyles: R
        })
          , X = Mi(F(( () => "string" == typeof e.scrim ? e.scrim : null)))
          , Y = F(( () => ({
            ...E.value ? {
                opacity: .2 * O.value,
                transition: "none"
            } : void 0,
            ...N.value
        })));
        function G() {
            P.value = !0
        }
        function K() {
            P.value = !1
        }
        return V({
            VList: {
                bgColor: "transparent"
            }
        }),
        x(( () => {
            const t = n.image || e.image;
            return y(Q, null, [y(e.tag, A({
                ref: C,
                onMouseenter: G,
                onMouseleave: K,
                class: ["v-navigation-drawer", `v-navigation-drawer--${I.value}`, {
                    "v-navigation-drawer--expand-on-hover": e.expandOnHover,
                    "v-navigation-drawer--floating": e.floating,
                    "v-navigation-drawer--is-hovering": P.value,
                    "v-navigation-drawer--rail": e.rail,
                    "v-navigation-drawer--temporary": _.value,
                    "v-navigation-drawer--active": m.value,
                    "v-navigation-drawer--sticky": T.value
                }, o.value, c.value, s.value, h.value, d.value, v.value, e.class],
                style: [u.value, R.value, M.value, w.value, H.value, e.style]
            }, S, a), {
                default: () => {
                    var a, i, r, o;
                    return [t && y("div", {
                        key: "image",
                        class: "v-navigation-drawer__img"
                    }, [n.image ? null == (a = n.image) ? void 0 : a.call(n, {
                        image: e.image
                    }) : y("img", {
                        src: e.image,
                        alt: ""
                    }, null)]), n.prepend && y("div", {
                        class: "v-navigation-drawer__prepend"
                    }, [null == (i = n.prepend) ? void 0 : i.call(n)]), y("div", {
                        class: "v-navigation-drawer__content"
                    }, [null == (r = n.default) ? void 0 : r.call(n)]), n.append && y("div", {
                        class: "v-navigation-drawer__append"
                    }, [null == (o = n.append) ? void 0 : o.call(n)])]
                }
            }), y(k, {
                name: "fade-transition"
            }, {
                default: () => [_.value && (E.value || m.value) && !!e.scrim && y("div", A({
                    class: ["v-navigation-drawer__scrim", X.backgroundColorClasses.value],
                    style: [Y.value, X.backgroundColorStyles.value],
                    onClick: () => m.value = !1
                }, S), null)]
            })])
        }
        )),
        {
            isStuck: z
        }
    }
})
  , oh = Ne({
    name: "VNoSsr",
    setup(e, t) {
        let {slots: a} = t;
        const i = as();
        return () => {
            var e;
            return i.value && (null == (e = a.default) ? void 0 : e.call(a))
        }
    }
})
  , sh = d({
    autofocus: Boolean,
    divider: String,
    focusAll: Boolean,
    label: {
        type: String,
        default: "$vuetify.input.otp"
    },
    length: {
        type: [Number, String],
        default: 6
    },
    modelValue: {
        type: [Number, String],
        default: void 0
    },
    placeholder: String,
    type: {
        type: String,
        default: "number"
    },
    ...Ti(),
    ...Tr(),
    ...Qt(Ps({
        variant: "outlined"
    }), ["baseColor", "bgColor", "class", "color", "disabled", "error", "loading", "rounded", "style", "theme", "variant"])
}, "VOtpInput")
  , lh = g()({
    name: "VOtpInput",
    props: sh(),
    emits: {
        finish: e => !0,
        "update:focused": e => !0,
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const {dimensionStyles: r} = Ei(e)
          , {isFocused: o, focus: s, blur: c} = Er(e)
          , u = re(e, "modelValue", "", (e => String(e).split("")), (e => e.join("")))
          , {t: d} = Te()
          , h = F(( () => Number(e.length)))
          , p = F(( () => Array(h.value).fill(0)))
          , v = l(-1)
          , g = l()
          , f = l([])
          , m = F(( () => f.value[v.value]));
        function b() {
            if ("number" === e.type && /[^0-9]/g.test(m.value.value))
                return void (m.value.value = "");
            const t = u.value.slice()
              , a = m.value.value;
            t[v.value] = a;
            let i = null;
            v.value > u.value.length ? i = u.value.length + 1 : v.value + 1 !== h.value && (i = "next"),
            u.value = t,
            i && Xe(g.value, i)
        }
        function w(e) {
            const t = u.value.slice()
              , a = v.value;
            let i = null;
            ["ArrowLeft", "ArrowRight", "Backspace", "Delete"].includes(e.key) && (e.preventDefault(),
            "ArrowLeft" === e.key ? i = "prev" : "ArrowRight" === e.key ? i = "next" : ["Backspace", "Delete"].includes(e.key) && (t[v.value] = "",
            u.value = t,
            v.value > 0 && "Backspace" === e.key ? i = "prev" : requestAnimationFrame(( () => {
                var e;
                null == (e = f.value[a]) || e.select()
            }
            ))),
            requestAnimationFrame(( () => {
                null != i && Xe(g.value, i)
            }
            )))
        }
        function k() {
            c(),
            v.value = -1
        }
        return V({
            VField: {
                color: F(( () => e.color)),
                bgColor: F(( () => e.color)),
                baseColor: F(( () => e.baseColor)),
                disabled: F(( () => e.disabled)),
                error: F(( () => e.error)),
                variant: F(( () => e.variant))
            }
        }, {
            scoped: !0
        }),
        $(u, (e => {
            e.length === h.value && i("finish", e.join(""))
        }
        ), {
            deep: !0
        }),
        $(v, (e => {
            e < 0 || q(( () => {
                var t;
                null == (t = f.value[e]) || t.select()
            }
            ))
        }
        )),
        x(( () => {
            var t;
            const [i,l] = Oe(a);
            return y("div", A({
                class: ["v-otp-input", {
                    "v-otp-input--divided": !!e.divider
                }, e.class],
                style: [e.style]
            }, i), [y("div", {
                ref: g,
                class: "v-otp-input__content",
                style: [r.value]
            }, [p.value.map(( (t, a) => y(Q, null, [e.divider && 0 !== a && y("span", {
                class: "v-otp-input__divider"
            }, [e.divider]), y(Ls, {
                focused: o.value && e.focusAll || v.value === a,
                key: a
            }, {
                ...n,
                loader: void 0,
                default: () => y("input", {
                    ref: e => f.value[a] = e,
                    "aria-label": d(e.label, a + 1),
                    autofocus: 0 === a && e.autofocus,
                    autocomplete: "one-time-code",
                    class: ["v-otp-input__field"],
                    disabled: e.disabled,
                    inputmode: "number" === e.type ? "numeric" : "text",
                    min: "number" === e.type ? 0 : void 0,
                    maxlength: "1",
                    placeholder: e.placeholder,
                    type: "number" === e.type ? "text" : e.type,
                    value: u.value[a],
                    onInput: b,
                    onFocus: e => {
                        return t = a,
                        s(),
                        void (v.value = t);
                        var t
                    }
                    ,
                    onBlur: k,
                    onKeydown: w,
                    onPaste: e => function(e, t) {
                        var a, i;
                        t.preventDefault(),
                        t.stopPropagation(),
                        u.value = ((null == (a = null == t ? void 0 : t.clipboardData) ? void 0 : a.getData("Text")) ?? "").split(""),
                        null == (i = f.value) || i[e].blur()
                    }(a, e)
                }, null)
            })]))), y("input", A({
                class: "v-otp-input-input",
                type: "hidden"
            }, l, {
                value: u.value.join("")
            }), null), y(gs, {
                contained: !0,
                "content-class": "v-otp-input__loader",
                "model-value": !!e.loading,
                persistent: !0
            }, {
                default: () => {
                    var t;
                    return [(null == (t = n.loader) ? void 0 : t.call(n)) ?? y(Ln, {
                        color: "boolean" == typeof e.loading ? void 0 : e.loading,
                        indeterminate: !0,
                        size: "24",
                        width: "2"
                    }, null)]
                }
            }), null == (t = n.default) ? void 0 : t.call(n)])])
        }
        )),
        {
            blur: () => {
                var e;
                null == (e = f.value) || e.some((e => e.blur()))
            }
            ,
            focus: () => {
                var e;
                null == (e = f.value) || e[0].focus()
            }
            ,
            reset: function() {
                u.value = []
            },
            isFocused: o
        }
    }
});
const ch = d({
    scale: {
        type: [Number, String],
        default: .5
    },
    ...h()
}, "VParallax")
  , uh = g()({
    name: "VParallax",
    props: ch(),
    setup(e, t) {
        let {slots: a} = t;
        const {intersectionRef: i, isIntersecting: n} = An()
          , {resizeRef: r, contentRect: o} = we()
          , {height: s} = Me()
          , c = l();
        let u;
        le(( () => {
            var e;
            i.value = r.value = null == (e = c.value) ? void 0 : e.$el
        }
        )),
        $(n, (e => {
            e ? (u = nt(i.value),
            u = u === document.scrollingElement ? document : u,
            u.addEventListener("scroll", p, {
                passive: !0
            }),
            p()) : u.removeEventListener("scroll", p)
        }
        )),
        Z(( () => {
            null == u || u.removeEventListener("scroll", p)
        }
        )),
        $(s, p),
        $(( () => {
            var e;
            return null == (e = o.value) ? void 0 : e.height
        }
        ), p);
        const d = F(( () => 1 - te(+e.scale)));
        let h = -1;
        function p() {
            n.value && (cancelAnimationFrame(h),
            h = requestAnimationFrame(( () => {
                var e;
                const t = (null == (e = c.value) ? void 0 : e.$el).querySelector(".v-img__img");
                if (!t)
                    return;
                const a = u instanceof Document ? document.documentElement.clientHeight : u.clientHeight
                  , n = u instanceof Document ? window.scrollY : u.scrollTop
                  , r = i.value.getBoundingClientRect().top + n
                  , s = o.value.height
                  , l = (h = (n - (r + (s - a) / 2)) * d.value,
                Math.floor(Math.abs(h)) * Math.sign(h));
                var h;
                const p = Math.max(1, (d.value * (a - s) + s) / s);
                t.style.setProperty("transform", `translateY(${l}px) scale(${p})`)
            }
            )))
        }
        return x(( () => y(Wi, {
            class: ["v-parallax", {
                "v-parallax--active": n.value
            }, e.class],
            style: e.style,
            ref: c,
            cover: !0,
            onLoadstart: p,
            onLoad: p
        }, a))),
        {}
    }
})
  , dh = d({
    ...Sr({
        falseIcon: "$radioOff",
        trueIcon: "$radioOn"
    })
}, "VRadio")
  , hh = g()({
    name: "VRadio",
    props: dh(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => y(Cr, A(e, {
            class: ["v-radio", e.class],
            style: e.style,
            type: "radio"
        }), a))),
        {}
    }
})
  , ph = d({
    height: {
        type: [Number, String],
        default: "auto"
    },
    ...Dr(),
    ...Fe(yr(), ["multiple"]),
    trueIcon: {
        type: me,
        default: "$radioOn"
    },
    falseIcon: {
        type: me,
        default: "$radioOff"
    },
    type: {
        type: String,
        default: "radio"
    }
}, "VRadioGroup")
  , vh = g()({
    name: "VRadioGroup",
    inheritAttrs: !1,
    props: ph(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const n = ce()
          , r = F(( () => e.id || `radio-group-${n}`))
          , o = re(e, "modelValue");
        return x(( () => {
            const [t,n] = Oe(a)
              , s = Rr.filterProps(e)
              , l = Cr.filterProps(e)
              , c = i.label ? i.label({
                label: e.label,
                props: {
                    for: r.value
                }
            }) : e.label;
            return y(Rr, A({
                class: ["v-radio-group", e.class],
                style: e.style
            }, t, s, {
                modelValue: o.value,
                "onUpdate:modelValue": e => o.value = e,
                id: r.value
            }), {
                ...i,
                default: t => {
                    let {id: a, messagesId: r, isDisabled: s, isReadonly: u} = t;
                    return y(Q, null, [c && y(br, {
                        id: a.value
                    }, {
                        default: () => [c]
                    }), y(kr, A(l, {
                        id: a.value,
                        "aria-describedby": r.value,
                        defaultsTarget: "VRadio",
                        trueIcon: e.trueIcon,
                        falseIcon: e.falseIcon,
                        type: e.type,
                        disabled: s.value,
                        readonly: u.value,
                        "aria-labelledby": c ? a.value : void 0,
                        multiple: !1
                    }, n, {
                        modelValue: o.value,
                        "onUpdate:modelValue": e => o.value = e
                    }), i)])
                }
            })
        }
        )),
        {}
    }
})
  , gh = d({
    ...Tr(),
    ...Dr(),
    ...jl(),
    strict: Boolean,
    modelValue: {
        type: Array,
        default: () => [0, 0]
    }
}, "VRangeSlider")
  , fh = g()({
    name: "VRangeSlider",
    props: gh(),
    emits: {
        "update:focused": e => !0,
        "update:modelValue": e => !0,
        end: e => !0,
        start: e => !0
    },
    setup(e, t) {
        let {slots: a, emit: i} = t;
        const n = l()
          , r = l()
          , o = l()
          , {rtlClasses: s} = b();
        const c = $l(e)
          , u = re(e, "modelValue", void 0, (e => (null == e ? void 0 : e.length) ? e.map((e => c.roundValue(e))) : [0, 0]))
          , {activeThumbRef: d, hasLabels: h, max: p, min: v, mousePressed: g, onSliderMousedown: f, onSliderTouchstart: m, position: w, trackContainerRef: k} = Ul({
            props: e,
            steps: c,
            onSliderStart: () => {
                i("start", u.value)
            }
            ,
            onSliderEnd: t => {
                var a;
                let {value: r} = t;
                const o = d.value === (null == (a = n.value) ? void 0 : a.$el) ? [r, u.value[1]] : [u.value[0], r];
                !e.strict && o[0] < o[1] && (u.value = o),
                i("end", u.value)
            }
            ,
            onSliderMove: t => {
                var a, i, o, s;
                let {value: l} = t;
                const [c,h] = u.value;
                e.strict || c !== h || c === v.value || (d.value = l > c ? null == (a = r.value) ? void 0 : a.$el : null == (i = n.value) ? void 0 : i.$el,
                null == (o = d.value) || o.focus()),
                d.value === (null == (s = n.value) ? void 0 : s.$el) ? u.value = [Math.min(l, h), h] : u.value = [c, Math.max(c, l)]
            }
            ,
            getActiveThumb: function(t) {
                if (!n.value || !r.value)
                    return;
                const a = Gl(t, n.value.$el, e.direction)
                  , i = Gl(t, r.value.$el, e.direction)
                  , o = Math.abs(a)
                  , s = Math.abs(i);
                return o < s || o === s && a < 0 ? n.value.$el : r.value.$el
            }
        })
          , {isFocused: S, focus: C, blur: P} = Er(e)
          , L = F(( () => w(u.value[0])))
          , I = F(( () => w(u.value[1])));
        return x(( () => {
            const t = Rr.filterProps(e)
              , i = !!(e.label || a.label || a.prepend);
            return y(Rr, A({
                class: ["v-slider", "v-range-slider", {
                    "v-slider--has-labels": !!a["tick-label"] || h.value,
                    "v-slider--focused": S.value,
                    "v-slider--pressed": g.value,
                    "v-slider--disabled": e.disabled
                }, s.value, e.class],
                style: e.style,
                ref: o
            }, t, {
                focused: S.value
            }), {
                ...a,
                prepend: i ? t => {
                    var i, n;
                    return y(Q, null, [(null == (i = a.label) ? void 0 : i.call(a, t)) ?? (e.label ? y(br, {
                        class: "v-slider__label",
                        text: e.label
                    }, null) : void 0), null == (n = a.prepend) ? void 0 : n.call(a, t)])
                }
                : void 0,
                default: t => {
                    var i, o;
                    let {id: s, messagesId: l} = t;
                    return y("div", {
                        class: "v-slider__container",
                        onMousedown: f,
                        onTouchstartPassive: m
                    }, [y("input", {
                        id: `${s.value}_start`,
                        name: e.name || s.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: "-1",
                        value: u.value[0]
                    }, null), y("input", {
                        id: `${s.value}_stop`,
                        name: e.name || s.value,
                        disabled: !!e.disabled,
                        readonly: !!e.readonly,
                        tabindex: "-1",
                        value: u.value[1]
                    }, null), y(Jl, {
                        ref: k,
                        start: L.value,
                        stop: I.value
                    }, {
                        "tick-label": a["tick-label"]
                    }), y(Zl, {
                        ref: n,
                        "aria-describedby": l.value,
                        focused: S && d.value === (null == (i = n.value) ? void 0 : i.$el),
                        modelValue: u.value[0],
                        "onUpdate:modelValue": e => u.value = [e, u.value[1]],
                        onFocus: e => {
                            var t, a, i, o;
                            C(),
                            d.value = null == (t = n.value) ? void 0 : t.$el,
                            u.value[0] === u.value[1] && u.value[1] === v.value && e.relatedTarget !== (null == (a = r.value) ? void 0 : a.$el) && (null == (i = n.value) || i.$el.blur(),
                            null == (o = r.value) || o.$el.focus())
                        }
                        ,
                        onBlur: () => {
                            P(),
                            d.value = void 0
                        }
                        ,
                        min: v.value,
                        max: u.value[1],
                        position: L.value,
                        ripple: e.ripple
                    }, {
                        "thumb-label": a["thumb-label"]
                    }), y(Zl, {
                        ref: r,
                        "aria-describedby": l.value,
                        focused: S && d.value === (null == (o = r.value) ? void 0 : o.$el),
                        modelValue: u.value[1],
                        "onUpdate:modelValue": e => u.value = [u.value[0], e],
                        onFocus: e => {
                            var t, a, i, o;
                            C(),
                            d.value = null == (t = r.value) ? void 0 : t.$el,
                            u.value[0] === u.value[1] && u.value[0] === p.value && e.relatedTarget !== (null == (a = n.value) ? void 0 : a.$el) && (null == (i = r.value) || i.$el.blur(),
                            null == (o = n.value) || o.$el.focus())
                        }
                        ,
                        onBlur: () => {
                            P(),
                            d.value = void 0
                        }
                        ,
                        min: u.value[0],
                        max: p.value,
                        position: I.value,
                        ripple: e.ripple
                    }, {
                        "thumb-label": a["thumb-label"]
                    })])
                }
            })
        }
        )),
        {}
    }
})
  , mh = d({
    name: String,
    itemAriaLabel: {
        type: String,
        default: "$vuetify.rating.ariaLabel.item"
    },
    activeColor: String,
    color: String,
    clearable: Boolean,
    disabled: Boolean,
    emptyIcon: {
        type: me,
        default: "$ratingEmpty"
    },
    fullIcon: {
        type: me,
        default: "$ratingFull"
    },
    halfIncrements: Boolean,
    hover: Boolean,
    length: {
        type: [Number, String],
        default: 5
    },
    readonly: Boolean,
    modelValue: {
        type: [Number, String],
        default: 0
    },
    itemLabels: Array,
    itemLabelPosition: {
        type: String,
        default: "top",
        validator: e => ["top", "bottom"].includes(e)
    },
    ripple: Boolean,
    ...h(),
    ...nn(),
    ...wn(),
    ...ai(),
    ...v()
}, "VRating")
  , bh = g()({
    name: "VRating",
    props: mh(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {t: i} = Te()
          , {themeClasses: n} = f(e)
          , r = re(e, "modelValue")
          , o = F(( () => te(parseFloat(r.value), 0, +e.length)))
          , s = F(( () => It(Number(e.length), 1)))
          , l = F(( () => s.value.flatMap((t => e.halfIncrements ? [t - .5, t] : [t]))))
          , c = j(-1)
          , u = F(( () => l.value.map((t => {
            const a = e.hover && c.value > -1
              , i = o.value >= t
              , n = c.value >= t
              , r = (a ? n : i) ? e.fullIcon : e.emptyIcon
              , s = e.activeColor ?? e.color;
            return {
                isFilled: i,
                isHovered: n,
                icon: r,
                color: i || n ? s : e.color
            }
        }
        ))))
          , d = F(( () => [0, ...l.value].map((t => ({
            onMouseenter: e.hover ? function() {
                c.value = t
            }
            : void 0,
            onMouseleave: e.hover ? function() {
                c.value = -1
            }
            : void 0,
            onClick: function() {
                e.disabled || e.readonly || (r.value = o.value === t && e.clearable ? 0 : t)
            }
        })))))
          , h = F(( () => e.name ?? `v-rating-${ce()}`));
        function p(t) {
            var n, r;
            let {value: s, index: l, showStar: c=!0} = t;
            const {onMouseenter: p, onMouseleave: v, onClick: g} = d.value[l + 1]
              , f = `${h.value}-${String(s).replace(".", "-")}`
              , m = {
                color: null == (n = u.value[l]) ? void 0 : n.color,
                density: e.density,
                disabled: e.disabled,
                icon: null == (r = u.value[l]) ? void 0 : r.icon,
                ripple: e.ripple,
                size: e.size,
                variant: "plain"
            };
            return y(Q, null, [y("label", {
                for: f,
                class: {
                    "v-rating__item--half": e.halfIncrements && s % 1 > 0,
                    "v-rating__item--full": e.halfIncrements && s % 1 == 0
                },
                onMouseenter: p,
                onMouseleave: v,
                onClick: g
            }, [y("span", {
                class: "v-rating__hidden"
            }, [i(e.itemAriaLabel, s, e.length)]), c ? a.item ? a.item({
                ...u.value[l],
                props: m,
                value: s,
                index: l,
                rating: o.value
            }) : y(sr, A({
                "aria-label": i(e.itemAriaLabel, s, e.length)
            }, m), null) : void 0]), y("input", {
                class: "v-rating__hidden",
                name: h.value,
                id: f,
                type: "radio",
                value: s,
                checked: o.value === s,
                tabindex: -1,
                readonly: e.readonly,
                disabled: e.disabled
            }, null)])
        }
        function v(e) {
            return a["item-label"] ? a["item-label"](e) : e.label ? y("span", null, [e.label]) : y("span", null, [vt("")])
        }
        return x(( () => {
            var t;
            const i = !!(null == (t = e.itemLabels) ? void 0 : t.length) || a["item-label"];
            return y(e.tag, {
                class: ["v-rating", {
                    "v-rating--hover": e.hover,
                    "v-rating--readonly": e.readonly
                }, n.value, e.class],
                style: e.style
            }, {
                default: () => [y(p, {
                    value: 0,
                    index: -1,
                    showStar: !1
                }, null), s.value.map(( (t, a) => {
                    var n, r;
                    return y("div", {
                        class: "v-rating__wrapper"
                    }, [i && "top" === e.itemLabelPosition ? v({
                        value: t,
                        index: a,
                        label: null == (n = e.itemLabels) ? void 0 : n[a]
                    }) : void 0, y("div", {
                        class: "v-rating__item"
                    }, [e.halfIncrements ? y(Q, null, [y(p, {
                        value: t - .5,
                        index: 2 * a
                    }, null), y(p, {
                        value: t,
                        index: 2 * a + 1
                    }, null)]) : y(p, {
                        value: t,
                        index: a
                    }, null)]), i && "bottom" === e.itemLabelPosition ? v({
                        value: t,
                        index: a,
                        label: null == (r = e.itemLabels) ? void 0 : r[a]
                    }) : void 0])
                }
                ))]
            })
        }
        )),
        {}
    }
})
  , xh = {
    actions: "button@2",
    article: "heading, paragraph",
    avatar: "avatar",
    button: "button",
    card: "image, heading",
    "card-avatar": "image, list-item-avatar",
    chip: "chip",
    "date-picker": "list-item, heading, divider, date-picker-options, date-picker-days, actions",
    "date-picker-options": "text, avatar@2",
    "date-picker-days": "avatar@28",
    divider: "divider",
    heading: "heading",
    image: "image",
    "list-item": "text",
    "list-item-avatar": "avatar, text",
    "list-item-two-line": "sentences",
    "list-item-avatar-two-line": "avatar, sentences",
    "list-item-three-line": "paragraph",
    "list-item-avatar-three-line": "avatar, paragraph",
    ossein: "ossein",
    paragraph: "text@3",
    sentences: "text@2",
    subtitle: "text",
    table: "table-heading, table-thead, table-tbody, table-tfoot",
    "table-heading": "chip, text",
    "table-thead": "heading@6",
    "table-tbody": "table-row-divider@6",
    "table-row-divider": "table-row, divider",
    "table-row": "text@6",
    "table-tfoot": "text@2, avatar@2",
    text: "text"
};
function yh(e) {
    return y("div", {
        class: ["v-skeleton-loader__bone", `v-skeleton-loader__${e}`]
    }, [arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []])
}
function wh(e) {
    const [t,a] = e.split("@");
    return Array.from({
        length: a
    }).map(( () => kh(t)))
}
function kh(e) {
    let t = [];
    if (!e)
        return t;
    const a = xh[e];
    if (e === a)
        ;
    else {
        if (e.includes(","))
            return Sh(e);
        if (e.includes("@"))
            return wh(e);
        a.includes(",") ? t = Sh(a) : a.includes("@") ? t = wh(a) : a && t.push(kh(a))
    }
    return [yh(e, t)]
}
function Sh(e) {
    return e.replace(/\s/g, "").split(",").map(kh)
}
const Ch = d({
    boilerplate: Boolean,
    color: String,
    loading: Boolean,
    loadingText: {
        type: String,
        default: "$vuetify.loading"
    },
    type: {
        type: [String, Array],
        default: "ossein"
    },
    ...Ti(),
    ...$i(),
    ...v()
}, "VSkeletonLoader")
  , Ah = g()({
    name: "VSkeletonLoader",
    props: Ch(),
    setup(e, t) {
        let {slots: a} = t;
        const {backgroundColorClasses: i, backgroundColorStyles: n} = Mi(W(e, "color"))
          , {dimensionStyles: r} = Ei(e)
          , {elevationClasses: o} = Ui(e)
          , {themeClasses: s} = f(e)
          , {t: l} = Te()
          , c = F(( () => kh(ve(e.type).join(","))));
        return x(( () => {
            var t;
            const u = !a.default || e.loading;
            return y("div", {
                class: ["v-skeleton-loader", {
                    "v-skeleton-loader--boilerplate": e.boilerplate
                }, s.value, i.value, o.value],
                style: [n.value, u ? r.value : {}],
                "aria-busy": e.boilerplate ? void 0 : u,
                "aria-live": e.boilerplate ? void 0 : "polite",
                "aria-label": e.boilerplate ? void 0 : l(e.loadingText),
                role: e.boilerplate ? void 0 : "alert"
            }, [u ? c.value : null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {}
    }
})
  , Ph = g()({
    name: "VSlideGroupItem",
    props: pn(),
    emits: {
        "group:selected": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = vn(e, Yr);
        return () => {
            var e;
            return null == (e = a.default) ? void 0 : e.call(a, {
                isSelected: i.isSelected.value,
                select: i.select,
                toggle: i.toggle,
                selectedClass: i.selectedClass.value
            })
        }
    }
});
const Lh = d({
    multiLine: Boolean,
    text: String,
    timer: [Boolean, String],
    timeout: {
        type: [Number, String],
        default: 5e3
    },
    vertical: Boolean,
    ..._n({
        location: "bottom"
    }),
    ...Dn(),
    ...Di(),
    ...ln(),
    ...v(),
    ...Fe(vs({
        transition: "v-snackbar-transition"
    }), ["persistent", "noClickAnimation", "scrim", "scrollStrategy"])
}, "VSnackbar")
  , Ih = g()({
    name: "VSnackbar",
    props: Lh(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , {locationStyles: n} = Tn(e)
          , {positionClasses: r} = Rn(e)
          , {scopeId: o} = rs()
          , {themeClasses: s} = f(e)
          , {colorClasses: c, colorStyles: u, variantClasses: d} = cn(e)
          , {roundedClasses: h} = Ri(e)
          , p = function(e) {
            const t = j(e);
            let a = -1;
            function i() {
                clearInterval(a)
            }
            return Pe(i),
            {
                clear: i,
                time: t,
                start: function(n) {
                    const r = n ? getComputedStyle(n) : {
                        transitionDuration: .2
                    }
                      , o = 1e3 * parseFloat(r.transitionDuration) || 200;
                    if (i(),
                    t.value <= 0)
                        return;
                    const s = performance.now();
                    a = window.setInterval(( () => {
                        const a = performance.now() - s + o;
                        t.value = Math.max(e - a, 0),
                        t.value <= 0 && i()
                    }
                    ), o)
                },
                reset: function() {
                    i(),
                    q(( () => t.value = e))
                }
            }
        }(Number(e.timeout))
          , v = l()
          , g = l()
          , m = j(!1);
        $(i, w),
        $(( () => e.timeout), w),
        ae(( () => {
            i.value && w()
        }
        ));
        let b = -1;
        function w() {
            p.reset(),
            window.clearTimeout(b);
            const t = Number(e.timeout);
            if (!i.value || -1 === t)
                return;
            const a = et(g.value);
            p.start(a),
            b = window.setTimeout(( () => {
                i.value = !1
            }
            ), t)
        }
        function k() {
            m.value = !0,
            p.reset(),
            window.clearTimeout(b)
        }
        function S() {
            m.value = !1,
            w()
        }
        return x(( () => {
            const t = gs.filterProps(e)
              , l = !!(a.default || a.text || e.text);
            return y(gs, A({
                ref: v,
                class: ["v-snackbar", {
                    "v-snackbar--active": i.value,
                    "v-snackbar--multi-line": e.multiLine && !e.vertical,
                    "v-snackbar--timer": !!e.timer,
                    "v-snackbar--vertical": e.vertical
                }, r.value, e.class],
                style: e.style
            }, t, {
                modelValue: i.value,
                "onUpdate:modelValue": e => i.value = e,
                contentProps: A({
                    class: ["v-snackbar__wrapper", s.value, c.value, h.value, d.value],
                    style: [n.value, u.value],
                    onPointerenter: k,
                    onPointerleave: S
                }, t.contentProps),
                persistent: !0,
                noClickAnimation: !0,
                scrim: !1,
                scrollStrategy: "none",
                _disableGlobalStack: !0
            }, o), {
                default: () => {
                    var t, i;
                    return [sn(!1, "v-snackbar"), e.timer && !m.value && y("div", {
                        key: "timer",
                        class: "v-snackbar__timer"
                    }, [y(On, {
                        ref: g,
                        color: "string" == typeof e.timer ? e.timer : "info",
                        max: e.timeout,
                        "model-value": p.time.value
                    }, null)]), l && y("div", {
                        key: "content",
                        class: "v-snackbar__content",
                        role: "status",
                        "aria-live": "polite"
                    }, [(null == (t = a.text) ? void 0 : t.call(a)) ?? e.text, null == (i = a.default) ? void 0 : i.call(a)]), a.actions && y(_i, {
                        defaults: {
                            VBtn: {
                                variant: "text",
                                ripple: !1,
                                slim: !0
                            }
                        }
                    }, {
                        default: () => [y("div", {
                            class: "v-snackbar__actions"
                        }, [a.actions()])]
                    })]
                }
                ,
                activator: a.activator
            })
        }
        )),
        bs({}, v)
    }
})
  , _h = d({
    color: String,
    disabled: {
        type: [Boolean, String],
        default: !1
    },
    prevText: {
        type: String,
        default: "$vuetify.stepper.prev"
    },
    nextText: {
        type: String,
        default: "$vuetify.stepper.next"
    }
}, "VStepperActions")
  , Th = g()({
    name: "VStepperActions",
    props: _h(),
    emits: {
        "click:prev": () => !0,
        "click:next": () => !0
    },
    setup(e, t) {
        let {emit: a, slots: i} = t;
        const {t: n} = Te();
        function r() {
            a("click:prev")
        }
        function o() {
            a("click:next")
        }
        return x(( () => {
            const t = {
                onClick: r
            }
              , a = {
                onClick: o
            };
            return y("div", {
                class: "v-stepper-actions"
            }, [y(_i, {
                defaults: {
                    VBtn: {
                        disabled: ["prev", !0].includes(e.disabled),
                        text: n(e.prevText),
                        variant: "text"
                    }
                }
            }, {
                default: () => {
                    var e;
                    return [(null == (e = i.prev) ? void 0 : e.call(i, {
                        props: t
                    })) ?? y(sr, t, null)]
                }
            }), y(_i, {
                defaults: {
                    VBtn: {
                        color: e.color,
                        disabled: ["next", !0].includes(e.disabled),
                        text: n(e.nextText),
                        variant: "tonal"
                    }
                }
            }, {
                default: () => {
                    var e;
                    return [(null == (e = i.next) ? void 0 : e.call(i, {
                        props: a
                    })) ?? y(sr, a, null)]
                }
            })])
        }
        )),
        {}
    }
})
  , Eh = _e("v-stepper-header")
  , Oh = d({
    color: String,
    title: String,
    subtitle: String,
    complete: Boolean,
    completeIcon: {
        type: String,
        default: "$complete"
    },
    editable: Boolean,
    editIcon: {
        type: String,
        default: "$edit"
    },
    error: Boolean,
    errorIcon: {
        type: String,
        default: "$error"
    },
    icon: String,
    ripple: {
        type: [Boolean, Object],
        default: !0
    },
    rules: {
        type: Array,
        default: () => []
    },
    ...pn()
}, "VStepperItem")
  , Vh = g()({
    name: "VStepperItem",
    directives: {
        Ripple: rr
    },
    props: Oh(),
    emits: {
        "group:selected": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = vn(e, Nh, !0)
          , n = F(( () => (null == i ? void 0 : i.value.value) ?? e.value))
          , r = F(( () => e.rules.every((e => !0 === e()))))
          , o = F(( () => !e.disabled && e.editable))
          , s = F(( () => e.error || !r.value))
          , l = F(( () => e.complete || e.rules.length > 0 && r.value))
          , c = F(( () => s.value ? e.errorIcon : l.value ? e.completeIcon : e.editable ? e.editIcon : e.icon))
          , u = F(( () => ({
            canEdit: o.value,
            hasError: s.value,
            hasCompleted: l.value,
            title: e.title,
            subtitle: e.subtitle,
            step: n.value,
            value: e.value
        })));
        return x(( () => {
            var t, r, d;
            const h = (!i || i.isSelected.value || l.value || o.value) && !s.value && !e.disabled
              , p = !(null == e.title && !a.title)
              , v = !(null == e.subtitle && !a.subtitle);
            return K(y("button", {
                class: ["v-stepper-item", {
                    "v-stepper-item--complete": l.value,
                    "v-stepper-item--disabled": e.disabled,
                    "v-stepper-item--error": s.value
                }, null == i ? void 0 : i.selectedClass.value],
                disabled: !e.editable,
                onClick: function() {
                    null == i || i.toggle()
                }
            }, [y(fr, {
                key: "stepper-avatar",
                class: "v-stepper-item__avatar",
                color: h ? e.color : void 0,
                size: 24
            }, {
                default: () => {
                    var e;
                    return [(null == (e = a.icon) ? void 0 : e.call(a, u.value)) ?? (c.value ? y(Cn, {
                        icon: c.value
                    }, null) : n.value)]
                }
            }), y("div", {
                class: "v-stepper-item__content"
            }, [p && y("div", {
                key: "title",
                class: "v-stepper-item__title"
            }, [(null == (t = a.title) ? void 0 : t.call(a, u.value)) ?? e.title]), v && y("div", {
                key: "subtitle",
                class: "v-stepper-item__subtitle"
            }, [(null == (r = a.subtitle) ? void 0 : r.call(a, u.value)) ?? e.subtitle]), null == (d = a.default) ? void 0 : d.call(a, u.value)])]), [[J("ripple"), e.ripple && e.editable, null]])
        }
        )),
        {}
    }
})
  , Fh = Symbol.for("vuetify:v-stepper")
  , Bh = d({
    ...Fe(Al(), ["continuous", "nextIcon", "prevIcon", "showArrows", "touch", "mandatory"])
}, "VStepperWindow")
  , Mh = g()({
    name: "VStepperWindow",
    props: Bh(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = de(Fh, null)
          , n = re(e, "modelValue")
          , r = F({
            get() {
                var e;
                return null == n.value && i ? null == (e = i.items.value.find((e => i.selected.value.includes(e.id)))) ? void 0 : e.value : n.value
            },
            set(e) {
                n.value = e
            }
        });
        return x(( () => {
            const t = Pl.filterProps(e);
            return y(Pl, A({
                _as: "VStepperWindow"
            }, t, {
                modelValue: r.value,
                "onUpdate:modelValue": e => r.value = e,
                class: "v-stepper-window",
                mandatory: !1,
                touch: !1
            }), a)
        }
        )),
        {}
    }
})
  , Dh = d({
    ..._l()
}, "VStepperWindowItem")
  , Rh = g()({
    name: "VStepperWindowItem",
    props: Dh(),
    setup(e, t) {
        let {slots: a} = t;
        return x(( () => {
            const t = Tl.filterProps(e);
            return y(Tl, A({
                _as: "VStepperWindowItem"
            }, t, {
                class: "v-stepper-window-item"
            }), a)
        }
        )),
        {}
    }
})
  , Nh = Symbol.for("vuetify:v-stepper")
  , zh = d({
    altLabels: Boolean,
    bgColor: String,
    editable: Boolean,
    hideActions: Boolean,
    items: {
        type: Array,
        default: () => []
    },
    itemTitle: {
        type: String,
        default: "title"
    },
    itemValue: {
        type: String,
        default: "value"
    },
    mobile: Boolean,
    nonLinear: Boolean,
    flat: Boolean,
    ...hn({
        mandatory: "force",
        selectedClass: "v-stepper-item--selected"
    }),
    ...nc(),
    ...Qt(_h(), ["prevText", "nextText"])
}, "VStepper")
  , Hh = g()({
    name: "VStepper",
    props: zh(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const {items: i, next: n, prev: r, selected: o} = gn(e, Nh)
          , {color: s, editable: l, prevText: c, nextText: u} = O(e)
          , d = F(( () => e.items.map(( (t, a) => ({
            title: He(t, e.itemTitle, t),
            value: He(t, e.itemValue, a + 1),
            raw: t
        })))))
          , h = F(( () => i.value.findIndex((e => o.value.includes(e.id)))))
          , p = F(( () => e.disabled ? e.disabled : 0 === h.value ? "prev" : h.value === i.value.length - 1 && "next"));
        return V({
            VStepperItem: {
                editable: l,
                prevText: c,
                nextText: u
            },
            VStepperActions: {
                color: s,
                disabled: p,
                prevText: c,
                nextText: u
            }
        }),
        x(( () => {
            const t = rc.filterProps(e)
              , i = !(!a.header && !e.items.length)
              , o = e.items.length > 0
              , s = !(e.hideActions || !o && !a.actions);
            return y(rc, A(t, {
                color: e.bgColor,
                class: ["v-stepper", {
                    "v-stepper--alt-labels": e.altLabels,
                    "v-stepper--flat": e.flat,
                    "v-stepper--non-linear": e.nonLinear,
                    "v-stepper--mobile": e.mobile
                }, e.class],
                style: e.style
            }), {
                default: () => {
                    var e, t;
                    return [i && y(Eh, {
                        key: "stepper-header"
                    }, {
                        default: () => [d.value.map(( (e, t) => y(Q, null, [!!t && y(wo, null, null), y(Vh, e, {
                            default: a[`header-item.${e.value}`] ?? a.header,
                            icon: a.icon,
                            title: a.title,
                            subtitle: a.subtitle
                        })])))]
                    }), o && y(Mh, {
                        key: "stepper-window"
                    }, {
                        default: () => [d.value.map((e => y(Rh, {
                            value: e.value
                        }, {
                            default: () => {
                                var t, i;
                                return (null == (t = a[`item.${e.value}`]) ? void 0 : t.call(a, e)) ?? (null == (i = a.item) ? void 0 : i.call(a, e))
                            }
                        })))]
                    }), null == (e = a.default) ? void 0 : e.call(a, {
                        prev: r,
                        next: n
                    }), s && ((null == (t = a.actions) ? void 0 : t.call(a, {
                        next: n,
                        prev: r
                    })) ?? y(Th, {
                        key: "stepper-actions",
                        "onClick:prev": r,
                        "onClick:next": n
                    }, a))]
                }
            })
        }
        )),
        {
            prev: r,
            next: n
        }
    }
})
  , Xh = d({
    indeterminate: Boolean,
    inset: Boolean,
    flat: Boolean,
    loading: {
        type: [Boolean, String],
        default: !1
    },
    ...Dr(),
    ...Sr()
}, "VSwitch")
  , Yh = g()({
    name: "VSwitch",
    inheritAttrs: !1,
    props: Xh(),
    emits: {
        "update:focused": e => !0,
        "update:modelValue": e => !0,
        "update:indeterminate": e => !0
    },
    setup(e, t) {
        let {attrs: a, slots: i} = t;
        const n = re(e, "indeterminate")
          , r = re(e, "modelValue")
          , {loaderClasses: o} = Fn(e)
          , {isFocused: s, focus: c, blur: u} = Er(e)
          , d = l()
          , h = F(( () => "string" == typeof e.loading && "" !== e.loading ? e.loading : e.color))
          , p = ce()
          , v = F(( () => e.id || `switch-${p}`));
        function g() {
            n.value && (n.value = !1)
        }
        function f(e) {
            var t, a;
            e.stopPropagation(),
            e.preventDefault(),
            null == (a = null == (t = d.value) ? void 0 : t.input) || a.click()
        }
        return x(( () => {
            const [t,l] = Oe(a)
              , p = Rr.filterProps(e)
              , m = Cr.filterProps(e);
            return y(Rr, A({
                class: ["v-switch", {
                    "v-switch--inset": e.inset
                }, {
                    "v-switch--indeterminate": n.value
                }, o.value, e.class]
            }, t, p, {
                modelValue: r.value,
                "onUpdate:modelValue": e => r.value = e,
                id: v.value,
                focused: s.value,
                style: e.style
            }), {
                ...i,
                default: t => {
                    let {id: a, messagesId: o, isDisabled: s, isReadonly: p, isValid: v} = t;
                    const b = {
                        model: r,
                        isValid: v
                    };
                    return y(Cr, A({
                        ref: d
                    }, m, {
                        modelValue: r.value,
                        "onUpdate:modelValue": [e => r.value = e, g],
                        id: a.value,
                        "aria-describedby": o.value,
                        type: "checkbox",
                        "aria-checked": n.value ? "mixed" : void 0,
                        disabled: s.value,
                        readonly: p.value,
                        onFocus: c,
                        onBlur: u
                    }, l), {
                        ...i,
                        default: e => {
                            let {backgroundColorClasses: t, backgroundColorStyles: a} = e;
                            return y("div", {
                                class: ["v-switch__track", ...t.value],
                                style: a.value,
                                onClick: f
                            }, [i["track-true"] && y("div", {
                                key: "prepend",
                                class: "v-switch__track-true"
                            }, [i["track-true"](b)]), i["track-false"] && y("div", {
                                key: "append",
                                class: "v-switch__track-false"
                            }, [i["track-false"](b)])])
                        }
                        ,
                        input: t => {
                            let {inputNode: a, icon: n, backgroundColorClasses: r, backgroundColorStyles: o} = t;
                            return y(Q, null, [a, y("div", {
                                class: ["v-switch__thumb", {
                                    "v-switch__thumb--filled": n || e.loading
                                }, e.inset ? void 0 : r.value],
                                style: e.inset ? void 0 : o.value
                            }, [i.thumb ? y(_i, {
                                defaults: {
                                    VIcon: {
                                        icon: n,
                                        size: "x-small"
                                    }
                                }
                            }, {
                                default: () => [i.thumb({
                                    ...b,
                                    icon: n
                                })]
                            }) : y(mi, null, {
                                default: () => [e.loading ? y(Bn, {
                                    name: "v-switch",
                                    active: !0,
                                    color: !1 === v.value ? void 0 : h.value
                                }, {
                                    default: e => i.loader ? i.loader(e) : y(Ln, {
                                        active: e.isActive,
                                        color: e.color,
                                        indeterminate: !0,
                                        size: "16",
                                        width: "2"
                                    }, null)
                                }) : n && y(Cn, {
                                    key: String(n),
                                    icon: n,
                                    size: "x-small"
                                }, null)]
                            })])])
                        }
                    })
                }
            })
        }
        )),
        {}
    }
})
  , Wh = d({
    color: String,
    height: [Number, String],
    window: Boolean,
    ...h(),
    ...$i(),
    ...ne(),
    ...Di(),
    ...ai(),
    ...v()
}, "VSystemBar")
  , Gh = g()({
    name: "VSystemBar",
    props: Wh(),
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {backgroundColorClasses: n, backgroundColorStyles: r} = Mi(W(e, "color"))
          , {elevationClasses: o} = Ui(e)
          , {roundedClasses: s} = Ri(e)
          , {ssrBootStyles: l} = Qi()
          , c = F(( () => e.height ?? (e.window ? 32 : 24)))
          , {layoutItemStyles: u} = se({
            id: e.name,
            order: F(( () => parseInt(e.order, 10))),
            position: j("top"),
            layoutSize: c,
            elementSize: c,
            active: F(( () => !0)),
            absolute: W(e, "absolute")
        });
        return x(( () => y(e.tag, {
            class: ["v-system-bar", {
                "v-system-bar--window": e.window
            }, i.value, n.value, o.value, s.value, e.class],
            style: [r.value, u.value, l.value, e.style]
        }, a))),
        {}
    }
})
  , jh = Symbol.for("vuetify:v-tabs")
  , $h = d({
    fixed: Boolean,
    sliderColor: String,
    hideSlider: Boolean,
    direction: {
        type: String,
        default: "horizontal"
    },
    ...Fe(or({
        selectedClass: "v-tab--selected",
        variant: "text"
    }), ["active", "block", "flat", "location", "position", "symbol"])
}, "VTab")
  , Uh = g()({
    name: "VTab",
    props: $h(),
    setup(e, t) {
        let {slots: a, attrs: i} = t;
        const {textColorClasses: n, textColorStyles: r} = Bi(e, "sliderColor")
          , o = l()
          , s = l()
          , c = F(( () => "horizontal" === e.direction))
          , u = F(( () => {
            var e, t;
            return (null == (t = null == (e = o.value) ? void 0 : e.group) ? void 0 : t.isSelected.value) ?? !1
        }
        ));
        function d(e) {
            var t, a;
            let {value: i} = e;
            if (i) {
                const e = null == (a = null == (t = o.value) ? void 0 : t.$el.parentElement) ? void 0 : a.querySelector(".v-tab--selected .v-tab__slider")
                  , i = s.value;
                if (!e || !i)
                    return;
                const n = getComputedStyle(e).color
                  , r = e.getBoundingClientRect()
                  , l = i.getBoundingClientRect()
                  , u = c.value ? "x" : "y"
                  , d = c.value ? "X" : "Y"
                  , h = c.value ? "right" : "bottom"
                  , p = c.value ? "width" : "height"
                  , v = r[u] > l[u] ? r[h] - l[h] : r[u] - l[u]
                  , g = Math.sign(v) > 0 ? c.value ? "right" : "bottom" : Math.sign(v) < 0 ? c.value ? "left" : "top" : "center"
                  , f = (Math.abs(v) + (Math.sign(v) < 0 ? r[p] : l[p])) / Math.max(r[p], l[p]) || 0
                  , m = r[p] / l[p] || 0
                  , b = 1.5;
                P(i, {
                    backgroundColor: [n, "currentcolor"],
                    transform: [`translate${d}(${v}px) scale${d}(${m})`, `translate${d}(${v / b}px) scale${d}(${(f - 1) / b + 1})`, "none"],
                    transformOrigin: Array(3).fill(g)
                }, {
                    duration: 225,
                    easing: I
                })
            }
        }
        return x(( () => {
            const t = sr.filterProps(e);
            return y(sr, A({
                symbol: jh,
                ref: o,
                class: ["v-tab", e.class],
                style: e.style,
                tabindex: u.value ? 0 : -1,
                role: "tab",
                "aria-selected": String(u.value),
                active: !1
            }, t, i, {
                block: e.fixed,
                maxWidth: e.fixed ? 300 : void 0,
                "onGroup:selected": d
            }), {
                ...a,
                default: () => {
                    var t;
                    return y(Q, null, [(null == (t = a.default) ? void 0 : t.call(a)) ?? e.text, !e.hideSlider && y("div", {
                        ref: s,
                        class: ["v-tab__slider", n.value],
                        style: r.value
                    }, null)])
                }
            })
        }
        )),
        bs({}, o)
    }
});
const qh = d({
    alignTabs: {
        type: String,
        default: "start"
    },
    color: String,
    fixedTabs: Boolean,
    items: {
        type: Array,
        default: () => []
    },
    stacked: Boolean,
    bgColor: String,
    grow: Boolean,
    height: {
        type: [Number, String],
        default: void 0
    },
    hideSlider: Boolean,
    sliderColor: String,
    ...Wr({
        mandatory: "force"
    }),
    ...nn(),
    ...ai()
}, "VTabs")
  , Zh = g()({
    name: "VTabs",
    props: qh(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , n = F(( () => {
            return (t = e.items) ? t.map((e => Le(e) ? e : {
                text: e,
                value: e
            })) : [];
            var t
        }
        ))
          , {densityClasses: r} = rn(e)
          , {backgroundColorClasses: o, backgroundColorStyles: s} = Mi(W(e, "bgColor"));
        return V({
            VTab: {
                color: W(e, "color"),
                direction: W(e, "direction"),
                stacked: W(e, "stacked"),
                fixed: W(e, "fixedTabs"),
                sliderColor: W(e, "sliderColor"),
                hideSlider: W(e, "hideSlider")
            }
        }),
        x(( () => {
            const t = Gr.filterProps(e);
            return y(Gr, A(t, {
                modelValue: i.value,
                "onUpdate:modelValue": e => i.value = e,
                class: ["v-tabs", `v-tabs--${e.direction}`, `v-tabs--align-tabs-${e.alignTabs}`, {
                    "v-tabs--fixed-tabs": e.fixedTabs,
                    "v-tabs--grow": e.grow,
                    "v-tabs--stacked": e.stacked
                }, r.value, o.value, e.class],
                style: [{
                    "--v-tabs-height": B(e.height)
                }, s.value, e.style],
                role: "tablist",
                symbol: jh
            }), {
                default: () => [a.default ? a.default() : n.value.map((e => y(Uh, A(e, {
                    key: e.text
                }), null)))]
            })
        }
        )),
        {}
    }
})
  , Kh = d({
    autoGrow: Boolean,
    autofocus: Boolean,
    counter: [Boolean, Number, String],
    counterValue: Function,
    prefix: String,
    placeholder: String,
    persistentPlaceholder: Boolean,
    persistentCounter: Boolean,
    noResize: Boolean,
    rows: {
        type: [Number, String],
        default: 5,
        validator: e => !isNaN(parseFloat(e))
    },
    maxRows: {
        type: [Number, String],
        validator: e => !isNaN(parseFloat(e))
    },
    suffix: String,
    modelModifiers: Object,
    ...Dr(),
    ...Ps()
}, "VTextarea")
  , Jh = g()({
    name: "VTextarea",
    directives: {
        Intersect: Xi
    },
    inheritAttrs: !1,
    props: Kh(),
    emits: {
        "click:control": e => !0,
        "mousedown:control": e => !0,
        "update:focused": e => !0,
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {attrs: a, emit: i, slots: n} = t;
        const r = re(e, "modelValue")
          , {isFocused: o, focus: s, blur: c} = Er(e)
          , u = F(( () => "function" == typeof e.counterValue ? e.counterValue(r.value) : (r.value || "").toString().length))
          , d = F(( () => a.maxlength ? a.maxlength : !e.counter || "number" != typeof e.counter && "string" != typeof e.counter ? void 0 : e.counter));
        function h(t, a) {
            var i, n;
            e.autofocus && t && (null == (n = null == (i = a[0].target) ? void 0 : i.focus) || n.call(i))
        }
        const p = l()
          , v = l()
          , g = j("")
          , f = l()
          , m = F(( () => e.persistentPlaceholder || o.value || e.active));
        function b() {
            var e;
            f.value !== document.activeElement && (null == (e = f.value) || e.focus()),
            o.value || s()
        }
        function w(e) {
            b(),
            i("click:control", e)
        }
        function k(e) {
            i("mousedown:control", e)
        }
        function S(t) {
            t.stopPropagation(),
            b(),
            q(( () => {
                r.value = "",
                dt(e["onClick:clear"], t)
            }
            ))
        }
        function C(t) {
            var a;
            const i = t.target;
            if (r.value = i.value,
            null == (a = e.modelModifiers) ? void 0 : a.trim) {
                const e = [i.selectionStart, i.selectionEnd];
                q(( () => {
                    i.selectionStart = e[0],
                    i.selectionEnd = e[1]
                }
                ))
            }
        }
        const P = l()
          , L = l(+e.rows)
          , I = F(( () => ["plain", "underlined"].includes(e.variant)));
        function _() {
            e.autoGrow && q(( () => {
                if (!P.value || !v.value)
                    return;
                const t = getComputedStyle(P.value)
                  , a = getComputedStyle(v.value.$el)
                  , i = parseFloat(t.getPropertyValue("--v-field-padding-top")) + parseFloat(t.getPropertyValue("--v-input-padding-top")) + parseFloat(t.getPropertyValue("--v-field-padding-bottom"))
                  , n = P.value.scrollHeight
                  , r = parseFloat(t.lineHeight)
                  , o = Math.max(parseFloat(e.rows) * r + i, parseFloat(a.getPropertyValue("--v-input-control-height")))
                  , s = parseFloat(e.maxRows) * r + i || 1 / 0
                  , l = te(n ?? 0, o, s);
                L.value = Math.floor((l - i) / r),
                g.value = B(l)
            }
            ))
        }
        let T;
        return le(( () => {
            e.autoGrow || (L.value = +e.rows)
        }
        )),
        ae(_),
        $(r, _),
        $(( () => e.rows), _),
        $(( () => e.maxRows), _),
        $(( () => e.density), _),
        $(P, (e => {
            e ? (T = new ResizeObserver(_),
            T.observe(P.value)) : null == T || T.disconnect()
        }
        )),
        Z(( () => {
            null == T || T.disconnect()
        }
        )),
        x(( () => {
            const t = !!(n.counter || e.counter || e.counterValue)
              , i = !(!t && !n.details)
              , [s,l] = Oe(a)
              , {modelValue: x, ..._} = Rr.filterProps(e)
              , T = Is(e);
            return y(Rr, A({
                ref: p,
                modelValue: r.value,
                "onUpdate:modelValue": e => r.value = e,
                class: ["v-textarea v-text-field", {
                    "v-textarea--prefixed": e.prefix,
                    "v-textarea--suffixed": e.suffix,
                    "v-text-field--prefixed": e.prefix,
                    "v-text-field--suffixed": e.suffix,
                    "v-textarea--auto-grow": e.autoGrow,
                    "v-textarea--no-resize": e.noResize || e.autoGrow,
                    "v-input--plain-underlined": I.value
                }, e.class],
                style: e.style
            }, s, _, {
                centerAffix: 1 === L.value && !I.value,
                focused: o.value
            }), {
                ...n,
                default: t => {
                    let {id: a, isDisabled: i, isDirty: s, isReadonly: u, isValid: d} = t;
                    return y(Ls, A({
                        ref: v,
                        style: {
                            "--v-textarea-control-height": g.value
                        },
                        onClick: w,
                        onMousedown: k,
                        "onClick:clear": S,
                        "onClick:prependInner": e["onClick:prependInner"],
                        "onClick:appendInner": e["onClick:appendInner"]
                    }, T, {
                        id: a.value,
                        active: m.value || s.value,
                        centerAffix: 1 === L.value && !I.value,
                        dirty: s.value || e.dirty,
                        disabled: i.value,
                        focused: o.value,
                        error: !1 === d.value
                    }), {
                        ...n,
                        default: t => {
                            let {props: {class: a, ...n}} = t;
                            return y(Q, null, [e.prefix && y("span", {
                                class: "v-text-field__prefix"
                            }, [e.prefix]), K(y("textarea", A({
                                ref: f,
                                class: a,
                                value: r.value,
                                onInput: C,
                                autofocus: e.autofocus,
                                readonly: u.value,
                                disabled: i.value,
                                placeholder: e.placeholder,
                                rows: e.rows,
                                name: e.name,
                                onFocus: b,
                                onBlur: c
                            }, n, l), null), [[J("intersect"), {
                                handler: h
                            }, null, {
                                once: !0
                            }]]), e.autoGrow && K(y("textarea", {
                                class: [a, "v-textarea__sizer"],
                                id: `${n.id}-sizer`,
                                "onUpdate:modelValue": e => r.value = e,
                                ref: P,
                                readonly: !0,
                                "aria-hidden": "true"
                            }, null), [[ea, r.value]]), e.suffix && y("span", {
                                class: "v-text-field__suffix"
                            }, [e.suffix])])
                        }
                    })
                }
                ,
                details: i ? a => {
                    var i;
                    return y(Q, null, [null == (i = n.details) ? void 0 : i.call(n, a), t && y(Q, null, [y("span", null, null), y(ks, {
                        active: e.persistentCounter || o.value,
                        value: u.value,
                        max: d.value
                    }, n.counter)])])
                }
                : void 0
            })
        }
        )),
        bs({}, p, v, f)
    }
})
  , Qh = d({
    withBackground: Boolean,
    ...h(),
    ...v(),
    ...ai()
}, "VThemeProvider")
  , ep = g()({
    name: "VThemeProvider",
    props: Qh(),
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e);
        return () => {
            var t;
            return e.withBackground ? y(e.tag, {
                class: ["v-theme-provider", i.value, e.class],
                style: e.style
            }, {
                default: () => {
                    var e;
                    return [null == (e = a.default) ? void 0 : e.call(a)]
                }
            }) : null == (t = a.default) ? void 0 : t.call(a)
        }
    }
})
  , tp = d({
    align: {
        type: String,
        default: "center",
        validator: e => ["center", "start"].includes(e)
    },
    direction: {
        type: String,
        default: "vertical",
        validator: e => ["vertical", "horizontal"].includes(e)
    },
    justify: {
        type: String,
        default: "auto",
        validator: e => ["auto", "center"].includes(e)
    },
    side: {
        type: String,
        validator: e => null == e || ["start", "end"].includes(e)
    },
    lineInset: {
        type: [String, Number],
        default: 0
    },
    lineThickness: {
        type: [String, Number],
        default: 2
    },
    lineColor: String,
    truncateLine: {
        type: String,
        validator: e => ["start", "end", "both"].includes(e)
    },
    ...h(),
    ...nn(),
    ...ai(),
    ...v()
}, "VTimeline")
  , ap = g()({
    name: "VTimeline",
    props: tp(),
    setup(e, t) {
        let {slots: a} = t;
        const {themeClasses: i} = f(e)
          , {densityClasses: n} = rn(e)
          , {rtlClasses: r} = b();
        V({
            VTimelineDivider: {
                lineColor: W(e, "lineColor")
            },
            VTimelineItem: {
                density: W(e, "density"),
                lineInset: W(e, "lineInset")
            }
        });
        const o = F(( () => {
            const t = e.side ? e.side : "default" !== e.density ? "end" : null;
            return t && `v-timeline--side-${t}`
        }
        ))
          , s = F(( () => {
            const t = ["v-timeline--truncate-line-start", "v-timeline--truncate-line-end"];
            switch (e.truncateLine) {
            case "both":
                return t;
            case "start":
                return t[0];
            case "end":
                return t[1];
            default:
                return null
            }
        }
        ));
        return x(( () => y(e.tag, {
            class: ["v-timeline", `v-timeline--${e.direction}`, `v-timeline--align-${e.align}`, `v-timeline--justify-${e.justify}`, s.value, {
                "v-timeline--inset-line": !!e.lineInset
            }, i.value, n.value, o.value, r.value, e.class],
            style: [{
                "--v-timeline-line-thickness": B(e.lineThickness)
            }, e.style]
        }, a))),
        {}
    }
})
  , ip = d({
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    icon: me,
    iconColor: String,
    lineColor: String,
    ...h(),
    ...Di(),
    ...wn(),
    ...$i()
}, "VTimelineDivider")
  , np = g()({
    name: "VTimelineDivider",
    props: ip(),
    setup(e, t) {
        let {slots: a} = t;
        const {sizeClasses: i, sizeStyles: n} = kn(e, "v-timeline-divider__dot")
          , {backgroundColorStyles: r, backgroundColorClasses: o} = Mi(W(e, "dotColor"))
          , {roundedClasses: s} = Ri(e, "v-timeline-divider__dot")
          , {elevationClasses: l} = Ui(e)
          , {backgroundColorClasses: c, backgroundColorStyles: u} = Mi(W(e, "lineColor"));
        return x(( () => y("div", {
            class: ["v-timeline-divider", {
                "v-timeline-divider--fill-dot": e.fillDot
            }, e.class],
            style: e.style
        }, [y("div", {
            class: ["v-timeline-divider__before", c.value],
            style: u.value
        }, null), !e.hideDot && y("div", {
            key: "dot",
            class: ["v-timeline-divider__dot", l.value, s.value, i.value],
            style: n.value
        }, [y("div", {
            class: ["v-timeline-divider__inner-dot", o.value, s.value],
            style: r.value
        }, [a.default ? y(_i, {
            key: "icon-defaults",
            disabled: !e.icon,
            defaults: {
                VIcon: {
                    color: e.iconColor,
                    icon: e.icon,
                    size: e.size
                }
            }
        }, a.default) : y(Cn, {
            key: "icon",
            color: e.iconColor,
            icon: e.icon,
            size: e.size
        }, null)])]), y("div", {
            class: ["v-timeline-divider__after", c.value],
            style: u.value
        }, null)]))),
        {}
    }
})
  , rp = d({
    density: String,
    dotColor: String,
    fillDot: Boolean,
    hideDot: Boolean,
    hideOpposite: {
        type: Boolean,
        default: void 0
    },
    icon: me,
    iconColor: String,
    lineInset: [Number, String],
    ...h(),
    ...Ti(),
    ...$i(),
    ...Di(),
    ...wn(),
    ...ai()
}, "VTimelineItem")
  , op = g()({
    name: "VTimelineItem",
    props: rp(),
    setup(e, t) {
        let {slots: a} = t;
        const {dimensionStyles: i} = Ei(e)
          , n = j(0)
          , r = l();
        return $(r, (e => {
            var t;
            e && (n.value = (null == (t = e.$el.querySelector(".v-timeline-divider__dot")) ? void 0 : t.getBoundingClientRect().width) ?? 0)
        }
        ), {
            flush: "post"
        }),
        x(( () => {
            var t, o;
            return y("div", {
                class: ["v-timeline-item", {
                    "v-timeline-item--fill-dot": e.fillDot
                }, e.class],
                style: [{
                    "--v-timeline-dot-size": B(n.value),
                    "--v-timeline-line-inset": e.lineInset ? `calc(var(--v-timeline-dot-size) / 2 + ${B(e.lineInset)})` : B(0)
                }, e.style]
            }, [y("div", {
                class: "v-timeline-item__body",
                style: i.value
            }, [null == (t = a.default) ? void 0 : t.call(a)]), y(np, {
                ref: r,
                hideDot: e.hideDot,
                icon: e.icon,
                iconColor: e.iconColor,
                size: e.size,
                elevation: e.elevation,
                dotColor: e.dotColor,
                fillDot: e.fillDot,
                rounded: e.rounded
            }, {
                default: a.icon
            }), "compact" !== e.density && y("div", {
                class: "v-timeline-item__opposite"
            }, [!e.hideOpposite && (null == (o = a.opposite) ? void 0 : o.call(a))])])
        }
        )),
        {}
    }
})
  , sp = d({
    ...h(),
    ...ln({
        variant: "text"
    })
}, "VToolbarItems")
  , lp = g()({
    name: "VToolbarItems",
    props: sp(),
    setup(e, t) {
        let {slots: a} = t;
        return V({
            VBtn: {
                color: W(e, "color"),
                height: "inherit",
                variant: W(e, "variant")
            }
        }),
        x(( () => {
            var t;
            return y("div", {
                class: ["v-toolbar-items", e.class],
                style: e.style
            }, [null == (t = a.default) ? void 0 : t.call(a)])
        }
        )),
        {}
    }
})
  , cp = d({
    id: String,
    text: String,
    ...Fe(vs({
        closeOnBack: !1,
        location: "end",
        locationStrategy: "connected",
        eager: !0,
        minWidth: 0,
        offset: 10,
        openOnClick: !1,
        openOnHover: !0,
        origin: "auto",
        scrim: !1,
        scrollStrategy: "reposition",
        transition: !1
    }), ["absolute", "persistent"])
}, "VTooltip")
  , up = g()({
    name: "VTooltip",
    props: cp(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = re(e, "modelValue")
          , {scopeId: n} = rs()
          , r = ce()
          , o = F(( () => e.id || `v-tooltip-${r}`))
          , s = l()
          , c = F(( () => e.location.split(" ").length > 1 ? e.location : e.location + " center"))
          , u = F(( () => "auto" === e.origin || "overlap" === e.origin || e.origin.split(" ").length > 1 || e.location.split(" ").length > 1 ? e.origin : e.origin + " center"))
          , d = F(( () => e.transition ? e.transition : i.value ? "scale-transition" : "fade-transition"))
          , h = F(( () => A({
            "aria-describedby": o.value
        }, e.activatorProps)));
        return x(( () => {
            const t = gs.filterProps(e);
            return y(gs, A({
                ref: s,
                class: ["v-tooltip", e.class],
                style: e.style,
                id: o.value
            }, t, {
                modelValue: i.value,
                "onUpdate:modelValue": e => i.value = e,
                transition: d.value,
                absolute: !0,
                location: c.value,
                origin: u.value,
                persistent: !0,
                role: "tooltip",
                activatorProps: h.value,
                _disableGlobalStack: !0
            }, n), {
                activator: a.activator,
                default: function() {
                    for (var t, i = arguments.length, n = new Array(i), r = 0; r < i; r++)
                        n[r] = arguments[r];
                    return (null == (t = a.default) ? void 0 : t.call(a, ...n)) ?? e.text
                }
            })
        }
        )),
        bs({}, s)
    }
})
  , dp = g()({
    name: "VValidation",
    props: Br(),
    emits: {
        "update:modelValue": e => !0
    },
    setup(e, t) {
        let {slots: a} = t;
        const i = Mr(e, "validation");
        return () => {
            var e;
            return null == (e = a.default) ? void 0 : e.call(a, i)
        }
    }
});
function hp(e, t) {
    var a;
    (null == (a = e._mutate) ? void 0 : a[t.instance.$.uid]) && (e._mutate[t.instance.$.uid].observer.disconnect(),
    delete e._mutate[t.instance.$.uid])
}
const pp = {
    mounted: function(e, t) {
        const a = t.modifiers || {}
          , i = t.value
          , {once: n, immediate: r, ...o} = a
          , s = !Object.keys(o).length
          , {handler: l, options: c} = "object" == typeof i ? i : {
            handler: i,
            options: {
                attributes: (null == o ? void 0 : o.attr) ?? s,
                characterData: (null == o ? void 0 : o.char) ?? s,
                childList: (null == o ? void 0 : o.child) ?? s,
                subtree: (null == o ? void 0 : o.sub) ?? s
            }
        }
          , u = new MutationObserver((function() {
            null == l || l(arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], arguments.length > 1 ? arguments[1] : void 0),
            n && hp(e, t)
        }
        ));
        r && (null == l || l([], u)),
        e._mutate = Object(e._mutate),
        e._mutate[t.instance.$.uid] = {
            observer: u
        },
        u.observe(e, c)
    },
    unmounted: hp
};
const vp = {
    mounted: function(e, t) {
        var a, i;
        const n = t.value
          , r = {
            passive: !(null == (a = t.modifiers) ? void 0 : a.active)
        };
        window.addEventListener("resize", n, r),
        e._onResize = Object(e._onResize),
        e._onResize[t.instance.$.uid] = {
            handler: n,
            options: r
        },
        (null == (i = t.modifiers) ? void 0 : i.quiet) || n()
    },
    unmounted: function(e, t) {
        var a;
        if (!(null == (a = e._onResize) ? void 0 : a[t.instance.$.uid]))
            return;
        const {handler: i, options: n} = e._onResize[t.instance.$.uid];
        window.removeEventListener("resize", i, n),
        delete e._onResize[t.instance.$.uid]
    }
};
function gp(e, t) {
    const {self: a=!1} = t.modifiers ?? {}
      , i = t.value
      , n = "object" == typeof i && i.options || {
        passive: !0
    }
      , r = "function" == typeof i || "handleEvent"in i ? i : i.handler
      , o = a ? e : t.arg ? document.querySelector(t.arg) : window;
    o && (o.addEventListener("scroll", r, n),
    e._onScroll = Object(e._onScroll),
    e._onScroll[t.instance.$.uid] = {
        handler: r,
        options: n,
        target: a ? void 0 : o
    })
}
function fp(e, t) {
    var a;
    if (!(null == (a = e._onScroll) ? void 0 : a[t.instance.$.uid]))
        return;
    const {handler: i, options: n, target: r=e} = e._onScroll[t.instance.$.uid];
    r.removeEventListener("scroll", i, n),
    delete e._onScroll[t.instance.$.uid]
}
const mp = {
    mounted: gp,
    unmounted: fp,
    updated: function(e, t) {
        t.value !== t.oldValue && (fp(e, t),
        gp(e, t))
    }
}
  , bp = {
    name: "DefaultTheme",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        "carousel-control-size": 10,
        gradient: "linear-gradient(to right, #3F78FF, #4680FF)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#4680FF",
        secondary: "#5B6B79",
        info: "#3ec9d6",
        success: "#2ca87f",
        warning: "#e58a00",
        error: "#dc2626",
        lightprimary: "#E9F0FF",
        lightsecondary: "#F8F9FA",
        lightsuccess: "#c0e5d9",
        lightinfo: "#c5eff3",
        lighterror: "#f5bebe",
        lightwarning: "#f7dcb3",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        darkprimary: "#3F78FF",
        darksecondary: "#3E4853",
        darkinfo: "#30bccc",
        darksuccess: "#21976c",
        darkwarning: "#de7700",
        darkerror: "#d31c1c",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#b8ceff",
        secondary200: "#d8dadd",
        warning200: "#faaf00"
    }
}
  , xp = {
    name: "LightTheme1",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #254EDB, #3366FF)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#3366FF",
        secondary: "#5B6B79",
        info: "#549BFF",
        success: "#58D62A",
        warning: "#FFB814",
        error: "#FF4528",
        lightprimary: "#D6E4FF",
        lightsecondary: "#F8F9FA",
        lightsuccess: "#EAFCD4",
        lightinfo: "#DCF0FF",
        lighterror: "#FFE7D3",
        lightwarning: "#FFF6D0",
        darkprimary: "#254EDB",
        darksecondary: "#3E4853",
        darkinfo: "#3D78DB",
        darksuccess: "#3DB81E",
        darkwarning: "#DB970E",
        darkerror: "#DB271D",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#ADC8FF",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , yp = {
    name: "LightTheme2",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #6A5DE3, #7265E6)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#7265E6",
        secondary: "#5B6B79",
        info: "#00a2ae",
        success: "#00A854",
        warning: "#FFBF00",
        error: "#F04134",
        lightprimary: "#EEEDFC",
        lightsecondary: "#F8F9FA",
        lightinfo: "#E0F4F5",
        lightsuccess: "#E0F5EA",
        lighterror: "#FDE8E7",
        lightwarning: "#FFF7E0",
        darkprimary: "#6A5DE3",
        darksecondary: "#3E4853",
        darkinfo: "#009AA7",
        darksuccess: "#00A04D",
        darkwarning: "#FFB900",
        darkerror: "#EE3B2F",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#B9B2F3",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , wp = {
    name: "LightTheme3",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #006933, #068e44)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#068e44",
        secondary: "#5B6B79",
        info: "#00A2AE",
        success: "#00A854",
        warning: "#FFBF00",
        error: "#F04134",
        lightprimary: "#E6F3EC",
        lightsecondary: "#F8F9FA",
        lightsuccess: "#E0F5EA",
        lightinfo: "#E0F4F5",
        lighterror: "#FDE8E7",
        lightwarning: "#FFF7E0",
        darkprimary: "#006933",
        darksecondary: "#3E4853",
        darkinfo: "#009AA7",
        darksuccess: "#00A04D",
        darkwarning: "#FFB900",
        darkerror: "#EE3B2F",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#5eb57d",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , kp = {
    name: "LightTheme4",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #2947ab, #3c64d0)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#3c64d0",
        secondary: "#5B6B79",
        info: "#00A2AE",
        success: "#00A854",
        warning: "#FFBF00",
        error: "#F04134",
        lightprimary: "#f0f6ff",
        lightsecondary: "#F8F9FA",
        lightsuccess: "#E0F5EA",
        lightinfo: "#E0F4F5",
        lighterror: "#FDE8E7",
        lightwarning: "#FFF7E0",
        darkprimary: "#2947ab",
        darksecondary: "#3E4853",
        darkinfo: "#009AA7",
        darksuccess: "#00A04D",
        darkwarning: "#FFB900",
        darkerror: "#EE3B2F",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#bed3f7",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , Sp = {
    name: "LightTheme5",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #cc5206, #f27013)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#f27013",
        secondary: "#5B6B79",
        info: "#00A2AE",
        success: "#00A854",
        warning: "#FFBF00",
        error: "#F04134",
        lightprimary: "#fff4e6",
        lightsecondary: "#F8F9FA",
        lightinfo: "#E0F4F5",
        lightsuccess: "#E0F5EA",
        lighterror: "#FDE8E7",
        lightwarning: "#FFF7E0",
        darkprimary: "#cc5206",
        darksecondary: "#3E4853",
        darkinfo: "#009AA7",
        darksuccess: "#00A04D",
        darkwarning: "#FFB900",
        darkerror: "#EE3B2F",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#ffc98f",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , Cp = {
    name: "LightTheme6",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #1a7b8a, #2aa1af)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#2aa1af",
        secondary: "#5B6B79",
        info: "#00A2AE",
        success: "#00A854",
        warning: "#FFBF00",
        error: "#F04134",
        lightprimary: "#e1f0ef",
        lightsecondary: "#F8F9FA",
        lightinfo: "#E0F4F5",
        lightsuccess: "#E0F5EA",
        lighterror: "#FDE8E7",
        lightwarning: "#FFF7E0",
        darkprimary: "#1a7b8a",
        darksecondary: "#3E4853",
        darkinfo: "#009AA7",
        darksuccess: "#00A04D",
        darkwarning: "#FFB900",
        darkerror: "#EE3B2F",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#9ad6d6",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , Ap = {
    name: "LightTheme7",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #008245, #00a854)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#00a854",
        secondary: "#5B6B79",
        info: "#00A2AE",
        success: "#00A854",
        warning: "#FFBF00",
        error: "#F04134",
        lightprimary: "#d1e8d99c",
        lightsecondary: "#F8F9FA",
        lightinfo: "#E0F4F5",
        lightsuccess: "#E0F5EA",
        lighterror: "#FDE8E7",
        lightwarning: "#FFF7E0",
        darkprimary: "#008245",
        darksecondary: "#3E4853",
        darkinfo: "#009AA7",
        darksuccess: "#00A04D",
        darkwarning: "#FFB900",
        darkerror: "#EE3B2F",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#63cf8e",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , Pp = {
    name: "LightTheme8",
    dark: !1,
    variables: {
        "border-color": "#e8ebee",
        gradient: "linear-gradient(to right, #007069, #009688)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.08)"
    },
    colors: {
        primary: "#009688",
        secondary: "#5B6B79",
        info: "#00A2AE",
        success: "#00A854",
        warning: "#FFBF00",
        error: "#F04134",
        lightprimary: "#c1d6d066",
        lightsecondary: "#F8F9FA",
        lightinfo: "#E0F4F5",
        lightsuccess: "#E0F5EA",
        lighterror: "#FDE8E7",
        lightwarning: "#FFF7E0",
        darkprimary: "#007069",
        darksecondary: "#3E4853",
        darkinfo: "#009AA7",
        darksuccess: "#00A04D",
        darkwarning: "#FFB900",
        darkerror: "#EE3B2F",
        darkText: "#1D2630",
        lightText: "#5B6B79",
        borderLight: "#e8ebee",
        inputBorder: "#BEC8D0",
        containerBg: "#F8F9FA",
        surface: "#fff",
        "on-surface-variant": "#fff",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#f3f5f7",
        primary200: "#5bbda9",
        secondary200: "#F3F5F7",
        warning200: "#faaf00"
    }
}
  , Lp = {
    name: "DarkDefaultTheme",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #7EA6FF, #6293FF)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.35)"
    },
    colors: {
        primary: "#6293FF",
        secondary: "#5b6b79",
        info: "#3ec9d6",
        success: "#2ca87f",
        warning: "#e58a00",
        error: "#dc2626",
        lightprimary: "#18243e",
        lightsecondary: "#131920",
        lightsuccess: "#e5f4ef",
        lightinfo: "#1ba9bc",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#3F78FF",
        darksecondary: "#5B6B79",
        darkinfo: "#30bccc",
        darksuccess: "#21976c",
        darkwarning: "#de7700",
        darkerror: "#d31c1c",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#376DFF",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Ip = {
    name: "DarkTheme1",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #567fe9, #305bdd)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#305bdd",
        secondary: "#5b6b79",
        info: "#4c88dd",
        success: "#4fba28",
        warning: "#dda116",
        error: "#dd3f27",
        lightprimary: "#1c2134",
        lightsecondary: "#131920",
        lightinfo: "#202734",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#273e83",
        darksecondary: "#5B6B79",
        darkinfo: "#416fb0",
        darksuccess: "#449626",
        darkwarning: "#83631a",
        darkerror: "#b03725",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#243462",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , _p = {
    name: "DarkTheme2",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #9186dd, #655ac8)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#655ac8",
        secondary: "#5b6b79",
        info: "#058e98",
        success: "#05934c",
        warning: "#dda705",
        error: "#d13c31",
        lightprimary: "#222130",
        lightsecondary: "#131920",
        lightinfo: "#1a2628",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#443e78",
        darksecondary: "#5B6B79",
        darkinfo: "#11595f",
        darksuccess: "#115c36",
        darkwarning: "#836611",
        darkerror: "#7d2e28",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#37335a",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Tp = {
    name: "DarkTheme3",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #1f8f4e, #0a7d3e)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#0a7d3e",
        secondary: "#5b6b79",
        info: "#058e98",
        success: "#05934c",
        warning: "#dda705",
        error: "#d13c31",
        lightprimary: "#1a231f",
        lightsecondary: "#131920",
        lightinfo: "#1a2628",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#13502f",
        darksecondary: "#5B6B79",
        darkinfo: "#11595f",
        darksuccess: "#115c36",
        darkwarning: "#836611",
        darkerror: "#7d2e28",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#174029",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Ep = {
    name: "DarkTheme4",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #5d7dcb, #385ab5)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#385ab5",
        secondary: "#5b6b79",
        info: "#058e98",
        success: "#05934c",
        warning: "#dda705",
        error: "#d13c31",
        lightprimary: "#1d212d",
        lightsecondary: "#131920",
        lightinfo: "#1a2628",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#2c3e6e",
        darksecondary: "#5B6B79",
        darkinfo: "#11595f",
        darksuccess: "#115c36",
        darkwarning: "#836611",
        darkerror: "#7d2e28",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#273353",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Op = {
    name: "DarkTheme5",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #e9883a, #d26415)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#d26415",
        secondary: "#5b6b79",
        info: "#058e98",
        success: "#05934c",
        warning: "#dda705",
        error: "#d13c31",
        lightprimary: "#32221a",
        lightsecondary: "#131920",
        lightinfo: "#1a2628",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#7d4319",
        darksecondary: "#5B6B79",
        darkinfo: "#11595f",
        darksuccess: "#115c36",
        darkwarning: "#836611",
        darkerror: "#7d2e28",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#5e371b",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Vp = {
    name: "DarkTheme6",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #47a6ad, #288d99)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#288d99",
        secondary: "#5b6b79",
        info: "#058e98",
        success: "#05934c",
        warning: "#dda705",
        error: "#d13c31",
        lightprimary: "#1c2628",
        lightsecondary: "#131920",
        lightinfo: "#1a2628",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#23595f",
        darksecondary: "#5B6B79",
        darkinfo: "#11595f",
        darksuccess: "#115c36",
        darkwarning: "#836611",
        darkerror: "#7d2e28",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#22454a",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Fp = {
    name: "DarkTheme7",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #1da65d, #05934c)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#05934c",
        secondary: "#5b6b79",
        info: "#058e98",
        success: "#05934c",
        warning: "#dda705",
        error: "#d13c31",
        lightprimary: "#1a2721",
        lightsecondary: "#131920",
        lightinfo: "#1a2628",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#115c36",
        darksecondary: "#5B6B79",
        darkinfo: "#11595f",
        darksuccess: "#115c36",
        darkwarning: "#836611",
        darkerror: "#7d2e28",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#15472e",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Bp = {
    name: "DarkTheme8",
    dark: !0,
    variables: {
        "border-color": "#3E4853",
        gradient: "linear-gradient(to right, #1a9686, #058478)",
        "card-shadow": "0px 8px 24px rgba(19, 25, 32, 0.47)"
    },
    colors: {
        primary: "#058478",
        secondary: "#5b6b79",
        info: "#058e98",
        success: "#05934c",
        warning: "#dda705",
        error: "#d13c31",
        lightprimary: "#1a2524",
        lightsecondary: "#131920",
        lightinfo: "#1a2628",
        lightsuccess: "#e5f4ef",
        lighterror: "#c3a4a4",
        lightwarning: "#fbf1e0",
        darkprimary: "#11544e",
        darksecondary: "#5B6B79",
        darkinfo: "#11595f",
        darksuccess: "#115c36",
        darkwarning: "#836611",
        darkerror: "#7d2e28",
        darkText: "#dadcde",
        lightText: "#798491",
        borderLight: "#29313b",
        inputBorder: "#3E4853",
        containerBg: "#131920",
        surface: "#1D2630",
        background: "#1D2630",
        "on-surface-variant": "#1D2630",
        facebook: "#4267b2",
        twitter: "#1da1f2",
        linkedin: "#0e76a8",
        gray100: "#1D2630",
        primary200: "#15423e",
        secondary200: "#3E4853",
        warning200: "#faaf00"
    }
}
  , Mp = ra({
    components: Object.freeze(Object.defineProperty({
        __proto__: null,
        VAlert: vr,
        VAlertTitle: dr,
        VApp: ti,
        VAppBar: tn,
        VAppBarNavIcon: cr,
        VAppBarTitle: ur,
        VAutocomplete: js,
        VAvatar: fr,
        VBadge: Us,
        VBanner: Qs,
        VBannerActions: Zs,
        VBannerText: Ks,
        VBottomNavigation: tl,
        VBottomSheet: rl,
        VBreadcrumbs: dl,
        VBreadcrumbsDivider: sl,
        VBreadcrumbsItem: cl,
        VBtn: sr,
        VBtnGroup: dn,
        VBtnToggle: xn,
        VCard: xl,
        VCardActions: hl,
        VCardItem: fl,
        VCardSubtitle: pl,
        VCardText: ml,
        VCardTitle: vl,
        VCarousel: Il,
        VCarouselItem: Ol,
        VCheckbox: zr,
        VCheckboxBtn: Pr,
        VChip: Zr,
        VChipGroup: Ur,
        VClassIcon: ta,
        VCode: Vl,
        VCol: Mu,
        VColorPicker: oc,
        VCombobox: lc,
        VComponentIcon: aa,
        VContainer: Iu,
        VCounter: ks,
        VDataIterator: Yc,
        VDataTable: ku,
        VDataTableFooter: $c,
        VDataTableHeaders: lu,
        VDataTableRow: hu,
        VDataTableRows: vu,
        VDataTableServer: Pu,
        VDataTableVirtual: Cu,
        VDatePicker: fd,
        VDatePickerControls: ad,
        VDatePickerHeader: nd,
        VDatePickerMonth: sd,
        VDatePickerMonths: cd,
        VDatePickerYears: dd,
        VDefaultsProvider: _i,
        VDialog: il,
        VDialogBottomTransition: vi,
        VDialogTopTransition: gi,
        VDialogTransition: ui,
        VDivider: wo,
        VExpandTransition: Pi,
        VExpandXTransition: Li,
        VExpansionPanel: Pd,
        VExpansionPanelText: kd,
        VExpansionPanelTitle: Cd,
        VExpansionPanels: yd,
        VFabTransition: pi,
        VFadeTransition: fi,
        VField: Ls,
        VFieldLabel: Cs,
        VFileInput: Id,
        VFooter: Td,
        VForm: Od,
        VHover: Fd,
        VIcon: Cn,
        VImg: Wi,
        VInfiniteScroll: Dd,
        VInput: Rr,
        VItem: Hd,
        VItemGroup: zd,
        VKbd: Xd,
        VLabel: br,
        VLayout: Wd,
        VLayoutItem: jd,
        VLazy: Ud,
        VLigatureIcon: ia,
        VList: Eo,
        VListGroup: po,
        VListImg: Oo,
        VListItem: mo,
        VListItemAction: Fo,
        VListItemMedia: Mo,
        VListItemSubtitle: vo,
        VListItemTitle: go,
        VListSubheader: xo,
        VLocaleProvider: Zd,
        VMain: Jd,
        VMenu: ys,
        VMessages: _r,
        VNavigationDrawer: rh,
        VNoSsr: oh,
        VOtpInput: lh,
        VOverlay: gs,
        VPagination: Gc,
        VParallax: uh,
        VProgressCircular: Ln,
        VProgressLinear: On,
        VRadio: hh,
        VRadioGroup: vh,
        VRangeSlider: fh,
        VRating: bh,
        VResponsive: Vi,
        VRow: Qu,
        VScaleTransition: mi,
        VScrollXReverseTransition: xi,
        VScrollXTransition: bi,
        VScrollYReverseTransition: wi,
        VScrollYTransition: yi,
        VSelect: Hs,
        VSelectionControl: Cr,
        VSelectionControlGroup: kr,
        VSheet: rc,
        VSkeletonLoader: Ah,
        VSlideGroup: Gr,
        VSlideGroupItem: Ph,
        VSlideXReverseTransition: Si,
        VSlideXTransition: ki,
        VSlideYReverseTransition: Ai,
        VSlideYTransition: Ci,
        VSlider: ec,
        VSnackbar: Ih,
        VSpacer: ed,
        VStepper: Hh,
        VStepperActions: Th,
        VStepperHeader: Eh,
        VStepperItem: Vh,
        VStepperWindow: Mh,
        VStepperWindowItem: Rh,
        VSvgIcon: na,
        VSwitch: Yh,
        VSystemBar: Gh,
        VTab: Uh,
        VTable: fu,
        VTabs: Zh,
        VTextField: Es,
        VTextarea: Jh,
        VThemeProvider: ep,
        VTimeline: ap,
        VTimelineItem: op,
        VToolbar: Ki,
        VToolbarItems: lp,
        VToolbarTitle: ni,
        VTooltip: up,
        VValidation: dp,
        VVirtualScroll: Ds,
        VWindow: Pl,
        VWindowItem: Tl
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    directives: Object.freeze(Object.defineProperty({
        __proto__: null,
        ClickOutside: hs,
        Intersect: Xi,
        Mutate: pp,
        Resize: vp,
        Ripple: rr,
        Scroll: mp,
        Touch: wl
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    theme: {
        defaultTheme: (null == (t = window.APP_CONFIG) ? void 0 : t.theme) || "DefaultTheme",
        themes: {
            DefaultTheme: bp,
            LightTheme1: xp,
            LightTheme2: yp,
            LightTheme3: wp,
            LightTheme4: kp,
            LightTheme5: Sp,
            LightTheme6: Cp,
            LightTheme7: Ap,
            LightTheme8: Pp,
            DarkDefaultTheme: Lp,
            DarkTheme1: Ip,
            DarkTheme8: Bp,
            DarkTheme7: Fp,
            DarkTheme6: Vp,
            DarkTheme5: Op,
            DarkTheme2: _p,
            DarkTheme3: Tp,
            DarkTheme4: Ep
        }
    },
    defaults: {
        VBtn: {},
        VCard: {
            rounded: "md"
        },
        VTextField: {
            rounded: "lg"
        },
        VTooltip: {
            location: "top"
        }
    }
});
function Dp(e) {
    return getComputedStyle(e)
}
function Rp(e, t) {
    for (var a in t) {
        var i = t[a];
        "number" == typeof i && (i += "px"),
        e.style[a] = i
    }
    return e
}
function Np(e) {
    var t = document.createElement("div");
    return t.className = e,
    t
}
var zp = "undefined" != typeof Element && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);
function Hp(e, t) {
    if (!zp)
        throw new Error("No element matching method supported");
    return zp.call(e, t)
}
function Xp(e) {
    e.remove ? e.remove() : e.parentNode && e.parentNode.removeChild(e)
}
function Yp(e, t) {
    return Array.prototype.filter.call(e.children, (function(e) {
        return Hp(e, t)
    }
    ))
}
var Wp = "ps"
  , Gp = "ps__rtl"
  , jp = {
    thumb: function(e) {
        return "ps__thumb-" + e
    },
    rail: function(e) {
        return "ps__rail-" + e
    },
    consuming: "ps__child--consume"
}
  , $p = {
    focus: "ps--focus",
    clicking: "ps--clicking",
    active: function(e) {
        return "ps--active-" + e
    },
    scrolling: function(e) {
        return "ps--scrolling-" + e
    }
}
  , Up = {
    x: null,
    y: null
};
function qp(e, t) {
    var a = e.element.classList
      , i = $p.scrolling(t);
    a.contains(i) ? clearTimeout(Up[t]) : a.add(i)
}
function Zp(e, t) {
    Up[t] = setTimeout((function() {
        return e.isAlive && e.element.classList.remove($p.scrolling(t))
    }
    ), e.settings.scrollingThreshold)
}
var Kp = function(e) {
    this.element = e,
    this.handlers = {}
}
  , Jp = {
    isEmpty: {
        configurable: !0
    }
};
Kp.prototype.bind = function(e, t) {
    void 0 === this.handlers[e] && (this.handlers[e] = []),
    this.handlers[e].push(t),
    this.element.addEventListener(e, t, !1)
}
,
Kp.prototype.unbind = function(e, t) {
    var a = this;
    this.handlers[e] = this.handlers[e].filter((function(i) {
        return !(!t || i === t) || (a.element.removeEventListener(e, i, !1),
        !1)
    }
    ))
}
,
Kp.prototype.unbindAll = function() {
    for (var e in this.handlers)
        this.unbind(e)
}
,
Jp.isEmpty.get = function() {
    var e = this;
    return Object.keys(this.handlers).every((function(t) {
        return 0 === e.handlers[t].length
    }
    ))
}
,
Object.defineProperties(Kp.prototype, Jp);
var Qp = function() {
    this.eventElements = []
};
function ev(e) {
    if ("function" == typeof window.CustomEvent)
        return new CustomEvent(e);
    var t = document.createEvent("CustomEvent");
    return t.initCustomEvent(e, !1, !1, void 0),
    t
}
function tv(e, t, a, i, n) {
    var r;
    if (void 0 === i && (i = !0),
    void 0 === n && (n = !1),
    "top" === t)
        r = ["contentHeight", "containerHeight", "scrollTop", "y", "up", "down"];
    else {
        if ("left" !== t)
            throw new Error("A proper axis should be provided");
        r = ["contentWidth", "containerWidth", "scrollLeft", "x", "left", "right"]
    }
    !function(e, t, a, i, n) {
        var r = a[0]
          , o = a[1]
          , s = a[2]
          , l = a[3]
          , c = a[4]
          , u = a[5];
        void 0 === i && (i = !0);
        void 0 === n && (n = !1);
        var d = e.element;
        e.reach[l] = null,
        d[s] < 1 && (e.reach[l] = "start");
        d[s] > e[r] - e[o] - 1 && (e.reach[l] = "end");
        t && (d.dispatchEvent(ev("ps-scroll-" + l)),
        t < 0 ? d.dispatchEvent(ev("ps-scroll-" + c)) : t > 0 && d.dispatchEvent(ev("ps-scroll-" + u)),
        i && function(e, t) {
            qp(e, t),
            Zp(e, t)
        }(e, l));
        e.reach[l] && (t || n) && d.dispatchEvent(ev("ps-" + l + "-reach-" + e.reach[l]))
    }(e, a, r, i, n)
}
function av(e) {
    return parseInt(e, 10) || 0
}
Qp.prototype.eventElement = function(e) {
    var t = this.eventElements.filter((function(t) {
        return t.element === e
    }
    ))[0];
    return t || (t = new Kp(e),
    this.eventElements.push(t)),
    t
}
,
Qp.prototype.bind = function(e, t, a) {
    this.eventElement(e).bind(t, a)
}
,
Qp.prototype.unbind = function(e, t, a) {
    var i = this.eventElement(e);
    i.unbind(t, a),
    i.isEmpty && this.eventElements.splice(this.eventElements.indexOf(i), 1)
}
,
Qp.prototype.unbindAll = function() {
    this.eventElements.forEach((function(e) {
        return e.unbindAll()
    }
    )),
    this.eventElements = []
}
,
Qp.prototype.once = function(e, t, a) {
    var i = this.eventElement(e)
      , n = function(e) {
        i.unbind(t, n),
        a(e)
    };
    i.bind(t, n)
}
;
var iv = {
    isWebKit: "undefined" != typeof document && "WebkitAppearance"in document.documentElement.style,
    supportsTouch: "undefined" != typeof window && ("ontouchstart"in window || "maxTouchPoints"in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),
    supportsIePointer: "undefined" != typeof navigator && navigator.msMaxTouchPoints,
    isChrome: "undefined" != typeof navigator && /Chrome/i.test(navigator && navigator.userAgent)
};
function nv(e) {
    var t = e.element
      , a = Math.floor(t.scrollTop)
      , i = t.getBoundingClientRect();
    e.containerWidth = Math.round(i.width),
    e.containerHeight = Math.round(i.height),
    e.contentWidth = t.scrollWidth,
    e.contentHeight = t.scrollHeight,
    t.contains(e.scrollbarXRail) || (Yp(t, jp.rail("x")).forEach((function(e) {
        return Xp(e)
    }
    )),
    t.appendChild(e.scrollbarXRail)),
    t.contains(e.scrollbarYRail) || (Yp(t, jp.rail("y")).forEach((function(e) {
        return Xp(e)
    }
    )),
    t.appendChild(e.scrollbarYRail)),
    !e.settings.suppressScrollX && e.containerWidth + e.settings.scrollXMarginOffset < e.contentWidth ? (e.scrollbarXActive = !0,
    e.railXWidth = e.containerWidth - e.railXMarginWidth,
    e.railXRatio = e.containerWidth / e.railXWidth,
    e.scrollbarXWidth = rv(e, av(e.railXWidth * e.containerWidth / e.contentWidth)),
    e.scrollbarXLeft = av((e.negativeScrollAdjustment + t.scrollLeft) * (e.railXWidth - e.scrollbarXWidth) / (e.contentWidth - e.containerWidth))) : e.scrollbarXActive = !1,
    !e.settings.suppressScrollY && e.containerHeight + e.settings.scrollYMarginOffset < e.contentHeight ? (e.scrollbarYActive = !0,
    e.railYHeight = e.containerHeight - e.railYMarginHeight,
    e.railYRatio = e.containerHeight / e.railYHeight,
    e.scrollbarYHeight = rv(e, av(e.railYHeight * e.containerHeight / e.contentHeight)),
    e.scrollbarYTop = av(a * (e.railYHeight - e.scrollbarYHeight) / (e.contentHeight - e.containerHeight))) : e.scrollbarYActive = !1,
    e.scrollbarXLeft >= e.railXWidth - e.scrollbarXWidth && (e.scrollbarXLeft = e.railXWidth - e.scrollbarXWidth),
    e.scrollbarYTop >= e.railYHeight - e.scrollbarYHeight && (e.scrollbarYTop = e.railYHeight - e.scrollbarYHeight),
    function(e, t) {
        var a = {
            width: t.railXWidth
        }
          , i = Math.floor(e.scrollTop);
        t.isRtl ? a.left = t.negativeScrollAdjustment + e.scrollLeft + t.containerWidth - t.contentWidth : a.left = e.scrollLeft;
        t.isScrollbarXUsingBottom ? a.bottom = t.scrollbarXBottom - i : a.top = t.scrollbarXTop + i;
        Rp(t.scrollbarXRail, a);
        var n = {
            top: i,
            height: t.railYHeight
        };
        t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + e.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - e.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + e.scrollLeft + 2 * t.containerWidth - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + e.scrollLeft;
        Rp(t.scrollbarYRail, n),
        Rp(t.scrollbarX, {
            left: t.scrollbarXLeft,
            width: t.scrollbarXWidth - t.railBorderXWidth
        }),
        Rp(t.scrollbarY, {
            top: t.scrollbarYTop,
            height: t.scrollbarYHeight - t.railBorderYWidth
        })
    }(t, e),
    e.scrollbarXActive ? t.classList.add($p.active("x")) : (t.classList.remove($p.active("x")),
    e.scrollbarXWidth = 0,
    e.scrollbarXLeft = 0,
    t.scrollLeft = !0 === e.isRtl ? e.contentWidth : 0),
    e.scrollbarYActive ? t.classList.add($p.active("y")) : (t.classList.remove($p.active("y")),
    e.scrollbarYHeight = 0,
    e.scrollbarYTop = 0,
    t.scrollTop = 0)
}
function rv(e, t) {
    return e.settings.minScrollbarLength && (t = Math.max(t, e.settings.minScrollbarLength)),
    e.settings.maxScrollbarLength && (t = Math.min(t, e.settings.maxScrollbarLength)),
    t
}
function ov(e, t) {
    var a = t[0]
      , i = t[1]
      , n = t[2]
      , r = t[3]
      , o = t[4]
      , s = t[5]
      , l = t[6]
      , c = t[7]
      , u = t[8]
      , d = e.element
      , h = null
      , p = null
      , v = null;
    function g(t) {
        t.touches && t.touches[0] && (t[n] = t.touches[0].pageY),
        d[l] = h + v * (t[n] - p),
        qp(e, c),
        nv(e),
        t.stopPropagation(),
        t.type.startsWith("touch") && t.changedTouches.length > 1 && t.preventDefault()
    }
    function f() {
        Zp(e, c),
        e[u].classList.remove($p.clicking),
        e.event.unbind(e.ownerDocument, "mousemove", g)
    }
    function m(t, o) {
        h = d[l],
        o && t.touches && (t[n] = t.touches[0].pageY),
        p = t[n],
        v = (e[i] - e[a]) / (e[r] - e[s]),
        o ? e.event.bind(e.ownerDocument, "touchmove", g) : (e.event.bind(e.ownerDocument, "mousemove", g),
        e.event.once(e.ownerDocument, "mouseup", f),
        t.preventDefault()),
        e[u].classList.add($p.clicking),
        t.stopPropagation()
    }
    e.event.bind(e[o], "mousedown", (function(e) {
        m(e)
    }
    )),
    e.event.bind(e[o], "touchstart", (function(e) {
        m(e, !0)
    }
    ))
}
var sv = {
    "click-rail": function(e) {
        e.element,
        e.event.bind(e.scrollbarY, "mousedown", (function(e) {
            return e.stopPropagation()
        }
        )),
        e.event.bind(e.scrollbarYRail, "mousedown", (function(t) {
            var a = t.pageY - window.pageYOffset - e.scrollbarYRail.getBoundingClientRect().top > e.scrollbarYTop ? 1 : -1;
            e.element.scrollTop += a * e.containerHeight,
            nv(e),
            t.stopPropagation()
        }
        )),
        e.event.bind(e.scrollbarX, "mousedown", (function(e) {
            return e.stopPropagation()
        }
        )),
        e.event.bind(e.scrollbarXRail, "mousedown", (function(t) {
            var a = t.pageX - window.pageXOffset - e.scrollbarXRail.getBoundingClientRect().left > e.scrollbarXLeft ? 1 : -1;
            e.element.scrollLeft += a * e.containerWidth,
            nv(e),
            t.stopPropagation()
        }
        ))
    },
    "drag-thumb": function(e) {
        ov(e, ["containerWidth", "contentWidth", "pageX", "railXWidth", "scrollbarX", "scrollbarXWidth", "scrollLeft", "x", "scrollbarXRail"]),
        ov(e, ["containerHeight", "contentHeight", "pageY", "railYHeight", "scrollbarY", "scrollbarYHeight", "scrollTop", "y", "scrollbarYRail"])
    },
    keyboard: function(e) {
        var t = e.element;
        e.event.bind(e.ownerDocument, "keydown", (function(a) {
            if (!(a.isDefaultPrevented && a.isDefaultPrevented() || a.defaultPrevented) && (Hp(t, ":hover") || Hp(e.scrollbarX, ":focus") || Hp(e.scrollbarY, ":focus"))) {
                var i, n = document.activeElement ? document.activeElement : e.ownerDocument.activeElement;
                if (n) {
                    if ("IFRAME" === n.tagName)
                        n = n.contentDocument.activeElement;
                    else
                        for (; n.shadowRoot; )
                            n = n.shadowRoot.activeElement;
                    if (Hp(i = n, "input,[contenteditable]") || Hp(i, "select,[contenteditable]") || Hp(i, "textarea,[contenteditable]") || Hp(i, "button,[contenteditable]"))
                        return
                }
                var r = 0
                  , o = 0;
                switch (a.which) {
                case 37:
                    r = a.metaKey ? -e.contentWidth : a.altKey ? -e.containerWidth : -30;
                    break;
                case 38:
                    o = a.metaKey ? e.contentHeight : a.altKey ? e.containerHeight : 30;
                    break;
                case 39:
                    r = a.metaKey ? e.contentWidth : a.altKey ? e.containerWidth : 30;
                    break;
                case 40:
                    o = a.metaKey ? -e.contentHeight : a.altKey ? -e.containerHeight : -30;
                    break;
                case 32:
                    o = a.shiftKey ? e.containerHeight : -e.containerHeight;
                    break;
                case 33:
                    o = e.containerHeight;
                    break;
                case 34:
                    o = -e.containerHeight;
                    break;
                case 36:
                    o = e.contentHeight;
                    break;
                case 35:
                    o = -e.contentHeight;
                    break;
                default:
                    return
                }
                e.settings.suppressScrollX && 0 !== r || e.settings.suppressScrollY && 0 !== o || (t.scrollTop -= o,
                t.scrollLeft += r,
                nv(e),
                function(a, i) {
                    var n = Math.floor(t.scrollTop);
                    if (0 === a) {
                        if (!e.scrollbarYActive)
                            return !1;
                        if (0 === n && i > 0 || n >= e.contentHeight - e.containerHeight && i < 0)
                            return !e.settings.wheelPropagation
                    }
                    var r = t.scrollLeft;
                    if (0 === i) {
                        if (!e.scrollbarXActive)
                            return !1;
                        if (0 === r && a < 0 || r >= e.contentWidth - e.containerWidth && a > 0)
                            return !e.settings.wheelPropagation
                    }
                    return !0
                }(r, o) && a.preventDefault())
            }
        }
        ))
    },
    wheel: function(e) {
        var t = e.element;
        function a(a) {
            var i = function(e) {
                var t = e.deltaX
                  , a = -1 * e.deltaY;
                return void 0 !== t && void 0 !== a || (t = -1 * e.wheelDeltaX / 6,
                a = e.wheelDeltaY / 6),
                e.deltaMode && 1 === e.deltaMode && (t *= 10,
                a *= 10),
                t != t && a != a && (t = 0,
                a = e.wheelDelta),
                e.shiftKey ? [-a, -t] : [t, a]
            }(a)
              , n = i[0]
              , r = i[1];
            if (!function(e, a, i) {
                if (!iv.isWebKit && t.querySelector("select:focus"))
                    return !0;
                if (!t.contains(e))
                    return !1;
                for (var n = e; n && n !== t; ) {
                    if (n.classList.contains(jp.consuming))
                        return !0;
                    var r = Dp(n);
                    if (i && r.overflowY.match(/(scroll|auto)/)) {
                        var o = n.scrollHeight - n.clientHeight;
                        if (o > 0 && (n.scrollTop > 0 && i < 0 || n.scrollTop < o && i > 0))
                            return !0
                    }
                    if (a && r.overflowX.match(/(scroll|auto)/)) {
                        var s = n.scrollWidth - n.clientWidth;
                        if (s > 0 && (n.scrollLeft > 0 && a < 0 || n.scrollLeft < s && a > 0))
                            return !0
                    }
                    n = n.parentNode
                }
                return !1
            }(a.target, n, r)) {
                var o = !1;
                e.settings.useBothWheelAxes ? e.scrollbarYActive && !e.scrollbarXActive ? (r ? t.scrollTop -= r * e.settings.wheelSpeed : t.scrollTop += n * e.settings.wheelSpeed,
                o = !0) : e.scrollbarXActive && !e.scrollbarYActive && (n ? t.scrollLeft += n * e.settings.wheelSpeed : t.scrollLeft -= r * e.settings.wheelSpeed,
                o = !0) : (t.scrollTop -= r * e.settings.wheelSpeed,
                t.scrollLeft += n * e.settings.wheelSpeed),
                nv(e),
                o = o || function(a, i) {
                    var n = Math.floor(t.scrollTop)
                      , r = 0 === t.scrollTop
                      , o = n + t.offsetHeight === t.scrollHeight
                      , s = 0 === t.scrollLeft
                      , l = t.scrollLeft + t.offsetWidth === t.scrollWidth;
                    return !(Math.abs(i) > Math.abs(a) ? r || o : s || l) || !e.settings.wheelPropagation
                }(n, r),
                o && !a.ctrlKey && (a.stopPropagation(),
                a.preventDefault())
            }
        }
        void 0 !== window.onwheel ? e.event.bind(t, "wheel", a) : void 0 !== window.onmousewheel && e.event.bind(t, "mousewheel", a)
    },
    touch: function(e) {
        if (iv.supportsTouch || iv.supportsIePointer) {
            var t = e.element
              , a = {}
              , i = 0
              , n = {}
              , r = null;
            iv.supportsTouch ? (e.event.bind(t, "touchstart", c),
            e.event.bind(t, "touchmove", u),
            e.event.bind(t, "touchend", d)) : iv.supportsIePointer && (window.PointerEvent ? (e.event.bind(t, "pointerdown", c),
            e.event.bind(t, "pointermove", u),
            e.event.bind(t, "pointerup", d)) : window.MSPointerEvent && (e.event.bind(t, "MSPointerDown", c),
            e.event.bind(t, "MSPointerMove", u),
            e.event.bind(t, "MSPointerUp", d)))
        }
        function o(a, i) {
            t.scrollTop -= i,
            t.scrollLeft -= a,
            nv(e)
        }
        function s(e) {
            return e.targetTouches ? e.targetTouches[0] : e
        }
        function l(e) {
            return (!e.pointerType || "pen" !== e.pointerType || 0 !== e.buttons) && (!(!e.targetTouches || 1 !== e.targetTouches.length) || !(!e.pointerType || "mouse" === e.pointerType || e.pointerType === e.MSPOINTER_TYPE_MOUSE))
        }
        function c(e) {
            if (l(e)) {
                var t = s(e);
                a.pageX = t.pageX,
                a.pageY = t.pageY,
                i = (new Date).getTime(),
                null !== r && clearInterval(r)
            }
        }
        function u(r) {
            if (l(r)) {
                var c = s(r)
                  , u = {
                    pageX: c.pageX,
                    pageY: c.pageY
                }
                  , d = u.pageX - a.pageX
                  , h = u.pageY - a.pageY;
                if (function(e, a, i) {
                    if (!t.contains(e))
                        return !1;
                    for (var n = e; n && n !== t; ) {
                        if (n.classList.contains(jp.consuming))
                            return !0;
                        var r = Dp(n);
                        if (i && r.overflowY.match(/(scroll|auto)/)) {
                            var o = n.scrollHeight - n.clientHeight;
                            if (o > 0 && (n.scrollTop > 0 && i < 0 || n.scrollTop < o && i > 0))
                                return !0
                        }
                        if (a && r.overflowX.match(/(scroll|auto)/)) {
                            var s = n.scrollWidth - n.clientWidth;
                            if (s > 0 && (n.scrollLeft > 0 && a < 0 || n.scrollLeft < s && a > 0))
                                return !0
                        }
                        n = n.parentNode
                    }
                    return !1
                }(r.target, d, h))
                    return;
                o(d, h),
                a = u;
                var p = (new Date).getTime()
                  , v = p - i;
                v > 0 && (n.x = d / v,
                n.y = h / v,
                i = p),
                function(a, i) {
                    var n = Math.floor(t.scrollTop)
                      , r = t.scrollLeft
                      , o = Math.abs(a)
                      , s = Math.abs(i);
                    if (s > o) {
                        if (i < 0 && n === e.contentHeight - e.containerHeight || i > 0 && 0 === n)
                            return 0 === window.scrollY && i > 0 && iv.isChrome
                    } else if (o > s && (a < 0 && r === e.contentWidth - e.containerWidth || a > 0 && 0 === r))
                        return !0;
                    return !0
                }(d, h) && r.preventDefault()
            }
        }
        function d() {
            e.settings.swipeEasing && (clearInterval(r),
            r = setInterval((function() {
                e.isInitialized ? clearInterval(r) : n.x || n.y ? Math.abs(n.x) < .01 && Math.abs(n.y) < .01 ? clearInterval(r) : e.element ? (o(30 * n.x, 30 * n.y),
                n.x *= .8,
                n.y *= .8) : clearInterval(r) : clearInterval(r)
            }
            ), 10))
        }
    }
}
  , lv = function(e, t) {
    var a = this;
    if (void 0 === t && (t = {}),
    "string" == typeof e && (e = document.querySelector(e)),
    !e || !e.nodeName)
        throw new Error("no element is specified to initialize PerfectScrollbar");
    for (var i in this.element = e,
    e.classList.add(Wp),
    this.settings = {
        handlers: ["click-rail", "drag-thumb", "keyboard", "wheel", "touch"],
        maxScrollbarLength: null,
        minScrollbarLength: null,
        scrollingThreshold: 1e3,
        scrollXMarginOffset: 0,
        scrollYMarginOffset: 0,
        suppressScrollX: !1,
        suppressScrollY: !1,
        swipeEasing: !0,
        useBothWheelAxes: !1,
        wheelPropagation: !0,
        wheelSpeed: 1
    },
    t)
        this.settings[i] = t[i];
    this.containerWidth = null,
    this.containerHeight = null,
    this.contentWidth = null,
    this.contentHeight = null;
    var n, r, o = function() {
        return e.classList.add($p.focus)
    }, s = function() {
        return e.classList.remove($p.focus)
    };
    this.isRtl = "rtl" === Dp(e).direction,
    !0 === this.isRtl && e.classList.add(Gp),
    this.isNegativeScroll = (r = e.scrollLeft,
    e.scrollLeft = -1,
    n = e.scrollLeft < 0,
    e.scrollLeft = r,
    n),
    this.negativeScrollAdjustment = this.isNegativeScroll ? e.scrollWidth - e.clientWidth : 0,
    this.event = new Qp,
    this.ownerDocument = e.ownerDocument || document,
    this.scrollbarXRail = Np(jp.rail("x")),
    e.appendChild(this.scrollbarXRail),
    this.scrollbarX = Np(jp.thumb("x")),
    this.scrollbarXRail.appendChild(this.scrollbarX),
    this.scrollbarX.setAttribute("tabindex", 0),
    this.event.bind(this.scrollbarX, "focus", o),
    this.event.bind(this.scrollbarX, "blur", s),
    this.scrollbarXActive = null,
    this.scrollbarXWidth = null,
    this.scrollbarXLeft = null;
    var l = Dp(this.scrollbarXRail);
    this.scrollbarXBottom = parseInt(l.bottom, 10),
    isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1,
    this.scrollbarXTop = av(l.top)) : this.isScrollbarXUsingBottom = !0,
    this.railBorderXWidth = av(l.borderLeftWidth) + av(l.borderRightWidth),
    Rp(this.scrollbarXRail, {
        display: "block"
    }),
    this.railXMarginWidth = av(l.marginLeft) + av(l.marginRight),
    Rp(this.scrollbarXRail, {
        display: ""
    }),
    this.railXWidth = null,
    this.railXRatio = null,
    this.scrollbarYRail = Np(jp.rail("y")),
    e.appendChild(this.scrollbarYRail),
    this.scrollbarY = Np(jp.thumb("y")),
    this.scrollbarYRail.appendChild(this.scrollbarY),
    this.scrollbarY.setAttribute("tabindex", 0),
    this.event.bind(this.scrollbarY, "focus", o),
    this.event.bind(this.scrollbarY, "blur", s),
    this.scrollbarYActive = null,
    this.scrollbarYHeight = null,
    this.scrollbarYTop = null;
    var c = Dp(this.scrollbarYRail);
    this.scrollbarYRight = parseInt(c.right, 10),
    isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1,
    this.scrollbarYLeft = av(c.left)) : this.isScrollbarYUsingRight = !0,
    this.scrollbarYOuterWidth = this.isRtl ? function(e) {
        var t = Dp(e);
        return av(t.width) + av(t.paddingLeft) + av(t.paddingRight) + av(t.borderLeftWidth) + av(t.borderRightWidth)
    }(this.scrollbarY) : null,
    this.railBorderYWidth = av(c.borderTopWidth) + av(c.borderBottomWidth),
    Rp(this.scrollbarYRail, {
        display: "block"
    }),
    this.railYMarginHeight = av(c.marginTop) + av(c.marginBottom),
    Rp(this.scrollbarYRail, {
        display: ""
    }),
    this.railYHeight = null,
    this.railYRatio = null,
    this.reach = {
        x: e.scrollLeft <= 0 ? "start" : e.scrollLeft >= this.contentWidth - this.containerWidth ? "end" : null,
        y: e.scrollTop <= 0 ? "start" : e.scrollTop >= this.contentHeight - this.containerHeight ? "end" : null
    },
    this.isAlive = !0,
    this.settings.handlers.forEach((function(e) {
        return sv[e](a)
    }
    )),
    this.lastScrollTop = Math.floor(e.scrollTop),
    this.lastScrollLeft = e.scrollLeft,
    this.event.bind(this.element, "scroll", (function(e) {
        return a.onScroll(e)
    }
    )),
    nv(this)
};
lv.prototype.update = function() {
    this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0,
    Rp(this.scrollbarXRail, {
        display: "block"
    }),
    Rp(this.scrollbarYRail, {
        display: "block"
    }),
    this.railXMarginWidth = av(Dp(this.scrollbarXRail).marginLeft) + av(Dp(this.scrollbarXRail).marginRight),
    this.railYMarginHeight = av(Dp(this.scrollbarYRail).marginTop) + av(Dp(this.scrollbarYRail).marginBottom),
    Rp(this.scrollbarXRail, {
        display: "none"
    }),
    Rp(this.scrollbarYRail, {
        display: "none"
    }),
    nv(this),
    tv(this, "top", 0, !1, !0),
    tv(this, "left", 0, !1, !0),
    Rp(this.scrollbarXRail, {
        display: ""
    }),
    Rp(this.scrollbarYRail, {
        display: ""
    }))
}
,
lv.prototype.onScroll = function(e) {
    this.isAlive && (nv(this),
    tv(this, "top", this.element.scrollTop - this.lastScrollTop),
    tv(this, "left", this.element.scrollLeft - this.lastScrollLeft),
    this.lastScrollTop = Math.floor(this.element.scrollTop),
    this.lastScrollLeft = this.element.scrollLeft)
}
,
lv.prototype.destroy = function() {
    this.isAlive && (this.event.unbindAll(),
    Xp(this.scrollbarX),
    Xp(this.scrollbarY),
    Xp(this.scrollbarXRail),
    Xp(this.scrollbarYRail),
    this.removePsClasses(),
    this.element = null,
    this.scrollbarX = null,
    this.scrollbarY = null,
    this.scrollbarXRail = null,
    this.scrollbarYRail = null,
    this.isAlive = !1)
}
,
lv.prototype.removePsClasses = function() {
    this.element.className = this.element.className.split(" ").filter((function(e) {
        return !e.match(/^ps([-_].+|)$/)
    }
    )).join(" ")
}
;
const cv = ["scroll", "ps-scroll-y", "ps-scroll-x", "ps-scroll-up", "ps-scroll-down", "ps-scroll-left", "ps-scroll-right", "ps-y-reach-start", "ps-y-reach-end", "ps-x-reach-start", "ps-x-reach-end"];
var uv = {
    name: "PerfectScrollbar",
    props: {
        options: {
            type: Object,
            required: !1,
            default: () => {}
        },
        tag: {
            type: String,
            required: !1,
            default: "div"
        },
        watchOptions: {
            type: Boolean,
            required: !1,
            default: !1
        }
    },
    emits: cv,
    data: () => ({
        ps: null
    }),
    watch: {
        watchOptions(e) {
            !e && this.watcher ? this.watcher() : this.createWatcher()
        }
    },
    mounted() {
        this.create(),
        this.watchOptions && this.createWatcher()
    },
    updated() {
        this.$nextTick(( () => {
            this.update()
        }
        ))
    },
    beforeUnmount() {
        this.destroy()
    },
    methods: {
        create() {
            this.ps && this.$isServer || (this.ps = new lv(this.$el,this.options),
            cv.forEach((e => {
                this.ps.element.addEventListener(e, (t => this.$emit(e, t)))
            }
            )))
        },
        createWatcher() {
            this.watcher = this.$watch("options", ( () => {
                this.destroy(),
                this.create()
            }
            ), {
                deep: !0
            })
        },
        update() {
            this.ps && this.ps.update()
        },
        destroy() {
            this.ps && (this.ps.destroy(),
            this.ps = null)
        }
    },
    render() {
        return S(this.tag, {
            class: "ps"
        }, this.$slots.default && this.$slots.default())
    }
}
  , dv = {
    install: (e, t) => {
        t && (t.name && "string" == typeof t.name && (uv.name = t.name),
        t.options && "object" == typeof t.options && (uv.props.options.default = () => t.options),
        t.tag && "string" == typeof t.tag && (uv.props.tag.default = t.tag),
        t.watchOptions && "boolean" == typeof t.watchOptions && (uv.props.watchOptions = t.watchOptions)),
        e.component(uv.name, uv)
    }
};
function hv(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var pv = {
    exports: {}
};
!function(e, t) {
    function a(e, t) {
        var a = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var i = Object.getOwnPropertySymbols(e);
            t && (i = i.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }
            ))),
            a.push.apply(a, i)
        }
        return a
    }
    function i(e) {
        for (var t = 1; t < arguments.length; t++) {
            var i = null != arguments[t] ? arguments[t] : {};
            t % 2 ? a(Object(i), !0).forEach((function(t) {
                l(e, t, i[t])
            }
            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(i)) : a(Object(i)).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(i, t))
            }
            ))
        }
        return e
    }
    function n(e) {
        return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    function r(e, t) {
        if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function")
    }
    function o(e, t) {
        for (var a = 0; a < t.length; a++) {
            var i = t[a];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    function s(e, t, a) {
        return t && o(e.prototype, t),
        a && o(e, a),
        e
    }
    function l(e, t, a) {
        return t in e ? Object.defineProperty(e, t, {
            value: a,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = a,
        e
    }
    function c(e, t) {
        if ("function" != typeof t && null !== t)
            throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }),
        t && d(e, t)
    }
    function u(e) {
        return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }
        )(e)
    }
    function d(e, t) {
        return (d = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t,
            e
        }
        )(e, t)
    }
    function h(e) {
        if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }
    function p(e) {
        var t = function() {
            if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                ))),
                !0
            } catch {
                return !1
            }
        }();
        return function() {
            var a, i = u(e);
            if (t) {
                var n = u(this).constructor;
                a = Reflect.construct(i, arguments, n)
            } else
                a = i.apply(this, arguments);
            return function(e, t) {
                if (t && ("object" == typeof t || "function" == typeof t))
                    return t;
                if (void 0 !== t)
                    throw new TypeError("Derived constructors may only return object or undefined");
                return h(e)
            }(this, a)
        }
    }
    function v(e, t) {
        return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            var a = null == e ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
            if (null != a) {
                var i, n, r = [], o = !0, s = !1;
                try {
                    for (a = a.call(e); !(o = (i = a.next()).done) && (r.push(i.value),
                    !t || r.length !== t); o = !0)
                        ;
                } catch (l) {
                    s = !0,
                    n = l
                } finally {
                    try {
                        o || null == a.return || a.return()
                    } finally {
                        if (s)
                            throw n
                    }
                }
                return r
            }
        }(e, t) || f(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function g(e) {
        return function(e) {
            if (Array.isArray(e))
                return m(e)
        }(e) || function(e) {
            if (typeof Symbol < "u" && null != e[Symbol.iterator] || null != e["@@iterator"])
                return Array.from(e)
        }(e) || f(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function f(e, t) {
        if (e) {
            if ("string" == typeof e)
                return m(e, t);
            var a = Object.prototype.toString.call(e).slice(8, -1);
            return "Object" === a && e.constructor && (a = e.constructor.name),
            "Map" === a || "Set" === a ? Array.from(e) : "Arguments" === a || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a) ? m(e, t) : void 0
        }
    }
    function m(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var a = 0, i = new Array(t); a < t; a++)
            i[a] = e[a];
        return i
    }
    var b = function() {
        function e() {
            r(this, e)
        }
        return s(e, [{
            key: "shadeRGBColor",
            value: function(e, t) {
                var a = t.split(",")
                  , i = e < 0 ? 0 : 255
                  , n = e < 0 ? -1 * e : e
                  , r = parseInt(a[0].slice(4), 10)
                  , o = parseInt(a[1], 10)
                  , s = parseInt(a[2], 10);
                return "rgb(" + (Math.round((i - r) * n) + r) + "," + (Math.round((i - o) * n) + o) + "," + (Math.round((i - s) * n) + s) + ")"
            }
        }, {
            key: "shadeHexColor",
            value: function(e, t) {
                var a = parseInt(t.slice(1), 16)
                  , i = e < 0 ? 0 : 255
                  , n = e < 0 ? -1 * e : e
                  , r = a >> 16
                  , o = a >> 8 & 255
                  , s = 255 & a;
                return "#" + (16777216 + 65536 * (Math.round((i - r) * n) + r) + 256 * (Math.round((i - o) * n) + o) + (Math.round((i - s) * n) + s)).toString(16).slice(1)
            }
        }, {
            key: "shadeColor",
            value: function(t, a) {
                return e.isColorHex(a) ? this.shadeHexColor(t, a) : this.shadeRGBColor(t, a)
            }
        }], [{
            key: "bind",
            value: function(e, t) {
                return function() {
                    return e.apply(t, arguments)
                }
            }
        }, {
            key: "isObject",
            value: function(e) {
                return e && "object" === n(e) && !Array.isArray(e) && null != e
            }
        }, {
            key: "is",
            value: function(e, t) {
                return Object.prototype.toString.call(t) === "[object " + e + "]"
            }
        }, {
            key: "listToArray",
            value: function(e) {
                var t, a = [];
                for (t = 0; t < e.length; t++)
                    a[t] = e[t];
                return a
            }
        }, {
            key: "extend",
            value: function(e, t) {
                var a = this;
                "function" != typeof Object.assign && (Object.assign = function(e) {
                    if (null == e)
                        throw new TypeError("Cannot convert undefined or null to object");
                    for (var t = Object(e), a = 1; a < arguments.length; a++) {
                        var i = arguments[a];
                        if (null != i)
                            for (var n in i)
                                i.hasOwnProperty(n) && (t[n] = i[n])
                    }
                    return t
                }
                );
                var i = Object.assign({}, e);
                return this.isObject(e) && this.isObject(t) && Object.keys(t).forEach((function(n) {
                    a.isObject(t[n]) && n in e ? i[n] = a.extend(e[n], t[n]) : Object.assign(i, l({}, n, t[n]))
                }
                )),
                i
            }
        }, {
            key: "extendArray",
            value: function(t, a) {
                var i = [];
                return t.map((function(t) {
                    i.push(e.extend(a, t))
                }
                )),
                i
            }
        }, {
            key: "monthMod",
            value: function(e) {
                return e % 12
            }
        }, {
            key: "clone",
            value: function(t) {
                if (e.is("Array", t)) {
                    for (var a = [], i = 0; i < t.length; i++)
                        a[i] = this.clone(t[i]);
                    return a
                }
                if (e.is("Null", t))
                    return null;
                if (e.is("Date", t))
                    return t;
                if ("object" === n(t)) {
                    var r = {};
                    for (var o in t)
                        t.hasOwnProperty(o) && (r[o] = this.clone(t[o]));
                    return r
                }
                return t
            }
        }, {
            key: "log10",
            value: function(e) {
                return Math.log(e) / Math.LN10
            }
        }, {
            key: "roundToBase10",
            value: function(e) {
                return Math.pow(10, Math.floor(Math.log10(e)))
            }
        }, {
            key: "roundToBase",
            value: function(e, t) {
                return Math.pow(t, Math.floor(Math.log(e) / Math.log(t)))
            }
        }, {
            key: "parseNumber",
            value: function(e) {
                return null === e ? e : parseFloat(e)
            }
        }, {
            key: "stripNumber",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
                return Number.isInteger(e) ? e : parseFloat(e.toPrecision(t))
            }
        }, {
            key: "randomId",
            value: function() {
                return (Math.random() + 1).toString(36).substring(4)
            }
        }, {
            key: "noExponents",
            value: function(e) {
                var t = String(e).split(/[eE]/);
                if (1 === t.length)
                    return t[0];
                var a = ""
                  , i = e < 0 ? "-" : ""
                  , n = t[0].replace(".", "")
                  , r = Number(t[1]) + 1;
                if (r < 0) {
                    for (a = i + "0."; r++; )
                        a += "0";
                    return a + n.replace(/^-/, "")
                }
                for (r -= n.length; r--; )
                    a += "0";
                return n + a
            }
        }, {
            key: "getDimensions",
            value: function(e) {
                var t = getComputedStyle(e, null)
                  , a = e.clientHeight
                  , i = e.clientWidth;
                return a -= parseFloat(t.paddingTop) + parseFloat(t.paddingBottom),
                [i -= parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), a]
            }
        }, {
            key: "getBoundingClientRect",
            value: function(e) {
                var t = e.getBoundingClientRect();
                return {
                    top: t.top,
                    right: t.right,
                    bottom: t.bottom,
                    left: t.left,
                    width: e.clientWidth,
                    height: e.clientHeight,
                    x: t.left,
                    y: t.top
                }
            }
        }, {
            key: "getLargestStringFromArr",
            value: function(e) {
                return e.reduce((function(e, t) {
                    return Array.isArray(t) && (t = t.reduce((function(e, t) {
                        return e.length > t.length ? e : t
                    }
                    ))),
                    e.length > t.length ? e : t
                }
                ), 0)
            }
        }, {
            key: "hexToRgba",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999"
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                "#" !== e.substring(0, 1) && (e = "#999999");
                var a = e.replace("#", "");
                a = a.match(new RegExp("(.{" + a.length / 3 + "})","g"));
                for (var i = 0; i < a.length; i++)
                    a[i] = parseInt(1 === a[i].length ? a[i] + a[i] : a[i], 16);
                return void 0 !== t && a.push(t),
                "rgba(" + a.join(",") + ")"
            }
        }, {
            key: "getOpacityFromRGBA",
            value: function(e) {
                return parseFloat(e.replace(/^.*,(.+)\)/, "$1"))
            }
        }, {
            key: "rgb2hex",
            value: function(e) {
                return (e = e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === e.length ? "#" + ("0" + parseInt(e[1], 10).toString(16)).slice(-2) + ("0" + parseInt(e[2], 10).toString(16)).slice(-2) + ("0" + parseInt(e[3], 10).toString(16)).slice(-2) : ""
            }
        }, {
            key: "isColorHex",
            value: function(e) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(e)
            }
        }, {
            key: "getPolygonPos",
            value: function(e, t) {
                for (var a = [], i = 2 * Math.PI / t, n = 0; n < t; n++) {
                    var r = {};
                    r.x = e * Math.sin(n * i),
                    r.y = -e * Math.cos(n * i),
                    a.push(r)
                }
                return a
            }
        }, {
            key: "polarToCartesian",
            value: function(e, t, a, i) {
                var n = (i - 90) * Math.PI / 180;
                return {
                    x: e + a * Math.cos(n),
                    y: t + a * Math.sin(n)
                }
            }
        }, {
            key: "escapeString",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x"
                  , a = e.toString().slice();
                return a.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, t)
            }
        }, {
            key: "negToZero",
            value: function(e) {
                return e < 0 ? 0 : e
            }
        }, {
            key: "moveIndexInArray",
            value: function(e, t, a) {
                if (a >= e.length)
                    for (var i = a - e.length + 1; i--; )
                        e.push(void 0);
                return e.splice(a, 0, e.splice(t, 1)[0]),
                e
            }
        }, {
            key: "extractNumber",
            value: function(e) {
                return parseFloat(e.replace(/[^\d.]*/g, ""))
            }
        }, {
            key: "findAncestor",
            value: function(e, t) {
                for (; (e = e.parentElement) && !e.classList.contains(t); )
                    ;
                return e
            }
        }, {
            key: "setELstyles",
            value: function(e, t) {
                for (var a in t)
                    t.hasOwnProperty(a) && (e.style.key = t[a])
            }
        }, {
            key: "isNumber",
            value: function(e) {
                return !isNaN(e) && parseFloat(Number(e)) === e && !isNaN(parseInt(e, 10))
            }
        }, {
            key: "isFloat",
            value: function(e) {
                return Number(e) === e && e % 1 != 0
            }
        }, {
            key: "isSafari",
            value: function() {
                return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
            }
        }, {
            key: "isFirefox",
            value: function() {
                return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
            }
        }, {
            key: "isIE11",
            value: function() {
                if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1)
                    return !0
            }
        }, {
            key: "isIE",
            value: function() {
                var e = window.navigator.userAgent
                  , t = e.indexOf("MSIE ");
                if (t > 0)
                    return parseInt(e.substring(t + 5, e.indexOf(".", t)), 10);
                if (e.indexOf("Trident/") > 0) {
                    var a = e.indexOf("rv:");
                    return parseInt(e.substring(a + 3, e.indexOf(".", a)), 10)
                }
                var i = e.indexOf("Edge/");
                return i > 0 && parseInt(e.substring(i + 5, e.indexOf(".", i)), 10)
            }
        }]),
        e
    }()
      , x = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.setEasingFunctions()
        }
        return s(e, [{
            key: "setEasingFunctions",
            value: function() {
                var e;
                if (!this.w.globals.easing) {
                    switch (this.w.config.chart.animations.easing) {
                    case "linear":
                        e = "-";
                        break;
                    case "easein":
                        e = "<";
                        break;
                    case "easeout":
                        e = ">";
                        break;
                    case "easeinout":
                    default:
                        e = "<>";
                        break;
                    case "swing":
                        e = function(e) {
                            var t = 1.70158;
                            return (e -= 1) * e * ((t + 1) * e + t) + 1
                        }
                        ;
                        break;
                    case "bounce":
                        e = function(e) {
                            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                        }
                        ;
                        break;
                    case "elastic":
                        e = function(e) {
                            return e === !!e ? e : Math.pow(2, -10 * e) * Math.sin((e - .075) * (2 * Math.PI) / .3) + 1
                        }
                    }
                    this.w.globals.easing = e
                }
            }
        }, {
            key: "animateLine",
            value: function(e, t, a, i) {
                e.attr(t).animate(i).attr(a)
            }
        }, {
            key: "animateMarker",
            value: function(e, t, a, i, n, r) {
                t || (t = 0),
                e.attr({
                    r: t,
                    width: t,
                    height: t
                }).animate(i, n).attr({
                    r: a,
                    width: a.width,
                    height: a.height
                }).afterAll((function() {
                    r()
                }
                ))
            }
        }, {
            key: "animateCircle",
            value: function(e, t, a, i, n) {
                e.attr({
                    r: t.r,
                    cx: t.cx,
                    cy: t.cy
                }).animate(i, n).attr({
                    r: a.r,
                    cx: a.cx,
                    cy: a.cy
                })
            }
        }, {
            key: "animateRect",
            value: function(e, t, a, i, n) {
                e.attr(t).animate(i).attr(a).afterAll((function() {
                    return n()
                }
                ))
            }
        }, {
            key: "animatePathsGradually",
            value: function(e) {
                var t = e.el
                  , a = e.realIndex
                  , i = e.j
                  , n = e.fill
                  , r = e.pathFrom
                  , o = e.pathTo
                  , s = e.speed
                  , l = e.delay
                  , c = this.w
                  , u = 0;
                c.config.chart.animations.animateGradually.enabled && (u = c.config.chart.animations.animateGradually.delay),
                c.config.chart.animations.dynamicAnimation.enabled && c.globals.dataChanged && "bar" !== c.config.chart.type && (u = 0),
                this.morphSVG(t, a, i, "line" !== c.config.chart.type || c.globals.comboCharts ? n : "stroke", r, o, s, l * u)
            }
        }, {
            key: "showDelayedElements",
            value: function() {
                this.w.globals.delayedElements.forEach((function(e) {
                    var t = e.el;
                    t.classList.remove("apexcharts-element-hidden"),
                    t.classList.add("apexcharts-hidden-element-shown")
                }
                ))
            }
        }, {
            key: "animationCompleted",
            value: function(e) {
                var t = this.w;
                t.globals.animationEnded || (t.globals.animationEnded = !0,
                this.showDelayedElements(),
                "function" == typeof t.config.chart.events.animationEnd && t.config.chart.events.animationEnd(this.ctx, {
                    el: e,
                    w: t
                }))
            }
        }, {
            key: "morphSVG",
            value: function(e, t, a, i, n, r, o, s) {
                var l = this
                  , c = this.w;
                n || (n = e.attr("pathFrom")),
                r || (r = e.attr("pathTo"));
                var u = function(e) {
                    return "radar" === c.config.chart.type && (o = 1),
                    "M 0 ".concat(c.globals.gridHeight)
                };
                (!n || n.indexOf("undefined") > -1 || n.indexOf("NaN") > -1) && (n = u()),
                (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = u()),
                c.globals.shouldAnimate || (o = 1),
                e.plot(n).animate(1, c.globals.easing, s).plot(n).animate(o, c.globals.easing, s).plot(r).afterAll((function() {
                    b.isNumber(a) ? a === c.globals.series[c.globals.maxValsInArrayIndex].length - 2 && c.globals.shouldAnimate && l.animationCompleted(e) : "none" !== i && c.globals.shouldAnimate && (!c.globals.comboCharts && t === c.globals.series.length - 1 || c.globals.comboCharts) && l.animationCompleted(e),
                    l.showDelayedElements()
                }
                ))
            }
        }]),
        e
    }()
      , y = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "getDefaultFilter",
            value: function(e, t) {
                var a = this.w;
                e.unfilter(!0),
                (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"),
                "none" !== a.config.states.normal.filter ? this.applyFilter(e, t, a.config.states.normal.filter.type, a.config.states.normal.filter.value) : a.config.chart.dropShadow.enabled && this.dropShadow(e, a.config.chart.dropShadow, t)
            }
        }, {
            key: "addNormalFilter",
            value: function(e, t) {
                var a = this.w;
                a.config.chart.dropShadow.enabled && !e.node.classList.contains("apexcharts-marker") && this.dropShadow(e, a.config.chart.dropShadow, t)
            }
        }, {
            key: "addLightenFilter",
            value: function(e, t, a) {
                var i = this
                  , n = this.w
                  , r = a.intensity;
                e.unfilter(!0),
                new window.SVG.Filter,
                e.filter((function(e) {
                    var a = n.config.chart.dropShadow;
                    (a.enabled ? i.addShadow(e, t, a) : e).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: 1.5,
                            intercept: r
                        }
                    })
                }
                )),
                e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)
            }
        }, {
            key: "addDarkenFilter",
            value: function(e, t, a) {
                var i = this
                  , n = this.w
                  , r = a.intensity;
                e.unfilter(!0),
                new window.SVG.Filter,
                e.filter((function(e) {
                    var a = n.config.chart.dropShadow;
                    (a.enabled ? i.addShadow(e, t, a) : e).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: r
                        }
                    })
                }
                )),
                e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)
            }
        }, {
            key: "applyFilter",
            value: function(e, t, a) {
                var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                switch (a) {
                case "none":
                    this.addNormalFilter(e, t);
                    break;
                case "lighten":
                    this.addLightenFilter(e, t, {
                        intensity: i
                    });
                    break;
                case "darken":
                    this.addDarkenFilter(e, t, {
                        intensity: i
                    })
                }
            }
        }, {
            key: "addShadow",
            value: function(e, t, a) {
                var i = a.blur
                  , n = a.top
                  , r = a.left
                  , o = a.color
                  , s = a.opacity
                  , l = e.flood(Array.isArray(o) ? o[t] : o, s).composite(e.sourceAlpha, "in").offset(r, n).gaussianBlur(i).merge(e.source);
                return e.blend(e.source, l)
            }
        }, {
            key: "dropShadow",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = t.top
                  , n = t.left
                  , r = t.blur
                  , o = t.color
                  , s = t.opacity
                  , l = t.noUserSpaceOnUse
                  , c = this.w;
                return e.unfilter(!0),
                b.isIE() && "radialBar" === c.config.chart.type || (o = Array.isArray(o) ? o[a] : o,
                e.filter((function(e) {
                    var t;
                    t = b.isSafari() || b.isFirefox() || b.isIE() ? e.flood(o, s).composite(e.sourceAlpha, "in").offset(n, i).gaussianBlur(r) : e.flood(o, s).composite(e.sourceAlpha, "in").offset(n, i).gaussianBlur(r).merge(e.source),
                    e.blend(e.source, t)
                }
                )),
                l || e.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"),
                this._scaleFilterSize(e.filterer.node)),
                e
            }
        }, {
            key: "setSelectionFilter",
            value: function(e, t, a) {
                var i = this.w;
                if (void 0 !== i.globals.selectedDataPoints[t] && i.globals.selectedDataPoints[t].indexOf(a) > -1) {
                    e.node.setAttribute("selected", !0);
                    var n = i.config.states.active.filter;
                    "none" !== n && this.applyFilter(e, t, n.type, n.value)
                }
            }
        }, {
            key: "_scaleFilterSize",
            value: function(e) {
                !function(t) {
                    for (var a in t)
                        t.hasOwnProperty(a) && e.setAttribute(a, t[a])
                }({
                    width: "200%",
                    height: "200%",
                    x: "-50%",
                    y: "-50%"
                })
            }
        }]),
        e
    }()
      , w = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "roundPathCorners",
            value: function(e, t) {
                function a(e, t, a) {
                    var n = t.x - e.x
                      , r = t.y - e.y
                      , o = Math.sqrt(n * n + r * r);
                    return i(e, t, Math.min(1, a / o))
                }
                function i(e, t, a) {
                    return {
                        x: e.x + (t.x - e.x) * a,
                        y: e.y + (t.y - e.y) * a
                    }
                }
                function n(e, t) {
                    e.length > 2 && (e[e.length - 2] = t.x,
                    e[e.length - 1] = t.y)
                }
                function r(e) {
                    return {
                        x: parseFloat(e[e.length - 2]),
                        y: parseFloat(e[e.length - 1])
                    }
                }
                e.indexOf("NaN") > -1 && (e = "");
                var o = e.split(/[,\s]/).reduce((function(e, t) {
                    var a = t.match("([a-zA-Z])(.+)");
                    return a ? (e.push(a[1]),
                    e.push(a[2])) : e.push(t),
                    e
                }
                ), []).reduce((function(e, t) {
                    return parseFloat(t) == t && e.length ? e[e.length - 1].push(t) : e.push([t]),
                    e
                }
                ), [])
                  , s = [];
                if (o.length > 1) {
                    var l = r(o[0])
                      , c = null;
                    "Z" == o[o.length - 1][0] && o[0].length > 2 && (c = ["L", l.x, l.y],
                    o[o.length - 1] = c),
                    s.push(o[0]);
                    for (var u = 1; u < o.length; u++) {
                        var d = s[s.length - 1]
                          , h = o[u]
                          , p = h == c ? o[1] : o[u + 1];
                        if (p && d && d.length > 2 && "L" == h[0] && p.length > 2 && "L" == p[0]) {
                            var v, g, f = r(d), m = r(h), b = r(p);
                            v = a(m, f, t),
                            g = a(m, b, t),
                            n(h, v),
                            h.origPoint = m,
                            s.push(h);
                            var x = i(v, m, .5)
                              , y = i(m, g, .5)
                              , w = ["C", x.x, x.y, y.x, y.y, g.x, g.y];
                            w.origPoint = m,
                            s.push(w)
                        } else
                            s.push(h)
                    }
                    if (c) {
                        var k = r(s[s.length - 1]);
                        s.push(["Z"]),
                        n(s[0], k)
                    }
                } else
                    s = o;
                return s.reduce((function(e, t) {
                    return e + t.join(" ") + " "
                }
                ), "")
            }
        }, {
            key: "drawLine",
            value: function(e, t, a, i) {
                var n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8"
                  , r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0
                  , o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
                return this.w.globals.dom.Paper.line().attr({
                    x1: e,
                    y1: t,
                    x2: a,
                    y2: i,
                    stroke: n,
                    "stroke-dasharray": r,
                    "stroke-width": o,
                    "stroke-linecap": s
                })
            }
        }, {
            key: "drawRect",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0
                  , a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0
                  , r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe"
                  , o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1
                  , s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null
                  , l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null
                  , c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0
                  , u = this.w.globals.dom.Paper.rect();
                return u.attr({
                    x: e,
                    y: t,
                    width: a > 0 ? a : 0,
                    height: i > 0 ? i : 0,
                    rx: n,
                    ry: n,
                    opacity: o,
                    "stroke-width": null !== s ? s : 0,
                    stroke: null !== l ? l : "none",
                    "stroke-dasharray": c
                }),
                u.node.setAttribute("fill", r),
                u
            }
        }, {
            key: "drawPolygon",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1"
                  , a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
                return this.w.globals.dom.Paper.polygon(e).attr({
                    fill: i,
                    stroke: t,
                    "stroke-width": a
                })
            }
        }, {
            key: "drawCircle",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                e < 0 && (e = 0);
                var a = this.w.globals.dom.Paper.circle(2 * e);
                return null !== t && a.attr(t),
                a
            }
        }, {
            key: "drawPath",
            value: function(e) {
                var t = e.d
                  , a = void 0 === t ? "" : t
                  , i = e.stroke
                  , n = void 0 === i ? "#a8a8a8" : i
                  , r = e.strokeWidth
                  , o = void 0 === r ? 1 : r
                  , s = e.fill
                  , l = e.fillOpacity
                  , c = void 0 === l ? 1 : l
                  , u = e.strokeOpacity
                  , d = void 0 === u ? 1 : u
                  , h = e.classes
                  , p = e.strokeLinecap
                  , v = void 0 === p ? null : p
                  , g = e.strokeDashArray
                  , f = void 0 === g ? 0 : g
                  , m = this.w;
                return null === v && (v = m.config.stroke.lineCap),
                (a.indexOf("undefined") > -1 || a.indexOf("NaN") > -1) && (a = "M 0 ".concat(m.globals.gridHeight)),
                m.globals.dom.Paper.path(a).attr({
                    fill: s,
                    "fill-opacity": c,
                    stroke: n,
                    "stroke-opacity": d,
                    "stroke-linecap": v,
                    "stroke-width": o,
                    "stroke-dasharray": f,
                    class: h
                })
            }
        }, {
            key: "group",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = this.w.globals.dom.Paper.group();
                return null !== e && t.attr(e),
                t
            }
        }, {
            key: "move",
            value: function(e, t) {
                return ["M", e, t].join(" ")
            }
        }, {
            key: "line",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , i = null;
                return null === a ? i = [" L", e, t].join(" ") : "H" === a ? i = [" H", e].join(" ") : "V" === a && (i = [" V", t].join(" ")),
                i
            }
        }, {
            key: "curve",
            value: function(e, t, a, i, n, r) {
                return ["C", e, t, a, i, n, r].join(" ")
            }
        }, {
            key: "quadraticCurve",
            value: function(e, t, a, i) {
                return ["Q", e, t, a, i].join(" ")
            }
        }, {
            key: "arc",
            value: function(e, t, a, i, n, r, o) {
                var s = "A";
                return arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (s = "a"),
                [s, e, t, a, i, n, r, o].join(" ")
            }
        }, {
            key: "renderPaths",
            value: function(e) {
                var t, a = e.j, n = e.realIndex, r = e.pathFrom, o = e.pathTo, s = e.stroke, l = e.strokeWidth, c = e.strokeLinecap, u = e.fill, d = e.animationDelay, h = e.initialSpeed, p = e.dataChangeSpeed, v = e.className, g = e.shouldClipToGrid, f = void 0 === g || g, m = e.bindEventsOnPaths, b = void 0 === m || m, w = e.drawShadow, k = void 0 === w || w, S = this.w, C = new y(this.ctx), A = new x(this.ctx), P = this.w.config.chart.animations.enabled, L = P && this.w.config.chart.animations.dynamicAnimation.enabled, I = !!(P && !S.globals.resized || L && S.globals.dataChanged && S.globals.shouldAnimate);
                I ? t = r : (t = o,
                S.globals.animationEnded = !0);
                var _, T = S.config.stroke.dashArray;
                _ = Array.isArray(T) ? T[n] : S.config.stroke.dashArray;
                var E = this.drawPath({
                    d: t,
                    stroke: s,
                    strokeWidth: l,
                    fill: u,
                    fillOpacity: 1,
                    classes: v,
                    strokeLinecap: c,
                    strokeDashArray: _
                });
                if (E.attr("index", n),
                f && E.attr({
                    "clip-path": "url(#gridRectMask".concat(S.globals.cuid, ")")
                }),
                "none" !== S.config.states.normal.filter.type)
                    C.getDefaultFilter(E, n);
                else if (S.config.chart.dropShadow.enabled && k && (!S.config.chart.dropShadow.enabledOnSeries || S.config.chart.dropShadow.enabledOnSeries && -1 !== S.config.chart.dropShadow.enabledOnSeries.indexOf(n))) {
                    var O = S.config.chart.dropShadow;
                    C.dropShadow(E, O, n)
                }
                b && (E.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, E)),
                E.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, E)),
                E.node.addEventListener("mousedown", this.pathMouseDown.bind(this, E))),
                E.attr({
                    pathTo: o,
                    pathFrom: r
                });
                var V = {
                    el: E,
                    j: a,
                    realIndex: n,
                    pathFrom: r,
                    pathTo: o,
                    fill: u,
                    strokeWidth: l,
                    delay: d
                };
                return !P || S.globals.resized || S.globals.dataChanged ? !S.globals.resized && S.globals.dataChanged || A.showDelayedElements() : A.animatePathsGradually(i(i({}, V), {}, {
                    speed: h
                })),
                S.globals.dataChanged && L && I && A.animatePathsGradually(i(i({}, V), {}, {
                    speed: p
                })),
                E
            }
        }, {
            key: "drawPattern",
            value: function(e, t, a) {
                var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8"
                  , n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                return this.w.globals.dom.Paper.pattern(t, a, (function(r) {
                    "horizontalLines" === e ? r.line(0, 0, a, 0).stroke({
                        color: i,
                        width: n + 1
                    }) : "verticalLines" === e ? r.line(0, 0, 0, t).stroke({
                        color: i,
                        width: n + 1
                    }) : "slantedLines" === e ? r.line(0, 0, t, a).stroke({
                        color: i,
                        width: n
                    }) : "squares" === e ? r.rect(t, a).fill("none").stroke({
                        color: i,
                        width: n
                    }) : "circles" === e && r.circle(t).fill("none").stroke({
                        color: i,
                        width: n
                    })
                }
                ))
            }
        }, {
            key: "drawGradient",
            value: function(e, t, a, i, n) {
                var r, o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, u = this.w;
                t.length < 9 && 0 === t.indexOf("#") && (t = b.hexToRgba(t, i)),
                a.length < 9 && 0 === a.indexOf("#") && (a = b.hexToRgba(a, n));
                var d = 0
                  , h = 1
                  , p = 1
                  , v = null;
                null !== s && (d = void 0 !== s[0] ? s[0] / 100 : 0,
                h = void 0 !== s[1] ? s[1] / 100 : 1,
                p = void 0 !== s[2] ? s[2] / 100 : 1,
                v = void 0 !== s[3] ? s[3] / 100 : null);
                var g = !("donut" !== u.config.chart.type && "pie" !== u.config.chart.type && "polarArea" !== u.config.chart.type && "bubble" !== u.config.chart.type);
                if (r = null === l || 0 === l.length ? u.globals.dom.Paper.gradient(g ? "radial" : "linear", (function(e) {
                    e.at(d, t, i),
                    e.at(h, a, n),
                    e.at(p, a, n),
                    null !== v && e.at(v, t, i)
                }
                )) : u.globals.dom.Paper.gradient(g ? "radial" : "linear", (function(e) {
                    (Array.isArray(l[c]) ? l[c] : l).forEach((function(t) {
                        e.at(t.offset / 100, t.color, t.opacity)
                    }
                    ))
                }
                )),
                g) {
                    var f = u.globals.gridWidth / 2
                      , m = u.globals.gridHeight / 2;
                    "bubble" !== u.config.chart.type ? r.attr({
                        gradientUnits: "userSpaceOnUse",
                        cx: f,
                        cy: m,
                        r: o
                    }) : r.attr({
                        cx: .5,
                        cy: .5,
                        r: .8,
                        fx: .2,
                        fy: .2
                    })
                } else
                    "vertical" === e ? r.from(0, 0).to(0, 1) : "diagonal" === e ? r.from(0, 0).to(1, 1) : "horizontal" === e ? r.from(0, 1).to(1, 1) : "diagonal2" === e && r.from(1, 0).to(0, 1);
                return r
            }
        }, {
            key: "getTextBasedOnMaxWidth",
            value: function(e) {
                var t = e.text
                  , a = e.maxWidth
                  , i = e.fontSize
                  , n = e.fontFamily
                  , r = this.getTextRects(t, i, n)
                  , o = r.width / t.length
                  , s = Math.floor(a / o);
                return a < r.width ? t.slice(0, s - 3) + "..." : t
            }
        }, {
            key: "drawText",
            value: function(e) {
                var t = this
                  , a = e.x
                  , n = e.y
                  , r = e.text
                  , o = e.textAnchor
                  , s = e.fontSize
                  , l = e.fontFamily
                  , c = e.fontWeight
                  , u = e.foreColor
                  , d = e.opacity
                  , h = e.maxWidth
                  , p = e.cssClass
                  , v = void 0 === p ? "" : p
                  , g = e.isPlainText
                  , f = void 0 === g || g
                  , m = e.dominantBaseline
                  , b = void 0 === m ? "auto" : m
                  , x = this.w;
                void 0 === r && (r = "");
                var y = r;
                o || (o = "start"),
                u && u.length || (u = x.config.chart.foreColor),
                l = l || x.config.chart.fontFamily,
                c = c || "regular";
                var w, k = {
                    maxWidth: h,
                    fontSize: s = s || "11px",
                    fontFamily: l
                };
                return Array.isArray(r) ? w = x.globals.dom.Paper.text((function(e) {
                    for (var a = 0; a < r.length; a++)
                        y = r[a],
                        h && (y = t.getTextBasedOnMaxWidth(i({
                            text: r[a]
                        }, k))),
                        0 === a ? e.tspan(y) : e.tspan(y).newLine()
                }
                )) : (h && (y = this.getTextBasedOnMaxWidth(i({
                    text: r
                }, k))),
                w = f ? x.globals.dom.Paper.plain(r) : x.globals.dom.Paper.text((function(e) {
                    return e.tspan(y)
                }
                ))),
                w.attr({
                    x: a,
                    y: n,
                    "text-anchor": o,
                    "dominant-baseline": b,
                    "font-size": s,
                    "font-family": l,
                    "font-weight": c,
                    fill: u,
                    class: "apexcharts-text " + v
                }),
                w.node.style.fontFamily = l,
                w.node.style.opacity = d,
                w
            }
        }, {
            key: "drawMarker",
            value: function(e, t, a) {
                e = e || 0;
                var i = a.pSize || 0
                  , n = null;
                if ("square" === a.shape || "rect" === a.shape) {
                    var r = void 0 === a.pRadius ? i / 2 : a.pRadius;
                    null !== t && i || (i = 0,
                    r = 0);
                    var o = 1.2 * i + r
                      , s = this.drawRect(o, o, o, o, r);
                    s.attr({
                        x: e - o / 2,
                        y: t - o / 2,
                        cx: e,
                        cy: t,
                        class: a.class ? a.class : "",
                        fill: a.pointFillColor,
                        "fill-opacity": a.pointFillOpacity ? a.pointFillOpacity : 1,
                        stroke: a.pointStrokeColor,
                        "stroke-width": a.pointStrokeWidth ? a.pointStrokeWidth : 0,
                        "stroke-opacity": a.pointStrokeOpacity ? a.pointStrokeOpacity : 1
                    }),
                    n = s
                } else
                    "circle" !== a.shape && a.shape || (b.isNumber(t) || (i = 0,
                    t = 0),
                    n = this.drawCircle(i, {
                        cx: e,
                        cy: t,
                        class: a.class ? a.class : "",
                        stroke: a.pointStrokeColor,
                        fill: a.pointFillColor,
                        "fill-opacity": a.pointFillOpacity ? a.pointFillOpacity : 1,
                        "stroke-width": a.pointStrokeWidth ? a.pointStrokeWidth : 0,
                        "stroke-opacity": a.pointStrokeOpacity ? a.pointStrokeOpacity : 1
                    }));
                return n
            }
        }, {
            key: "pathMouseEnter",
            value: function(e, t) {
                var a = this.w
                  , i = new y(this.ctx)
                  , n = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10);
                if ("function" == typeof a.config.chart.events.dataPointMouseEnter && a.config.chart.events.dataPointMouseEnter(t, this.ctx, {
                    seriesIndex: n,
                    dataPointIndex: r,
                    w: a
                }),
                this.ctx.events.fireEvent("dataPointMouseEnter", [t, this.ctx, {
                    seriesIndex: n,
                    dataPointIndex: r,
                    w: a
                }]),
                ("none" === a.config.states.active.filter.type || "true" !== e.node.getAttribute("selected")) && "none" !== a.config.states.hover.filter.type && !a.globals.isTouchDevice) {
                    var o = a.config.states.hover.filter;
                    i.applyFilter(e, n, o.type, o.value)
                }
            }
        }, {
            key: "pathMouseLeave",
            value: function(e, t) {
                var a = this.w
                  , i = new y(this.ctx)
                  , n = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10);
                "function" == typeof a.config.chart.events.dataPointMouseLeave && a.config.chart.events.dataPointMouseLeave(t, this.ctx, {
                    seriesIndex: n,
                    dataPointIndex: r,
                    w: a
                }),
                this.ctx.events.fireEvent("dataPointMouseLeave", [t, this.ctx, {
                    seriesIndex: n,
                    dataPointIndex: r,
                    w: a
                }]),
                "none" !== a.config.states.active.filter.type && "true" === e.node.getAttribute("selected") || "none" !== a.config.states.hover.filter.type && i.getDefaultFilter(e, n)
            }
        }, {
            key: "pathMouseDown",
            value: function(e, t) {
                var a = this.w
                  , i = new y(this.ctx)
                  , n = parseInt(e.node.getAttribute("index"), 10)
                  , r = parseInt(e.node.getAttribute("j"), 10)
                  , o = "false";
                if ("true" === e.node.getAttribute("selected")) {
                    if (e.node.setAttribute("selected", "false"),
                    a.globals.selectedDataPoints[n].indexOf(r) > -1) {
                        var s = a.globals.selectedDataPoints[n].indexOf(r);
                        a.globals.selectedDataPoints[n].splice(s, 1)
                    }
                } else {
                    if (!a.config.states.active.allowMultipleDataPointsSelection && a.globals.selectedDataPoints.length > 0) {
                        a.globals.selectedDataPoints = [];
                        var l = a.globals.dom.Paper.select(".apexcharts-series path").members
                          , c = a.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members
                          , u = function(e) {
                            Array.prototype.forEach.call(e, (function(e) {
                                e.node.setAttribute("selected", "false"),
                                i.getDefaultFilter(e, n)
                            }
                            ))
                        };
                        u(l),
                        u(c)
                    }
                    e.node.setAttribute("selected", "true"),
                    o = "true",
                    void 0 === a.globals.selectedDataPoints[n] && (a.globals.selectedDataPoints[n] = []),
                    a.globals.selectedDataPoints[n].push(r)
                }
                if ("true" === o) {
                    var d = a.config.states.active.filter;
                    if ("none" !== d)
                        i.applyFilter(e, n, d.type, d.value);
                    else if ("none" !== a.config.states.hover.filter && !a.globals.isTouchDevice) {
                        var h = a.config.states.hover.filter;
                        i.applyFilter(e, n, h.type, h.value)
                    }
                } else
                    "none" !== a.config.states.active.filter.type && ("none" === a.config.states.hover.filter.type || a.globals.isTouchDevice ? i.getDefaultFilter(e, n) : (h = a.config.states.hover.filter,
                    i.applyFilter(e, n, h.type, h.value)));
                "function" == typeof a.config.chart.events.dataPointSelection && a.config.chart.events.dataPointSelection(t, this.ctx, {
                    selectedDataPoints: a.globals.selectedDataPoints,
                    seriesIndex: n,
                    dataPointIndex: r,
                    w: a
                }),
                t && this.ctx.events.fireEvent("dataPointSelection", [t, this.ctx, {
                    selectedDataPoints: a.globals.selectedDataPoints,
                    seriesIndex: n,
                    dataPointIndex: r,
                    w: a
                }])
            }
        }, {
            key: "rotateAroundCenter",
            value: function(e) {
                var t = {};
                return e && "function" == typeof e.getBBox && (t = e.getBBox()),
                {
                    x: t.x + t.width / 2,
                    y: t.y + t.height / 2
                }
            }
        }, {
            key: "getTextRects",
            value: function(e, t, a, i) {
                var n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
                  , r = this.w
                  , o = this.drawText({
                    x: -200,
                    y: -200,
                    text: e,
                    textAnchor: "start",
                    fontSize: t,
                    fontFamily: a,
                    foreColor: "#fff",
                    opacity: 0
                });
                i && o.attr("transform", i),
                r.globals.dom.Paper.add(o);
                var s = o.bbox();
                return n || (s = o.node.getBoundingClientRect()),
                o.remove(),
                {
                    width: s.width,
                    height: s.height
                }
            }
        }, {
            key: "placeTextWithEllipsis",
            value: function(e, t, a) {
                if ("function" == typeof e.getComputedTextLength && (e.textContent = t,
                t.length > 0 && e.getComputedTextLength() >= a / 1.1)) {
                    for (var i = t.length - 3; i > 0; i -= 3)
                        if (e.getSubStringLength(0, i) <= a / 1.1)
                            return void (e.textContent = t.substring(0, i) + "...");
                    e.textContent = "."
                }
            }
        }], [{
            key: "setAttrs",
            value: function(e, t) {
                for (var a in t)
                    t.hasOwnProperty(a) && e.setAttribute(a, t[a])
            }
        }]),
        e
    }()
      , k = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "getStackedSeriesTotals",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = this.w
                  , a = [];
                if (0 === t.globals.series.length)
                    return a;
                for (var i = 0; i < t.globals.series[t.globals.maxValsInArrayIndex].length; i++) {
                    for (var n = 0, r = 0; r < t.globals.series.length; r++)
                        void 0 !== t.globals.series[r][i] && -1 === e.indexOf(r) && (n += t.globals.series[r][i]);
                    a.push(n)
                }
                return a
            }
        }, {
            key: "getSeriesTotalByIndex",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return null === e ? this.w.config.series.reduce((function(e, t) {
                    return e + t
                }
                ), 0) : this.w.globals.series[e].reduce((function(e, t) {
                    return e + t
                }
                ), 0)
            }
        }, {
            key: "getStackedSeriesTotalsByGroups",
            value: function() {
                var e = this
                  , t = this.w
                  , a = [];
                return t.globals.seriesGroups.forEach((function(i) {
                    var n = [];
                    t.config.series.forEach((function(e, t) {
                        i.indexOf(e.name) > -1 && n.push(t)
                    }
                    ));
                    var r = t.globals.series.map((function(e, t) {
                        return -1 === n.indexOf(t) ? t : -1
                    }
                    )).filter((function(e) {
                        return -1 !== e
                    }
                    ));
                    a.push(e.getStackedSeriesTotals(r))
                }
                )),
                a
            }
        }, {
            key: "isSeriesNull",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return 0 === (null === e ? this.w.config.series.filter((function(e) {
                    return null !== e
                }
                )) : this.w.config.series[e].data.filter((function(e) {
                    return null !== e
                }
                ))).length
            }
        }, {
            key: "seriesHaveSameValues",
            value: function(e) {
                return this.w.globals.series[e].every((function(e, t, a) {
                    return e === a[0]
                }
                ))
            }
        }, {
            key: "getCategoryLabels",
            value: function(e) {
                var t = this.w
                  , a = e.slice();
                return t.config.xaxis.convertedCatToNumeric && (a = e.map((function(e, a) {
                    return t.config.xaxis.labels.formatter(e - t.globals.minX + 1)
                }
                ))),
                a
            }
        }, {
            key: "getLargestSeries",
            value: function() {
                var e = this.w;
                e.globals.maxValsInArrayIndex = e.globals.series.map((function(e) {
                    return e.length
                }
                )).indexOf(Math.max.apply(Math, e.globals.series.map((function(e) {
                    return e.length
                }
                ))))
            }
        }, {
            key: "getLargestMarkerSize",
            value: function() {
                var e = this.w
                  , t = 0;
                return e.globals.markers.size.forEach((function(e) {
                    t = Math.max(t, e)
                }
                )),
                e.config.markers.discrete && e.config.markers.discrete.length && e.config.markers.discrete.forEach((function(e) {
                    t = Math.max(t, e.size)
                }
                )),
                t > 0 && (t += e.config.markers.hover.sizeOffset + 1),
                e.globals.markers.largestSize = t,
                t
            }
        }, {
            key: "getSeriesTotals",
            value: function() {
                var e = this.w;
                e.globals.seriesTotals = e.globals.series.map((function(e, t) {
                    var a = 0;
                    if (Array.isArray(e))
                        for (var i = 0; i < e.length; i++)
                            a += e[i];
                    else
                        a += e;
                    return a
                }
                ))
            }
        }, {
            key: "getSeriesTotalsXRange",
            value: function(e, t) {
                var a = this.w;
                return a.globals.series.map((function(i, n) {
                    for (var r = 0, o = 0; o < i.length; o++)
                        a.globals.seriesX[n][o] > e && a.globals.seriesX[n][o] < t && (r += i[o]);
                    return r
                }
                ))
            }
        }, {
            key: "getPercentSeries",
            value: function() {
                var e = this.w;
                e.globals.seriesPercent = e.globals.series.map((function(t, a) {
                    var i = [];
                    if (Array.isArray(t))
                        for (var n = 0; n < t.length; n++) {
                            var r = e.globals.stackedSeriesTotals[n]
                              , o = 0;
                            r && (o = 100 * t[n] / r),
                            i.push(o)
                        }
                    else {
                        var s = 100 * t / e.globals.seriesTotals.reduce((function(e, t) {
                            return e + t
                        }
                        ), 0);
                        i.push(s)
                    }
                    return i
                }
                ))
            }
        }, {
            key: "getCalculatedRatios",
            value: function() {
                var e, t, a, i = this.w.globals, n = [], r = 0, o = [], s = .1, l = 0;
                if (i.yRange = [],
                i.isMultipleYAxis)
                    for (var c = 0; c < i.minYArr.length; c++)
                        i.yRange.push(Math.abs(i.minYArr[c] - i.maxYArr[c])),
                        o.push(0);
                else
                    i.yRange.push(Math.abs(i.minY - i.maxY));
                i.xRange = Math.abs(i.maxX - i.minX),
                i.zRange = Math.abs(i.maxZ - i.minZ);
                for (var u = 0; u < i.yRange.length; u++)
                    n.push(i.yRange[u] / i.gridHeight);
                if (t = i.xRange / i.gridWidth,
                e = i.yRange / i.gridWidth,
                a = i.xRange / i.gridHeight,
                (r = i.zRange / i.gridHeight * 16) || (r = 1),
                i.minY !== Number.MIN_VALUE && 0 !== Math.abs(i.minY) && (i.hasNegs = !0),
                i.isMultipleYAxis) {
                    o = [];
                    for (var d = 0; d < n.length; d++)
                        o.push(-i.minYArr[d] / n[d])
                } else
                    o.push(-i.minY / n[0]),
                    i.minY !== Number.MIN_VALUE && 0 !== Math.abs(i.minY) && (s = -i.minY / e,
                    l = i.minX / t);
                return {
                    yRatio: n,
                    invertedYRatio: e,
                    zRatio: r,
                    xRatio: t,
                    invertedXRatio: a,
                    baseLineInvertedY: s,
                    baseLineY: o,
                    baseLineX: l
                }
            }
        }, {
            key: "getLogSeries",
            value: function(e) {
                var t = this
                  , a = this.w;
                return a.globals.seriesLog = e.map((function(e, i) {
                    return a.config.yaxis[i] && a.config.yaxis[i].logarithmic ? e.map((function(e) {
                        return null === e ? null : t.getLogVal(a.config.yaxis[i].logBase, e, i)
                    }
                    )) : e
                }
                )),
                a.globals.invalidLogScale ? e : a.globals.seriesLog
            }
        }, {
            key: "getBaseLog",
            value: function(e, t) {
                return Math.log(t) / Math.log(e)
            }
        }, {
            key: "getLogVal",
            value: function(e, t, a) {
                if (0 === t)
                    return 0;
                var i = this.w
                  , n = 0 === i.globals.minYArr[a] ? -1 : this.getBaseLog(e, i.globals.minYArr[a])
                  , r = (0 === i.globals.maxYArr[a] ? 0 : this.getBaseLog(e, i.globals.maxYArr[a])) - n;
                return t < 1 ? t / r : (this.getBaseLog(e, t) - n) / r
            }
        }, {
            key: "getLogYRatios",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = this.w.globals;
                return i.yLogRatio = e.slice(),
                i.logYRange = i.yRange.map((function(e, n) {
                    if (a.config.yaxis[n] && t.w.config.yaxis[n].logarithmic) {
                        var r, o = -Number.MAX_VALUE, s = Number.MIN_VALUE;
                        return i.seriesLog.forEach((function(e, t) {
                            e.forEach((function(e) {
                                a.config.yaxis[t] && a.config.yaxis[t].logarithmic && (o = Math.max(e, o),
                                s = Math.min(e, s))
                            }
                            ))
                        }
                        )),
                        r = Math.pow(i.yRange[n], Math.abs(s - o) / i.yRange[n]),
                        i.yLogRatio[n] = r / i.gridHeight,
                        r
                    }
                }
                )),
                i.invalidLogScale ? e.slice() : i.yLogRatio
            }
        }], [{
            key: "checkComboSeries",
            value: function(e) {
                var t = !1
                  , a = 0
                  , i = 0;
                return e.length && void 0 !== e[0].type && e.forEach((function(e) {
                    "bar" !== e.type && "column" !== e.type && "candlestick" !== e.type && "boxPlot" !== e.type || a++,
                    void 0 !== e.type && i++
                }
                )),
                i > 0 && (t = !0),
                {
                    comboBarCount: a,
                    comboCharts: t
                }
            }
        }, {
            key: "extendArrayProps",
            value: function(e, t, a) {
                return t.yaxis && (t = e.extendYAxis(t, a)),
                t.annotations && (t.annotations.yaxis && (t = e.extendYAxisAnnotations(t)),
                t.annotations.xaxis && (t = e.extendXAxisAnnotations(t)),
                t.annotations.points && (t = e.extendPointAnnotations(t))),
                t
            }
        }]),
        e
    }()
      , S = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.annoCtx = t
        }
        return s(e, [{
            key: "setOrientations",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , a = this.w;
                if ("vertical" === e.label.orientation) {
                    var i = null !== t ? t : 0
                      , n = a.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(i, "']"));
                    if (null !== n) {
                        var r = n.getBoundingClientRect();
                        n.setAttribute("x", parseFloat(n.getAttribute("x")) - r.height + 4),
                        "top" === e.label.position ? n.setAttribute("y", parseFloat(n.getAttribute("y")) + r.width) : n.setAttribute("y", parseFloat(n.getAttribute("y")) - r.width);
                        var o = this.annoCtx.graphics.rotateAroundCenter(n)
                          , s = o.x
                          , l = o.y;
                        n.setAttribute("transform", "rotate(-90 ".concat(s, " ").concat(l, ")"))
                    }
                }
            }
        }, {
            key: "addBackgroundToAnno",
            value: function(e, t) {
                var a = this.w;
                if (!e || void 0 === t.label.text || void 0 !== t.label.text && !String(t.label.text).trim())
                    return null;
                var i = a.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect()
                  , n = e.getBoundingClientRect()
                  , r = t.label.style.padding.left
                  , o = t.label.style.padding.right
                  , s = t.label.style.padding.top
                  , l = t.label.style.padding.bottom;
                "vertical" === t.label.orientation && (s = t.label.style.padding.left,
                l = t.label.style.padding.right,
                r = t.label.style.padding.top,
                o = t.label.style.padding.bottom);
                var c = n.left - i.left - r
                  , u = n.top - i.top - s
                  , d = this.annoCtx.graphics.drawRect(c - a.globals.barPadForNumericAxis, u, n.width + r + o, n.height + s + l, t.label.borderRadius, t.label.style.background, 1, t.label.borderWidth, t.label.borderColor, 0);
                return t.id && d.node.classList.add(t.id),
                d
            }
        }, {
            key: "annotationsBackground",
            value: function() {
                var e = this
                  , t = this.w
                  , a = function(a, i, n) {
                    var r = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(n, "-annotations .apexcharts-").concat(n, "-annotation-label[rel='").concat(i, "']"));
                    if (r) {
                        var o = r.parentNode
                          , s = e.addBackgroundToAnno(r, a);
                        s && (o.insertBefore(s.node, r),
                        a.label.mouseEnter && s.node.addEventListener("mouseenter", a.label.mouseEnter.bind(e, a)),
                        a.label.mouseLeave && s.node.addEventListener("mouseleave", a.label.mouseLeave.bind(e, a)),
                        a.label.click && s.node.addEventListener("click", a.label.click.bind(e, a)))
                    }
                };
                t.config.annotations.xaxis.map((function(e, t) {
                    a(e, t, "xaxis")
                }
                )),
                t.config.annotations.yaxis.map((function(e, t) {
                    a(e, t, "yaxis")
                }
                )),
                t.config.annotations.points.map((function(e, t) {
                    a(e, t, "point")
                }
                ))
            }
        }, {
            key: "getY1Y2",
            value: function(e, t) {
                var a, i = "y1" === e ? t.y : t.y2, n = this.w;
                if (this.annoCtx.invertAxis) {
                    var r = n.globals.labels.indexOf(i);
                    n.config.xaxis.convertedCatToNumeric && (r = n.globals.categoryLabels.indexOf(i));
                    var o = n.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
                    o && (a = parseFloat(o.getAttribute("y"))),
                    void 0 !== t.seriesIndex && n.globals.barHeight && (a = a - n.globals.barHeight / 2 * (n.globals.series.length - 1) + n.globals.barHeight * t.seriesIndex)
                } else {
                    var s;
                    s = n.config.yaxis[t.yAxisIndex].logarithmic ? (i = new k(this.annoCtx.ctx).getLogVal(i, t.yAxisIndex)) / n.globals.yLogRatio[t.yAxisIndex] : (i - n.globals.minYArr[t.yAxisIndex]) / (n.globals.yRange[t.yAxisIndex] / n.globals.gridHeight),
                    a = n.globals.gridHeight - s,
                    !t.marker || void 0 !== t.y && null !== t.y || (a = 0),
                    n.config.yaxis[t.yAxisIndex] && n.config.yaxis[t.yAxisIndex].reversed && (a = s)
                }
                return "string" == typeof i && i.indexOf("px") > -1 && (a = parseFloat(i)),
                a
            }
        }, {
            key: "getX1X2",
            value: function(e, t) {
                var a = this.w
                  , i = this.annoCtx.invertAxis ? a.globals.minY : a.globals.minX
                  , n = this.annoCtx.invertAxis ? a.globals.maxY : a.globals.maxX
                  , r = this.annoCtx.invertAxis ? a.globals.yRange[0] : a.globals.xRange
                  , o = (t.x - i) / (r / a.globals.gridWidth);
                this.annoCtx.inversedReversedAxis && (o = (n - t.x) / (r / a.globals.gridWidth)),
                "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || a.globals.dataFormatXNumeric || (o = this.getStringX(t.x));
                var s = (t.x2 - i) / (r / a.globals.gridWidth);
                return this.annoCtx.inversedReversedAxis && (s = (n - t.x2) / (r / a.globals.gridWidth)),
                "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || a.globals.dataFormatXNumeric || (s = this.getStringX(t.x2)),
                void 0 !== t.x && null !== t.x || !t.marker || (o = a.globals.gridWidth),
                "x1" === e && "string" == typeof t.x && t.x.indexOf("px") > -1 && (o = parseFloat(t.x)),
                "x2" === e && "string" == typeof t.x2 && t.x2.indexOf("px") > -1 && (s = parseFloat(t.x2)),
                void 0 !== t.seriesIndex && a.globals.barWidth && !this.annoCtx.invertAxis && (o = o - a.globals.barWidth / 2 * (a.globals.series.length - 1) + a.globals.barWidth * t.seriesIndex),
                "x1" === e ? o : s
            }
        }, {
            key: "getStringX",
            value: function(e) {
                var t = this.w
                  , a = e;
                t.config.xaxis.convertedCatToNumeric && t.globals.categoryLabels.length && (e = t.globals.categoryLabels.indexOf(e) + 1);
                var i = t.globals.labels.indexOf(e)
                  , n = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (i + 1) + ")");
                return n && (a = parseFloat(n.getAttribute("x"))),
                a
            }
        }]),
        e
    }()
      , C = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.annoCtx = t,
            this.invertAxis = this.annoCtx.invertAxis,
            this.helpers = new S(this.annoCtx)
        }
        return s(e, [{
            key: "addXaxisAnnotation",
            value: function(e, t, a) {
                var i, n = this.w, r = this.helpers.getX1X2("x1", e), o = e.label.text, s = e.strokeDashArray;
                if (b.isNumber(r)) {
                    if (null === e.x2 || void 0 === e.x2) {
                        var l = this.annoCtx.graphics.drawLine(r + e.offsetX, 0 + e.offsetY, r + e.offsetX, n.globals.gridHeight + e.offsetY, e.borderColor, s, e.borderWidth);
                        t.appendChild(l.node),
                        e.id && l.node.classList.add(e.id)
                    } else {
                        if ((i = this.helpers.getX1X2("x2", e)) < r) {
                            var c = r;
                            r = i,
                            i = c
                        }
                        var u = this.annoCtx.graphics.drawRect(r + e.offsetX, 0 + e.offsetY, i - r, n.globals.gridHeight + e.offsetY, 0, e.fillColor, e.opacity, 1, e.borderColor, s);
                        u.node.classList.add("apexcharts-annotation-rect"),
                        u.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")")),
                        t.appendChild(u.node),
                        e.id && u.node.classList.add(e.id)
                    }
                    var d = this.annoCtx.graphics.getTextRects(o, parseFloat(e.label.style.fontSize))
                      , h = "top" === e.label.position ? 4 : "center" === e.label.position ? n.globals.gridHeight / 2 + ("vertical" === e.label.orientation ? d.width / 2 : 0) : n.globals.gridHeight
                      , p = this.annoCtx.graphics.drawText({
                        x: r + e.label.offsetX,
                        y: h + e.label.offsetY - ("vertical" === e.label.orientation ? "top" === e.label.position ? d.width / 2 - 12 : -d.width / 2 : 0),
                        text: o,
                        textAnchor: e.label.textAnchor,
                        fontSize: e.label.style.fontSize,
                        fontFamily: e.label.style.fontFamily,
                        fontWeight: e.label.style.fontWeight,
                        foreColor: e.label.style.color,
                        cssClass: "apexcharts-xaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                    });
                    p.attr({
                        rel: a
                    }),
                    t.appendChild(p.node),
                    this.annoCtx.helpers.setOrientations(e, a)
                }
            }
        }, {
            key: "drawXAxisAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , a = this.annoCtx.graphics.group({
                    class: "apexcharts-xaxis-annotations"
                });
                return t.config.annotations.xaxis.map((function(t, i) {
                    e.addXaxisAnnotation(t, a.node, i)
                }
                )),
                a
            }
        }]),
        e
    }()
      , A = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.annoCtx = t,
            this.helpers = new S(this.annoCtx)
        }
        return s(e, [{
            key: "addYaxisAnnotation",
            value: function(e, t, a) {
                var i, n = this.w, r = e.strokeDashArray, o = this.helpers.getY1Y2("y1", e), s = e.label.text;
                if (null === e.y2 || void 0 === e.y2) {
                    var l = this.annoCtx.graphics.drawLine(0 + e.offsetX, o + e.offsetY, this._getYAxisAnnotationWidth(e), o + e.offsetY, e.borderColor, r, e.borderWidth);
                    t.appendChild(l.node),
                    e.id && l.node.classList.add(e.id)
                } else {
                    if ((i = this.helpers.getY1Y2("y2", e)) > o) {
                        var c = o;
                        o = i,
                        i = c
                    }
                    var u = this.annoCtx.graphics.drawRect(0 + e.offsetX, i + e.offsetY, this._getYAxisAnnotationWidth(e), o - i, 0, e.fillColor, e.opacity, 1, e.borderColor, r);
                    u.node.classList.add("apexcharts-annotation-rect"),
                    u.attr("clip-path", "url(#gridRectMask".concat(n.globals.cuid, ")")),
                    t.appendChild(u.node),
                    e.id && u.node.classList.add(e.id)
                }
                var d = "right" === e.label.position ? n.globals.gridWidth : "center" === e.label.position ? n.globals.gridWidth / 2 : 0
                  , h = this.annoCtx.graphics.drawText({
                    x: d + e.label.offsetX,
                    y: (i ?? o) + e.label.offsetY - 3,
                    text: s,
                    textAnchor: e.label.textAnchor,
                    fontSize: e.label.style.fontSize,
                    fontFamily: e.label.style.fontFamily,
                    fontWeight: e.label.style.fontWeight,
                    foreColor: e.label.style.color,
                    cssClass: "apexcharts-yaxis-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                });
                h.attr({
                    rel: a
                }),
                t.appendChild(h.node)
            }
        }, {
            key: "_getYAxisAnnotationWidth",
            value: function(e) {
                var t = this.w;
                return t.globals.gridWidth,
                (e.width.indexOf("%") > -1 ? t.globals.gridWidth * parseInt(e.width, 10) / 100 : parseInt(e.width, 10)) + e.offsetX
            }
        }, {
            key: "drawYAxisAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , a = this.annoCtx.graphics.group({
                    class: "apexcharts-yaxis-annotations"
                });
                return t.config.annotations.yaxis.map((function(t, i) {
                    e.addYaxisAnnotation(t, a.node, i)
                }
                )),
                a
            }
        }]),
        e
    }()
      , P = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.annoCtx = t,
            this.helpers = new S(this.annoCtx)
        }
        return s(e, [{
            key: "addPointAnnotation",
            value: function(e, t, a) {
                this.w;
                var i = this.helpers.getX1X2("x1", e)
                  , n = this.helpers.getY1Y2("y1", e);
                if (b.isNumber(i)) {
                    var r = {
                        pSize: e.marker.size,
                        pointStrokeWidth: e.marker.strokeWidth,
                        pointFillColor: e.marker.fillColor,
                        pointStrokeColor: e.marker.strokeColor,
                        shape: e.marker.shape,
                        pRadius: e.marker.radius,
                        class: "apexcharts-point-annotation-marker ".concat(e.marker.cssClass, " ").concat(e.id ? e.id : "")
                    }
                      , o = this.annoCtx.graphics.drawMarker(i + e.marker.offsetX, n + e.marker.offsetY, r);
                    t.appendChild(o.node);
                    var s = e.label.text ? e.label.text : ""
                      , l = this.annoCtx.graphics.drawText({
                        x: i + e.label.offsetX,
                        y: n + e.label.offsetY - e.marker.size - parseFloat(e.label.style.fontSize) / 1.6,
                        text: s,
                        textAnchor: e.label.textAnchor,
                        fontSize: e.label.style.fontSize,
                        fontFamily: e.label.style.fontFamily,
                        fontWeight: e.label.style.fontWeight,
                        foreColor: e.label.style.color,
                        cssClass: "apexcharts-point-annotation-label ".concat(e.label.style.cssClass, " ").concat(e.id ? e.id : "")
                    });
                    if (l.attr({
                        rel: a
                    }),
                    t.appendChild(l.node),
                    e.customSVG.SVG) {
                        var c = this.annoCtx.graphics.group({
                            class: "apexcharts-point-annotations-custom-svg " + e.customSVG.cssClass
                        });
                        c.attr({
                            transform: "translate(".concat(i + e.customSVG.offsetX, ", ").concat(n + e.customSVG.offsetY, ")")
                        }),
                        c.node.innerHTML = e.customSVG.SVG,
                        t.appendChild(c.node)
                    }
                    if (e.image.path) {
                        var u = e.image.width ? e.image.width : 20
                          , d = e.image.height ? e.image.height : 20;
                        o = this.annoCtx.addImage({
                            x: i + e.image.offsetX - u / 2,
                            y: n + e.image.offsetY - d / 2,
                            width: u,
                            height: d,
                            path: e.image.path,
                            appendTo: ".apexcharts-point-annotations"
                        })
                    }
                    e.mouseEnter && o.node.addEventListener("mouseenter", e.mouseEnter.bind(this, e)),
                    e.mouseLeave && o.node.addEventListener("mouseleave", e.mouseLeave.bind(this, e)),
                    e.click && o.node.addEventListener("click", e.click.bind(this, e))
                }
            }
        }, {
            key: "drawPointAnnotations",
            value: function() {
                var e = this
                  , t = this.w
                  , a = this.annoCtx.graphics.group({
                    class: "apexcharts-point-annotations"
                });
                return t.config.annotations.points.map((function(t, i) {
                    e.addPointAnnotation(t, a.node, i)
                }
                )),
                a
            }
        }]),
        e
    }()
      , L = {
        name: "en",
        options: {
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            toolbar: {
                exportToSVG: "Download SVG",
                exportToPNG: "Download PNG",
                exportToCSV: "Download CSV",
                menu: "Menu",
                selection: "Selection",
                selectionZoom: "Selection Zoom",
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                pan: "Panning",
                reset: "Reset Zoom"
            }
        }
    }
      , I = function() {
        function e() {
            r(this, e),
            this.yAxis = {
                show: !0,
                showAlways: !1,
                showForNullSeries: !0,
                seriesName: void 0,
                opposite: !1,
                reversed: !1,
                logarithmic: !1,
                logBase: 10,
                tickAmount: void 0,
                stepSize: void 0,
                forceNiceScale: !1,
                max: void 0,
                min: void 0,
                floating: !1,
                decimalsInFloat: void 0,
                labels: {
                    show: !0,
                    minWidth: 0,
                    maxWidth: 160,
                    offsetX: 0,
                    offsetY: 0,
                    align: void 0,
                    rotate: 0,
                    padding: 20,
                    style: {
                        colors: [],
                        fontSize: "11px",
                        fontWeight: 400,
                        fontFamily: void 0,
                        cssClass: ""
                    },
                    formatter: void 0
                },
                axisBorder: {
                    show: !1,
                    color: "#e0e0e0",
                    width: 1,
                    offsetX: 0,
                    offsetY: 0
                },
                axisTicks: {
                    show: !1,
                    color: "#e0e0e0",
                    width: 6,
                    offsetX: 0,
                    offsetY: 0
                },
                title: {
                    text: void 0,
                    rotate: -90,
                    offsetY: 0,
                    offsetX: 0,
                    style: {
                        color: void 0,
                        fontSize: "11px",
                        fontWeight: 900,
                        fontFamily: void 0,
                        cssClass: ""
                    }
                },
                tooltip: {
                    enabled: !1,
                    offsetX: 0
                },
                crosshairs: {
                    show: !0,
                    position: "front",
                    stroke: {
                        color: "#b6b6b6",
                        width: 1,
                        dashArray: 0
                    }
                }
            },
            this.pointAnnotation = {
                id: void 0,
                x: 0,
                y: null,
                yAxisIndex: 0,
                seriesIndex: void 0,
                mouseEnter: void 0,
                mouseLeave: void 0,
                click: void 0,
                marker: {
                    size: 4,
                    fillColor: "#fff",
                    strokeWidth: 2,
                    strokeColor: "#333",
                    shape: "circle",
                    offsetX: 0,
                    offsetY: 0,
                    radius: 2,
                    cssClass: ""
                },
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    offsetX: 0,
                    offsetY: 0,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    click: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                },
                customSVG: {
                    SVG: void 0,
                    cssClass: void 0,
                    offsetX: 0,
                    offsetY: 0
                },
                image: {
                    path: void 0,
                    width: 20,
                    height: 20,
                    offsetX: 0,
                    offsetY: 0
                }
            },
            this.yAxisAnnotation = {
                id: void 0,
                y: 0,
                y2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                width: "100%",
                yAxisIndex: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "end",
                    position: "right",
                    offsetX: 0,
                    offsetY: -3,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    click: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                }
            },
            this.xAxisAnnotation = {
                id: void 0,
                x: 0,
                x2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    orientation: "vertical",
                    position: "top",
                    offsetX: 0,
                    offsetY: 0,
                    mouseEnter: void 0,
                    mouseLeave: void 0,
                    click: void 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {
                            left: 5,
                            right: 5,
                            top: 2,
                            bottom: 2
                        }
                    }
                }
            },
            this.text = {
                x: 0,
                y: 0,
                text: "",
                textAnchor: "start",
                foreColor: void 0,
                fontSize: "13px",
                fontFamily: void 0,
                fontWeight: 400,
                appendTo: ".apexcharts-annotations",
                backgroundColor: "transparent",
                borderColor: "#c2c2c2",
                borderRadius: 0,
                borderWidth: 0,
                paddingLeft: 4,
                paddingRight: 4,
                paddingTop: 2,
                paddingBottom: 2
            }
        }
        return s(e, [{
            key: "init",
            value: function() {
                return {
                    annotations: {
                        yaxis: [this.yAxisAnnotation],
                        xaxis: [this.xAxisAnnotation],
                        points: [this.pointAnnotation],
                        texts: [],
                        images: [],
                        shapes: []
                    },
                    chart: {
                        animations: {
                            enabled: !0,
                            easing: "easeinout",
                            speed: 800,
                            animateGradually: {
                                delay: 150,
                                enabled: !0
                            },
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 350
                            }
                        },
                        background: "transparent",
                        locales: [L],
                        defaultLocale: "en",
                        dropShadow: {
                            enabled: !1,
                            enabledOnSeries: void 0,
                            top: 2,
                            left: 2,
                            blur: 4,
                            color: "#000",
                            opacity: .35
                        },
                        events: {
                            animationEnd: void 0,
                            beforeMount: void 0,
                            mounted: void 0,
                            updated: void 0,
                            click: void 0,
                            mouseMove: void 0,
                            mouseLeave: void 0,
                            xAxisLabelClick: void 0,
                            legendClick: void 0,
                            markerClick: void 0,
                            selection: void 0,
                            dataPointSelection: void 0,
                            dataPointMouseEnter: void 0,
                            dataPointMouseLeave: void 0,
                            beforeZoom: void 0,
                            beforeResetZoom: void 0,
                            zoomed: void 0,
                            scrolled: void 0,
                            brushScrolled: void 0
                        },
                        foreColor: "#373d3f",
                        fontFamily: "Helvetica, Arial, sans-serif",
                        height: "auto",
                        parentHeightOffset: 15,
                        redrawOnParentResize: !0,
                        redrawOnWindowResize: !0,
                        id: void 0,
                        group: void 0,
                        nonce: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        selection: {
                            enabled: !1,
                            type: "x",
                            fill: {
                                color: "#24292e",
                                opacity: .1
                            },
                            stroke: {
                                width: 1,
                                color: "#24292e",
                                opacity: .4,
                                dashArray: 3
                            },
                            xaxis: {
                                min: void 0,
                                max: void 0
                            },
                            yaxis: {
                                min: void 0,
                                max: void 0
                            }
                        },
                        sparkline: {
                            enabled: !1
                        },
                        brush: {
                            enabled: !1,
                            autoScaleYaxis: !0,
                            target: void 0,
                            targets: void 0
                        },
                        stacked: !1,
                        stackOnlyBar: !0,
                        stackType: "normal",
                        toolbar: {
                            show: !0,
                            offsetX: 0,
                            offsetY: 0,
                            tools: {
                                download: !0,
                                selection: !0,
                                zoom: !0,
                                zoomin: !0,
                                zoomout: !0,
                                pan: !0,
                                reset: !0,
                                customIcons: []
                            },
                            export: {
                                csv: {
                                    filename: void 0,
                                    columnDelimiter: ",",
                                    headerCategory: "category",
                                    headerValue: "value",
                                    dateFormatter: function(e) {
                                        return new Date(e).toDateString()
                                    }
                                },
                                png: {
                                    filename: void 0
                                },
                                svg: {
                                    filename: void 0
                                }
                            },
                            autoSelected: "zoom"
                        },
                        type: "line",
                        width: "100%",
                        zoom: {
                            enabled: !0,
                            type: "x",
                            autoScaleYaxis: !1,
                            zoomedArea: {
                                fill: {
                                    color: "#90CAF9",
                                    opacity: .4
                                },
                                stroke: {
                                    color: "#0D47A1",
                                    opacity: .4,
                                    width: 1
                                }
                            }
                        }
                    },
                    plotOptions: {
                        area: {
                            fillTo: "origin"
                        },
                        bar: {
                            horizontal: !1,
                            columnWidth: "70%",
                            barHeight: "70%",
                            distributed: !1,
                            borderRadius: 0,
                            borderRadiusApplication: "around",
                            borderRadiusWhenStacked: "last",
                            rangeBarOverlap: !0,
                            rangeBarGroupRows: !1,
                            hideZeroBarsWhenGrouped: !1,
                            isDumbbell: !1,
                            dumbbellColors: void 0,
                            isFunnel: !1,
                            isFunnel3d: !0,
                            colors: {
                                ranges: [],
                                backgroundBarColors: [],
                                backgroundBarOpacity: 1,
                                backgroundBarRadius: 0
                            },
                            dataLabels: {
                                position: "top",
                                maxItems: 100,
                                hideOverflowingLabels: !0,
                                orientation: "horizontal",
                                total: {
                                    enabled: !1,
                                    formatter: void 0,
                                    offsetX: 0,
                                    offsetY: 0,
                                    style: {
                                        color: "#373d3f",
                                        fontSize: "12px",
                                        fontFamily: void 0,
                                        fontWeight: 600
                                    }
                                }
                            }
                        },
                        bubble: {
                            zScaling: !0,
                            minBubbleRadius: void 0,
                            maxBubbleRadius: void 0
                        },
                        candlestick: {
                            colors: {
                                upward: "#00B746",
                                downward: "#EF403C"
                            },
                            wick: {
                                useFillColor: !0
                            }
                        },
                        boxPlot: {
                            colors: {
                                upper: "#00E396",
                                lower: "#008FFB"
                            }
                        },
                        heatmap: {
                            radius: 2,
                            enableShades: !0,
                            shadeIntensity: .5,
                            reverseNegativeShade: !1,
                            distributed: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        treemap: {
                            enableShades: !0,
                            shadeIntensity: .5,
                            distributed: !1,
                            reverseNegativeShade: !1,
                            useFillColorAsStroke: !1,
                            borderRadius: 4,
                            dataLabels: {
                                format: "scale"
                            },
                            colorScale: {
                                inverse: !1,
                                ranges: [],
                                min: void 0,
                                max: void 0
                            }
                        },
                        radialBar: {
                            inverseOrder: !1,
                            startAngle: 0,
                            endAngle: 360,
                            offsetX: 0,
                            offsetY: 0,
                            hollow: {
                                margin: 5,
                                size: "50%",
                                background: "transparent",
                                image: void 0,
                                imageWidth: 150,
                                imageHeight: 150,
                                imageOffsetX: 0,
                                imageOffsetY: 0,
                                imageClipped: !0,
                                position: "front",
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            track: {
                                show: !0,
                                startAngle: void 0,
                                endAngle: void 0,
                                background: "#f2f2f2",
                                strokeWidth: "97%",
                                opacity: 1,
                                margin: 5,
                                dropShadow: {
                                    enabled: !1,
                                    top: 0,
                                    left: 0,
                                    blur: 3,
                                    color: "#000",
                                    opacity: .5
                                }
                            },
                            dataLabels: {
                                show: !0,
                                name: {
                                    show: !0,
                                    fontSize: "16px",
                                    fontFamily: void 0,
                                    fontWeight: 600,
                                    color: void 0,
                                    offsetY: 0,
                                    formatter: function(e) {
                                        return e
                                    }
                                },
                                value: {
                                    show: !0,
                                    fontSize: "14px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    color: void 0,
                                    offsetY: 16,
                                    formatter: function(e) {
                                        return e + "%"
                                    }
                                },
                                total: {
                                    show: !1,
                                    label: "Total",
                                    fontSize: "16px",
                                    fontWeight: 600,
                                    fontFamily: void 0,
                                    color: void 0,
                                    formatter: function(e) {
                                        return e.globals.seriesTotals.reduce((function(e, t) {
                                            return e + t
                                        }
                                        ), 0) / e.globals.series.length + "%"
                                    }
                                }
                            },
                            barLabels: {
                                enabled: !1,
                                margin: 5,
                                useSeriesColors: !0,
                                fontFamily: void 0,
                                fontWeight: 600,
                                fontSize: "16px",
                                formatter: function(e) {
                                    return e
                                },
                                onClick: void 0
                            }
                        },
                        pie: {
                            customScale: 1,
                            offsetX: 0,
                            offsetY: 0,
                            startAngle: 0,
                            endAngle: 360,
                            expandOnClick: !0,
                            dataLabels: {
                                offset: 0,
                                minAngleToShowLabel: 10
                            },
                            donut: {
                                size: "65%",
                                background: "transparent",
                                labels: {
                                    show: !1,
                                    name: {
                                        show: !0,
                                        fontSize: "16px",
                                        fontFamily: void 0,
                                        fontWeight: 600,
                                        color: void 0,
                                        offsetY: -10,
                                        formatter: function(e) {
                                            return e
                                        }
                                    },
                                    value: {
                                        show: !0,
                                        fontSize: "20px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        color: void 0,
                                        offsetY: 10,
                                        formatter: function(e) {
                                            return e
                                        }
                                    },
                                    total: {
                                        show: !1,
                                        showAlways: !1,
                                        label: "Total",
                                        fontSize: "16px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        color: void 0,
                                        formatter: function(e) {
                                            return e.globals.seriesTotals.reduce((function(e, t) {
                                                return e + t
                                            }
                                            ), 0)
                                        }
                                    }
                                }
                            }
                        },
                        polarArea: {
                            rings: {
                                strokeWidth: 1,
                                strokeColor: "#e8e8e8"
                            },
                            spokes: {
                                strokeWidth: 1,
                                connectorColors: "#e8e8e8"
                            }
                        },
                        radar: {
                            size: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            polygons: {
                                strokeWidth: 1,
                                strokeColors: "#e8e8e8",
                                connectorColors: "#e8e8e8",
                                fill: {
                                    colors: void 0
                                }
                            }
                        }
                    },
                    colors: void 0,
                    dataLabels: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        formatter: function(e) {
                            return null !== e ? e : ""
                        },
                        textAnchor: "middle",
                        distributed: !1,
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0,
                            fontWeight: 600,
                            colors: void 0
                        },
                        background: {
                            enabled: !0,
                            foreColor: "#fff",
                            borderRadius: 2,
                            padding: 4,
                            opacity: .9,
                            borderWidth: 1,
                            borderColor: "#fff",
                            dropShadow: {
                                enabled: !1,
                                top: 1,
                                left: 1,
                                blur: 1,
                                color: "#000",
                                opacity: .45
                            }
                        },
                        dropShadow: {
                            enabled: !1,
                            top: 1,
                            left: 1,
                            blur: 1,
                            color: "#000",
                            opacity: .45
                        }
                    },
                    fill: {
                        type: "solid",
                        colors: void 0,
                        opacity: .85,
                        gradient: {
                            shade: "dark",
                            type: "horizontal",
                            shadeIntensity: .5,
                            gradientToColors: void 0,
                            inverseColors: !0,
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [0, 50, 100],
                            colorStops: []
                        },
                        image: {
                            src: [],
                            width: void 0,
                            height: void 0
                        },
                        pattern: {
                            style: "squares",
                            width: 6,
                            height: 6,
                            strokeWidth: 2
                        }
                    },
                    forecastDataPoints: {
                        count: 0,
                        fillOpacity: .5,
                        strokeWidth: void 0,
                        dashArray: 4
                    },
                    grid: {
                        show: !0,
                        borderColor: "#e0e0e0",
                        strokeDashArray: 0,
                        position: "back",
                        xaxis: {
                            lines: {
                                show: !1
                            }
                        },
                        yaxis: {
                            lines: {
                                show: !0
                            }
                        },
                        row: {
                            colors: void 0,
                            opacity: .5
                        },
                        column: {
                            colors: void 0,
                            opacity: .5
                        },
                        padding: {
                            top: 0,
                            right: 10,
                            bottom: 0,
                            left: 12
                        }
                    },
                    labels: [],
                    legend: {
                        show: !0,
                        showForSingleSeries: !1,
                        showForNullSeries: !0,
                        showForZeroSeries: !0,
                        floating: !1,
                        position: "bottom",
                        horizontalAlign: "center",
                        inverseOrder: !1,
                        fontSize: "12px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        width: void 0,
                        height: void 0,
                        formatter: void 0,
                        tooltipHoverFormatter: void 0,
                        offsetX: -20,
                        offsetY: 4,
                        customLegendItems: [],
                        labels: {
                            colors: void 0,
                            useSeriesColors: !1
                        },
                        markers: {
                            width: 12,
                            height: 12,
                            strokeWidth: 0,
                            fillColors: void 0,
                            strokeColor: "#fff",
                            radius: 12,
                            customHTML: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            onClick: void 0
                        },
                        itemMargin: {
                            horizontal: 5,
                            vertical: 2
                        },
                        onItemClick: {
                            toggleDataSeries: !0
                        },
                        onItemHover: {
                            highlightDataSeries: !0
                        }
                    },
                    markers: {
                        discrete: [],
                        size: 0,
                        colors: void 0,
                        strokeColors: "#fff",
                        strokeWidth: 2,
                        strokeOpacity: .9,
                        strokeDashArray: 0,
                        fillOpacity: 1,
                        shape: "circle",
                        width: 8,
                        height: 8,
                        radius: 2,
                        offsetX: 0,
                        offsetY: 0,
                        onClick: void 0,
                        onDblClick: void 0,
                        showNullDataPoints: !0,
                        hover: {
                            size: void 0,
                            sizeOffset: 3
                        }
                    },
                    noData: {
                        text: void 0,
                        align: "center",
                        verticalAlign: "middle",
                        offsetX: 0,
                        offsetY: 0,
                        style: {
                            color: void 0,
                            fontSize: "14px",
                            fontFamily: void 0
                        }
                    },
                    responsive: [],
                    series: void 0,
                    states: {
                        normal: {
                            filter: {
                                type: "none",
                                value: 0
                            }
                        },
                        hover: {
                            filter: {
                                type: "lighten",
                                value: .1
                            }
                        },
                        active: {
                            allowMultipleDataPointsSelection: !1,
                            filter: {
                                type: "darken",
                                value: .5
                            }
                        }
                    },
                    title: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 0,
                        floating: !1,
                        style: {
                            fontSize: "14px",
                            fontWeight: 900,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    subtitle: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 30,
                        floating: !1,
                        style: {
                            fontSize: "12px",
                            fontWeight: 400,
                            fontFamily: void 0,
                            color: void 0
                        }
                    },
                    stroke: {
                        show: !0,
                        curve: "smooth",
                        lineCap: "butt",
                        width: 2,
                        colors: void 0,
                        dashArray: 0,
                        fill: {
                            type: "solid",
                            colors: void 0,
                            opacity: .85,
                            gradient: {
                                shade: "dark",
                                type: "horizontal",
                                shadeIntensity: .5,
                                gradientToColors: void 0,
                                inverseColors: !0,
                                opacityFrom: 1,
                                opacityTo: 1,
                                stops: [0, 50, 100],
                                colorStops: []
                            }
                        }
                    },
                    tooltip: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        shared: !0,
                        hideEmptySeries: !1,
                        followCursor: !1,
                        intersect: !1,
                        inverseOrder: !1,
                        custom: void 0,
                        fillSeriesColor: !1,
                        theme: "light",
                        cssClass: "",
                        style: {
                            fontSize: "12px",
                            fontFamily: void 0
                        },
                        onDatasetHover: {
                            highlightDataSeries: !1
                        },
                        x: {
                            show: !0,
                            format: "dd MMM",
                            formatter: void 0
                        },
                        y: {
                            formatter: void 0,
                            title: {
                                formatter: function(e) {
                                    return e ? e + ": " : ""
                                }
                            }
                        },
                        z: {
                            formatter: void 0,
                            title: "Size: "
                        },
                        marker: {
                            show: !0,
                            fillColors: void 0
                        },
                        items: {
                            display: "flex"
                        },
                        fixed: {
                            enabled: !1,
                            position: "topRight",
                            offsetX: 0,
                            offsetY: 0
                        }
                    },
                    xaxis: {
                        type: "category",
                        categories: [],
                        convertedCatToNumeric: !1,
                        offsetX: 0,
                        offsetY: 0,
                        overwriteCategories: void 0,
                        labels: {
                            show: !0,
                            rotate: -45,
                            rotateAlways: !1,
                            hideOverlappingLabels: !0,
                            trim: !1,
                            minHeight: void 0,
                            maxHeight: 120,
                            showDuplicates: !0,
                            style: {
                                colors: [],
                                fontSize: "12px",
                                fontWeight: 400,
                                fontFamily: void 0,
                                cssClass: ""
                            },
                            offsetX: 0,
                            offsetY: 0,
                            format: void 0,
                            formatter: void 0,
                            datetimeUTC: !0,
                            datetimeFormatter: {
                                year: "yyyy",
                                month: "MMM 'yy",
                                day: "dd MMM",
                                hour: "HH:mm",
                                minute: "HH:mm:ss",
                                second: "HH:mm:ss"
                            }
                        },
                        group: {
                            groups: [],
                            style: {
                                colors: [],
                                fontSize: "12px",
                                fontWeight: 400,
                                fontFamily: void 0,
                                cssClass: ""
                            }
                        },
                        axisBorder: {
                            show: !0,
                            color: "#e0e0e0",
                            width: "100%",
                            height: 1,
                            offsetX: 0,
                            offsetY: 0
                        },
                        axisTicks: {
                            show: !0,
                            color: "#e0e0e0",
                            height: 6,
                            offsetX: 0,
                            offsetY: 0
                        },
                        stepSize: void 0,
                        tickAmount: void 0,
                        tickPlacement: "on",
                        min: void 0,
                        max: void 0,
                        range: void 0,
                        floating: !1,
                        decimalsInFloat: void 0,
                        position: "bottom",
                        title: {
                            text: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            style: {
                                color: void 0,
                                fontSize: "12px",
                                fontWeight: 900,
                                fontFamily: void 0,
                                cssClass: ""
                            }
                        },
                        crosshairs: {
                            show: !0,
                            width: 1,
                            position: "back",
                            opacity: .9,
                            stroke: {
                                color: "#b6b6b6",
                                width: 1,
                                dashArray: 3
                            },
                            fill: {
                                type: "solid",
                                color: "#B1B9C4",
                                gradient: {
                                    colorFrom: "#D8E3F0",
                                    colorTo: "#BED1E6",
                                    stops: [0, 100],
                                    opacityFrom: .4,
                                    opacityTo: .5
                                }
                            },
                            dropShadow: {
                                enabled: !1,
                                left: 0,
                                top: 0,
                                blur: 1,
                                opacity: .4
                            }
                        },
                        tooltip: {
                            enabled: !0,
                            offsetY: 0,
                            formatter: void 0,
                            style: {
                                fontSize: "12px",
                                fontFamily: void 0
                            }
                        }
                    },
                    yaxis: this.yAxis,
                    theme: {
                        mode: "light",
                        palette: "palette1",
                        monochrome: {
                            enabled: !1,
                            color: "#008FFB",
                            shadeTo: "light",
                            shadeIntensity: .65
                        }
                    }
                }
            }
        }]),
        e
    }()
      , _ = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.graphics = new w(this.ctx),
            this.w.globals.isBarHorizontal && (this.invertAxis = !0),
            this.helpers = new S(this),
            this.xAxisAnnotations = new C(this),
            this.yAxisAnnotations = new A(this),
            this.pointsAnnotations = new P(this),
            this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0),
            this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
        }
        return s(e, [{
            key: "drawAxesAnnotations",
            value: function() {
                var e = this.w;
                if (e.globals.axisCharts) {
                    for (var t = this.yAxisAnnotations.drawYAxisAnnotations(), a = this.xAxisAnnotations.drawXAxisAnnotations(), i = this.pointsAnnotations.drawPointAnnotations(), n = e.config.chart.animations.enabled, r = [t, a, i], o = [a.node, t.node, i.node], s = 0; s < 3; s++)
                        e.globals.dom.elGraphical.add(r[s]),
                        !n || e.globals.resized || e.globals.dataChanged || "scatter" !== e.config.chart.type && "bubble" !== e.config.chart.type && e.globals.dataPoints > 1 && o[s].classList.add("apexcharts-element-hidden"),
                        e.globals.delayedElements.push({
                            el: o[s],
                            index: 0
                        });
                    this.helpers.annotationsBackground()
                }
            }
        }, {
            key: "drawImageAnnos",
            value: function() {
                var e = this;
                this.w.config.annotations.images.map((function(t, a) {
                    e.addImage(t, a)
                }
                ))
            }
        }, {
            key: "drawTextAnnos",
            value: function() {
                var e = this;
                this.w.config.annotations.texts.map((function(t, a) {
                    e.addText(t, a)
                }
                ))
            }
        }, {
            key: "addXaxisAnnotation",
            value: function(e, t, a) {
                this.xAxisAnnotations.addXaxisAnnotation(e, t, a)
            }
        }, {
            key: "addYaxisAnnotation",
            value: function(e, t, a) {
                this.yAxisAnnotations.addYaxisAnnotation(e, t, a)
            }
        }, {
            key: "addPointAnnotation",
            value: function(e, t, a) {
                this.pointsAnnotations.addPointAnnotation(e, t, a)
            }
        }, {
            key: "addText",
            value: function(e, t) {
                var a = e.x
                  , i = e.y
                  , n = e.text
                  , r = e.textAnchor
                  , o = e.foreColor
                  , s = e.fontSize
                  , l = e.fontFamily
                  , c = e.fontWeight
                  , u = e.cssClass
                  , d = e.backgroundColor
                  , h = e.borderWidth
                  , p = e.strokeDashArray
                  , v = e.borderRadius
                  , g = e.borderColor
                  , f = e.appendTo
                  , m = void 0 === f ? ".apexcharts-svg" : f
                  , b = e.paddingLeft
                  , x = void 0 === b ? 4 : b
                  , y = e.paddingRight
                  , w = void 0 === y ? 4 : y
                  , k = e.paddingBottom
                  , S = void 0 === k ? 2 : k
                  , C = e.paddingTop
                  , A = void 0 === C ? 2 : C
                  , P = this.w
                  , L = this.graphics.drawText({
                    x: a,
                    y: i,
                    text: n,
                    textAnchor: r || "start",
                    fontSize: s || "12px",
                    fontWeight: c || "regular",
                    fontFamily: l || P.config.chart.fontFamily,
                    foreColor: o || P.config.chart.foreColor,
                    cssClass: u
                })
                  , I = P.globals.dom.baseEl.querySelector(m);
                I && I.appendChild(L.node);
                var _ = L.bbox();
                if (n) {
                    var T = this.graphics.drawRect(_.x - x, _.y - A, _.width + x + w, _.height + S + A, v, d || "transparent", 1, h, g, p);
                    I.insertBefore(T.node, L.node)
                }
            }
        }, {
            key: "addImage",
            value: function(e, t) {
                var a = this.w
                  , i = e.path
                  , n = e.x
                  , r = void 0 === n ? 0 : n
                  , o = e.y
                  , s = void 0 === o ? 0 : o
                  , l = e.width
                  , c = void 0 === l ? 20 : l
                  , u = e.height
                  , d = void 0 === u ? 20 : u
                  , h = e.appendTo
                  , p = void 0 === h ? ".apexcharts-svg" : h
                  , v = a.globals.dom.Paper.image(i);
                v.size(c, d).move(r, s);
                var g = a.globals.dom.baseEl.querySelector(p);
                return g && g.appendChild(v.node),
                v
            }
        }, {
            key: "addXaxisAnnotationExternal",
            value: function(e, t, a) {
                return this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: a,
                    type: "xaxis",
                    contextMethod: a.addXaxisAnnotation
                }),
                a
            }
        }, {
            key: "addYaxisAnnotationExternal",
            value: function(e, t, a) {
                return this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: a,
                    type: "yaxis",
                    contextMethod: a.addYaxisAnnotation
                }),
                a
            }
        }, {
            key: "addPointAnnotationExternal",
            value: function(e, t, a) {
                return void 0 === this.invertAxis && (this.invertAxis = a.w.globals.isBarHorizontal),
                this.addAnnotationExternal({
                    params: e,
                    pushToMemory: t,
                    context: a,
                    type: "point",
                    contextMethod: a.addPointAnnotation
                }),
                a
            }
        }, {
            key: "addAnnotationExternal",
            value: function(e) {
                var t = e.params
                  , a = e.pushToMemory
                  , i = e.context
                  , n = e.type
                  , r = e.contextMethod
                  , o = i
                  , s = o.w
                  , l = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(n, "-annotations"))
                  , c = l.childNodes.length + 1
                  , u = new I
                  , d = Object.assign({}, "xaxis" === n ? u.xAxisAnnotation : "yaxis" === n ? u.yAxisAnnotation : u.pointAnnotation)
                  , h = b.extend(d, t);
                switch (n) {
                case "xaxis":
                    this.addXaxisAnnotation(h, l, c);
                    break;
                case "yaxis":
                    this.addYaxisAnnotation(h, l, c);
                    break;
                case "point":
                    this.addPointAnnotation(h, l, c)
                }
                var p = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(n, "-annotations .apexcharts-").concat(n, "-annotation-label[rel='").concat(c, "']"))
                  , v = this.helpers.addBackgroundToAnno(p, h);
                return v && l.insertBefore(v.node, p),
                a && s.globals.memory.methodsToExec.push({
                    context: o,
                    id: h.id ? h.id : b.randomId(),
                    method: r,
                    label: "addAnnotation",
                    params: t
                }),
                i
            }
        }, {
            key: "clearAnnotations",
            value: function(e) {
                var t = e.w
                  , a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                t.globals.memory.methodsToExec.map((function(e, a) {
                    "addText" !== e.label && "addAnnotation" !== e.label || t.globals.memory.methodsToExec.splice(a, 1)
                }
                )),
                a = b.listToArray(a),
                Array.prototype.forEach.call(a, (function(e) {
                    for (; e.firstChild; )
                        e.removeChild(e.firstChild)
                }
                ))
            }
        }, {
            key: "removeAnnotation",
            value: function(e, t) {
                var a = e.w
                  , i = a.globals.dom.baseEl.querySelectorAll(".".concat(t));
                i && (a.globals.memory.methodsToExec.map((function(e, i) {
                    e.id === t && a.globals.memory.methodsToExec.splice(i, 1)
                }
                )),
                Array.prototype.forEach.call(i, (function(e) {
                    e.parentElement.removeChild(e)
                }
                )))
            }
        }]),
        e
    }()
      , T = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.months31 = [1, 3, 5, 7, 8, 10, 12],
            this.months30 = [2, 4, 6, 9, 11],
            this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        }
        return s(e, [{
            key: "isValidDate",
            value: function(e) {
                return "number" != typeof e && !isNaN(this.parseDate(e))
            }
        }, {
            key: "getTimeStamp",
            value: function(e) {
                return Date.parse(e) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toISOString().substr(0, 25)).getTime() : new Date(e).getTime() : e
            }
        }, {
            key: "getDate",
            value: function(e) {
                return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(e).toUTCString()) : new Date(e)
            }
        }, {
            key: "parseDate",
            value: function(e) {
                var t = Date.parse(e);
                if (!isNaN(t))
                    return this.getTimeStamp(e);
                var a = Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                return this.getTimeStamp(a)
            }
        }, {
            key: "parseDateWithTimezone",
            value: function(e) {
                return Date.parse(e.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
            }
        }, {
            key: "formatDate",
            value: function(e, t) {
                var a = this.w.globals.locale
                  , i = this.w.config.xaxis.labels.datetimeUTC
                  , n = ["\0"].concat(g(a.months))
                  , r = [""].concat(g(a.shortMonths))
                  , o = [""].concat(g(a.days))
                  , s = [""].concat(g(a.shortDays));
                function l(e, t) {
                    var a = e + "";
                    for (t = t || 2; a.length < t; )
                        a = "0" + a;
                    return a
                }
                var c = i ? e.getUTCFullYear() : e.getFullYear();
                t = (t = (t = t.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(/(^|[^\\])yy/g, "$1" + c.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c);
                var u = (i ? e.getUTCMonth() : e.getMonth()) + 1;
                t = (t = (t = (t = t.replace(/(^|[^\\])MMMM+/g, "$1" + n[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + l(u))).replace(/(^|[^\\])M/g, "$1" + u);
                var d = i ? e.getUTCDate() : e.getDate();
                t = (t = (t = (t = t.replace(/(^|[^\\])dddd+/g, "$1" + o[0])).replace(/(^|[^\\])ddd/g, "$1" + s[0])).replace(/(^|[^\\])dd/g, "$1" + l(d))).replace(/(^|[^\\])d/g, "$1" + d);
                var h = i ? e.getUTCHours() : e.getHours()
                  , p = h > 12 ? h - 12 : 0 === h ? 12 : h;
                t = (t = (t = (t = t.replace(/(^|[^\\])HH+/g, "$1" + l(h))).replace(/(^|[^\\])H/g, "$1" + h)).replace(/(^|[^\\])hh+/g, "$1" + l(p))).replace(/(^|[^\\])h/g, "$1" + p);
                var v = i ? e.getUTCMinutes() : e.getMinutes();
                t = (t = t.replace(/(^|[^\\])mm+/g, "$1" + l(v))).replace(/(^|[^\\])m/g, "$1" + v);
                var f = i ? e.getUTCSeconds() : e.getSeconds();
                t = (t = t.replace(/(^|[^\\])ss+/g, "$1" + l(f))).replace(/(^|[^\\])s/g, "$1" + f);
                var m = i ? e.getUTCMilliseconds() : e.getMilliseconds();
                t = t.replace(/(^|[^\\])fff+/g, "$1" + l(m, 3)),
                m = Math.round(m / 10),
                t = t.replace(/(^|[^\\])ff/g, "$1" + l(m)),
                m = Math.round(m / 10);
                var b = h < 12 ? "AM" : "PM";
                t = (t = (t = t.replace(/(^|[^\\])f/g, "$1" + m)).replace(/(^|[^\\])TT+/g, "$1" + b)).replace(/(^|[^\\])T/g, "$1" + b.charAt(0));
                var x = b.toLowerCase();
                t = (t = t.replace(/(^|[^\\])tt+/g, "$1" + x)).replace(/(^|[^\\])t/g, "$1" + x.charAt(0));
                var y = -e.getTimezoneOffset()
                  , w = i || !y ? "Z" : y > 0 ? "+" : "-";
                if (!i) {
                    var k = (y = Math.abs(y)) % 60;
                    w += l(Math.floor(y / 60)) + ":" + l(k)
                }
                t = t.replace(/(^|[^\\])K/g, "$1" + w);
                var S = (i ? e.getUTCDay() : e.getDay()) + 1;
                return (t = (t = (t = (t = t.replace(new RegExp(o[0],"g"), o[S])).replace(new RegExp(s[0],"g"), s[S])).replace(new RegExp(n[0],"g"), n[u])).replace(new RegExp(r[0],"g"), r[u])).replace(/\\(.)/g, "$1")
            }
        }, {
            key: "getTimeUnitsfromTimestamp",
            value: function(e, t, a) {
                var i = this.w;
                void 0 !== i.config.xaxis.min && (e = i.config.xaxis.min),
                void 0 !== i.config.xaxis.max && (t = i.config.xaxis.max);
                var n = this.getDate(e)
                  , r = this.getDate(t)
                  , o = this.formatDate(n, "yyyy MM dd HH mm ss fff").split(" ")
                  , s = this.formatDate(r, "yyyy MM dd HH mm ss fff").split(" ");
                return {
                    minMillisecond: parseInt(o[6], 10),
                    maxMillisecond: parseInt(s[6], 10),
                    minSecond: parseInt(o[5], 10),
                    maxSecond: parseInt(s[5], 10),
                    minMinute: parseInt(o[4], 10),
                    maxMinute: parseInt(s[4], 10),
                    minHour: parseInt(o[3], 10),
                    maxHour: parseInt(s[3], 10),
                    minDate: parseInt(o[2], 10),
                    maxDate: parseInt(s[2], 10),
                    minMonth: parseInt(o[1], 10) - 1,
                    maxMonth: parseInt(s[1], 10) - 1,
                    minYear: parseInt(o[0], 10),
                    maxYear: parseInt(s[0], 10)
                }
            }
        }, {
            key: "isLeapYear",
            value: function(e) {
                return e % 4 == 0 && e % 100 != 0 || e % 400 == 0
            }
        }, {
            key: "calculcateLastDaysOfMonth",
            value: function(e, t, a) {
                return this.determineDaysOfMonths(e, t) - a
            }
        }, {
            key: "determineDaysOfYear",
            value: function(e) {
                var t = 365;
                return this.isLeapYear(e) && (t = 366),
                t
            }
        }, {
            key: "determineRemainingDaysOfYear",
            value: function(e, t, a) {
                var i = this.daysCntOfYear[t] + a;
                return t > 1 && this.isLeapYear() && i++,
                i
            }
        }, {
            key: "determineDaysOfMonths",
            value: function(e, t) {
                var a = 30;
                switch (e = b.monthMod(e),
                !0) {
                case this.months30.indexOf(e) > -1:
                    2 === e && (a = this.isLeapYear(t) ? 29 : 28);
                    break;
                case this.months31.indexOf(e) > -1:
                default:
                    a = 31
                }
                return a
            }
        }]),
        e
    }()
      , E = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.tooltipKeyFormat = "dd MMM"
        }
        return s(e, [{
            key: "xLabelFormat",
            value: function(e, t, a, i) {
                var n = this.w;
                if ("datetime" === n.config.xaxis.type && void 0 === n.config.xaxis.labels.formatter && void 0 === n.config.tooltip.x.formatter) {
                    var r = new T(this.ctx);
                    return r.formatDate(r.getDate(t), n.config.tooltip.x.format)
                }
                return e(t, a, i)
            }
        }, {
            key: "defaultGeneralFormatter",
            value: function(e) {
                return Array.isArray(e) ? e.map((function(e) {
                    return e
                }
                )) : e
            }
        }, {
            key: "defaultYFormatter",
            value: function(e, t, a) {
                var i = this.w;
                return b.isNumber(e) && (e = 0 !== i.globals.yValueDecimal ? e.toFixed(void 0 !== t.decimalsInFloat ? t.decimalsInFloat : i.globals.yValueDecimal) : i.globals.maxYArr[a] - i.globals.minYArr[a] < 5 ? e.toFixed(1) : e.toFixed(0)),
                e
            }
        }, {
            key: "setLabelFormatters",
            value: function() {
                var e = this
                  , t = this.w;
                return t.globals.xaxisTooltipFormatter = function(t) {
                    return e.defaultGeneralFormatter(t)
                }
                ,
                t.globals.ttKeyFormatter = function(t) {
                    return e.defaultGeneralFormatter(t)
                }
                ,
                t.globals.ttZFormatter = function(e) {
                    return e
                }
                ,
                t.globals.legendFormatter = function(t) {
                    return e.defaultGeneralFormatter(t)
                }
                ,
                void 0 !== t.config.xaxis.labels.formatter ? t.globals.xLabelFormatter = t.config.xaxis.labels.formatter : t.globals.xLabelFormatter = function(e) {
                    if (b.isNumber(e)) {
                        if (!t.config.xaxis.convertedCatToNumeric && "numeric" === t.config.xaxis.type) {
                            if (b.isNumber(t.config.xaxis.decimalsInFloat))
                                return e.toFixed(t.config.xaxis.decimalsInFloat);
                            var a = t.globals.maxX - t.globals.minX;
                            return a > 0 && a < 100 ? e.toFixed(1) : e.toFixed(0)
                        }
                        return t.globals.isBarHorizontal && t.globals.maxY - t.globals.minYArr < 4 ? e.toFixed(1) : e.toFixed(0)
                    }
                    return e
                }
                ,
                "function" == typeof t.config.tooltip.x.formatter ? t.globals.ttKeyFormatter = t.config.tooltip.x.formatter : t.globals.ttKeyFormatter = t.globals.xLabelFormatter,
                "function" == typeof t.config.xaxis.tooltip.formatter && (t.globals.xaxisTooltipFormatter = t.config.xaxis.tooltip.formatter),
                (Array.isArray(t.config.tooltip.y) || void 0 !== t.config.tooltip.y.formatter) && (t.globals.ttVal = t.config.tooltip.y),
                void 0 !== t.config.tooltip.z.formatter && (t.globals.ttZFormatter = t.config.tooltip.z.formatter),
                void 0 !== t.config.legend.formatter && (t.globals.legendFormatter = t.config.legend.formatter),
                t.config.yaxis.forEach((function(a, i) {
                    void 0 !== a.labels.formatter ? t.globals.yLabelFormatters[i] = a.labels.formatter : t.globals.yLabelFormatters[i] = function(n) {
                        return t.globals.xyCharts ? Array.isArray(n) ? n.map((function(t) {
                            return e.defaultYFormatter(t, a, i)
                        }
                        )) : e.defaultYFormatter(n, a, i) : n
                    }
                }
                )),
                t.globals
            }
        }, {
            key: "heatmapLabelFormatters",
            value: function() {
                var e = this.w;
                if ("heatmap" === e.config.chart.type) {
                    e.globals.yAxisScale[0].result = e.globals.seriesNames.slice();
                    var t = e.globals.seriesNames.reduce((function(e, t) {
                        return e.length > t.length ? e : t
                    }
                    ), 0);
                    e.globals.yAxisScale[0].niceMax = t,
                    e.globals.yAxisScale[0].niceMin = t
                }
            }
        }]),
        e
    }()
      , O = function(e) {
        var t, a = e.isTimeline, i = e.ctx, n = e.seriesIndex, r = e.dataPointIndex, o = e.y1, s = e.y2, l = e.w, c = l.globals.seriesRangeStart[n][r], u = l.globals.seriesRangeEnd[n][r], d = l.globals.labels[r], h = l.config.series[n].name ? l.config.series[n].name : "", p = l.globals.ttKeyFormatter, v = l.config.tooltip.y.title.formatter, g = {
            w: l,
            seriesIndex: n,
            dataPointIndex: r,
            start: c,
            end: u
        };
        "function" == typeof v && (h = v(h, g)),
        null !== (t = l.config.series[n].data[r]) && void 0 !== t && t.x && (d = l.config.series[n].data[r].x),
        a || "datetime" === l.config.xaxis.type && (d = new E(i).xLabelFormat(l.globals.ttKeyFormatter, d, d, {
            i: void 0,
            dateFormatter: new T(i).formatDate,
            w: l
        })),
        "function" == typeof p && (d = p(d, g)),
        Number.isFinite(o) && Number.isFinite(s) && (c = o,
        u = s);
        var f = ""
          , m = ""
          , b = l.globals.colors[n];
        if (void 0 === l.config.tooltip.x.formatter)
            if ("datetime" === l.config.xaxis.type) {
                var x = new T(i);
                f = x.formatDate(x.getDate(c), l.config.tooltip.x.format),
                m = x.formatDate(x.getDate(u), l.config.tooltip.x.format)
            } else
                f = c,
                m = u;
        else
            f = l.config.tooltip.x.formatter(c),
            m = l.config.tooltip.x.formatter(u);
        return {
            start: c,
            end: u,
            startVal: f,
            endVal: m,
            ylabel: d,
            color: b,
            seriesName: h
        }
    }
      , V = function(e) {
        var t = e.color
          , a = e.seriesName
          , i = e.ylabel
          , n = e.start
          , r = e.end
          , o = e.seriesIndex
          , s = e.dataPointIndex
          , l = e.ctx.tooltip.tooltipLabels.getFormatters(o);
        n = l.yLbFormatter(n),
        r = l.yLbFormatter(r);
        var c = l.yLbFormatter(e.w.globals.series[o][s])
          , u = '<span class="value start-value">\n  '.concat(n, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r, "\n  </span>");
        return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t + '">' + (a || "") + '</span></div><div> <span class="category">' + i + ": </span> " + (e.w.globals.comboCharts ? "rangeArea" === e.w.config.series[o].type || "rangeBar" === e.w.config.series[o].type ? u : "<span>".concat(c, "</span>") : u) + " </div></div>"
    }
      , F = function() {
        function e(t) {
            r(this, e),
            this.opts = t
        }
        return s(e, [{
            key: "hideYAxis",
            value: function() {
                this.opts.yaxis[0].show = !1,
                this.opts.yaxis[0].title.text = "",
                this.opts.yaxis[0].axisBorder.show = !1,
                this.opts.yaxis[0].axisTicks.show = !1,
                this.opts.yaxis[0].floating = !0
            }
        }, {
            key: "line",
            value: function() {
                return {
                    chart: {
                        animations: {
                            easing: "swing"
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 5,
                        curve: "straight"
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "sparkline",
            value: function(e) {
                return this.hideYAxis(),
                b.extend(e, {
                    grid: {
                        show: !1,
                        padding: {
                            left: 0,
                            right: 0,
                            top: 0,
                            bottom: 0
                        }
                    },
                    legend: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        },
                        axisBorder: {
                            show: !1
                        },
                        axisTicks: {
                            show: !1
                        }
                    },
                    chart: {
                        toolbar: {
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    }
                })
            }
        }, {
            key: "bar",
            value: function() {
                return {
                    chart: {
                        stacked: !1,
                        animations: {
                            easing: "swing"
                        }
                    },
                    plotOptions: {
                        bar: {
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        }
                    },
                    stroke: {
                        width: 0,
                        lineCap: "round"
                    },
                    fill: {
                        opacity: .85
                    },
                    legend: {
                        markers: {
                            shape: "square",
                            radius: 2,
                            size: 8
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        },
                        tickPlacement: "between",
                        crosshairs: {
                            width: "barWidth",
                            position: "back",
                            fill: {
                                type: "gradient"
                            },
                            dropShadow: {
                                enabled: !1
                            },
                            stroke: {
                                width: 0
                            }
                        }
                    }
                }
            }
        }, {
            key: "funnel",
            value: function() {
                return this.hideYAxis(),
                i(i({}, this.bar()), {}, {
                    chart: {
                        animations: {
                            easing: "linear",
                            speed: 800,
                            animateGradually: {
                                enabled: !1
                            }
                        }
                    },
                    plotOptions: {
                        bar: {
                            horizontal: !0,
                            borderRadiusApplication: "around",
                            borderRadius: 0,
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    grid: {
                        show: !1,
                        padding: {
                            left: 0,
                            right: 0
                        }
                    },
                    xaxis: {
                        labels: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        },
                        axisBorder: {
                            show: !1
                        },
                        axisTicks: {
                            show: !1
                        }
                    }
                })
            }
        }, {
            key: "candlestick",
            value: function() {
                var e = this;
                return {
                    stroke: {
                        width: 1,
                        colors: ["#333"]
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(t) {
                            var a = t.seriesIndex
                              , i = t.dataPointIndex
                              , n = t.w;
                            return e._getBoxTooltip(n, a, i, ["Open", "High", "", "Low", "Close"], "candlestick")
                        }
                    },
                    states: {
                        active: {
                            filter: {
                                type: "none"
                            }
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "boxPlot",
            value: function() {
                var e = this;
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !1
                            }
                        }
                    },
                    stroke: {
                        width: 1,
                        colors: ["#24292e"]
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !0,
                        custom: function(t) {
                            var a = t.seriesIndex
                              , i = t.dataPointIndex
                              , n = t.w;
                            return e._getBoxTooltip(n, a, i, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
                        }
                    },
                    markers: {
                        size: 5,
                        strokeWidth: 1,
                        strokeColors: "#111"
                    },
                    xaxis: {
                        crosshairs: {
                            width: 1
                        }
                    }
                }
            }
        }, {
            key: "rangeBar",
            value: function() {
                return {
                    chart: {
                        animations: {
                            animateGradually: !1
                        }
                    },
                    stroke: {
                        width: 0,
                        lineCap: "square"
                    },
                    plotOptions: {
                        bar: {
                            borderRadius: 0,
                            dataLabels: {
                                position: "center"
                            }
                        }
                    },
                    dataLabels: {
                        enabled: !1,
                        formatter: function(e, t) {
                            t.ctx;
                            var a = t.seriesIndex
                              , i = t.dataPointIndex
                              , n = t.w
                              , r = function() {
                                var e = n.globals.seriesRangeStart[a][i];
                                return n.globals.seriesRangeEnd[a][i] - e
                            };
                            return n.globals.comboCharts ? "rangeBar" === n.config.series[a].type || "rangeArea" === n.config.series[a].type ? r() : e : r()
                        },
                        background: {
                            enabled: !1
                        },
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    markers: {
                        size: 10
                    },
                    tooltip: {
                        shared: !1,
                        followCursor: !0,
                        custom: function(e) {
                            return e.w.config.plotOptions && e.w.config.plotOptions.bar && e.w.config.plotOptions.bar.horizontal ? (a = O(i(i({}, t = e), {}, {
                                isTimeline: !0
                            })),
                            n = a.color,
                            r = a.seriesName,
                            o = a.ylabel,
                            s = a.startVal,
                            l = a.endVal,
                            V(i(i({}, t), {}, {
                                color: n,
                                seriesName: r,
                                ylabel: o,
                                start: s,
                                end: l
                            }))) : function(e) {
                                var t = O(e)
                                  , a = t.color
                                  , n = t.seriesName
                                  , r = t.ylabel
                                  , o = t.start
                                  , s = t.end;
                                return V(i(i({}, e), {}, {
                                    color: a,
                                    seriesName: n,
                                    ylabel: r,
                                    start: o,
                                    end: s
                                }))
                            }(e);
                            var t, a, n, r, o, s, l
                        }
                    },
                    xaxis: {
                        tickPlacement: "between",
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            stroke: {
                                width: 0
                            }
                        }
                    }
                }
            }
        }, {
            key: "dumbbell",
            value: function(e) {
                var t, a;
                return null !== (t = e.plotOptions.bar) && void 0 !== t && t.barHeight || (e.plotOptions.bar.barHeight = 2),
                null !== (a = e.plotOptions.bar) && void 0 !== a && a.columnWidth || (e.plotOptions.bar.columnWidth = 2),
                e
            }
        }, {
            key: "area",
            value: function() {
                return {
                    stroke: {
                        width: 4,
                        fill: {
                            type: "solid",
                            gradient: {
                                inverseColors: !1,
                                shade: "light",
                                type: "vertical",
                                opacityFrom: .65,
                                opacityTo: .5,
                                stops: [0, 100, 100]
                            }
                        }
                    },
                    fill: {
                        type: "gradient",
                        gradient: {
                            inverseColors: !1,
                            shade: "light",
                            type: "vertical",
                            opacityFrom: .65,
                            opacityTo: .5,
                            stops: [0, 100, 100]
                        }
                    },
                    markers: {
                        size: 0,
                        hover: {
                            sizeOffset: 6
                        }
                    },
                    tooltip: {
                        followCursor: !1
                    }
                }
            }
        }, {
            key: "rangeArea",
            value: function() {
                return {
                    stroke: {
                        curve: "straight",
                        width: 0
                    },
                    fill: {
                        type: "solid",
                        opacity: .6
                    },
                    markers: {
                        size: 0
                    },
                    states: {
                        hover: {
                            filter: {
                                type: "none"
                            }
                        },
                        active: {
                            filter: {
                                type: "none"
                            }
                        }
                    },
                    tooltip: {
                        intersect: !1,
                        shared: !0,
                        followCursor: !0,
                        custom: function(e) {
                            return a = O(t = e),
                            n = a.color,
                            r = a.seriesName,
                            o = a.ylabel,
                            s = a.start,
                            l = a.end,
                            V(i(i({}, t), {}, {
                                color: n,
                                seriesName: r,
                                ylabel: o,
                                start: s,
                                end: l
                            }));
                            var t, a, n, r, o, s, l
                        }
                    }
                }
            }
        }, {
            key: "brush",
            value: function(e) {
                return b.extend(e, {
                    chart: {
                        toolbar: {
                            autoSelected: "selection",
                            show: !1
                        },
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        enabled: !1
                    },
                    stroke: {
                        width: 1
                    },
                    tooltip: {
                        enabled: !1
                    },
                    xaxis: {
                        tooltip: {
                            enabled: !1
                        }
                    }
                })
            }
        }, {
            key: "stacked100",
            value: function(e) {
                e.dataLabels = e.dataLabels || {},
                e.dataLabels.formatter = e.dataLabels.formatter || void 0;
                var t = e.dataLabels.formatter;
                return e.yaxis.forEach((function(t, a) {
                    e.yaxis[a].min = 0,
                    e.yaxis[a].max = 100
                }
                )),
                "bar" === e.chart.type && (e.dataLabels.formatter = t || function(e) {
                    return "number" == typeof e && e ? e.toFixed(0) + "%" : e
                }
                ),
                e
            }
        }, {
            key: "stackedBars",
            value: function() {
                var e = this.bar();
                return i(i({}, e), {}, {
                    plotOptions: i(i({}, e.plotOptions), {}, {
                        bar: i(i({}, e.plotOptions.bar), {}, {
                            borderRadiusApplication: "end",
                            borderRadiusWhenStacked: "last"
                        })
                    })
                })
            }
        }, {
            key: "convertCatToNumeric",
            value: function(e) {
                return e.xaxis.convertedCatToNumeric = !0,
                e
            }
        }, {
            key: "convertCatToNumericXaxis",
            value: function(e, t, a) {
                e.xaxis.type = "numeric",
                e.xaxis.labels = e.xaxis.labels || {},
                e.xaxis.labels.formatter = e.xaxis.labels.formatter || function(e) {
                    return b.isNumber(e) ? Math.floor(e) : e
                }
                ;
                var i = e.xaxis.labels.formatter
                  , n = e.xaxis.categories && e.xaxis.categories.length ? e.xaxis.categories : e.labels;
                return a && a.length && (n = a.map((function(e) {
                    return Array.isArray(e) ? e : String(e)
                }
                ))),
                n && n.length && (e.xaxis.labels.formatter = function(e) {
                    return b.isNumber(e) ? i(n[Math.floor(e) - 1]) : i(e)
                }
                ),
                e.xaxis.categories = [],
                e.labels = [],
                e.xaxis.tickAmount = e.xaxis.tickAmount || "dataPoints",
                e
            }
        }, {
            key: "bubble",
            value: function() {
                return {
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    xaxis: {
                        crosshairs: {
                            width: 0
                        }
                    },
                    fill: {
                        type: "solid",
                        gradient: {
                            shade: "light",
                            inverse: !0,
                            shadeIntensity: .55,
                            opacityFrom: .4,
                            opacityTo: .8
                        }
                    }
                }
            }
        }, {
            key: "scatter",
            value: function() {
                return {
                    dataLabels: {
                        enabled: !1
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0
                    },
                    markers: {
                        size: 6,
                        strokeWidth: 1,
                        hover: {
                            sizeOffset: 2
                        }
                    }
                }
            }
        }, {
            key: "heatmap",
            value: function() {
                return {
                    chart: {
                        stacked: !1
                    },
                    fill: {
                        opacity: 1
                    },
                    dataLabels: {
                        style: {
                            colors: ["#fff"]
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    tooltip: {
                        followCursor: !0,
                        marker: {
                            show: !1
                        },
                        x: {
                            show: !1
                        }
                    },
                    legend: {
                        position: "top",
                        markers: {
                            shape: "square",
                            size: 10,
                            offsetY: 2
                        }
                    },
                    grid: {
                        padding: {
                            right: 20
                        }
                    }
                }
            }
        }, {
            key: "treemap",
            value: function() {
                return {
                    chart: {
                        zoom: {
                            enabled: !1
                        }
                    },
                    dataLabels: {
                        style: {
                            fontSize: 14,
                            fontWeight: 600,
                            colors: ["#fff"]
                        }
                    },
                    stroke: {
                        show: !0,
                        width: 2,
                        colors: ["#fff"]
                    },
                    legend: {
                        show: !1
                    },
                    fill: {
                        gradient: {
                            stops: [0, 100]
                        }
                    },
                    tooltip: {
                        followCursor: !0,
                        x: {
                            show: !1
                        }
                    },
                    grid: {
                        padding: {
                            left: 0,
                            right: 0
                        }
                    },
                    xaxis: {
                        crosshairs: {
                            show: !1
                        },
                        tooltip: {
                            enabled: !1
                        }
                    }
                }
            }
        }, {
            key: "pie",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    plotOptions: {
                        pie: {
                            donut: {
                                labels: {
                                    show: !1
                                }
                            }
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            stops: [0, 100]
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "donut",
            value: function() {
                return {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        style: {
                            colors: ["#fff"]
                        },
                        background: {
                            enabled: !1
                        },
                        dropShadow: {
                            enabled: !0
                        }
                    },
                    stroke: {
                        colors: ["#fff"]
                    },
                    fill: {
                        opacity: 1,
                        gradient: {
                            shade: "light",
                            shadeIntensity: .35,
                            stops: [80, 100],
                            opacityFrom: 1,
                            opacityTo: 1
                        }
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "polarArea",
            value: function() {
                return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6,
                {
                    chart: {
                        toolbar: {
                            show: !1
                        }
                    },
                    dataLabels: {
                        formatter: function(e) {
                            return e.toFixed(1) + "%"
                        },
                        enabled: !1
                    },
                    stroke: {
                        show: !0,
                        width: 2
                    },
                    fill: {
                        opacity: .7
                    },
                    tooltip: {
                        theme: "dark",
                        fillSeriesColor: !0
                    },
                    legend: {
                        position: "right"
                    }
                }
            }
        }, {
            key: "radar",
            value: function() {
                return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6,
                {
                    dataLabels: {
                        enabled: !1,
                        style: {
                            fontSize: "11px"
                        }
                    },
                    stroke: {
                        width: 2
                    },
                    markers: {
                        size: 3,
                        strokeWidth: 1,
                        strokeOpacity: 1
                    },
                    fill: {
                        opacity: .2
                    },
                    tooltip: {
                        shared: !1,
                        intersect: !0,
                        followCursor: !0
                    },
                    grid: {
                        show: !1
                    },
                    xaxis: {
                        labels: {
                            formatter: function(e) {
                                return e
                            },
                            style: {
                                colors: ["#a8a8a8"],
                                fontSize: "11px"
                            }
                        },
                        tooltip: {
                            enabled: !1
                        },
                        crosshairs: {
                            show: !1
                        }
                    }
                }
            }
        }, {
            key: "radialBar",
            value: function() {
                return {
                    chart: {
                        animations: {
                            dynamicAnimation: {
                                enabled: !0,
                                speed: 800
                            }
                        },
                        toolbar: {
                            show: !1
                        }
                    },
                    fill: {
                        gradient: {
                            shade: "dark",
                            shadeIntensity: .4,
                            inverseColors: !1,
                            type: "diagonal2",
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [70, 98, 100]
                        }
                    },
                    legend: {
                        show: !1,
                        position: "right"
                    },
                    tooltip: {
                        enabled: !1,
                        fillSeriesColor: !0
                    }
                }
            }
        }, {
            key: "_getBoxTooltip",
            value: function(e, t, a, i, n) {
                var r = e.globals.seriesCandleO[t][a]
                  , o = e.globals.seriesCandleH[t][a]
                  , s = e.globals.seriesCandleM[t][a]
                  , l = e.globals.seriesCandleL[t][a]
                  , c = e.globals.seriesCandleC[t][a];
                return e.config.series[t].type && e.config.series[t].type !== n ? '<div class="apexcharts-custom-tooltip">\n          '.concat(e.config.series[t].name ? e.config.series[t].name : "series-" + (t + 1), ": <strong>").concat(e.globals.series[t][a], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(e.config.chart.type, '">') + "<div>".concat(i[0], ': <span class="value">') + r + "</span></div>" + "<div>".concat(i[1], ': <span class="value">') + o + "</span></div>" + (s ? "<div>".concat(i[2], ': <span class="value">') + s + "</span></div>" : "") + "<div>".concat(i[3], ': <span class="value">') + l + "</span></div>" + "<div>".concat(i[4], ': <span class="value">') + c + "</span></div></div>"
            }
        }]),
        e
    }()
      , B = function() {
        function e(t) {
            r(this, e),
            this.opts = t
        }
        return s(e, [{
            key: "init",
            value: function(e) {
                var t = e.responsiveOverride
                  , a = this.opts
                  , i = new I
                  , r = new F(a);
                this.chartType = a.chart.type,
                a = this.extendYAxis(a),
                a = this.extendAnnotations(a);
                var o = i.init()
                  , s = {};
                if (a && "object" === n(a)) {
                    var l, c, u, d, h, p, v, g, f = {};
                    f = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(a.chart.type) ? r[a.chart.type]() : r.line(),
                    null !== (l = a.plotOptions) && void 0 !== l && null !== (c = l.bar) && void 0 !== c && c.isFunnel && (f = r.funnel()),
                    a.chart.stacked && "bar" === a.chart.type && (f = r.stackedBars()),
                    null !== (u = a.chart.brush) && void 0 !== u && u.enabled && (f = r.brush(f)),
                    a.chart.stacked && "100%" === a.chart.stackType && (a = r.stacked100(a)),
                    null !== (d = a.plotOptions) && void 0 !== d && null !== (h = d.bar) && void 0 !== h && h.isDumbbell && (a = r.dumbbell(a)),
                    this.checkForDarkTheme(window.Apex),
                    this.checkForDarkTheme(a),
                    a.xaxis = a.xaxis || window.Apex.xaxis || {},
                    t || (a.xaxis.convertedCatToNumeric = !1),
                    (null !== (p = (a = this.checkForCatToNumericXAxis(this.chartType, f, a)).chart.sparkline) && void 0 !== p && p.enabled || null !== (v = window.Apex.chart) && void 0 !== v && null !== (g = v.sparkline) && void 0 !== g && g.enabled) && (f = r.sparkline(f)),
                    s = b.extend(o, f)
                }
                var m = b.extend(s, window.Apex);
                return o = b.extend(m, a),
                this.handleUserInputErrors(o)
            }
        }, {
            key: "checkForCatToNumericXAxis",
            value: function(e, t, a) {
                var i, n, r = new F(a), o = ("bar" === e || "boxPlot" === e) && (null === (i = a.plotOptions) || void 0 === i || null === (n = i.bar) || void 0 === n ? void 0 : n.horizontal), s = "pie" === e || "polarArea" === e || "donut" === e || "radar" === e || "radialBar" === e || "heatmap" === e, l = "datetime" !== a.xaxis.type && "numeric" !== a.xaxis.type, c = a.xaxis.tickPlacement ? a.xaxis.tickPlacement : t.xaxis && t.xaxis.tickPlacement;
                return o || s || !l || "between" === c || (a = r.convertCatToNumeric(a)),
                a
            }
        }, {
            key: "extendYAxis",
            value: function(e, t) {
                var a = new I;
                (void 0 === e.yaxis || !e.yaxis || Array.isArray(e.yaxis) && 0 === e.yaxis.length) && (e.yaxis = {}),
                e.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (e.yaxis = b.extend(e.yaxis, window.Apex.yaxis)),
                e.yaxis.constructor !== Array ? e.yaxis = [b.extend(a.yAxis, e.yaxis)] : e.yaxis = b.extendArray(e.yaxis, a.yAxis);
                var i = !1;
                e.yaxis.forEach((function(e) {
                    e.logarithmic && (i = !0)
                }
                ));
                var n = e.series;
                return t && !n && (n = t.config.series),
                i && n.length !== e.yaxis.length && n.length && (e.yaxis = n.map((function(t, i) {
                    if (t.name || (n[i].name = "series-".concat(i + 1)),
                    e.yaxis[i])
                        return e.yaxis[i].seriesName = n[i].name,
                        e.yaxis[i];
                    var r = b.extend(a.yAxis, e.yaxis[0]);
                    return r.show = !1,
                    r
                }
                ))),
                i && n.length > 1 && (n.length,
                e.yaxis.length),
                e
            }
        }, {
            key: "extendAnnotations",
            value: function(e) {
                return void 0 === e.annotations && (e.annotations = {},
                e.annotations.yaxis = [],
                e.annotations.xaxis = [],
                e.annotations.points = []),
                e = this.extendYAxisAnnotations(e),
                e = this.extendXAxisAnnotations(e),
                this.extendPointAnnotations(e)
            }
        }, {
            key: "extendYAxisAnnotations",
            value: function(e) {
                var t = new I;
                return e.annotations.yaxis = b.extendArray(void 0 !== e.annotations.yaxis ? e.annotations.yaxis : [], t.yAxisAnnotation),
                e
            }
        }, {
            key: "extendXAxisAnnotations",
            value: function(e) {
                var t = new I;
                return e.annotations.xaxis = b.extendArray(void 0 !== e.annotations.xaxis ? e.annotations.xaxis : [], t.xAxisAnnotation),
                e
            }
        }, {
            key: "extendPointAnnotations",
            value: function(e) {
                var t = new I;
                return e.annotations.points = b.extendArray(void 0 !== e.annotations.points ? e.annotations.points : [], t.pointAnnotation),
                e
            }
        }, {
            key: "checkForDarkTheme",
            value: function(e) {
                e.theme && "dark" === e.theme.mode && (e.tooltip || (e.tooltip = {}),
                "light" !== e.tooltip.theme && (e.tooltip.theme = "dark"),
                e.chart.foreColor || (e.chart.foreColor = "#f6f7f8"),
                e.chart.background || (e.chart.background = "#424242"),
                e.theme.palette || (e.theme.palette = "palette4"))
            }
        }, {
            key: "handleUserInputErrors",
            value: function(e) {
                var t = e;
                if (t.tooltip.shared && t.tooltip.intersect)
                    throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                if ("bar" === t.chart.type && t.plotOptions.bar.horizontal) {
                    if (t.yaxis.length > 1)
                        throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                    t.yaxis[0].reversed && (t.yaxis[0].opposite = !0),
                    t.xaxis.tooltip.enabled = !1,
                    t.yaxis[0].tooltip.enabled = !1,
                    t.chart.zoom.enabled = !1
                }
                return "bar" !== t.chart.type && "rangeBar" !== t.chart.type || t.tooltip.shared && "barWidth" === t.xaxis.crosshairs.width && t.series.length > 1 && (t.xaxis.crosshairs.width = "tickWidth"),
                "candlestick" !== t.chart.type && "boxPlot" !== t.chart.type || t.yaxis[0].reversed && (t.yaxis[0].reversed = !1),
                t
            }
        }]),
        e
    }()
      , M = function() {
        function e() {
            r(this, e)
        }
        return s(e, [{
            key: "initGlobalVars",
            value: function(e) {
                e.series = [],
                e.seriesCandleO = [],
                e.seriesCandleH = [],
                e.seriesCandleM = [],
                e.seriesCandleL = [],
                e.seriesCandleC = [],
                e.seriesRangeStart = [],
                e.seriesRangeEnd = [],
                e.seriesRange = [],
                e.seriesPercent = [],
                e.seriesGoals = [],
                e.seriesX = [],
                e.seriesZ = [],
                e.seriesNames = [],
                e.seriesTotals = [],
                e.seriesLog = [],
                e.seriesColors = [],
                e.stackedSeriesTotals = [],
                e.seriesXvalues = [],
                e.seriesYvalues = [],
                e.labels = [],
                e.hasXaxisGroups = !1,
                e.groups = [],
                e.hasSeriesGroups = !1,
                e.seriesGroups = [],
                e.categoryLabels = [],
                e.timescaleLabels = [],
                e.noLabelsProvided = !1,
                e.resizeTimer = null,
                e.selectionResizeTimer = null,
                e.delayedElements = [],
                e.pointsArray = [],
                e.dataLabelsRects = [],
                e.isXNumeric = !1,
                e.skipLastTimelinelabel = !1,
                e.skipFirstTimelinelabel = !1,
                e.isDataXYZ = !1,
                e.isMultiLineX = !1,
                e.isMultipleYAxis = !1,
                e.maxY = -Number.MAX_VALUE,
                e.minY = Number.MIN_VALUE,
                e.minYArr = [],
                e.maxYArr = [],
                e.maxX = -Number.MAX_VALUE,
                e.minX = Number.MAX_VALUE,
                e.initialMaxX = -Number.MAX_VALUE,
                e.initialMinX = Number.MAX_VALUE,
                e.maxDate = 0,
                e.minDate = Number.MAX_VALUE,
                e.minZ = Number.MAX_VALUE,
                e.maxZ = -Number.MAX_VALUE,
                e.minXDiff = Number.MAX_VALUE,
                e.yAxisScale = [],
                e.xAxisScale = null,
                e.xAxisTicksPositions = [],
                e.yLabelsCoords = [],
                e.yTitleCoords = [],
                e.barPadForNumericAxis = 0,
                e.padHorizontal = 0,
                e.xRange = 0,
                e.yRange = [],
                e.zRange = 0,
                e.dataPoints = 0,
                e.xTickAmount = 0
            }
        }, {
            key: "globalVars",
            value: function(e) {
                return {
                    chartID: null,
                    cuid: null,
                    events: {
                        beforeMount: [],
                        mounted: [],
                        updated: [],
                        clicked: [],
                        selection: [],
                        dataPointSelection: [],
                        zoomed: [],
                        scrolled: []
                    },
                    colors: [],
                    clientX: null,
                    clientY: null,
                    fill: {
                        colors: []
                    },
                    stroke: {
                        colors: []
                    },
                    dataLabels: {
                        style: {
                            colors: []
                        }
                    },
                    radarPolygons: {
                        fill: {
                            colors: []
                        }
                    },
                    markers: {
                        colors: [],
                        size: e.markers.size,
                        largestSize: 0
                    },
                    animationEnded: !1,
                    isTouchDevice: "ontouchstart"in window || navigator.msMaxTouchPoints,
                    isDirty: !1,
                    isExecCalled: !1,
                    initialConfig: null,
                    initialSeries: [],
                    lastXAxis: [],
                    lastYAxis: [],
                    columnSeries: null,
                    labels: [],
                    timescaleLabels: [],
                    noLabelsProvided: !1,
                    allSeriesCollapsed: !1,
                    collapsedSeries: [],
                    collapsedSeriesIndices: [],
                    ancillaryCollapsedSeries: [],
                    ancillaryCollapsedSeriesIndices: [],
                    risingSeries: [],
                    dataFormatXNumeric: !1,
                    capturedSeriesIndex: -1,
                    capturedDataPointIndex: -1,
                    selectedDataPoints: [],
                    goldenPadding: 35,
                    invalidLogScale: !1,
                    ignoreYAxisIndexes: [],
                    yAxisSameScaleIndices: [],
                    maxValsInArrayIndex: 0,
                    radialSize: 0,
                    selection: void 0,
                    zoomEnabled: "zoom" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.zoom && e.chart.zoom.enabled,
                    panEnabled: "pan" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.pan,
                    selectionEnabled: "selection" === e.chart.toolbar.autoSelected && e.chart.toolbar.tools.selection,
                    yaxis: null,
                    mousedown: !1,
                    lastClientPosition: {},
                    visibleXRange: void 0,
                    yValueDecimal: 0,
                    total: 0,
                    SVGNS: "http://www.w3.org/2000/svg",
                    svgWidth: 0,
                    svgHeight: 0,
                    noData: !1,
                    locale: {},
                    dom: {},
                    memory: {
                        methodsToExec: []
                    },
                    shouldAnimate: !0,
                    skipLastTimelinelabel: !1,
                    skipFirstTimelinelabel: !1,
                    delayedElements: [],
                    axisCharts: !0,
                    isDataXYZ: !1,
                    resized: !1,
                    resizeTimer: null,
                    comboCharts: !1,
                    dataChanged: !1,
                    previousPaths: [],
                    allSeriesHasEqualX: !0,
                    pointsArray: [],
                    dataLabelsRects: [],
                    lastDrawnDataLabelsIndexes: [],
                    hasNullValues: !1,
                    easing: null,
                    zoomed: !1,
                    gridWidth: 0,
                    gridHeight: 0,
                    rotateXLabels: !1,
                    defaultLabels: !1,
                    xLabelFormatter: void 0,
                    yLabelFormatters: [],
                    xaxisTooltipFormatter: void 0,
                    ttKeyFormatter: void 0,
                    ttVal: void 0,
                    ttZFormatter: void 0,
                    LINE_HEIGHT_RATIO: 1.618,
                    xAxisLabelsHeight: 0,
                    xAxisGroupLabelsHeight: 0,
                    xAxisLabelsWidth: 0,
                    yAxisLabelsWidth: 0,
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0,
                    translateYAxisX: [],
                    yAxisWidths: [],
                    translateXAxisY: 0,
                    translateXAxisX: 0,
                    tooltip: null
                }
            }
        }, {
            key: "init",
            value: function(e) {
                var t = this.globalVars(e);
                return this.initGlobalVars(t),
                t.initialConfig = b.extend({}, e),
                t.initialSeries = b.clone(e.series),
                t.lastXAxis = b.clone(t.initialConfig.xaxis),
                t.lastYAxis = b.clone(t.initialConfig.yaxis),
                t
            }
        }]),
        e
    }()
      , D = function() {
        function e(t) {
            r(this, e),
            this.opts = t
        }
        return s(e, [{
            key: "init",
            value: function() {
                var e = new B(this.opts).init({
                    responsiveOverride: !1
                });
                return {
                    config: e,
                    globals: (new M).init(e)
                }
            }
        }]),
        e
    }()
      , R = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.opts = null,
            this.seriesIndex = 0
        }
        return s(e, [{
            key: "clippedImgArea",
            value: function(e) {
                var t = this.w
                  , a = t.config
                  , i = parseInt(t.globals.gridWidth, 10)
                  , n = parseInt(t.globals.gridHeight, 10)
                  , r = i > n ? i : n
                  , o = e.image
                  , s = 0
                  , l = 0;
                void 0 === e.width && void 0 === e.height ? void 0 !== a.fill.image.width && void 0 !== a.fill.image.height ? (s = a.fill.image.width + 1,
                l = a.fill.image.height) : (s = r + 1,
                l = r) : (s = e.width,
                l = e.height);
                var c = document.createElementNS(t.globals.SVGNS, "pattern");
                w.setAttrs(c, {
                    id: e.patternID,
                    patternUnits: e.patternUnits ? e.patternUnits : "userSpaceOnUse",
                    width: s + "px",
                    height: l + "px"
                });
                var u = document.createElementNS(t.globals.SVGNS, "image");
                c.appendChild(u),
                u.setAttributeNS(window.SVG.xlink, "href", o),
                w.setAttrs(u, {
                    x: 0,
                    y: 0,
                    preserveAspectRatio: "none",
                    width: s + "px",
                    height: l + "px"
                }),
                u.style.opacity = e.opacity,
                t.globals.dom.elDefs.node.appendChild(c)
            }
        }, {
            key: "getSeriesIndex",
            value: function(e) {
                var t = this.w
                  , a = t.config.chart.type;
                return ("bar" === a || "rangeBar" === a) && t.config.plotOptions.bar.distributed || "heatmap" === a || "treemap" === a ? this.seriesIndex = e.seriesNumber : this.seriesIndex = e.seriesNumber % t.globals.series.length,
                this.seriesIndex
            }
        }, {
            key: "fillPath",
            value: function(e) {
                var t = this.w;
                this.opts = e;
                var a, i, n, r = this.w.config;
                this.seriesIndex = this.getSeriesIndex(e);
                var o = this.getFillColors()[this.seriesIndex];
                void 0 !== t.globals.seriesColors[this.seriesIndex] && (o = t.globals.seriesColors[this.seriesIndex]),
                "function" == typeof o && (o = o({
                    seriesIndex: this.seriesIndex,
                    dataPointIndex: e.dataPointIndex,
                    value: e.value,
                    w: t
                }));
                var s = e.fillType ? e.fillType : this.getFillType(this.seriesIndex)
                  , l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity;
                e.color && (o = e.color),
                o || (o = "#fff");
                var c = o;
                if (-1 === o.indexOf("rgb") ? o.length < 9 && (c = b.hexToRgba(o, l)) : o.indexOf("rgba") > -1 && (l = b.getOpacityFromRGBA(o)),
                e.opacity && (l = e.opacity),
                "pattern" === s && (i = this.handlePatternFill({
                    fillConfig: e.fillConfig,
                    patternFill: i,
                    fillColor: o,
                    fillOpacity: l,
                    defaultColor: c
                })),
                "gradient" === s && (n = this.handleGradientFill({
                    fillConfig: e.fillConfig,
                    fillColor: o,
                    fillOpacity: l,
                    i: this.seriesIndex
                })),
                "image" === s) {
                    var u = r.fill.image.src
                      , d = e.patternID ? e.patternID : "";
                    this.clippedImgArea({
                        opacity: l,
                        image: Array.isArray(u) ? e.seriesNumber < u.length ? u[e.seriesNumber] : u[0] : u,
                        width: e.width ? e.width : void 0,
                        height: e.height ? e.height : void 0,
                        patternUnits: e.patternUnits,
                        patternID: "pattern".concat(t.globals.cuid).concat(e.seriesNumber + 1).concat(d)
                    }),
                    a = "url(#pattern".concat(t.globals.cuid).concat(e.seriesNumber + 1).concat(d, ")")
                } else
                    a = "gradient" === s ? n : "pattern" === s ? i : c;
                return e.solid && (a = c),
                a
            }
        }, {
            key: "getFillType",
            value: function(e) {
                var t = this.w;
                return Array.isArray(t.config.fill.type) ? t.config.fill.type[e] : t.config.fill.type
            }
        }, {
            key: "getFillColors",
            value: function() {
                var e = this.w
                  , t = e.config
                  , a = this.opts
                  , i = [];
                return e.globals.comboCharts ? "line" === e.config.series[this.seriesIndex].type ? Array.isArray(e.globals.stroke.colors) ? i = e.globals.stroke.colors : i.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? i = e.globals.fill.colors : i.push(e.globals.fill.colors) : "line" === t.chart.type ? Array.isArray(e.globals.stroke.colors) ? i = e.globals.stroke.colors : i.push(e.globals.stroke.colors) : Array.isArray(e.globals.fill.colors) ? i = e.globals.fill.colors : i.push(e.globals.fill.colors),
                void 0 !== a.fillColors && (i = [],
                Array.isArray(a.fillColors) ? i = a.fillColors.slice() : i.push(a.fillColors)),
                i
            }
        }, {
            key: "handlePatternFill",
            value: function(e) {
                var t = e.fillConfig
                  , a = (e.patternFill,
                e.fillColor)
                  , i = e.fillOpacity
                  , n = e.defaultColor
                  , r = this.w.config.fill;
                t && (r = t);
                var o = this.opts
                  , s = new w(this.ctx)
                  , l = Array.isArray(r.pattern.strokeWidth) ? r.pattern.strokeWidth[this.seriesIndex] : r.pattern.strokeWidth
                  , c = a;
                return Array.isArray(r.pattern.style) ? void 0 !== r.pattern.style[o.seriesNumber] ? s.drawPattern(r.pattern.style[o.seriesNumber], r.pattern.width, r.pattern.height, c, l, i) : n : s.drawPattern(r.pattern.style, r.pattern.width, r.pattern.height, c, l, i)
            }
        }, {
            key: "handleGradientFill",
            value: function(e) {
                var t = e.fillColor
                  , a = e.fillOpacity
                  , n = e.fillConfig
                  , r = e.i
                  , o = this.w.config.fill;
                n && (o = i(i({}, o), n));
                var s, l = this.opts, c = new w(this.ctx), u = new b, d = o.gradient.type, h = t, p = void 0 === o.gradient.opacityFrom ? a : Array.isArray(o.gradient.opacityFrom) ? o.gradient.opacityFrom[r] : o.gradient.opacityFrom;
                h.indexOf("rgba") > -1 && (p = b.getOpacityFromRGBA(h));
                var v = void 0 === o.gradient.opacityTo ? a : Array.isArray(o.gradient.opacityTo) ? o.gradient.opacityTo[r] : o.gradient.opacityTo;
                if (void 0 === o.gradient.gradientToColors || 0 === o.gradient.gradientToColors.length)
                    s = "dark" === o.gradient.shade ? u.shadeColor(-1 * parseFloat(o.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? b.rgb2hex(t) : t) : u.shadeColor(parseFloat(o.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? b.rgb2hex(t) : t);
                else if (o.gradient.gradientToColors[l.seriesNumber]) {
                    var g = o.gradient.gradientToColors[l.seriesNumber];
                    s = g,
                    g.indexOf("rgba") > -1 && (v = b.getOpacityFromRGBA(g))
                } else
                    s = t;
                if (o.gradient.gradientFrom && (h = o.gradient.gradientFrom),
                o.gradient.gradientTo && (s = o.gradient.gradientTo),
                o.gradient.inverseColors) {
                    var f = h;
                    h = s,
                    s = f
                }
                return h.indexOf("rgb") > -1 && (h = b.rgb2hex(h)),
                s.indexOf("rgb") > -1 && (s = b.rgb2hex(s)),
                c.drawGradient(d, h, s, p, v, l.size, o.gradient.stops, o.gradient.colorStops, r)
            }
        }]),
        e
    }()
      , N = function() {
        function e(t, a) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "setGlobalMarkerSize",
            value: function() {
                var e = this.w;
                if (e.globals.markers.size = Array.isArray(e.config.markers.size) ? e.config.markers.size : [e.config.markers.size],
                e.globals.markers.size.length > 0) {
                    if (e.globals.markers.size.length < e.globals.series.length + 1)
                        for (var t = 0; t <= e.globals.series.length; t++)
                            void 0 === e.globals.markers.size[t] && e.globals.markers.size.push(e.globals.markers.size[0])
                } else
                    e.globals.markers.size = e.config.series.map((function(t) {
                        return e.config.markers.size
                    }
                    ))
            }
        }, {
            key: "plotChartMarkers",
            value: function(e, t, a, i) {
                var n, r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o = this.w, s = t, l = e, c = null, u = new w(this.ctx), d = o.config.markers.discrete && o.config.markers.discrete.length;
                if ((o.globals.markers.size[t] > 0 || r || d) && (c = u.group({
                    class: r || d ? "" : "apexcharts-series-markers"
                })).attr("clip-path", "url(#gridRectMarkerMask".concat(o.globals.cuid, ")")),
                Array.isArray(l.x))
                    for (var h = 0; h < l.x.length; h++) {
                        var p = a;
                        1 === a && 0 === h && (p = 0),
                        1 === a && 1 === h && (p = 1);
                        var v = "apexcharts-marker";
                        if ("line" !== o.config.chart.type && "area" !== o.config.chart.type || o.globals.comboCharts || o.config.tooltip.intersect || (v += " no-pointer-events"),
                        (Array.isArray(o.config.markers.size) ? o.globals.markers.size[t] > 0 : o.config.markers.size > 0) || r || d) {
                            b.isNumber(l.y[h]) ? v += " w".concat(b.randomId()) : v = "apexcharts-nullpoint";
                            var g = this.getMarkerConfig({
                                cssClass: v,
                                seriesIndex: t,
                                dataPointIndex: p
                            });
                            o.config.series[s].data[p] && (o.config.series[s].data[p].fillColor && (g.pointFillColor = o.config.series[s].data[p].fillColor),
                            o.config.series[s].data[p].strokeColor && (g.pointStrokeColor = o.config.series[s].data[p].strokeColor)),
                            i && (g.pSize = i),
                            (l.x[h] < 0 || l.x[h] > o.globals.gridWidth || l.y[h] < -o.globals.markers.largestSize || l.y[h] > o.globals.gridHeight + o.globals.markers.largestSize) && (g.pSize = 0),
                            (n = u.drawMarker(l.x[h], l.y[h], g)).attr("rel", p),
                            n.attr("j", p),
                            n.attr("index", t),
                            n.node.setAttribute("default-marker-size", g.pSize),
                            new y(this.ctx).setSelectionFilter(n, t, p),
                            this.addEvents(n),
                            c && c.add(n)
                        } else
                            void 0 === o.globals.pointsArray[t] && (o.globals.pointsArray[t] = []),
                            o.globals.pointsArray[t].push([l.x[h], l.y[h]])
                    }
                return c
            }
        }, {
            key: "getMarkerConfig",
            value: function(e) {
                var t = e.cssClass
                  , a = e.seriesIndex
                  , i = e.dataPointIndex
                  , n = void 0 === i ? null : i
                  , r = e.finishRadius
                  , o = void 0 === r ? null : r
                  , s = this.w
                  , l = this.getMarkerStyle(a)
                  , c = s.globals.markers.size[a]
                  , u = s.config.markers;
                return null !== n && u.discrete.length && u.discrete.map((function(e) {
                    e.seriesIndex === a && e.dataPointIndex === n && (l.pointStrokeColor = e.strokeColor,
                    l.pointFillColor = e.fillColor,
                    c = e.size,
                    l.pointShape = e.shape)
                }
                )),
                {
                    pSize: null === o ? c : o,
                    pRadius: u.radius,
                    width: Array.isArray(u.width) ? u.width[a] : u.width,
                    height: Array.isArray(u.height) ? u.height[a] : u.height,
                    pointStrokeWidth: Array.isArray(u.strokeWidth) ? u.strokeWidth[a] : u.strokeWidth,
                    pointStrokeColor: l.pointStrokeColor,
                    pointFillColor: l.pointFillColor,
                    shape: l.pointShape || (Array.isArray(u.shape) ? u.shape[a] : u.shape),
                    class: t,
                    pointStrokeOpacity: Array.isArray(u.strokeOpacity) ? u.strokeOpacity[a] : u.strokeOpacity,
                    pointStrokeDashArray: Array.isArray(u.strokeDashArray) ? u.strokeDashArray[a] : u.strokeDashArray,
                    pointFillOpacity: Array.isArray(u.fillOpacity) ? u.fillOpacity[a] : u.fillOpacity,
                    seriesIndex: a
                }
            }
        }, {
            key: "addEvents",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx);
                e.node.addEventListener("mouseenter", a.pathMouseEnter.bind(this.ctx, e)),
                e.node.addEventListener("mouseleave", a.pathMouseLeave.bind(this.ctx, e)),
                e.node.addEventListener("mousedown", a.pathMouseDown.bind(this.ctx, e)),
                e.node.addEventListener("click", t.config.markers.onClick),
                e.node.addEventListener("dblclick", t.config.markers.onDblClick),
                e.node.addEventListener("touchstart", a.pathMouseDown.bind(this.ctx, e), {
                    passive: !0
                })
            }
        }, {
            key: "getMarkerStyle",
            value: function(e) {
                var t = this.w
                  , a = t.globals.markers.colors
                  , i = t.config.markers.strokeColor || t.config.markers.strokeColors;
                return {
                    pointStrokeColor: Array.isArray(i) ? i[e] : i,
                    pointFillColor: Array.isArray(a) ? a[e] : a
                }
            }
        }]),
        e
    }()
      , z = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
        }
        return s(e, [{
            key: "draw",
            value: function(e, t, a) {
                var i = this.w
                  , n = new w(this.ctx)
                  , r = a.realIndex
                  , o = a.pointsPos
                  , s = a.zRatio
                  , l = a.elParent
                  , c = n.group({
                    class: "apexcharts-series-markers apexcharts-series-".concat(i.config.chart.type)
                });
                if (c.attr("clip-path", "url(#gridRectMarkerMask".concat(i.globals.cuid, ")")),
                Array.isArray(o.x))
                    for (var u = 0; u < o.x.length; u++) {
                        var d = t + 1
                          , h = !0;
                        0 === t && 0 === u && (d = 0),
                        0 === t && 1 === u && (d = 1);
                        var p = 0
                          , v = i.globals.markers.size[r];
                        if (s !== 1 / 0) {
                            var g = i.config.plotOptions.bubble;
                            v = i.globals.seriesZ[r][d],
                            g.zScaling && (v /= s),
                            g.minBubbleRadius && v < g.minBubbleRadius && (v = g.minBubbleRadius),
                            g.maxBubbleRadius && v > g.maxBubbleRadius && (v = g.maxBubbleRadius)
                        }
                        i.config.chart.animations.enabled || (p = v);
                        var f = o.x[u]
                          , m = o.y[u];
                        if (p = p || 0,
                        null !== m && void 0 !== i.globals.series[r][d] || (h = !1),
                        h) {
                            var b = this.drawPoint(f, m, p, v, r, d, t);
                            c.add(b)
                        }
                        l.add(c)
                    }
            }
        }, {
            key: "drawPoint",
            value: function(e, t, a, i, n, r, o) {
                var s = this.w
                  , l = n
                  , c = new x(this.ctx)
                  , u = new y(this.ctx)
                  , d = new R(this.ctx)
                  , h = new N(this.ctx)
                  , p = new w(this.ctx)
                  , v = h.getMarkerConfig({
                    cssClass: "apexcharts-marker",
                    seriesIndex: l,
                    dataPointIndex: r,
                    finishRadius: "bubble" === s.config.chart.type || s.globals.comboCharts && s.config.series[n] && "bubble" === s.config.series[n].type ? i : null
                });
                i = v.pSize;
                var g, f = d.fillPath({
                    seriesNumber: n,
                    dataPointIndex: r,
                    color: v.pointFillColor,
                    patternUnits: "objectBoundingBox",
                    value: s.globals.series[n][o]
                });
                if ("circle" === v.shape ? g = p.drawCircle(a) : "square" !== v.shape && "rect" !== v.shape || (g = p.drawRect(0, 0, v.width - v.pointStrokeWidth / 2, v.height - v.pointStrokeWidth / 2, v.pRadius)),
                s.config.series[l].data[r] && s.config.series[l].data[r].fillColor && (f = s.config.series[l].data[r].fillColor),
                g.attr({
                    x: e - v.width / 2 - v.pointStrokeWidth / 2,
                    y: t - v.height / 2 - v.pointStrokeWidth / 2,
                    cx: e,
                    cy: t,
                    fill: f,
                    "fill-opacity": v.pointFillOpacity,
                    stroke: v.pointStrokeColor,
                    r: i,
                    "stroke-width": v.pointStrokeWidth,
                    "stroke-dasharray": v.pointStrokeDashArray,
                    "stroke-opacity": v.pointStrokeOpacity
                }),
                s.config.chart.dropShadow.enabled) {
                    var m = s.config.chart.dropShadow;
                    u.dropShadow(g, m, n)
                }
                if (!this.initialAnim || s.globals.dataChanged || s.globals.resized)
                    s.globals.animationEnded = !0;
                else {
                    var b = s.config.chart.animations.speed;
                    c.animateMarker(g, 0, "circle" === v.shape ? i : {
                        width: v.width,
                        height: v.height
                    }, b, s.globals.easing, (function() {
                        window.setTimeout((function() {
                            c.animationCompleted(g)
                        }
                        ), 100)
                    }
                    ))
                }
                if (s.globals.dataChanged && "circle" === v.shape)
                    if (this.dynamicAnim) {
                        var k, S, C, A, P = s.config.chart.animations.dynamicAnimation.speed;
                        null != (A = s.globals.previousPaths[n] && s.globals.previousPaths[n][o]) && (k = A.x,
                        S = A.y,
                        C = void 0 !== A.r ? A.r : i);
                        for (var L = 0; L < s.globals.collapsedSeries.length; L++)
                            s.globals.collapsedSeries[L].index === n && (P = 1,
                            i = 0);
                        0 === e && 0 === t && (i = 0),
                        c.animateCircle(g, {
                            cx: k,
                            cy: S,
                            r: C
                        }, {
                            cx: e,
                            cy: t,
                            r: i
                        }, P, s.globals.easing)
                    } else
                        g.attr({
                            r: i
                        });
                return g.attr({
                    rel: r,
                    j: r,
                    index: n,
                    "default-marker-size": i
                }),
                u.setSelectionFilter(g, n, r),
                h.addEvents(g),
                g.node.classList.add("apexcharts-marker"),
                g
            }
        }, {
            key: "centerTextInBubble",
            value: function(e) {
                var t = this.w;
                return {
                    y: e += parseInt(t.config.dataLabels.style.fontSize, 10) / 4
                }
            }
        }]),
        e
    }()
      , H = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "dataLabelsCorrection",
            value: function(e, t, a, i, n, r, o) {
                var s = this.w
                  , l = !1
                  , c = new w(this.ctx).getTextRects(a, o)
                  , u = c.width
                  , d = c.height;
                t < 0 && (t = 0),
                t > s.globals.gridHeight + d && (t = s.globals.gridHeight + d / 2),
                void 0 === s.globals.dataLabelsRects[i] && (s.globals.dataLabelsRects[i] = []),
                s.globals.dataLabelsRects[i].push({
                    x: e,
                    y: t,
                    width: u,
                    height: d
                });
                var h = s.globals.dataLabelsRects[i].length - 2
                  , p = void 0 !== s.globals.lastDrawnDataLabelsIndexes[i] ? s.globals.lastDrawnDataLabelsIndexes[i][s.globals.lastDrawnDataLabelsIndexes[i].length - 1] : 0;
                if (void 0 !== s.globals.dataLabelsRects[i][h]) {
                    var v = s.globals.dataLabelsRects[i][p];
                    (e > v.x + v.width || t > v.y + v.height || t + d < v.y || e + u < v.x) && (l = !0)
                }
                return (0 === n || r) && (l = !0),
                {
                    x: e,
                    y: t,
                    textRects: c,
                    drawnextLabel: l
                }
            }
        }, {
            key: "drawDataLabel",
            value: function(e) {
                var t = this
                  , a = e.type
                  , i = e.pos
                  , n = e.i
                  , r = e.j
                  , o = e.isRangeStart
                  , s = e.strokeWidth
                  , l = void 0 === s ? 2 : s
                  , c = this.w
                  , u = new w(this.ctx)
                  , d = c.config.dataLabels
                  , h = 0
                  , p = 0
                  , v = r
                  , g = null;
                if (!d.enabled || !Array.isArray(i.x))
                    return g;
                g = u.group({
                    class: "apexcharts-data-labels"
                });
                for (var f = 0; f < i.x.length; f++)
                    if (h = i.x[f] + d.offsetX,
                    p = i.y[f] + d.offsetY + l,
                    !isNaN(h)) {
                        1 === r && 0 === f && (v = 0),
                        1 === r && 1 === f && (v = 1);
                        var m = c.globals.series[n][v];
                        "rangeArea" === a && (m = o ? c.globals.seriesRangeStart[n][v] : c.globals.seriesRangeEnd[n][v]);
                        var b = ""
                          , x = function(e) {
                            return c.config.dataLabels.formatter(e, {
                                ctx: t.ctx,
                                seriesIndex: n,
                                dataPointIndex: v,
                                w: c
                            })
                        };
                        "bubble" === c.config.chart.type ? (b = x(m = c.globals.seriesZ[n][v]),
                        p = i.y[f],
                        p = new z(this.ctx).centerTextInBubble(p, n, v).y) : void 0 !== m && (b = x(m)),
                        this.plotDataLabelsText({
                            x: h,
                            y: p,
                            text: b,
                            i: n,
                            j: v,
                            parent: g,
                            offsetCorrection: !0,
                            dataLabelsConfig: c.config.dataLabels
                        })
                    }
                return g
            }
        }, {
            key: "plotDataLabelsText",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx)
                  , i = e.x
                  , n = e.y
                  , r = e.i
                  , o = e.j
                  , s = e.text
                  , l = e.textAnchor
                  , c = e.fontSize
                  , u = e.parent
                  , d = e.dataLabelsConfig
                  , h = e.color
                  , p = e.alwaysDrawDataLabel
                  , v = e.offsetCorrection;
                if (!(Array.isArray(t.config.dataLabels.enabledOnSeries) && t.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
                    var g = {
                        x: i,
                        y: n,
                        drawnextLabel: !0,
                        textRects: null
                    };
                    v && (g = this.dataLabelsCorrection(i, n, s, r, o, p, parseInt(d.style.fontSize, 10))),
                    t.globals.zoomed || (i = g.x,
                    n = g.y),
                    g.textRects && (i < -20 - g.textRects.width || i > t.globals.gridWidth + g.textRects.width + 30) && (s = "");
                    var f = t.globals.dataLabels.style.colors[r];
                    (("bar" === t.config.chart.type || "rangeBar" === t.config.chart.type) && t.config.plotOptions.bar.distributed || t.config.dataLabels.distributed) && (f = t.globals.dataLabels.style.colors[o]),
                    "function" == typeof f && (f = f({
                        series: t.globals.series,
                        seriesIndex: r,
                        dataPointIndex: o,
                        w: t
                    })),
                    h && (f = h);
                    var m = d.offsetX
                      , b = d.offsetY;
                    if ("bar" !== t.config.chart.type && "rangeBar" !== t.config.chart.type || (m = 0,
                    b = 0),
                    g.drawnextLabel) {
                        var x = a.drawText({
                            width: 100,
                            height: parseInt(d.style.fontSize, 10),
                            x: i + m,
                            y: n + b,
                            foreColor: f,
                            textAnchor: l || d.textAnchor,
                            text: s,
                            fontSize: c || d.style.fontSize,
                            fontFamily: d.style.fontFamily,
                            fontWeight: d.style.fontWeight || "normal"
                        });
                        if (x.attr({
                            class: "apexcharts-datalabel",
                            cx: i,
                            cy: n
                        }),
                        d.dropShadow.enabled) {
                            var k = d.dropShadow;
                            new y(this.ctx).dropShadow(x, k)
                        }
                        u.add(x),
                        void 0 === t.globals.lastDrawnDataLabelsIndexes[r] && (t.globals.lastDrawnDataLabelsIndexes[r] = []),
                        t.globals.lastDrawnDataLabelsIndexes[r].push(o)
                    }
                }
            }
        }, {
            key: "addBackgroundToDataLabel",
            value: function(e, t) {
                var a = this.w
                  , i = a.config.dataLabels.background
                  , n = i.padding
                  , r = i.padding / 2
                  , o = t.width
                  , s = t.height
                  , l = new w(this.ctx).drawRect(t.x - n, t.y - r / 2, o + 2 * n, s + r, i.borderRadius, "transparent" === a.config.chart.background ? "#fff" : a.config.chart.background, i.opacity, i.borderWidth, i.borderColor);
                return i.dropShadow.enabled && new y(this.ctx).dropShadow(l, i.dropShadow),
                l
            }
        }, {
            key: "dataLabelsBackground",
            value: function() {
                var e = this.w;
                if ("bubble" !== e.config.chart.type)
                    for (var t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), a = 0; a < t.length; a++) {
                        var i = t[a]
                          , n = i.getBBox()
                          , r = null;
                        if (n.width && n.height && (r = this.addBackgroundToDataLabel(i, n)),
                        r) {
                            i.parentNode.insertBefore(r.node, i);
                            var o = i.getAttribute("fill");
                            !e.config.chart.animations.enabled || e.globals.resized || e.globals.dataChanged ? r.attr({
                                fill: o
                            }) : r.animate().attr({
                                fill: o
                            }),
                            i.setAttribute("fill", e.config.dataLabels.background.foreColor)
                        }
                    }
            }
        }, {
            key: "bringForward",
            value: function() {
                for (var e = this.w, t = e.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), a = e.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), i = 0; i < t.length; i++)
                    a && a.insertBefore(t[i], a.nextSibling)
            }
        }]),
        e
    }()
      , X = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.legendInactiveClass = "legend-mouseover-inactive"
        }
        return s(e, [{
            key: "getAllSeriesEls",
            value: function() {
                return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
            }
        }, {
            key: "getSeriesByName",
            value: function(e) {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(b.escapeString(e), "']"))
            }
        }, {
            key: "isSeriesHidden",
            value: function(e) {
                var t = this.getSeriesByName(e)
                  , a = parseInt(t.getAttribute("data:realIndex"), 10);
                return {
                    isHidden: t.classList.contains("apexcharts-series-collapsed"),
                    realIndex: a
                }
            }
        }, {
            key: "addCollapsedClassToSeries",
            value: function(e, t) {
                var a = this.w;
                function i(a) {
                    for (var i = 0; i < a.length; i++)
                        a[i].index === t && e.node.classList.add("apexcharts-series-collapsed")
                }
                i(a.globals.collapsedSeries),
                i(a.globals.ancillaryCollapsedSeries)
            }
        }, {
            key: "toggleSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                return this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, t.isHidden),
                t.isHidden
            }
        }, {
            key: "showSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                t.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !0)
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                var t = this.isSeriesHidden(e);
                t.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(t.realIndex, !1)
            }
        }, {
            key: "resetSeries",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , i = this.w
                  , n = b.clone(i.globals.initialSeries);
                i.globals.previousPaths = [],
                a ? (i.globals.collapsedSeries = [],
                i.globals.ancillaryCollapsedSeries = [],
                i.globals.collapsedSeriesIndices = [],
                i.globals.ancillaryCollapsedSeriesIndices = []) : n = this.emptyCollapsedSeries(n),
                i.config.series = n,
                e && (t && (i.globals.zoomed = !1,
                this.ctx.updateHelpers.revertDefaultAxisMinMax()),
                this.ctx.updateHelpers._updateSeries(n, i.config.chart.animations.dynamicAnimation.enabled))
            }
        }, {
            key: "emptyCollapsedSeries",
            value: function(e) {
                for (var t = this.w, a = 0; a < e.length; a++)
                    t.globals.collapsedSeriesIndices.indexOf(a) > -1 && (e[a].data = []);
                return e
            }
        }, {
            key: "toggleSeriesOnHover",
            value: function(e, t) {
                var a = this.w;
                t || (t = e.target);
                var i = a.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                if ("mousemove" === e.type) {
                    var n = parseInt(t.getAttribute("rel"), 10) - 1
                      , r = null
                      , o = null;
                    a.globals.axisCharts || "radialBar" === a.config.chart.type ? a.globals.axisCharts ? (r = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(n, "']")),
                    o = a.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(n, "']"))) : r = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(n + 1, "']")) : r = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(n + 1, "'] path"));
                    for (var s = 0; s < i.length; s++)
                        i[s].classList.add(this.legendInactiveClass);
                    null !== r && (a.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass),
                    r.classList.remove(this.legendInactiveClass),
                    null !== o && o.classList.remove(this.legendInactiveClass))
                } else if ("mouseout" === e.type)
                    for (var l = 0; l < i.length; l++)
                        i[l].classList.remove(this.legendInactiveClass)
            }
        }, {
            key: "highlightRangeInSeries",
            value: function(e, t) {
                var a = this
                  , i = this.w
                  , n = i.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect")
                  , r = function(e) {
                    for (var t = 0; t < n.length; t++)
                        n[t].classList[e](a.legendInactiveClass)
                };
                if ("mousemove" === e.type) {
                    var o = parseInt(t.getAttribute("rel"), 10) - 1;
                    r("add"),
                    function(e) {
                        for (var t = 0; t < n.length; t++) {
                            var i = parseInt(n[t].getAttribute("val"), 10);
                            i >= e.from && i <= e.to && n[t].classList.remove(a.legendInactiveClass)
                        }
                    }(i.config.plotOptions.heatmap.colorScale.ranges[o])
                } else
                    "mouseout" === e.type && r("remove")
            }
        }, {
            key: "getActiveConfigSeriesIndex",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc"
                  , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
                  , a = this.w
                  , i = 0;
                if (a.config.series.length > 1)
                    for (var n = a.config.series.map((function(e, i) {
                        return e.data && e.data.length > 0 && -1 === a.globals.collapsedSeriesIndices.indexOf(i) && (!a.globals.comboCharts || 0 === t.length || t.length && t.indexOf(a.config.series[i].type) > -1) ? i : -1
                    }
                    )), r = "asc" === e ? 0 : n.length - 1; "asc" === e ? r < n.length : r >= 0; "asc" === e ? r++ : r--)
                        if (-1 !== n[r]) {
                            i = n[r];
                            break
                        }
                return i
            }
        }, {
            key: "getBarSeriesIndices",
            value: function() {
                return this.w.globals.comboCharts ? this.w.config.series.map((function(e, t) {
                    return "bar" === e.type || "column" === e.type ? t : -1
                }
                )).filter((function(e) {
                    return -1 !== e
                }
                )) : this.w.config.series.map((function(e, t) {
                    return t
                }
                ))
            }
        }, {
            key: "getPreviousPaths",
            value: function() {
                var e = this.w;
                function t(t, a, i) {
                    for (var n = t[a].childNodes, r = {
                        type: i,
                        paths: [],
                        realIndex: t[a].getAttribute("data:realIndex")
                    }, o = 0; o < n.length; o++)
                        if (n[o].hasAttribute("pathTo")) {
                            var s = n[o].getAttribute("pathTo");
                            r.paths.push({
                                d: s
                            })
                        }
                    e.globals.previousPaths.push(r)
                }
                e.globals.previousPaths = [],
                ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach((function(a) {
                    for (var i, n = (i = a,
                    e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(i, "-series .apexcharts-series"))), r = 0; r < n.length; r++)
                        t(n, r, a)
                }
                )),
                this.handlePrevBubbleScatterPaths("bubble"),
                this.handlePrevBubbleScatterPaths("scatter");
                var a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series"));
                if (a.length > 0)
                    for (var i = function(t) {
                        for (var a = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(t, "'] rect")), i = [], n = function(e) {
                            var t = function(t) {
                                return a[e].getAttribute(t)
                            }
                              , n = {
                                x: parseFloat(t("x")),
                                y: parseFloat(t("y")),
                                width: parseFloat(t("width")),
                                height: parseFloat(t("height"))
                            };
                            i.push({
                                rect: n,
                                color: a[e].getAttribute("color")
                            })
                        }, r = 0; r < a.length; r++)
                            n(r);
                        e.globals.previousPaths.push(i)
                    }, n = 0; n < a.length; n++)
                        i(n);
                e.globals.axisCharts || (e.globals.previousPaths = e.globals.series)
            }
        }, {
            key: "handlePrevBubbleScatterPaths",
            value: function(e) {
                var t = this.w
                  , a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series"));
                if (a.length > 0)
                    for (var i = 0; i < a.length; i++) {
                        for (var n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(e, "-series .apexcharts-series[data\\:realIndex='").concat(i, "'] circle")), r = [], o = 0; o < n.length; o++)
                            r.push({
                                x: n[o].getAttribute("cx"),
                                y: n[o].getAttribute("cy"),
                                r: n[o].getAttribute("r")
                            });
                        t.globals.previousPaths.push(r)
                    }
            }
        }, {
            key: "clearPreviousPaths",
            value: function() {
                var e = this.w;
                e.globals.previousPaths = [],
                e.globals.allSeriesCollapsed = !1
            }
        }, {
            key: "handleNoData",
            value: function() {
                var e = this.w
                  , t = e.config.noData
                  , a = new w(this.ctx)
                  , i = e.globals.svgWidth / 2
                  , n = e.globals.svgHeight / 2
                  , r = "middle";
                if (e.globals.noData = !0,
                e.globals.animationEnded = !0,
                "left" === t.align ? (i = 10,
                r = "start") : "right" === t.align && (i = e.globals.svgWidth - 10,
                r = "end"),
                "top" === t.verticalAlign ? n = 50 : "bottom" === t.verticalAlign && (n = e.globals.svgHeight - 50),
                i += t.offsetX,
                n = n + parseInt(t.style.fontSize, 10) + 2 + t.offsetY,
                void 0 !== t.text && "" !== t.text) {
                    var o = a.drawText({
                        x: i,
                        y: n,
                        text: t.text,
                        textAnchor: r,
                        fontSize: t.style.fontSize,
                        fontFamily: t.style.fontFamily,
                        foreColor: t.style.color,
                        opacity: 1,
                        class: "apexcharts-text-nodata"
                    });
                    e.globals.dom.Paper.add(o)
                }
            }
        }, {
            key: "setNullSeriesToZeroValues",
            value: function(e) {
                for (var t = this.w, a = 0; a < e.length; a++)
                    if (0 === e[a].length)
                        for (var i = 0; i < e[t.globals.maxValsInArrayIndex].length; i++)
                            e[a].push(0);
                return e
            }
        }, {
            key: "hasAllSeriesEqualX",
            value: function() {
                for (var e = !0, t = this.w, a = this.filteredSeriesX(), i = 0; i < a.length - 1; i++)
                    if (a[i][0] !== a[i + 1][0]) {
                        e = !1;
                        break
                    }
                return t.globals.allSeriesHasEqualX = e,
                e
            }
        }, {
            key: "filteredSeriesX",
            value: function() {
                return this.w.globals.seriesX.map((function(e) {
                    return e.length > 0 ? e : []
                }
                ))
            }
        }]),
        e
    }()
      , Y = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.twoDSeries = [],
            this.threeDSeries = [],
            this.twoDSeriesX = [],
            this.seriesGoals = [],
            this.coreUtils = new k(this.ctx)
        }
        return s(e, [{
            key: "isMultiFormat",
            value: function() {
                return this.isFormatXY() || this.isFormat2DArray()
            }
        }, {
            key: "isFormatXY",
            value: function() {
                var e = this.w.config.series.slice()
                  , t = new X(this.ctx);
                if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(),
                void 0 !== e[this.activeSeriesIndex].data && e[this.activeSeriesIndex].data.length > 0 && null !== e[this.activeSeriesIndex].data[0] && void 0 !== e[this.activeSeriesIndex].data[0].x && null !== e[this.activeSeriesIndex].data[0])
                    return !0
            }
        }, {
            key: "isFormat2DArray",
            value: function() {
                var e = this.w.config.series.slice()
                  , t = new X(this.ctx);
                if (this.activeSeriesIndex = t.getActiveConfigSeriesIndex(),
                void 0 !== e[this.activeSeriesIndex].data && e[this.activeSeriesIndex].data.length > 0 && void 0 !== e[this.activeSeriesIndex].data[0] && null !== e[this.activeSeriesIndex].data[0] && e[this.activeSeriesIndex].data[0].constructor === Array)
                    return !0
            }
        }, {
            key: "handleFormat2DArray",
            value: function(e, t) {
                for (var a = this.w.config, i = this.w.globals, n = "boxPlot" === a.chart.type || "boxPlot" === a.series[t].type, r = 0; r < e[t].data.length; r++)
                    if (void 0 !== e[t].data[r][1] && (Array.isArray(e[t].data[r][1]) && 4 === e[t].data[r][1].length && !n ? this.twoDSeries.push(b.parseNumber(e[t].data[r][1][3])) : e[t].data[r].length >= 5 ? this.twoDSeries.push(b.parseNumber(e[t].data[r][4])) : this.twoDSeries.push(b.parseNumber(e[t].data[r][1])),
                    i.dataFormatXNumeric = !0),
                    "datetime" === a.xaxis.type) {
                        var o = new Date(e[t].data[r][0]);
                        o = new Date(o).getTime(),
                        this.twoDSeriesX.push(o)
                    } else
                        this.twoDSeriesX.push(e[t].data[r][0]);
                for (var s = 0; s < e[t].data.length; s++)
                    void 0 !== e[t].data[s][2] && (this.threeDSeries.push(e[t].data[s][2]),
                    i.isDataXYZ = !0)
            }
        }, {
            key: "handleFormatXY",
            value: function(e, t) {
                var a = this.w.config
                  , i = this.w.globals
                  , n = new T(this.ctx)
                  , r = t;
                i.collapsedSeriesIndices.indexOf(t) > -1 && (r = this.activeSeriesIndex);
                for (var o = 0; o < e[t].data.length; o++)
                    void 0 !== e[t].data[o].y && (Array.isArray(e[t].data[o].y) ? this.twoDSeries.push(b.parseNumber(e[t].data[o].y[e[t].data[o].y.length - 1])) : this.twoDSeries.push(b.parseNumber(e[t].data[o].y))),
                    void 0 !== e[t].data[o].goals && Array.isArray(e[t].data[o].goals) ? (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []),
                    this.seriesGoals[t].push(e[t].data[o].goals)) : (void 0 === this.seriesGoals[t] && (this.seriesGoals[t] = []),
                    this.seriesGoals[t].push(null));
                for (var s = 0; s < e[r].data.length; s++) {
                    var l = "string" == typeof e[r].data[s].x
                      , c = Array.isArray(e[r].data[s].x)
                      , u = !c && !!n.isValidDate(e[r].data[s].x);
                    if (l || u)
                        if (l || a.xaxis.convertedCatToNumeric) {
                            var d = i.isBarHorizontal && i.isRangeData;
                            "datetime" !== a.xaxis.type || d ? (this.fallbackToCategory = !0,
                            this.twoDSeriesX.push(e[r].data[s].x),
                            isNaN(e[r].data[s].x) || "category" === this.w.config.xaxis.type || "string" == typeof e[r].data[s].x || (i.isXNumeric = !0)) : this.twoDSeriesX.push(n.parseDate(e[r].data[s].x))
                        } else
                            "datetime" === a.xaxis.type ? this.twoDSeriesX.push(n.parseDate(e[r].data[s].x.toString())) : (i.dataFormatXNumeric = !0,
                            i.isXNumeric = !0,
                            this.twoDSeriesX.push(parseFloat(e[r].data[s].x)));
                    else
                        c ? (this.fallbackToCategory = !0,
                        this.twoDSeriesX.push(e[r].data[s].x)) : (i.isXNumeric = !0,
                        i.dataFormatXNumeric = !0,
                        this.twoDSeriesX.push(e[r].data[s].x))
                }
                if (e[t].data[0] && void 0 !== e[t].data[0].z) {
                    for (var h = 0; h < e[t].data.length; h++)
                        this.threeDSeries.push(e[t].data[h].z);
                    i.isDataXYZ = !0
                }
            }
        }, {
            key: "handleRangeData",
            value: function(e, t) {
                var a = this.w.globals
                  , i = {};
                return this.isFormat2DArray() ? i = this.handleRangeDataFormat("array", e, t) : this.isFormatXY() && (i = this.handleRangeDataFormat("xy", e, t)),
                a.seriesRangeStart.push(i.start),
                a.seriesRangeEnd.push(i.end),
                a.seriesRange.push(i.rangeUniques),
                a.seriesRange.forEach((function(e, t) {
                    e && e.forEach((function(e, t) {
                        e.y.forEach((function(t, a) {
                            for (var i = 0; i < e.y.length; i++)
                                if (a !== i) {
                                    var n = t.y1
                                      , r = t.y2
                                      , o = e.y[i].y1;
                                    n <= e.y[i].y2 && o <= r && (e.overlaps.indexOf(t.rangeName) < 0 && e.overlaps.push(t.rangeName),
                                    e.overlaps.indexOf(e.y[i].rangeName) < 0 && e.overlaps.push(e.y[i].rangeName))
                                }
                        }
                        ))
                    }
                    ))
                }
                )),
                i
            }
        }, {
            key: "handleCandleStickBoxData",
            value: function(e, t) {
                var a = this.w.globals
                  , i = {};
                return this.isFormat2DArray() ? i = this.handleCandleStickBoxDataFormat("array", e, t) : this.isFormatXY() && (i = this.handleCandleStickBoxDataFormat("xy", e, t)),
                a.seriesCandleO[t] = i.o,
                a.seriesCandleH[t] = i.h,
                a.seriesCandleM[t] = i.m,
                a.seriesCandleL[t] = i.l,
                a.seriesCandleC[t] = i.c,
                i
            }
        }, {
            key: "handleRangeDataFormat",
            value: function(e, t, a) {
                var i = []
                  , n = []
                  , r = t[a].data.filter((function(e, t, a) {
                    return t === a.findIndex((function(t) {
                        return t.x === e.x
                    }
                    ))
                }
                )).map((function(e, t) {
                    return {
                        x: e.x,
                        overlaps: [],
                        y: []
                    }
                }
                ));
                if ("array" === e)
                    for (var o = 0; o < t[a].data.length; o++)
                        Array.isArray(t[a].data[o]) ? (i.push(t[a].data[o][1][0]),
                        n.push(t[a].data[o][1][1])) : (i.push(t[a].data[o]),
                        n.push(t[a].data[o]));
                else if ("xy" === e)
                    for (var s = function(e) {
                        var o = Array.isArray(t[a].data[e].y)
                          , s = b.randomId()
                          , l = t[a].data[e].x
                          , c = {
                            y1: o ? t[a].data[e].y[0] : t[a].data[e].y,
                            y2: o ? t[a].data[e].y[1] : t[a].data[e].y,
                            rangeName: s
                        };
                        t[a].data[e].rangeName = s;
                        var u = r.findIndex((function(e) {
                            return e.x === l
                        }
                        ));
                        r[u].y.push(c),
                        i.push(c.y1),
                        n.push(c.y2)
                    }, l = 0; l < t[a].data.length; l++)
                        s(l);
                return {
                    start: i,
                    end: n,
                    rangeUniques: r
                }
            }
        }, {
            key: "handleCandleStickBoxDataFormat",
            value: function(e, t, a) {
                var i = this.w
                  , n = "boxPlot" === i.config.chart.type || "boxPlot" === i.config.series[a].type
                  , r = []
                  , o = []
                  , s = []
                  , l = []
                  , c = [];
                if ("array" === e)
                    if (n && 6 === t[a].data[0].length || !n && 5 === t[a].data[0].length)
                        for (var u = 0; u < t[a].data.length; u++)
                            r.push(t[a].data[u][1]),
                            o.push(t[a].data[u][2]),
                            n ? (s.push(t[a].data[u][3]),
                            l.push(t[a].data[u][4]),
                            c.push(t[a].data[u][5])) : (l.push(t[a].data[u][3]),
                            c.push(t[a].data[u][4]));
                    else
                        for (var d = 0; d < t[a].data.length; d++)
                            Array.isArray(t[a].data[d][1]) && (r.push(t[a].data[d][1][0]),
                            o.push(t[a].data[d][1][1]),
                            n ? (s.push(t[a].data[d][1][2]),
                            l.push(t[a].data[d][1][3]),
                            c.push(t[a].data[d][1][4])) : (l.push(t[a].data[d][1][2]),
                            c.push(t[a].data[d][1][3])));
                else if ("xy" === e)
                    for (var h = 0; h < t[a].data.length; h++)
                        Array.isArray(t[a].data[h].y) && (r.push(t[a].data[h].y[0]),
                        o.push(t[a].data[h].y[1]),
                        n ? (s.push(t[a].data[h].y[2]),
                        l.push(t[a].data[h].y[3]),
                        c.push(t[a].data[h].y[4])) : (l.push(t[a].data[h].y[2]),
                        c.push(t[a].data[h].y[3])));
                return {
                    o: r,
                    h: o,
                    m: s,
                    l: l,
                    c: c
                }
            }
        }, {
            key: "parseDataAxisCharts",
            value: function(e) {
                var t, a = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, n = this.w.config, r = this.w.globals, o = new T(i), s = n.labels.length > 0 ? n.labels.slice() : n.xaxis.categories.slice();
                if (r.isRangeBar = "rangeBar" === n.chart.type && r.isBarHorizontal,
                r.hasXaxisGroups = "category" === n.xaxis.type && n.xaxis.group.groups.length > 0,
                r.hasXaxisGroups && (r.groups = n.xaxis.group.groups),
                r.hasSeriesGroups = null === (t = e[0]) || void 0 === t ? void 0 : t.group,
                r.hasSeriesGroups) {
                    var l = []
                      , c = g(new Set(e.map((function(e) {
                        return e.group
                    }
                    ))));
                    e.forEach((function(e, t) {
                        var a = c.indexOf(e.group);
                        l[a] || (l[a] = []),
                        l[a].push(e.name)
                    }
                    )),
                    r.seriesGroups = l
                }
                for (var u = function() {
                    for (var e = 0; e < s.length; e++)
                        if ("string" == typeof s[e]) {
                            if (!o.isValidDate(s[e]))
                                throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                            a.twoDSeriesX.push(o.parseDate(s[e]))
                        } else
                            a.twoDSeriesX.push(s[e])
                }, d = 0; d < e.length; d++) {
                    if (this.twoDSeries = [],
                    this.twoDSeriesX = [],
                    this.threeDSeries = [],
                    void 0 === e[d].data)
                        return;
                    if ("rangeBar" !== n.chart.type && "rangeArea" !== n.chart.type && "rangeBar" !== e[d].type && "rangeArea" !== e[d].type || (r.isRangeData = !0,
                    "rangeBar" !== n.chart.type && "rangeArea" !== n.chart.type || this.handleRangeData(e, d)),
                    this.isMultiFormat())
                        this.isFormat2DArray() ? this.handleFormat2DArray(e, d) : this.isFormatXY() && this.handleFormatXY(e, d),
                        "candlestick" !== n.chart.type && "candlestick" !== e[d].type && "boxPlot" !== n.chart.type && "boxPlot" !== e[d].type || this.handleCandleStickBoxData(e, d),
                        r.series.push(this.twoDSeries),
                        r.labels.push(this.twoDSeriesX),
                        r.seriesX.push(this.twoDSeriesX),
                        r.seriesGoals = this.seriesGoals,
                        d !== this.activeSeriesIndex || this.fallbackToCategory || (r.isXNumeric = !0);
                    else {
                        "datetime" === n.xaxis.type ? (r.isXNumeric = !0,
                        u(),
                        r.seriesX.push(this.twoDSeriesX)) : "numeric" === n.xaxis.type && (r.isXNumeric = !0,
                        s.length > 0 && (this.twoDSeriesX = s,
                        r.seriesX.push(this.twoDSeriesX))),
                        r.labels.push(this.twoDSeriesX);
                        var h = e[d].data.map((function(e) {
                            return b.parseNumber(e)
                        }
                        ));
                        r.series.push(h)
                    }
                    r.seriesZ.push(this.threeDSeries),
                    void 0 !== e[d].name ? r.seriesNames.push(e[d].name) : r.seriesNames.push("series-" + parseInt(d + 1, 10)),
                    void 0 !== e[d].color ? r.seriesColors.push(e[d].color) : r.seriesColors.push(void 0)
                }
                return this.w
            }
        }, {
            key: "parseDataNonAxisCharts",
            value: function(e) {
                var t = this.w.globals
                  , a = this.w.config;
                t.series = e.slice(),
                t.seriesNames = a.labels.slice();
                for (var i = 0; i < t.series.length; i++)
                    void 0 === t.seriesNames[i] && t.seriesNames.push("series-" + (i + 1));
                return this.w
            }
        }, {
            key: "handleExternalLabelsData",
            value: function(e) {
                var t = this.w.config
                  , a = this.w.globals;
                t.xaxis.categories.length > 0 ? a.labels = t.xaxis.categories : t.labels.length > 0 ? a.labels = t.labels.slice() : this.fallbackToCategory ? (a.labels = a.labels[0],
                a.seriesRange.length && (a.seriesRange.map((function(e) {
                    e.forEach((function(e) {
                        a.labels.indexOf(e.x) < 0 && e.x && a.labels.push(e.x)
                    }
                    ))
                }
                )),
                a.labels = Array.from(new Set(a.labels.map(JSON.stringify)), JSON.parse)),
                t.xaxis.convertedCatToNumeric && (new F(t).convertCatToNumericXaxis(t, this.ctx, a.seriesX[0]),
                this._generateExternalLabels(e))) : this._generateExternalLabels(e)
            }
        }, {
            key: "_generateExternalLabels",
            value: function(e) {
                var t = this.w.globals
                  , a = this.w.config
                  , i = [];
                if (t.axisCharts) {
                    if (t.series.length > 0)
                        if (this.isFormatXY())
                            for (var n = a.series.map((function(e, t) {
                                return e.data.filter((function(e, t, a) {
                                    return a.findIndex((function(t) {
                                        return t.x === e.x
                                    }
                                    )) === t
                                }
                                ))
                            }
                            )), r = n.reduce((function(e, t, a, i) {
                                return i[e].length > t.length ? e : a
                            }
                            ), 0), o = 0; o < n[r].length; o++)
                                i.push(o + 1);
                        else
                            for (var s = 0; s < t.series[t.maxValsInArrayIndex].length; s++)
                                i.push(s + 1);
                    t.seriesX = [];
                    for (var l = 0; l < e.length; l++)
                        t.seriesX.push(i);
                    this.w.globals.isBarHorizontal || (t.isXNumeric = !0)
                }
                if (0 === i.length) {
                    i = t.axisCharts ? [] : t.series.map((function(e, t) {
                        return t + 1
                    }
                    ));
                    for (var c = 0; c < e.length; c++)
                        t.seriesX.push(i)
                }
                t.labels = i,
                a.xaxis.convertedCatToNumeric && (t.categoryLabels = i.map((function(e) {
                    return a.xaxis.labels.formatter(e)
                }
                ))),
                t.noLabelsProvided = !0
            }
        }, {
            key: "parseData",
            value: function(e) {
                var t = this.w
                  , a = t.config
                  , i = t.globals;
                if (this.excludeCollapsedSeriesInYAxis(),
                this.fallbackToCategory = !1,
                this.ctx.core.resetGlobals(),
                this.ctx.core.isMultipleY(),
                i.axisCharts ? (this.parseDataAxisCharts(e),
                this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(e),
                a.chart.stacked) {
                    var n = new X(this.ctx);
                    i.series = n.setNullSeriesToZeroValues(i.series)
                }
                this.coreUtils.getSeriesTotals(),
                i.axisCharts && (i.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(),
                i.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()),
                this.coreUtils.getPercentSeries(),
                i.dataFormatXNumeric || i.isXNumeric && ("numeric" !== a.xaxis.type || 0 !== a.labels.length || 0 !== a.xaxis.categories.length) || this.handleExternalLabelsData(e);
                for (var r = this.coreUtils.getCategoryLabels(i.labels), o = 0; o < r.length; o++)
                    if (Array.isArray(r[o])) {
                        i.isMultiLineX = !0;
                        break
                    }
            }
        }, {
            key: "excludeCollapsedSeriesInYAxis",
            value: function() {
                var e = this
                  , t = this.w;
                t.globals.ignoreYAxisIndexes = t.globals.collapsedSeries.map((function(a, i) {
                    if (e.w.globals.isMultipleYAxis && !t.config.chart.stacked)
                        return a.index
                }
                ))
            }
        }]),
        e
    }()
      , W = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "getLabel",
            value: function(e, t, a, i) {
                var n, r, o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", l = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], c = this.w, u = void 0 === e[i] ? "" : e[i], d = u, h = c.globals.xLabelFormatter, p = c.config.xaxis.labels.formatter, v = !1, g = new E(this.ctx), f = u;
                l && (d = g.xLabelFormat(h, u, f, {
                    i: i,
                    dateFormatter: new T(this.ctx).formatDate,
                    w: c
                }),
                void 0 !== p && (d = p(u, e[i], {
                    i: i,
                    dateFormatter: new T(this.ctx).formatDate,
                    w: c
                }))),
                t.length > 0 ? (n = t[i].unit,
                r = null,
                t.forEach((function(e) {
                    "month" === e.unit ? r = "year" : "day" === e.unit ? r = "month" : "hour" === e.unit ? r = "day" : "minute" === e.unit && (r = "hour")
                }
                )),
                v = r === n,
                a = t[i].position,
                d = t[i].value) : "datetime" === c.config.xaxis.type && void 0 === p && (d = ""),
                void 0 === d && (d = ""),
                d = Array.isArray(d) ? d : d.toString();
                var m, b = new w(this.ctx);
                m = c.globals.rotateXLabels && l ? b.getTextRects(d, parseInt(s, 10), null, "rotate(".concat(c.config.xaxis.labels.rotate, " 0 0)"), !1) : b.getTextRects(d, parseInt(s, 10));
                var x = !c.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                return !Array.isArray(d) && (0 === d.indexOf("NaN") || 0 === d.toLowerCase().indexOf("invalid") || d.toLowerCase().indexOf("infinity") >= 0 || o.indexOf(d) >= 0 && x) && (d = ""),
                {
                    x: a,
                    text: d,
                    textRect: m,
                    isBold: v
                }
            }
        }, {
            key: "checkLabelBasedOnTickamount",
            value: function(e, t, a) {
                var i = this.w
                  , n = i.config.xaxis.tickAmount;
                return "dataPoints" === n && (n = Math.round(i.globals.gridWidth / 120)),
                n > a || e % Math.round(a / (n + 1)) == 0 || (t.text = ""),
                t
            }
        }, {
            key: "checkForOverflowingLabels",
            value: function(e, t, a, i, n) {
                var r = this.w;
                if (0 === e && r.globals.skipFirstTimelinelabel && (t.text = ""),
                e === a - 1 && r.globals.skipLastTimelinelabel && (t.text = ""),
                r.config.xaxis.labels.hideOverlappingLabels && i.length > 0) {
                    var o = n[n.length - 1];
                    t.x < o.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + o.x && (t.text = "")
                }
                return t
            }
        }, {
            key: "checkForReversedLabels",
            value: function(e, t) {
                var a = this.w;
                return a.config.yaxis[e] && a.config.yaxis[e].reversed && t.reverse(),
                t
            }
        }, {
            key: "isYAxisHidden",
            value: function(e) {
                var t = this.w
                  , a = new k(this.ctx);
                return !t.config.yaxis[e].show || !t.config.yaxis[e].showForNullSeries && a.isSeriesNull(e) && -1 === t.globals.collapsedSeriesIndices.indexOf(e)
            }
        }, {
            key: "getYAxisForeColor",
            value: function(e, t) {
                var a = this.w;
                return Array.isArray(e) && a.globals.yAxisScale[t] && this.ctx.theme.pushExtraColors(e, a.globals.yAxisScale[t].result.length, !1),
                e
            }
        }, {
            key: "drawYAxisTicks",
            value: function(e, t, a, i, n, r, o) {
                var s = this.w
                  , l = new w(this.ctx)
                  , c = s.globals.translateY;
                if (i.show && t > 0) {
                    !0 === s.config.yaxis[n].opposite && (e += i.width);
                    for (var u = t; u >= 0; u--) {
                        var d = c + t / 10 + s.config.yaxis[n].labels.offsetY - 1;
                        s.globals.isBarHorizontal && (d = r * u),
                        "heatmap" === s.config.chart.type && (d += r / 2);
                        var h = l.drawLine(e + a.offsetX - i.width + i.offsetX, d + i.offsetY, e + a.offsetX + i.offsetX, d + i.offsetY, i.color);
                        o.add(h),
                        c += r
                    }
                }
            }
        }]),
        e
    }()
      , G = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "scaleSvgNode",
            value: function(e, t) {
                var a = parseFloat(e.getAttributeNS(null, "width"))
                  , i = parseFloat(e.getAttributeNS(null, "height"));
                e.setAttributeNS(null, "width", a * t),
                e.setAttributeNS(null, "height", i * t),
                e.setAttributeNS(null, "viewBox", "0 0 " + a + " " + i)
            }
        }, {
            key: "fixSvgStringForIe11",
            value: function(e) {
                if (!b.isIE11())
                    return e.replace(/&nbsp;/g, "&#160;");
                var t = 0
                  , a = e.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, (function(e) {
                    return 2 == ++t ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : e
                }
                ));
                return (a = a.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
            }
        }, {
            key: "getSvgString",
            value: function(e) {
                null == e && (e = 1);
                var t = this.w.globals.dom.Paper.svg();
                if (1 !== e) {
                    var a = this.w.globals.dom.Paper.node.cloneNode(!0);
                    this.scaleSvgNode(a, e),
                    t = (new XMLSerializer).serializeToString(a)
                }
                return this.fixSvgStringForIe11(t)
            }
        }, {
            key: "cleanup",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs")
                  , a = e.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs")
                  , i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                Array.prototype.forEach.call(i, (function(e) {
                    e.setAttribute("width", 0)
                }
                )),
                t && t[0] && (t[0].setAttribute("x", -500),
                t[0].setAttribute("x1", -500),
                t[0].setAttribute("x2", -500)),
                a && a[0] && (a[0].setAttribute("y", -100),
                a[0].setAttribute("y1", -100),
                a[0].setAttribute("y2", -100))
            }
        }, {
            key: "svgUrl",
            value: function() {
                this.cleanup();
                var e = this.getSvgString()
                  , t = new Blob([e],{
                    type: "image/svg+xml;charset=utf-8"
                });
                return URL.createObjectURL(t)
            }
        }, {
            key: "dataURI",
            value: function(e) {
                var t = this;
                return new Promise((function(a) {
                    var i = t.w
                      , n = e ? e.scale || e.width / i.globals.svgWidth : 1;
                    t.cleanup();
                    var r = document.createElement("canvas");
                    r.width = i.globals.svgWidth * n,
                    r.height = parseInt(i.globals.dom.elWrap.style.height, 10) * n;
                    var o = "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background
                      , s = r.getContext("2d");
                    s.fillStyle = o,
                    s.fillRect(0, 0, r.width * n, r.height * n);
                    var l = t.getSvgString(n);
                    if (window.canvg && b.isIE11()) {
                        var c = window.canvg.Canvg.fromString(s, l, {
                            ignoreClear: !0,
                            ignoreDimensions: !0
                        });
                        c.start();
                        var u = r.msToBlob();
                        c.stop(),
                        a({
                            blob: u
                        })
                    } else {
                        var d = "data:image/svg+xml," + encodeURIComponent(l)
                          , h = new Image;
                        h.crossOrigin = "anonymous",
                        h.onload = function() {
                            if (s.drawImage(h, 0, 0),
                            r.msToBlob) {
                                var e = r.msToBlob();
                                a({
                                    blob: e
                                })
                            } else {
                                var t = r.toDataURL("image/png");
                                a({
                                    imgURI: t
                                })
                            }
                        }
                        ,
                        h.src = d
                    }
                }
                ))
            }
        }, {
            key: "exportToSVG",
            value: function() {
                this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg")
            }
        }, {
            key: "exportToPng",
            value: function() {
                var e = this;
                this.dataURI().then((function(t) {
                    var a = t.imgURI
                      , i = t.blob;
                    i ? navigator.msSaveOrOpenBlob(i, e.w.globals.chartID + ".png") : e.triggerDownload(a, e.w.config.chart.toolbar.export.png.filename, ".png")
                }
                ))
            }
        }, {
            key: "exportToCSV",
            value: function(e) {
                var t = this
                  , a = e.series
                  , i = e.fileName
                  , n = e.columnDelimiter
                  , r = void 0 === n ? "," : n
                  , o = e.lineDelimiter
                  , s = void 0 === o ? "\n" : o
                  , l = this.w;
                a || (a = l.config.series);
                var c, u, d = [], h = [], p = "", v = l.globals.series.map((function(e, t) {
                    return -1 === l.globals.collapsedSeriesIndices.indexOf(t) ? e : []
                }
                )), f = function(e) {
                    return "datetime" === l.config.xaxis.type && String(e).length >= 10
                }, m = Math.max.apply(Math, g(a.map((function(e) {
                    return e.data ? e.data.length : 0
                }
                )))), x = new Y(this.ctx), y = new W(this.ctx), w = function(e) {
                    var a = "";
                    if (l.globals.axisCharts) {
                        if ("category" === l.config.xaxis.type || l.config.xaxis.convertedCatToNumeric)
                            if (l.globals.isBarHorizontal) {
                                var i = l.globals.yLabelFormatters[0]
                                  , n = new X(t.ctx).getActiveConfigSeriesIndex();
                                a = i(l.globals.labels[e], {
                                    seriesIndex: n,
                                    dataPointIndex: e,
                                    w: l
                                })
                            } else
                                a = y.getLabel(l.globals.labels, l.globals.timescaleLabels, 0, e).text;
                        "datetime" === l.config.xaxis.type && (l.config.xaxis.categories.length ? a = l.config.xaxis.categories[e] : l.config.labels.length && (a = l.config.labels[e]))
                    } else
                        a = l.config.labels[e];
                    return Array.isArray(a) && (a = a.join(" ")),
                    b.isNumber(a) ? a : a.split(r).join("")
                };
                d.push(l.config.chart.toolbar.export.csv.headerCategory),
                "boxPlot" === l.config.chart.type ? (d.push("minimum"),
                d.push("q1"),
                d.push("median"),
                d.push("q3"),
                d.push("maximum")) : "candlestick" === l.config.chart.type ? (d.push("open"),
                d.push("high"),
                d.push("low"),
                d.push("close")) : "rangeBar" === l.config.chart.type ? (d.push("minimum"),
                d.push("maximum")) : a.map((function(e, t) {
                    var a = (e.name ? e.name : "series-".concat(t)) + "";
                    l.globals.axisCharts && d.push(a.split(r).join("") ? a.split(r).join("") : "series-".concat(t))
                }
                )),
                l.globals.axisCharts || (d.push(l.config.chart.toolbar.export.csv.headerValue),
                h.push(d.join(r))),
                l.globals.allSeriesHasEqualX || !l.globals.axisCharts || l.config.xaxis.categories.length || l.config.labels.length ? a.map((function(e, t) {
                    l.globals.axisCharts ? function(e, t) {
                        if (d.length && 0 === t && h.push(d.join(r)),
                        e.data) {
                            e.data = e.data.length && e.data || g(Array(m)).map((function() {
                                return ""
                            }
                            ));
                            for (var i = 0; i < e.data.length; i++) {
                                d = [];
                                var n = w(i);
                                if (n || (x.isFormatXY() ? n = a[t].data[i].x : x.isFormat2DArray() && (n = a[t].data[i] ? a[t].data[i][0] : "")),
                                0 === t) {
                                    d.push(f(n) ? l.config.chart.toolbar.export.csv.dateFormatter(n) : b.isNumber(n) ? n : n.split(r).join(""));
                                    for (var o = 0; o < l.globals.series.length; o++) {
                                        var s;
                                        x.isFormatXY() ? d.push(null === (s = a[o].data[i]) || void 0 === s ? void 0 : s.y) : d.push(v[o][i])
                                    }
                                }
                                ("candlestick" === l.config.chart.type || e.type && "candlestick" === e.type) && (d.pop(),
                                d.push(l.globals.seriesCandleO[t][i]),
                                d.push(l.globals.seriesCandleH[t][i]),
                                d.push(l.globals.seriesCandleL[t][i]),
                                d.push(l.globals.seriesCandleC[t][i])),
                                ("boxPlot" === l.config.chart.type || e.type && "boxPlot" === e.type) && (d.pop(),
                                d.push(l.globals.seriesCandleO[t][i]),
                                d.push(l.globals.seriesCandleH[t][i]),
                                d.push(l.globals.seriesCandleM[t][i]),
                                d.push(l.globals.seriesCandleL[t][i]),
                                d.push(l.globals.seriesCandleC[t][i])),
                                "rangeBar" === l.config.chart.type && (d.pop(),
                                d.push(l.globals.seriesRangeStart[t][i]),
                                d.push(l.globals.seriesRangeEnd[t][i])),
                                d.length && h.push(d.join(r))
                            }
                        }
                    }(e, t) : ((d = []).push(l.globals.labels[t].split(r).join("")),
                    d.push(v[t]),
                    h.push(d.join(r)))
                }
                )) : (c = new Set,
                u = {},
                a.forEach((function(e, t) {
                    null == e || e.data.forEach((function(e) {
                        var i, n;
                        if (x.isFormatXY())
                            i = e.x,
                            n = e.y;
                        else {
                            if (!x.isFormat2DArray())
                                return;
                            i = e[0],
                            n = e[1]
                        }
                        u[i] || (u[i] = Array(a.length).fill("")),
                        u[i][t] = n,
                        c.add(i)
                    }
                    ))
                }
                )),
                d.length && h.push(d.join(r)),
                Array.from(c).sort().forEach((function(e) {
                    h.push([f(e) && "datetime" === l.config.xaxis.type ? l.config.chart.toolbar.export.csv.dateFormatter(e) : b.isNumber(e) ? e : e.split(r).join(""), u[e].join(r)])
                }
                ))),
                p += h.join(s),
                this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + p), i || l.config.chart.toolbar.export.csv.filename, ".csv")
            }
        }, {
            key: "triggerDownload",
            value: function(e, t, a) {
                var i = document.createElement("a");
                i.href = e,
                i.download = (t || this.w.globals.chartID) + a,
                document.body.appendChild(i),
                i.click(),
                document.body.removeChild(i)
            }
        }]),
        e
    }()
      , j = function() {
        function e(t, a) {
            r(this, e),
            this.ctx = t,
            this.elgrid = a,
            this.w = t.w;
            var i = this.w;
            this.axesUtils = new W(t),
            this.xaxisLabels = i.globals.labels.slice(),
            i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()),
            i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories),
            this.drawnLabels = [],
            this.drawnLabelsRects = [],
            "top" === i.config.xaxis.position ? this.offY = 0 : this.offY = i.globals.gridHeight + 1,
            this.offY = this.offY + i.config.xaxis.axisBorder.offsetY,
            this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal,
            this.xaxisFontSize = i.config.xaxis.labels.style.fontSize,
            this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily,
            this.xaxisForeColors = i.config.xaxis.labels.style.colors,
            this.xaxisBorderWidth = i.config.xaxis.axisBorder.width,
            this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()),
            this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10),
            this.xaxisBorderHeight = i.config.xaxis.axisBorder.height,
            this.yaxis = i.config.yaxis[0]
        }
        return s(e, [{
            key: "drawXaxis",
            value: function() {
                var e = this.w
                  , t = new w(this.ctx)
                  , a = t.group({
                    class: "apexcharts-xaxis",
                    transform: "translate(".concat(e.config.xaxis.offsetX, ", ").concat(e.config.xaxis.offsetY, ")")
                })
                  , i = t.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
                });
                a.add(i);
                for (var n = [], r = 0; r < this.xaxisLabels.length; r++)
                    n.push(this.xaxisLabels[r]);
                if (this.drawXAxisLabelAndGroup(!0, t, i, n, e.globals.isXNumeric, (function(e, t) {
                    return t
                }
                )),
                e.globals.hasXaxisGroups) {
                    var o = e.globals.groups;
                    n = [];
                    for (var s = 0; s < o.length; s++)
                        n.push(o[s].title);
                    var l = {};
                    e.config.xaxis.group.style && (l.xaxisFontSize = e.config.xaxis.group.style.fontSize,
                    l.xaxisFontFamily = e.config.xaxis.group.style.fontFamily,
                    l.xaxisForeColors = e.config.xaxis.group.style.colors,
                    l.fontWeight = e.config.xaxis.group.style.fontWeight,
                    l.cssClass = e.config.xaxis.group.style.cssClass),
                    this.drawXAxisLabelAndGroup(!1, t, i, n, !1, (function(e, t) {
                        return o[e].cols * t
                    }
                    ), l)
                }
                if (void 0 !== e.config.xaxis.title.text) {
                    var c = t.group({
                        class: "apexcharts-xaxis-title"
                    })
                      , u = t.drawText({
                        x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                        y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === e.config.xaxis.position ? e.globals.xAxisLabelsHeight : -e.globals.xAxisLabelsHeight - 10) + e.config.xaxis.title.offsetY,
                        text: e.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: e.config.xaxis.title.style.fontSize,
                        fontFamily: e.config.xaxis.title.style.fontFamily,
                        fontWeight: e.config.xaxis.title.style.fontWeight,
                        foreColor: e.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
                    });
                    c.add(u),
                    a.add(c)
                }
                if (e.config.xaxis.axisBorder.show) {
                    var d = e.globals.barPadForNumericAxis
                      , h = t.drawLine(e.globals.padHorizontal + e.config.xaxis.axisBorder.offsetX - d, this.offY, this.xaxisBorderWidth + d, this.offY, e.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                    this.elgrid && this.elgrid.elGridBorders && e.config.grid.show ? this.elgrid.elGridBorders.add(h) : a.add(h)
                }
                return a
            }
        }, {
            key: "drawXAxisLabelAndGroup",
            value: function(e, t, a, i, n, r) {
                var o, s = this, l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, c = [], u = [], d = this.w, h = l.xaxisFontSize || this.xaxisFontSize, p = l.xaxisFontFamily || this.xaxisFontFamily, v = l.xaxisForeColors || this.xaxisForeColors, g = l.fontWeight || d.config.xaxis.labels.style.fontWeight, f = l.cssClass || d.config.xaxis.labels.style.cssClass, m = d.globals.padHorizontal, b = i.length, x = "category" === d.config.xaxis.type ? d.globals.dataPoints : b;
                if (0 === x && b > x && (x = b),
                n) {
                    var y = x > 1 ? x - 1 : x;
                    o = d.globals.gridWidth / Math.min(y, b - 1),
                    m = m + r(0, o) / 2 + d.config.xaxis.labels.offsetX
                } else
                    o = d.globals.gridWidth / x,
                    m = m + r(0, o) + d.config.xaxis.labels.offsetX;
                for (var w = function(n) {
                    var l = m - r(n, o) / 2 + d.config.xaxis.labels.offsetX;
                    0 === n && 1 === b && o / 2 === m && 1 === x && (l = d.globals.gridWidth / 2);
                    var y = s.axesUtils.getLabel(i, d.globals.timescaleLabels, l, n, c, h, e)
                      , w = 28;
                    if (d.globals.rotateXLabels && e && (w = 22),
                    d.config.xaxis.title.text && "top" === d.config.xaxis.position && (w += parseFloat(d.config.xaxis.title.style.fontSize) + 2),
                    e || (w = w + parseFloat(h) + (d.globals.xAxisLabelsHeight - d.globals.xAxisGroupLabelsHeight) + (d.globals.rotateXLabels ? 10 : 0)),
                    y = void 0 !== d.config.xaxis.tickAmount && "dataPoints" !== d.config.xaxis.tickAmount && "datetime" !== d.config.xaxis.type ? s.axesUtils.checkLabelBasedOnTickamount(n, y, b) : s.axesUtils.checkForOverflowingLabels(n, y, b, c, u),
                    d.config.xaxis.labels.show) {
                        var k = t.drawText({
                            x: y.x,
                            y: s.offY + d.config.xaxis.labels.offsetY + w - ("top" === d.config.xaxis.position ? d.globals.xAxisHeight + d.config.xaxis.axisTicks.height - 2 : 0),
                            text: y.text,
                            textAnchor: "middle",
                            fontWeight: y.isBold ? 600 : g,
                            fontSize: h,
                            fontFamily: p,
                            foreColor: Array.isArray(v) ? e && d.config.xaxis.convertedCatToNumeric ? v[d.globals.minX + n - 1] : v[n] : v,
                            isPlainText: !1,
                            cssClass: (e ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + f
                        });
                        if (a.add(k),
                        k.on("click", (function(e) {
                            if ("function" == typeof d.config.chart.events.xAxisLabelClick) {
                                var t = Object.assign({}, d, {
                                    labelIndex: n
                                });
                                d.config.chart.events.xAxisLabelClick(e, s.ctx, t)
                            }
                        }
                        )),
                        e) {
                            var S = document.createElementNS(d.globals.SVGNS, "title");
                            S.textContent = Array.isArray(y.text) ? y.text.join(" ") : y.text,
                            k.node.appendChild(S),
                            "" !== y.text && (c.push(y.text),
                            u.push(y))
                        }
                    }
                    n < b - 1 && (m += r(n + 1, o))
                }, k = 0; k <= b - 1; k++)
                    w(k)
            }
        }, {
            key: "drawXaxisInversed",
            value: function(e) {
                var t, a, i = this, n = this.w, r = new w(this.ctx), o = n.config.yaxis[0].opposite ? n.globals.translateYAxisX[e] : 0, s = r.group({
                    class: "apexcharts-yaxis apexcharts-xaxis-inversed",
                    rel: e
                }), l = r.group({
                    class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                    transform: "translate(" + o + ", 0)"
                });
                s.add(l);
                var c = [];
                if (n.config.yaxis[e].show)
                    for (var u = 0; u < this.xaxisLabels.length; u++)
                        c.push(this.xaxisLabels[u]);
                t = n.globals.gridHeight / c.length,
                a = -t / 2.2;
                var d = n.globals.yLabelFormatters[0]
                  , h = n.config.yaxis[0].labels;
                if (h.show)
                    for (var p = function(o) {
                        var s = void 0 === c[o] ? "" : c[o];
                        s = d(s, {
                            seriesIndex: e,
                            dataPointIndex: o,
                            w: n
                        });
                        var u = i.axesUtils.getYAxisForeColor(h.style.colors, e)
                          , p = 0;
                        Array.isArray(s) && (p = s.length / 2 * parseInt(h.style.fontSize, 10));
                        var v = h.offsetX - 15
                          , g = "end";
                        i.yaxis.opposite && (g = "start"),
                        "left" === n.config.yaxis[0].labels.align ? (v = h.offsetX,
                        g = "start") : "center" === n.config.yaxis[0].labels.align ? (v = h.offsetX,
                        g = "middle") : "right" === n.config.yaxis[0].labels.align && (g = "end");
                        var f = r.drawText({
                            x: v,
                            y: a + t + h.offsetY - p,
                            text: s,
                            textAnchor: g,
                            foreColor: Array.isArray(u) ? u[o] : u,
                            fontSize: h.style.fontSize,
                            fontFamily: h.style.fontFamily,
                            fontWeight: h.style.fontWeight,
                            isPlainText: !1,
                            cssClass: "apexcharts-yaxis-label " + h.style.cssClass,
                            maxWidth: h.maxWidth
                        });
                        l.add(f),
                        f.on("click", (function(e) {
                            if ("function" == typeof n.config.chart.events.xAxisLabelClick) {
                                var t = Object.assign({}, n, {
                                    labelIndex: o
                                });
                                n.config.chart.events.xAxisLabelClick(e, i.ctx, t)
                            }
                        }
                        ));
                        var m = document.createElementNS(n.globals.SVGNS, "title");
                        if (m.textContent = Array.isArray(s) ? s.join(" ") : s,
                        f.node.appendChild(m),
                        0 !== n.config.yaxis[e].labels.rotate) {
                            var b = r.rotateAroundCenter(f.node);
                            f.node.setAttribute("transform", "rotate(".concat(n.config.yaxis[e].labels.rotate, " 0 ").concat(b.y, ")"))
                        }
                        a += t
                    }, v = 0; v <= c.length - 1; v++)
                        p(v);
                if (void 0 !== n.config.yaxis[0].title.text) {
                    var g = r.group({
                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                        transform: "translate(" + o + ", 0)"
                    })
                      , f = r.drawText({
                        x: n.config.yaxis[0].title.offsetX,
                        y: n.globals.gridHeight / 2 + n.config.yaxis[0].title.offsetY,
                        text: n.config.yaxis[0].title.text,
                        textAnchor: "middle",
                        foreColor: n.config.yaxis[0].title.style.color,
                        fontSize: n.config.yaxis[0].title.style.fontSize,
                        fontWeight: n.config.yaxis[0].title.style.fontWeight,
                        fontFamily: n.config.yaxis[0].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + n.config.yaxis[0].title.style.cssClass
                    });
                    g.add(f),
                    s.add(g)
                }
                var m = 0;
                this.isCategoryBarHorizontal && n.config.yaxis[0].opposite && (m = n.globals.gridWidth);
                var b = n.config.xaxis.axisBorder;
                if (b.show) {
                    var x = r.drawLine(n.globals.padHorizontal + b.offsetX + m, 1 + b.offsetY, n.globals.padHorizontal + b.offsetX + m, n.globals.gridHeight + b.offsetY, b.color, 0);
                    this.elgrid && this.elgrid.elGridBorders && n.config.grid.show ? this.elgrid.elGridBorders.add(x) : s.add(x)
                }
                return n.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(m, c.length, n.config.yaxis[0].axisBorder, n.config.yaxis[0].axisTicks, 0, t, s),
                s
            }
        }, {
            key: "drawXaxisTicks",
            value: function(e, t, a) {
                var i = this.w
                  , n = e;
                if (!(e < 0 || e - 2 > i.globals.gridWidth)) {
                    var r = this.offY + i.config.xaxis.axisTicks.offsetY;
                    if (t = t + r + i.config.xaxis.axisTicks.height,
                    "top" === i.config.xaxis.position && (t = r - i.config.xaxis.axisTicks.height),
                    i.config.xaxis.axisTicks.show) {
                        var o = new w(this.ctx).drawLine(e + i.config.xaxis.axisTicks.offsetX, r + i.config.xaxis.offsetY, n + i.config.xaxis.axisTicks.offsetX, t + i.config.xaxis.offsetY, i.config.xaxis.axisTicks.color);
                        a.add(o),
                        o.node.classList.add("apexcharts-xaxis-tick")
                    }
                }
            }
        }, {
            key: "getXAxisTicksPositions",
            value: function() {
                var e = this.w
                  , t = []
                  , a = this.xaxisLabels.length
                  , i = e.globals.padHorizontal;
                if (e.globals.timescaleLabels.length > 0)
                    for (var n = 0; n < a; n++)
                        i = this.xaxisLabels[n].position,
                        t.push(i);
                else
                    for (var r = a, o = 0; o < r; o++) {
                        var s = r;
                        e.globals.isXNumeric && "bar" !== e.config.chart.type && (s -= 1),
                        i += e.globals.gridWidth / s,
                        t.push(i)
                    }
                return t
            }
        }, {
            key: "xAxisLabelCorrections",
            value: function() {
                var e = this.w
                  , t = new w(this.ctx)
                  , a = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g")
                  , i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)")
                  , n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text")
                  , r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                if (e.globals.rotateXLabels || e.config.xaxis.labels.rotateAlways)
                    for (var o = 0; o < i.length; o++) {
                        var s = t.rotateAroundCenter(i[o]);
                        s.y = s.y - 1,
                        s.x = s.x + 1,
                        i[o].setAttribute("transform", "rotate(".concat(e.config.xaxis.labels.rotate, " ").concat(s.x, " ").concat(s.y, ")")),
                        i[o].setAttribute("text-anchor", "end"),
                        a.setAttribute("transform", "translate(0, ".concat(-10, ")"));
                        var l = i[o].childNodes;
                        e.config.xaxis.labels.trim && Array.prototype.forEach.call(l, (function(a) {
                            t.placeTextWithEllipsis(a, a.textContent, e.globals.xAxisLabelsHeight - ("bottom" === e.config.legend.position ? 20 : 10))
                        }
                        ))
                    }
                else
                    !function() {
                        for (var a = e.globals.gridWidth / (e.globals.labels.length + 1), n = 0; n < i.length; n++) {
                            var r = i[n].childNodes;
                            e.config.xaxis.labels.trim && "datetime" !== e.config.xaxis.type && Array.prototype.forEach.call(r, (function(e) {
                                t.placeTextWithEllipsis(e, e.textContent, a)
                            }
                            ))
                        }
                    }();
                if (n.length > 0) {
                    var c = n[n.length - 1].getBBox()
                      , u = n[0].getBBox();
                    c.x < -20 && n[n.length - 1].parentNode.removeChild(n[n.length - 1]),
                    u.x + u.width > e.globals.gridWidth && !e.globals.isBarHorizontal && n[0].parentNode.removeChild(n[0]);
                    for (var d = 0; d < r.length; d++)
                        t.placeTextWithEllipsis(r[d], r[d].textContent, e.config.yaxis[0].labels.maxWidth - (e.config.yaxis[0].title.text ? 2 * parseFloat(e.config.yaxis[0].title.style.fontSize) : 0) - 15)
                }
            }
        }]),
        e
    }()
      , $ = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w;
            var a = this.w;
            this.xaxisLabels = a.globals.labels.slice(),
            this.axesUtils = new W(t),
            this.isRangeBar = a.globals.seriesRange.length && a.globals.isBarHorizontal,
            a.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a.globals.timescaleLabels.slice())
        }
        return s(e, [{
            key: "drawGridArea",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , t = this.w
                  , a = new w(this.ctx);
                null === e && (e = a.group({
                    class: "apexcharts-grid"
                }));
                var i = a.drawLine(t.globals.padHorizontal, 1, t.globals.padHorizontal, t.globals.gridHeight, "transparent")
                  , n = a.drawLine(t.globals.padHorizontal, t.globals.gridHeight, t.globals.gridWidth, t.globals.gridHeight, "transparent");
                return e.add(n),
                e.add(i),
                e
            }
        }, {
            key: "drawGrid",
            value: function() {
                var e = null;
                return this.w.globals.axisCharts && (e = this.renderGrid(),
                this.drawGridArea(e.el)),
                e
            }
        }, {
            key: "createGridMask",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , a = new w(this.ctx)
                  , i = Array.isArray(e.config.stroke.width) ? 0 : e.config.stroke.width;
                if (Array.isArray(e.config.stroke.width)) {
                    var n = 0;
                    e.config.stroke.width.forEach((function(e) {
                        n = Math.max(n, e)
                    }
                    )),
                    i = n
                }
                t.dom.elGridRectMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(t.cuid)),
                t.dom.elGridRectMarkerMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(t.cuid)),
                t.dom.elForecastMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elForecastMask.setAttribute("id", "forecastMask".concat(t.cuid)),
                t.dom.elNonForecastMask = document.createElementNS(t.SVGNS, "clipPath"),
                t.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(t.cuid));
                var r = e.config.chart.type
                  , o = 0
                  , s = 0;
                ("bar" === r || "rangeBar" === r || "candlestick" === r || "boxPlot" === r || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && (o = e.config.grid.padding.left,
                s = e.config.grid.padding.right,
                t.barPadForNumericAxis > o && (o = t.barPadForNumericAxis,
                s = t.barPadForNumericAxis)),
                t.dom.elGridRect = a.drawRect(-i - o - 2, 2 * -i - 2, t.gridWidth + i + s + o + 4, t.gridHeight + 4 * i + 4, 0, "#fff");
                var l = e.globals.markers.largestSize + 1;
                t.dom.elGridRectMarker = a.drawRect(2 * -l, 2 * -l, t.gridWidth + 4 * l, t.gridHeight + 4 * l, 0, "#fff"),
                t.dom.elGridRectMask.appendChild(t.dom.elGridRect.node),
                t.dom.elGridRectMarkerMask.appendChild(t.dom.elGridRectMarker.node);
                var c = t.dom.baseEl.querySelector("defs");
                c.appendChild(t.dom.elGridRectMask),
                c.appendChild(t.dom.elForecastMask),
                c.appendChild(t.dom.elNonForecastMask),
                c.appendChild(t.dom.elGridRectMarkerMask)
            }
        }, {
            key: "_drawGridLines",
            value: function(e) {
                var t = e.i
                  , a = e.x1
                  , i = e.y1
                  , n = e.x2
                  , r = e.y2
                  , o = e.xCount
                  , s = e.parent
                  , l = this.w;
                if (!(0 === t && l.globals.skipFirstTimelinelabel || t === o - 1 && l.globals.skipLastTimelinelabel && !l.config.xaxis.labels.formatter || "radar" === l.config.chart.type)) {
                    l.config.grid.xaxis.lines.show && this._drawGridLine({
                        i: t,
                        x1: a,
                        y1: i,
                        x2: n,
                        y2: r,
                        xCount: o,
                        parent: s
                    });
                    var c = 0;
                    if (l.globals.hasXaxisGroups && "between" === l.config.xaxis.tickPlacement) {
                        var u = l.globals.groups;
                        if (u) {
                            for (var d = 0, h = 0; d < t && h < u.length; h++)
                                d += u[h].cols;
                            d === t && (c = .6 * l.globals.xAxisLabelsHeight)
                        }
                    }
                    new j(this.ctx).drawXaxisTicks(a, c, l.globals.dom.elGraphical)
                }
            }
        }, {
            key: "_drawGridLine",
            value: function(e) {
                var t = e.i
                  , a = e.x1
                  , i = e.y1
                  , n = e.x2
                  , r = e.y2
                  , o = e.xCount
                  , s = e.parent
                  , l = this.w
                  , c = !1
                  , u = s.node.classList.contains("apexcharts-gridlines-horizontal")
                  , d = l.config.grid.strokeDashArray
                  , h = l.globals.barPadForNumericAxis;
                (0 === i && 0 === r || 0 === a && 0 === n) && (c = !0),
                i === l.globals.gridHeight && r === l.globals.gridHeight && (c = !0),
                !l.globals.isBarHorizontal || 0 !== t && t !== o - 1 || (c = !0);
                var p = new w(this).drawLine(a - (u ? h : 0), i, n + (u ? h : 0), r, l.config.grid.borderColor, d);
                p.node.classList.add("apexcharts-gridline"),
                c && l.config.grid.show ? this.elGridBorders.add(p) : s.add(p)
            }
        }, {
            key: "_drawGridBandRect",
            value: function(e) {
                var t = e.c
                  , a = e.x1
                  , i = e.y1
                  , n = e.x2
                  , r = e.y2
                  , o = e.type
                  , s = this.w
                  , l = new w(this.ctx)
                  , c = s.globals.barPadForNumericAxis;
                if ("column" !== o || "datetime" !== s.config.xaxis.type) {
                    var u = s.config.grid[o].colors[t]
                      , d = l.drawRect(a - ("row" === o ? c : 0), i, n + ("row" === o ? 2 * c : 0), r, 0, u, s.config.grid[o].opacity);
                    this.elg.add(d),
                    d.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")),
                    d.node.classList.add("apexcharts-grid-".concat(o))
                }
            }
        }, {
            key: "_drawXYLines",
            value: function(e) {
                var t = this
                  , a = e.xCount
                  , i = e.tickAmount
                  , n = this.w;
                if (n.config.grid.xaxis.lines.show || n.config.xaxis.axisTicks.show) {
                    var r, o = n.globals.padHorizontal, s = n.globals.gridHeight;
                    n.globals.timescaleLabels.length ? function(e) {
                        for (var i = e.xC, n = e.x1, r = e.y1, o = e.x2, s = e.y2, l = 0; l < i; l++)
                            n = t.xaxisLabels[l].position,
                            o = t.xaxisLabels[l].position,
                            t._drawGridLines({
                                i: l,
                                x1: n,
                                y1: r,
                                x2: o,
                                y2: s,
                                xCount: a,
                                parent: t.elgridLinesV
                            })
                    }({
                        xC: a,
                        x1: o,
                        y1: 0,
                        x2: r,
                        y2: s
                    }) : (n.globals.isXNumeric && (a = n.globals.xAxisScale.result.length),
                    function(e) {
                        for (var i = e.xC, r = e.x1, o = e.y1, s = e.x2, l = e.y2, c = 0; c < i + (n.globals.isXNumeric ? 0 : 1); c++)
                            0 === c && 1 === i && 1 === n.globals.dataPoints && (s = r = n.globals.gridWidth / 2),
                            t._drawGridLines({
                                i: c,
                                x1: r,
                                y1: o,
                                x2: s,
                                y2: l,
                                xCount: a,
                                parent: t.elgridLinesV
                            }),
                            s = r += n.globals.gridWidth / (n.globals.isXNumeric ? i - 1 : i)
                    }({
                        xC: a,
                        x1: o,
                        y1: 0,
                        x2: r,
                        y2: s
                    }))
                }
                if (n.config.grid.yaxis.lines.show) {
                    var l = 0
                      , c = 0
                      , u = n.globals.gridWidth
                      , d = i + 1;
                    this.isRangeBar && (d = n.globals.labels.length);
                    for (var h = 0; h < d + (this.isRangeBar ? 1 : 0); h++)
                        this._drawGridLine({
                            i: h,
                            xCount: d + (this.isRangeBar ? 1 : 0),
                            x1: 0,
                            y1: l,
                            x2: u,
                            y2: c,
                            parent: this.elgridLinesH
                        }),
                        c = l += n.globals.gridHeight / (this.isRangeBar ? d : i)
                }
            }
        }, {
            key: "_drawInvertedXYLines",
            value: function(e) {
                var t = e.xCount
                  , a = this.w;
                if (a.config.grid.xaxis.lines.show || a.config.xaxis.axisTicks.show)
                    for (var i, n = a.globals.padHorizontal, r = a.globals.gridHeight, o = 0; o < t + 1; o++)
                        a.config.grid.xaxis.lines.show && this._drawGridLine({
                            i: o,
                            xCount: t + 1,
                            x1: n,
                            y1: 0,
                            x2: i,
                            y2: r,
                            parent: this.elgridLinesV
                        }),
                        new j(this.ctx).drawXaxisTicks(n, 0, a.globals.dom.elGraphical),
                        i = n = n + a.globals.gridWidth / t + .3;
                if (a.config.grid.yaxis.lines.show)
                    for (var s = 0, l = 0, c = a.globals.gridWidth, u = 0; u < a.globals.dataPoints + 1; u++)
                        this._drawGridLine({
                            i: u,
                            xCount: a.globals.dataPoints + 1,
                            x1: 0,
                            y1: s,
                            x2: c,
                            y2: l,
                            parent: this.elgridLinesH
                        }),
                        l = s += a.globals.gridHeight / a.globals.dataPoints
            }
        }, {
            key: "renderGrid",
            value: function() {
                var e, t, a, i = this.w, n = new w(this.ctx);
                this.elg = n.group({
                    class: "apexcharts-grid"
                }),
                this.elgridLinesH = n.group({
                    class: "apexcharts-gridlines-horizontal"
                }),
                this.elgridLinesV = n.group({
                    class: "apexcharts-gridlines-vertical"
                }),
                this.elGridBorders = n.group({
                    class: "apexcharts-grid-borders"
                }),
                this.elg.add(this.elgridLinesH),
                this.elg.add(this.elgridLinesV),
                i.config.grid.show || (this.elgridLinesV.hide(),
                this.elgridLinesH.hide(),
                this.elGridBorders.hide());
                for (var r, o = i.globals.yAxisScale.length ? i.globals.yAxisScale[0].result.length - 1 : 5, s = 0; s < i.globals.series.length && (void 0 !== i.globals.yAxisScale[s] && (o = i.globals.yAxisScale[s].result.length - 1),
                !(o > 2)); s++)
                    ;
                !i.globals.isBarHorizontal || this.isRangeBar ? (r = this.xaxisLabels.length,
                this.isRangeBar && (r--,
                o = i.globals.labels.length,
                i.config.xaxis.tickAmount && i.config.xaxis.labels.formatter && (r = i.config.xaxis.tickAmount),
                (null === (e = i.globals.yAxisScale) || void 0 === e || null === (t = e[0]) || void 0 === t || null === (a = t.result) || void 0 === a ? void 0 : a.length) > 0 && "datetime" !== i.config.xaxis.type && (r = i.globals.yAxisScale[0].result.length - 1)),
                this._drawXYLines({
                    xCount: r,
                    tickAmount: o
                })) : (r = o,
                o = i.globals.xTickAmount,
                this._drawInvertedXYLines({
                    xCount: r,
                    tickAmount: o
                }));
                return this.drawGridBands(r, o),
                {
                    el: this.elg,
                    elGridBorders: this.elGridBorders,
                    xAxisTickWidth: i.globals.gridWidth / r
                }
            }
        }, {
            key: "drawGridBands",
            value: function(e, t) {
                var a = this.w;
                if (void 0 !== a.config.grid.row.colors && a.config.grid.row.colors.length > 0)
                    for (var i = 0, n = a.globals.gridHeight / t, r = a.globals.gridWidth, o = 0, s = 0; o < t; o++,
                    s++)
                        s >= a.config.grid.row.colors.length && (s = 0),
                        this._drawGridBandRect({
                            c: s,
                            x1: 0,
                            y1: i,
                            x2: r,
                            y2: n,
                            type: "row"
                        }),
                        i += a.globals.gridHeight / t;
                if (void 0 !== a.config.grid.column.colors && a.config.grid.column.colors.length > 0)
                    for (var l = a.globals.isBarHorizontal || "on" !== a.config.xaxis.tickPlacement || "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric ? e : e - 1, c = a.globals.padHorizontal, u = a.globals.padHorizontal + a.globals.gridWidth / l, d = a.globals.gridHeight, h = 0, p = 0; h < e; h++,
                    p++)
                        p >= a.config.grid.column.colors.length && (p = 0),
                        this._drawGridBandRect({
                            c: p,
                            x1: c,
                            y1: 0,
                            x2: u,
                            y2: d,
                            type: "column"
                        }),
                        c += a.globals.gridWidth / l
            }
        }]),
        e
    }()
      , U = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "niceScale",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , n = arguments.length > 4 ? arguments[4] : void 0
                  , r = this.w
                  , o = Math.abs(t - e);
                if ("dataPoints" === (a = this._adjustTicksForSmallRange(a, i, o)) && (a = r.globals.dataPoints - 1),
                e === Number.MIN_VALUE && 0 === t || !b.isNumber(e) && !b.isNumber(t) || e === Number.MIN_VALUE && t === -Number.MAX_VALUE)
                    return e = 0,
                    t = a,
                    this.linearScale(e, t, a, i, r.config.yaxis[i].stepSize);
                e > t ? t = e + .1 : e === t && (e = 0 === e ? 0 : e - .5,
                t = 0 === t ? 2 : t + .5);
                var s = [];
                o < 1 && n && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[i].type || "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[i].type || r.globals.isRangeData) && (t *= 1.01);
                var l = a + 1;
                l < 2 ? l = 2 : l > 2 && (l -= 2);
                var c = o / l
                  , u = Math.floor(b.log10(c))
                  , d = Math.pow(10, u)
                  , h = Math.round(c / d);
                h < 1 && (h = 1);
                var p = h * d;
                r.config.yaxis[i].stepSize && (p = r.config.yaxis[i].stepSize),
                r.globals.isBarHorizontal && r.config.xaxis.stepSize && "datetime" !== r.config.xaxis.type && (p = r.config.xaxis.stepSize);
                var v = p * Math.floor(e / p)
                  , g = p * Math.ceil(t / p)
                  , f = v;
                if (n && o > 2) {
                    for (; s.push(b.stripNumber(f, 7)),
                    !((f += p) > g); )
                        ;
                    return {
                        result: s,
                        niceMin: s[0],
                        niceMax: s[s.length - 1]
                    }
                }
                var m = e;
                (s = []).push(b.stripNumber(m, 7));
                for (var x = Math.abs(t - e) / a, y = 0; y <= a; y++)
                    m += x,
                    s.push(m);
                return s[s.length - 2] >= t && s.pop(),
                {
                    result: s,
                    niceMin: s[0],
                    niceMax: s[s.length - 1]
                }
            }
        }, {
            key: "linearScale",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 5
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , n = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0
                  , r = Math.abs(t - e);
                "dataPoints" === (a = this._adjustTicksForSmallRange(a, i, r)) && (a = this.w.globals.dataPoints - 1),
                n || (n = r / a),
                a === Number.MAX_VALUE && (a = 5,
                n = 1);
                for (var o = [], s = e; a >= 0; )
                    o.push(s),
                    s += n,
                    a -= 1;
                return {
                    result: o,
                    niceMin: o[0],
                    niceMax: o[o.length - 1]
                }
            }
        }, {
            key: "logarithmicScaleNice",
            value: function(e, t, a) {
                t <= 0 && (t = Math.max(e, a)),
                e <= 0 && (e = Math.min(t, a));
                for (var i = [], n = Math.ceil(Math.log(t) / Math.log(a) + 1), r = Math.floor(Math.log(e) / Math.log(a)); r < n; r++)
                    i.push(Math.pow(a, r));
                return {
                    result: i,
                    niceMin: i[0],
                    niceMax: i[i.length - 1]
                }
            }
        }, {
            key: "logarithmicScale",
            value: function(e, t, a) {
                t <= 0 && (t = Math.max(e, a)),
                e <= 0 && (e = Math.min(t, a));
                for (var i = [], n = Math.log(t) / Math.log(a), r = Math.log(e) / Math.log(a), o = n - r, s = Math.round(o), l = o / s, c = 0, u = r; c < s; c++,
                u += l)
                    i.push(Math.pow(a, u));
                return i.push(Math.pow(a, n)),
                {
                    result: i,
                    niceMin: e,
                    niceMax: t
                }
            }
        }, {
            key: "_adjustTicksForSmallRange",
            value: function(e, t, a) {
                var i = e;
                if (void 0 !== t && this.w.config.yaxis[t].labels.formatter && void 0 === this.w.config.yaxis[t].tickAmount) {
                    var n = Number(this.w.config.yaxis[t].labels.formatter(1));
                    b.isNumber(n) && 0 === this.w.globals.yValueDecimal && (i = Math.ceil(a))
                }
                return i < e ? i : e
            }
        }, {
            key: "setYScaleForIndex",
            value: function(e, t, a) {
                var i = this.w.globals
                  , n = this.w.config
                  , r = i.isBarHorizontal ? n.xaxis : n.yaxis[e];
                void 0 === i.yAxisScale[e] && (i.yAxisScale[e] = []);
                var o = Math.abs(a - t);
                if (r.logarithmic && o <= 5 && (i.invalidLogScale = !0),
                r.logarithmic && o > 5)
                    i.allSeriesCollapsed = !1,
                    i.yAxisScale[e] = this.logarithmicScale(t, a, r.logBase),
                    i.yAxisScale[e] = r.forceNiceScale ? this.logarithmicScaleNice(t, a, r.logBase) : this.logarithmicScale(t, a, r.logBase);
                else if (a !== -Number.MAX_VALUE && b.isNumber(a))
                    if (i.allSeriesCollapsed = !1,
                    void 0 === r.min && void 0 === r.max || r.forceNiceScale) {
                        var s = void 0 === n.yaxis[e].max && void 0 === n.yaxis[e].min || n.yaxis[e].forceNiceScale;
                        i.yAxisScale[e] = this.niceScale(t, a, r.tickAmount ? r.tickAmount : o < 5 && o > 1 ? o + 1 : 5, e, s)
                    } else
                        i.yAxisScale[e] = this.linearScale(t, a, r.tickAmount, e, n.yaxis[e].stepSize);
                else
                    i.yAxisScale[e] = this.linearScale(0, 5, 5, e, n.yaxis[e].stepSize)
            }
        }, {
            key: "setXScale",
            value: function(e, t) {
                var a = this.w
                  , i = a.globals
                  , n = Math.abs(t - e);
                return t !== -Number.MAX_VALUE && b.isNumber(t) ? i.xAxisScale = this.linearScale(e, t, a.config.xaxis.tickAmount ? a.config.xaxis.tickAmount : n < 5 && n > 1 ? n + 1 : 5, 0, a.config.xaxis.stepSize) : i.xAxisScale = this.linearScale(0, 5, 5),
                i.xAxisScale
            }
        }, {
            key: "setMultipleYScales",
            value: function() {
                var e = this
                  , t = this.w.globals
                  , a = this.w.config
                  , i = t.minYArr.concat([])
                  , n = t.maxYArr.concat([])
                  , r = [];
                a.yaxis.forEach((function(t, o) {
                    var s = o;
                    a.series.forEach((function(e, a) {
                        e.name === t.seriesName && (s = a,
                        o !== a ? r.push({
                            index: a,
                            similarIndex: o,
                            alreadyExists: !0
                        }) : r.push({
                            index: a
                        }))
                    }
                    ));
                    var l = i[s]
                      , c = n[s];
                    e.setYScaleForIndex(o, l, c)
                }
                )),
                this.sameScaleInMultipleAxes(i, n, r)
            }
        }, {
            key: "sameScaleInMultipleAxes",
            value: function(e, t, a) {
                var i = this
                  , n = this.w.config
                  , r = this.w.globals
                  , o = [];
                a.forEach((function(e) {
                    e.alreadyExists && (void 0 === o[e.index] && (o[e.index] = []),
                    o[e.index].push(e.index),
                    o[e.index].push(e.similarIndex))
                }
                )),
                r.yAxisSameScaleIndices = o,
                o.forEach((function(e, t) {
                    o.forEach((function(a, i) {
                        var n, r;
                        t !== i && (n = e,
                        r = a,
                        n.filter((function(e) {
                            return -1 !== r.indexOf(e)
                        }
                        ))).length > 0 && (o[t] = o[t].concat(o[i]))
                    }
                    ))
                }
                ));
                var s = o.map((function(e) {
                    return e.filter((function(t, a) {
                        return e.indexOf(t) === a
                    }
                    ))
                }
                )).map((function(e) {
                    return e.sort()
                }
                ));
                o = o.filter((function(e) {
                    return !!e
                }
                ));
                var l = s.slice()
                  , c = l.map((function(e) {
                    return JSON.stringify(e)
                }
                ));
                l = l.filter((function(e, t) {
                    return c.indexOf(JSON.stringify(e)) === t
                }
                ));
                var u = []
                  , d = [];
                e.forEach((function(e, a) {
                    l.forEach((function(i, n) {
                        i.indexOf(a) > -1 && (void 0 === u[n] && (u[n] = [],
                        d[n] = []),
                        u[n].push({
                            key: a,
                            value: e
                        }),
                        d[n].push({
                            key: a,
                            value: t[a]
                        }))
                    }
                    ))
                }
                ));
                var h = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE)
                  , p = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                u.forEach((function(e, t) {
                    e.forEach((function(e, a) {
                        h[t] = Math.min(e.value, h[t])
                    }
                    ))
                }
                )),
                d.forEach((function(e, t) {
                    e.forEach((function(e, a) {
                        p[t] = Math.max(e.value, p[t])
                    }
                    ))
                }
                )),
                e.forEach((function(e, t) {
                    d.forEach((function(e, a) {
                        var o = h[a]
                          , s = p[a];
                        n.chart.stacked && (s = 0,
                        e.forEach((function(e, t) {
                            e.value !== -Number.MAX_VALUE && (s += e.value),
                            o !== Number.MIN_VALUE && (o += u[a][t].value)
                        }
                        ))),
                        e.forEach((function(a, l) {
                            e[l].key === t && (void 0 !== n.yaxis[t].min && (o = "function" == typeof n.yaxis[t].min ? n.yaxis[t].min(r.minY) : n.yaxis[t].min),
                            void 0 !== n.yaxis[t].max && (s = "function" == typeof n.yaxis[t].max ? n.yaxis[t].max(r.maxY) : n.yaxis[t].max),
                            i.setYScaleForIndex(t, o, s))
                        }
                        ))
                    }
                    ))
                }
                ))
            }
        }, {
            key: "autoScaleY",
            value: function(e, t, a) {
                e || (e = this);
                var i = e.w;
                if (i.globals.isMultipleYAxis || i.globals.collapsedSeries.length)
                    return t;
                var n = i.globals.seriesX[0]
                  , r = i.config.chart.stacked;
                return t.forEach((function(e, o) {
                    for (var s = 0, l = 0; l < n.length; l++)
                        if (n[l] >= a.xaxis.min) {
                            s = l;
                            break
                        }
                    var c, u, d = i.globals.minYArr[o], h = i.globals.maxYArr[o], p = i.globals.stackedSeriesTotals;
                    i.globals.series.forEach((function(o, l) {
                        var v = o[s];
                        r ? (v = p[s],
                        c = u = v,
                        p.forEach((function(e, t) {
                            n[t] <= a.xaxis.max && n[t] >= a.xaxis.min && (e > u && null !== e && (u = e),
                            o[t] < c && null !== o[t] && (c = o[t]))
                        }
                        ))) : (c = u = v,
                        o.forEach((function(e, t) {
                            if (n[t] <= a.xaxis.max && n[t] >= a.xaxis.min) {
                                var r = e
                                  , o = e;
                                i.globals.series.forEach((function(a, i) {
                                    null !== e && (r = Math.min(a[t], r),
                                    o = Math.max(a[t], o))
                                }
                                )),
                                o > u && null !== o && (u = o),
                                r < c && null !== r && (c = r)
                            }
                        }
                        ))),
                        void 0 === c && void 0 === u && (c = d,
                        u = h),
                        u *= u < 0 ? .9 : 1.1,
                        0 == (c *= c < 0 ? 1.1 : .9) && 0 === u && (c = -1,
                        u = 1),
                        u < 0 && u < h && (u = h),
                        c < 0 && c > d && (c = d),
                        t.length > 1 ? (t[l].min = void 0 === e.min ? c : e.min,
                        t[l].max = void 0 === e.max ? u : e.max) : (t[0].min = void 0 === e.min ? c : e.min,
                        t[0].max = void 0 === e.max ? u : e.max)
                    }
                    ))
                }
                )),
                t
            }
        }]),
        e
    }()
      , q = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.scales = new U(t)
        }
        return s(e, [{
            key: "init",
            value: function() {
                this.setYRange(),
                this.setXRange(),
                this.setZRange()
            }
        }, {
            key: "getMinYMaxY",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE
                  , a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , n = this.w.config
                  , r = this.w.globals
                  , o = -Number.MAX_VALUE
                  , s = Number.MIN_VALUE;
                null === i && (i = e + 1);
                var l = r.series
                  , c = l
                  , u = l;
                "candlestick" === n.chart.type ? (c = r.seriesCandleL,
                u = r.seriesCandleH) : "boxPlot" === n.chart.type ? (c = r.seriesCandleO,
                u = r.seriesCandleC) : r.isRangeData && (c = r.seriesRangeStart,
                u = r.seriesRangeEnd);
                for (var d = e; d < i; d++) {
                    r.dataPoints = Math.max(r.dataPoints, l[d].length),
                    r.categoryLabels.length && (r.dataPoints = r.categoryLabels.filter((function(e) {
                        return void 0 !== e
                    }
                    )).length),
                    r.labels.length && "datetime" !== n.xaxis.type && 0 !== r.series.reduce((function(e, t) {
                        return e + t.length
                    }
                    ), 0) && (r.dataPoints = Math.max(r.dataPoints, r.labels.length));
                    for (var h = 0; h < r.series[d].length; h++) {
                        var p = l[d][h];
                        null !== p && b.isNumber(p) ? (void 0 !== u[d][h] && (o = Math.max(o, u[d][h]),
                        t = Math.min(t, u[d][h])),
                        void 0 !== c[d][h] && (t = Math.min(t, c[d][h]),
                        a = Math.max(a, c[d][h])),
                        "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type && "rangeArea" === this.w.config.chart.type && "rangeBar" === this.w.config.chart.type || ("candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || void 0 !== r.seriesCandleC[d][h] && (o = Math.max(o, r.seriesCandleO[d][h]),
                        o = Math.max(o, r.seriesCandleH[d][h]),
                        o = Math.max(o, r.seriesCandleL[d][h]),
                        o = Math.max(o, r.seriesCandleC[d][h]),
                        "boxPlot" === this.w.config.chart.type && (o = Math.max(o, r.seriesCandleM[d][h]))),
                        !n.series[d].type || "candlestick" === n.series[d].type && "boxPlot" === n.series[d].type && "rangeArea" === n.series[d].type && "rangeBar" === n.series[d].type || (o = Math.max(o, r.series[d][h]),
                        t = Math.min(t, r.series[d][h])),
                        a = o),
                        r.seriesGoals[d] && r.seriesGoals[d][h] && Array.isArray(r.seriesGoals[d][h]) && r.seriesGoals[d][h].forEach((function(e) {
                            s !== Number.MIN_VALUE && (s = Math.min(s, e.value),
                            t = s),
                            o = Math.max(o, e.value),
                            a = o
                        }
                        )),
                        b.isFloat(p) && (p = b.noExponents(p),
                        r.yValueDecimal = Math.max(r.yValueDecimal, p.toString().split(".")[1].length)),
                        s > c[d][h] && c[d][h] < 0 && (s = c[d][h])) : r.hasNullValues = !0
                    }
                }
                return "rangeBar" === n.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && (s = t),
                "bar" === n.chart.type && (s < 0 && o < 0 && (o = 0),
                s === Number.MIN_VALUE && (s = 0)),
                {
                    minY: s,
                    maxY: o,
                    lowestY: t,
                    highestY: a
                }
            }
        }, {
            key: "setYRange",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                e.maxY = -Number.MAX_VALUE,
                e.minY = Number.MIN_VALUE;
                var a = Number.MAX_VALUE;
                if (e.isMultipleYAxis)
                    for (var i = 0; i < e.series.length; i++) {
                        var n = this.getMinYMaxY(i, a, null, i + 1);
                        e.minYArr.push(n.minY),
                        e.maxYArr.push(n.maxY),
                        a = n.lowestY
                    }
                var r = this.getMinYMaxY(0, a, null, e.series.length);
                if (e.minY = r.minY,
                e.maxY = r.maxY,
                a = r.lowestY,
                t.chart.stacked && this._setStackedMinMax(),
                ("line" === t.chart.type || "area" === t.chart.type || "candlestick" === t.chart.type || "boxPlot" === t.chart.type || "rangeBar" === t.chart.type && !e.isBarHorizontal) && e.minY === Number.MIN_VALUE && a !== -Number.MAX_VALUE && a !== e.maxY) {
                    var o = e.maxY - a;
                    (a >= 0 && a <= 10 || void 0 !== t.yaxis[0].min || void 0 !== t.yaxis[0].max) && (o = 0),
                    e.minY = a - 5 * o / 100,
                    a > 0 && e.minY < 0 && (e.minY = 0),
                    e.maxY = e.maxY + 5 * o / 100
                }
                return t.yaxis.forEach((function(t, a) {
                    void 0 !== t.max && ("number" == typeof t.max ? e.maxYArr[a] = t.max : "function" == typeof t.max && (e.maxYArr[a] = t.max(e.isMultipleYAxis ? e.maxYArr[a] : e.maxY)),
                    e.maxY = e.maxYArr[a]),
                    void 0 !== t.min && ("number" == typeof t.min ? e.minYArr[a] = t.min : "function" == typeof t.min && (e.minYArr[a] = t.min(e.isMultipleYAxis ? e.minYArr[a] === Number.MIN_VALUE ? 0 : e.minYArr[a] : e.minY)),
                    e.minY = e.minYArr[a])
                }
                )),
                e.isBarHorizontal && ["min", "max"].forEach((function(a) {
                    void 0 !== t.xaxis[a] && "number" == typeof t.xaxis[a] && ("min" === a ? e.minY = t.xaxis[a] : e.maxY = t.xaxis[a])
                }
                )),
                e.isMultipleYAxis ? (this.scales.setMultipleYScales(),
                e.minY = a,
                e.yAxisScale.forEach((function(t, a) {
                    e.minYArr[a] = t.niceMin,
                    e.maxYArr[a] = t.niceMax
                }
                ))) : (this.scales.setYScaleForIndex(0, e.minY, e.maxY),
                e.minY = e.yAxisScale[0].niceMin,
                e.maxY = e.yAxisScale[0].niceMax,
                e.minYArr[0] = e.yAxisScale[0].niceMin,
                e.maxYArr[0] = e.yAxisScale[0].niceMax),
                {
                    minY: e.minY,
                    maxY: e.maxY,
                    minYArr: e.minYArr,
                    maxYArr: e.maxYArr,
                    yAxisScale: e.yAxisScale
                }
            }
        }, {
            key: "setXRange",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config
                  , a = "numeric" === t.xaxis.type || "datetime" === t.xaxis.type || "category" === t.xaxis.type && !e.noLabelsProvided || e.noLabelsProvided || e.isXNumeric;
                if (e.isXNumeric && function() {
                    for (var t = 0; t < e.series.length; t++)
                        if (e.labels[t])
                            for (var a = 0; a < e.labels[t].length; a++)
                                null !== e.labels[t][a] && b.isNumber(e.labels[t][a]) && (e.maxX = Math.max(e.maxX, e.labels[t][a]),
                                e.initialMaxX = Math.max(e.maxX, e.labels[t][a]),
                                e.minX = Math.min(e.minX, e.labels[t][a]),
                                e.initialMinX = Math.min(e.minX, e.labels[t][a]))
                }(),
                e.noLabelsProvided && 0 === t.xaxis.categories.length && (e.maxX = e.labels[e.labels.length - 1],
                e.initialMaxX = e.labels[e.labels.length - 1],
                e.minX = 1,
                e.initialMinX = 1),
                e.isXNumeric || e.noLabelsProvided || e.dataFormatXNumeric) {
                    var i;
                    if (void 0 === t.xaxis.tickAmount ? (i = Math.round(e.svgWidth / 150),
                    "numeric" === t.xaxis.type && e.dataPoints < 30 && (i = e.dataPoints - 1),
                    i > e.dataPoints && 0 !== e.dataPoints && (i = e.dataPoints - 1)) : "dataPoints" === t.xaxis.tickAmount ? (e.series.length > 1 && (i = e.series[e.maxValsInArrayIndex].length - 1),
                    e.isXNumeric && (i = e.maxX - e.minX - 1)) : i = t.xaxis.tickAmount,
                    e.xTickAmount = i,
                    void 0 !== t.xaxis.max && "number" == typeof t.xaxis.max && (e.maxX = t.xaxis.max),
                    void 0 !== t.xaxis.min && "number" == typeof t.xaxis.min && (e.minX = t.xaxis.min),
                    void 0 !== t.xaxis.range && (e.minX = e.maxX - t.xaxis.range),
                    e.minX !== Number.MAX_VALUE && e.maxX !== -Number.MAX_VALUE)
                        if (t.xaxis.convertedCatToNumeric && !e.dataFormatXNumeric) {
                            for (var n = [], r = e.minX - 1; r < e.maxX; r++)
                                n.push(r + 1);
                            e.xAxisScale = {
                                result: n,
                                niceMin: n[0],
                                niceMax: n[n.length - 1]
                            }
                        } else
                            e.xAxisScale = this.scales.setXScale(e.minX, e.maxX);
                    else
                        e.xAxisScale = this.scales.linearScale(0, i, i, 0, t.xaxis.stepSize),
                        e.noLabelsProvided && e.labels.length > 0 && (e.xAxisScale = this.scales.linearScale(1, e.labels.length, i - 1, 0, t.xaxis.stepSize),
                        e.seriesX = e.labels.slice());
                    a && (e.labels = e.xAxisScale.result.slice())
                }
                return e.isBarHorizontal && e.labels.length && (e.xTickAmount = e.labels.length),
                this._handleSingleDataPoint(),
                this._getMinXDiff(),
                {
                    minX: e.minX,
                    maxX: e.maxX
                }
            }
        }, {
            key: "setZRange",
            value: function() {
                var e = this.w.globals;
                if (e.isDataXYZ)
                    for (var t = 0; t < e.series.length; t++)
                        if (void 0 !== e.seriesZ[t])
                            for (var a = 0; a < e.seriesZ[t].length; a++)
                                null !== e.seriesZ[t][a] && b.isNumber(e.seriesZ[t][a]) && (e.maxZ = Math.max(e.maxZ, e.seriesZ[t][a]),
                                e.minZ = Math.min(e.minZ, e.seriesZ[t][a]))
            }
        }, {
            key: "_handleSingleDataPoint",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                if (e.minX === e.maxX) {
                    var a = new T(this.ctx);
                    if ("datetime" === t.xaxis.type) {
                        var i = a.getDate(e.minX);
                        t.xaxis.labels.datetimeUTC ? i.setUTCDate(i.getUTCDate() - 2) : i.setDate(i.getDate() - 2),
                        e.minX = new Date(i).getTime();
                        var n = a.getDate(e.maxX);
                        t.xaxis.labels.datetimeUTC ? n.setUTCDate(n.getUTCDate() + 2) : n.setDate(n.getDate() + 2),
                        e.maxX = new Date(n).getTime()
                    } else
                        ("numeric" === t.xaxis.type || "category" === t.xaxis.type && !e.noLabelsProvided) && (e.minX = e.minX - 2,
                        e.initialMinX = e.minX,
                        e.maxX = e.maxX + 2,
                        e.initialMaxX = e.maxX)
                }
            }
        }, {
            key: "_getMinXDiff",
            value: function() {
                var e = this.w.globals;
                e.isXNumeric && e.seriesX.forEach((function(t, a) {
                    1 === t.length && t.push(e.seriesX[e.maxValsInArrayIndex][e.seriesX[e.maxValsInArrayIndex].length - 1]);
                    var i = t.slice();
                    i.sort((function(e, t) {
                        return e - t
                    }
                    )),
                    i.forEach((function(t, a) {
                        if (a > 0) {
                            var n = t - i[a - 1];
                            n > 0 && (e.minXDiff = Math.min(n, e.minXDiff))
                        }
                    }
                    )),
                    1 !== e.dataPoints && e.minXDiff !== Number.MAX_VALUE || (e.minXDiff = .5)
                }
                ))
            }
        }, {
            key: "_setStackedMinMax",
            value: function() {
                var e = this
                  , t = this.w.globals;
                if (t.series.length) {
                    var a = t.seriesGroups;
                    a.length || (a = [this.w.config.series.map((function(e) {
                        return e.name
                    }
                    ))]);
                    var i = {}
                      , n = {};
                    a.forEach((function(a) {
                        i[a] = [],
                        n[a] = [],
                        e.w.config.series.map((function(e, t) {
                            return a.indexOf(e.name) > -1 ? t : null
                        }
                        )).filter((function(e) {
                            return null !== e
                        }
                        )).forEach((function(r) {
                            for (var o = 0; o < t.series[t.maxValsInArrayIndex].length; o++) {
                                var s, l;
                                void 0 === i[a][o] && (i[a][o] = 0,
                                n[a][o] = 0),
                                (e.w.config.chart.stacked && !t.comboCharts || e.w.config.chart.stacked && t.comboCharts && (!e.w.config.chart.stackOnlyBar || "bar" === (null === (s = e.w.config.series) || void 0 === s || null === (l = s[r]) || void 0 === l ? void 0 : l.type))) && null !== t.series[r][o] && b.isNumber(t.series[r][o]) && (t.series[r][o] > 0 ? i[a][o] += parseFloat(t.series[r][o]) + 1e-4 : n[a][o] += parseFloat(t.series[r][o]))
                            }
                        }
                        ))
                    }
                    )),
                    Object.entries(i).forEach((function(e) {
                        var a = v(e, 1)[0];
                        i[a].forEach((function(e, r) {
                            t.maxY = Math.max(t.maxY, i[a][r]),
                            t.minY = Math.min(t.minY, n[a][r])
                        }
                        ))
                    }
                    ))
                }
            }
        }]),
        e
    }()
      , Z = function() {
        function e(t, a) {
            r(this, e),
            this.ctx = t,
            this.elgrid = a,
            this.w = t.w;
            var i = this.w;
            this.xaxisFontSize = i.config.xaxis.labels.style.fontSize,
            this.axisFontFamily = i.config.xaxis.labels.style.fontFamily,
            this.xaxisForeColors = i.config.xaxis.labels.style.colors,
            this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal,
            this.xAxisoffX = 0,
            "bottom" === i.config.xaxis.position && (this.xAxisoffX = i.globals.gridHeight),
            this.drawnLabels = [],
            this.axesUtils = new W(t)
        }
        return s(e, [{
            key: "drawYaxis",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = new w(this.ctx)
                  , n = a.config.yaxis[e].labels.style
                  , r = n.fontSize
                  , o = n.fontFamily
                  , s = n.fontWeight
                  , l = i.group({
                    class: "apexcharts-yaxis",
                    rel: e,
                    transform: "translate(" + a.globals.translateYAxisX[e] + ", 0)"
                });
                if (this.axesUtils.isYAxisHidden(e))
                    return l;
                var c = i.group({
                    class: "apexcharts-yaxis-texts-g"
                });
                l.add(c);
                var u = a.globals.yAxisScale[e].result.length - 1
                  , d = a.globals.gridHeight / u
                  , h = a.globals.translateY
                  , p = a.globals.yLabelFormatters[e]
                  , v = a.globals.yAxisScale[e].result.slice();
                v = this.axesUtils.checkForReversedLabels(e, v);
                var g = "";
                if (a.config.yaxis[e].labels.show)
                    for (var f = function(l) {
                        var f = v[l];
                        f = p(f, l, a);
                        var m = a.config.yaxis[e].labels.padding;
                        a.config.yaxis[e].opposite && 0 !== a.config.yaxis.length && (m *= -1);
                        var b = "end";
                        a.config.yaxis[e].opposite && (b = "start"),
                        "left" === a.config.yaxis[e].labels.align ? b = "start" : "center" === a.config.yaxis[e].labels.align ? b = "middle" : "right" === a.config.yaxis[e].labels.align && (b = "end");
                        var x = t.axesUtils.getYAxisForeColor(n.colors, e)
                          , y = a.config.yaxis[e].labels.offsetY;
                        "heatmap" === a.config.chart.type && (y -= (a.globals.gridHeight / a.globals.series.length - 1) / 2);
                        var w = i.drawText({
                            x: m,
                            y: h + u / 10 + y + 1,
                            text: f,
                            textAnchor: b,
                            fontSize: r,
                            fontFamily: o,
                            fontWeight: s,
                            maxWidth: a.config.yaxis[e].labels.maxWidth,
                            foreColor: Array.isArray(x) ? x[l] : x,
                            isPlainText: !1,
                            cssClass: "apexcharts-yaxis-label " + n.cssClass
                        });
                        l === u && (g = w),
                        c.add(w);
                        var k = document.createElementNS(a.globals.SVGNS, "title");
                        if (k.textContent = Array.isArray(f) ? f.join(" ") : f,
                        w.node.appendChild(k),
                        0 !== a.config.yaxis[e].labels.rotate) {
                            var S = i.rotateAroundCenter(g.node)
                              , C = i.rotateAroundCenter(w.node);
                            w.node.setAttribute("transform", "rotate(".concat(a.config.yaxis[e].labels.rotate, " ").concat(S.x, " ").concat(C.y, ")"))
                        }
                        h += d
                    }, m = u; m >= 0; m--)
                        f(m);
                if (void 0 !== a.config.yaxis[e].title.text) {
                    var b = i.group({
                        class: "apexcharts-yaxis-title"
                    })
                      , x = 0;
                    a.config.yaxis[e].opposite && (x = a.globals.translateYAxisX[e]);
                    var y = i.drawText({
                        x: x,
                        y: a.globals.gridHeight / 2 + a.globals.translateY + a.config.yaxis[e].title.offsetY,
                        text: a.config.yaxis[e].title.text,
                        textAnchor: "end",
                        foreColor: a.config.yaxis[e].title.style.color,
                        fontSize: a.config.yaxis[e].title.style.fontSize,
                        fontWeight: a.config.yaxis[e].title.style.fontWeight,
                        fontFamily: a.config.yaxis[e].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + a.config.yaxis[e].title.style.cssClass
                    });
                    b.add(y),
                    l.add(b)
                }
                var k = a.config.yaxis[e].axisBorder
                  , S = 31 + k.offsetX;
                if (a.config.yaxis[e].opposite && (S = -31 - k.offsetX),
                k.show) {
                    var C = i.drawLine(S, a.globals.translateY + k.offsetY - 2, S, a.globals.gridHeight + a.globals.translateY + k.offsetY + 2, k.color, 0, k.width);
                    l.add(C)
                }
                return a.config.yaxis[e].axisTicks.show && this.axesUtils.drawYAxisTicks(S, u, k, a.config.yaxis[e].axisTicks, e, d, l),
                l
            }
        }, {
            key: "drawYaxisInversed",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx)
                  , i = a.group({
                    class: "apexcharts-xaxis apexcharts-yaxis-inversed"
                })
                  , n = a.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")")
                });
                i.add(n);
                var r = t.globals.yAxisScale[e].result.length - 1
                  , o = t.globals.gridWidth / r + .1
                  , s = o + t.config.xaxis.labels.offsetX
                  , l = t.globals.xLabelFormatter
                  , c = t.globals.yAxisScale[e].result.slice()
                  , u = t.globals.timescaleLabels;
                u.length > 0 && (this.xaxisLabels = u.slice(),
                r = (c = u.slice()).length),
                c = this.axesUtils.checkForReversedLabels(e, c);
                var d = u.length;
                if (t.config.xaxis.labels.show)
                    for (var h = d ? 0 : r; d ? h < d : h >= 0; d ? h++ : h--) {
                        var p = c[h];
                        p = l(p, h, t);
                        var v = t.globals.gridWidth + t.globals.padHorizontal - (s - o + t.config.xaxis.labels.offsetX);
                        if (u.length) {
                            var g = this.axesUtils.getLabel(c, u, v, h, this.drawnLabels, this.xaxisFontSize);
                            v = g.x,
                            p = g.text,
                            this.drawnLabels.push(g.text),
                            0 === h && t.globals.skipFirstTimelinelabel && (p = ""),
                            h === c.length - 1 && t.globals.skipLastTimelinelabel && (p = "")
                        }
                        var f = a.drawText({
                            x: v,
                            y: this.xAxisoffX + t.config.xaxis.labels.offsetY + 30 - ("top" === t.config.xaxis.position ? t.globals.xAxisHeight + t.config.xaxis.axisTicks.height - 2 : 0),
                            text: p,
                            textAnchor: "middle",
                            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[e] : this.xaxisForeColors,
                            fontSize: this.xaxisFontSize,
                            fontFamily: this.xaxisFontFamily,
                            fontWeight: t.config.xaxis.labels.style.fontWeight,
                            isPlainText: !1,
                            cssClass: "apexcharts-xaxis-label " + t.config.xaxis.labels.style.cssClass
                        });
                        n.add(f),
                        f.tspan(p);
                        var m = document.createElementNS(t.globals.SVGNS, "title");
                        m.textContent = p,
                        f.node.appendChild(m),
                        s += o
                    }
                return this.inversedYAxisTitleText(i),
                this.inversedYAxisBorder(i),
                i
            }
        }, {
            key: "inversedYAxisBorder",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx)
                  , i = t.config.xaxis.axisBorder;
                if (i.show) {
                    var n = 0;
                    "bar" === t.config.chart.type && t.globals.isXNumeric && (n -= 15);
                    var r = a.drawLine(t.globals.padHorizontal + n + i.offsetX, this.xAxisoffX, t.globals.gridWidth, this.xAxisoffX, i.color, 0, i.height);
                    this.elgrid && this.elgrid.elGridBorders && t.config.grid.show ? this.elgrid.elGridBorders.add(r) : e.add(r)
                }
            }
        }, {
            key: "inversedYAxisTitleText",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx);
                if (void 0 !== t.config.xaxis.title.text) {
                    var i = a.group({
                        class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
                    })
                      , n = a.drawText({
                        x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX,
                        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(t.config.xaxis.title.style.fontSize) + t.config.xaxis.title.offsetY + 20,
                        text: t.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: t.config.xaxis.title.style.fontSize,
                        fontFamily: t.config.xaxis.title.style.fontFamily,
                        fontWeight: t.config.xaxis.title.style.fontWeight,
                        foreColor: t.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass
                    });
                    i.add(n),
                    e.add(i)
                }
            }
        }, {
            key: "yAxisTitleRotate",
            value: function(e, t) {
                var a = this.w
                  , i = new w(this.ctx)
                  , n = {
                    width: 0,
                    height: 0
                }
                  , r = {
                    width: 0,
                    height: 0
                }
                  , o = a.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-texts-g"));
                null !== o && (n = o.getBoundingClientRect());
                var s = a.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(e, "'] .apexcharts-yaxis-title text"));
                if (null !== s && (r = s.getBoundingClientRect()),
                null !== s) {
                    var l = this.xPaddingForYAxisTitle(e, n, r, t);
                    s.setAttribute("x", l.xPos - (t ? 10 : 0))
                }
                if (null !== s) {
                    var c = i.rotateAroundCenter(s);
                    s.setAttribute("transform", "rotate(".concat(t ? -1 * a.config.yaxis[e].title.rotate : a.config.yaxis[e].title.rotate, " ").concat(c.x, " ").concat(c.y, ")"))
                }
            }
        }, {
            key: "xPaddingForYAxisTitle",
            value: function(e, t, a, i) {
                var n = this.w
                  , r = 0
                  , o = 0
                  , s = 10;
                return void 0 === n.config.yaxis[e].title.text || e < 0 ? {
                    xPos: o,
                    padd: 0
                } : (i ? (o = t.width + n.config.yaxis[e].title.offsetX + a.width / 2 + s / 2,
                0 === (r += 1) && (o -= s / 2)) : (o = -1 * t.width + n.config.yaxis[e].title.offsetX + s / 2 + a.width / 2,
                n.globals.isBarHorizontal && (s = 25,
                o = -1 * t.width - n.config.yaxis[e].title.offsetX - s)),
                {
                    xPos: o,
                    padd: s
                })
            }
        }, {
            key: "setYAxisXPosition",
            value: function(e, t) {
                var a = this.w
                  , i = 0
                  , n = 0
                  , r = 18
                  , o = 1;
                a.config.yaxis.length > 1 && (this.multipleYs = !0),
                a.config.yaxis.map((function(s, l) {
                    var c = a.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !s.show || s.floating || 0 === e[l].width
                      , u = e[l].width + t[l].width;
                    s.opposite ? a.globals.isBarHorizontal ? (n = a.globals.gridWidth + a.globals.translateX - 1,
                    a.globals.translateYAxisX[l] = n - s.labels.offsetX) : (n = a.globals.gridWidth + a.globals.translateX + o,
                    c || (o = o + u + 20),
                    a.globals.translateYAxisX[l] = n - s.labels.offsetX + 20) : (i = a.globals.translateX - r,
                    c || (r = r + u + 20),
                    a.globals.translateYAxisX[l] = i + s.labels.offsetX)
                }
                ))
            }
        }, {
            key: "setYAxisTextAlignments",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                (t = b.listToArray(t)).forEach((function(t, a) {
                    var i = e.config.yaxis[a];
                    if (i && !i.floating && void 0 !== i.labels.align) {
                        var n = e.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(a, "'] .apexcharts-yaxis-texts-g"))
                          , r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(a, "'] .apexcharts-yaxis-label"));
                        r = b.listToArray(r);
                        var o = n.getBoundingClientRect();
                        "left" === i.labels.align ? (r.forEach((function(e, t) {
                            e.setAttribute("text-anchor", "start")
                        }
                        )),
                        i.opposite || n.setAttribute("transform", "translate(-".concat(o.width, ", 0)"))) : "center" === i.labels.align ? (r.forEach((function(e, t) {
                            e.setAttribute("text-anchor", "middle")
                        }
                        )),
                        n.setAttribute("transform", "translate(".concat(o.width / 2 * (i.opposite ? 1 : -1), ", 0)"))) : "right" === i.labels.align && (r.forEach((function(e, t) {
                            e.setAttribute("text-anchor", "end")
                        }
                        )),
                        i.opposite && n.setAttribute("transform", "translate(".concat(o.width, ", 0)")))
                    }
                }
                ))
            }
        }]),
        e
    }()
      , K = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.documentEvent = b.bind(this.documentEvent, this)
        }
        return s(e, [{
            key: "addEventListener",
            value: function(e, t) {
                var a = this.w;
                a.globals.events.hasOwnProperty(e) ? a.globals.events[e].push(t) : a.globals.events[e] = [t]
            }
        }, {
            key: "removeEventListener",
            value: function(e, t) {
                var a = this.w;
                if (a.globals.events.hasOwnProperty(e)) {
                    var i = a.globals.events[e].indexOf(t);
                    -1 !== i && a.globals.events[e].splice(i, 1)
                }
            }
        }, {
            key: "fireEvent",
            value: function(e, t) {
                var a = this.w;
                if (a.globals.events.hasOwnProperty(e)) {
                    t && t.length || (t = []);
                    for (var i = a.globals.events[e], n = i.length, r = 0; r < n; r++)
                        i[r].apply(null, t)
                }
            }
        }, {
            key: "setupEventHandlers",
            value: function() {
                var e = this
                  , t = this.w
                  , a = this.ctx
                  , i = t.globals.dom.baseEl.querySelector(t.globals.chartClass);
                this.ctx.eventList.forEach((function(e) {
                    i.addEventListener(e, (function(e) {
                        var i = Object.assign({}, t, {
                            seriesIndex: t.globals.capturedSeriesIndex,
                            dataPointIndex: t.globals.capturedDataPointIndex
                        });
                        "mousemove" === e.type || "touchmove" === e.type ? "function" == typeof t.config.chart.events.mouseMove && t.config.chart.events.mouseMove(e, a, i) : "mouseleave" === e.type || "touchleave" === e.type ? "function" == typeof t.config.chart.events.mouseLeave && t.config.chart.events.mouseLeave(e, a, i) : ("mouseup" === e.type && 1 === e.which || "touchend" === e.type) && ("function" == typeof t.config.chart.events.click && t.config.chart.events.click(e, a, i),
                        a.ctx.events.fireEvent("click", [e, a, i]))
                    }
                    ), {
                        capture: !1,
                        passive: !0
                    })
                }
                )),
                this.ctx.eventList.forEach((function(a) {
                    t.globals.dom.baseEl.addEventListener(a, e.documentEvent, {
                        passive: !0
                    })
                }
                )),
                this.ctx.core.setupBrushHandler()
            }
        }, {
            key: "documentEvent",
            value: function(e) {
                var t = this.w
                  , a = e.target.className;
                if ("click" === e.type) {
                    var i = t.globals.dom.baseEl.querySelector(".apexcharts-menu");
                    i && i.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== a && i.classList.remove("apexcharts-menu-open")
                }
                t.globals.clientX = "touchmove" === e.type ? e.touches[0].clientX : e.clientX,
                t.globals.clientY = "touchmove" === e.type ? e.touches[0].clientY : e.clientY
            }
        }]),
        e
    }()
      , J = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "setCurrentLocaleValues",
            value: function(e) {
                var t = this.w.config.chart.locales;
                window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (t = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                var a = t.filter((function(t) {
                    return t.name === e
                }
                ))[0];
                if (!a)
                    throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                var i = b.extend(L, a);
                this.w.globals.locale = i.options
            }
        }]),
        e
    }()
      , Q = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "drawAxis",
            value: function(e, t) {
                var a, i, n = this, r = this.w.globals, o = this.w.config, s = new j(this.ctx,t), l = new Z(this.ctx,t);
                r.axisCharts && "radar" !== e && (r.isBarHorizontal ? (i = l.drawYaxisInversed(0),
                a = s.drawXaxisInversed(0),
                r.dom.elGraphical.add(a),
                r.dom.elGraphical.add(i)) : (a = s.drawXaxis(),
                r.dom.elGraphical.add(a),
                o.yaxis.map((function(e, t) {
                    if (-1 === r.ignoreYAxisIndexes.indexOf(t) && (i = l.drawYaxis(t),
                    r.dom.Paper.add(i),
                    "back" === n.w.config.grid.position)) {
                        var a = r.dom.Paper.children()[1];
                        a.remove(),
                        r.dom.Paper.add(a)
                    }
                }
                ))))
            }
        }]),
        e
    }()
      , ee = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "drawXCrosshairs",
            value: function() {
                var e = this.w
                  , t = new w(this.ctx)
                  , a = new y(this.ctx)
                  , i = e.config.xaxis.crosshairs.fill.gradient
                  , n = e.config.xaxis.crosshairs.dropShadow
                  , r = e.config.xaxis.crosshairs.fill.type
                  , o = i.colorFrom
                  , s = i.colorTo
                  , l = i.opacityFrom
                  , c = i.opacityTo
                  , u = i.stops
                  , d = n.enabled
                  , h = n.left
                  , p = n.top
                  , v = n.blur
                  , g = n.color
                  , f = n.opacity
                  , m = e.config.xaxis.crosshairs.fill.color;
                if (e.config.xaxis.crosshairs.show) {
                    "gradient" === r && (m = t.drawGradient("vertical", o, s, l, c, null, u, null));
                    var x = t.drawRect();
                    1 === e.config.xaxis.crosshairs.width && (x = t.drawLine());
                    var k = e.globals.gridHeight;
                    (!b.isNumber(k) || k < 0) && (k = 0);
                    var S = e.config.xaxis.crosshairs.width;
                    (!b.isNumber(S) || S < 0) && (S = 0),
                    x.attr({
                        class: "apexcharts-xcrosshairs",
                        x: 0,
                        y: 0,
                        y2: k,
                        width: S,
                        height: k,
                        fill: m,
                        filter: "none",
                        "fill-opacity": e.config.xaxis.crosshairs.opacity,
                        stroke: e.config.xaxis.crosshairs.stroke.color,
                        "stroke-width": e.config.xaxis.crosshairs.stroke.width,
                        "stroke-dasharray": e.config.xaxis.crosshairs.stroke.dashArray
                    }),
                    d && (x = a.dropShadow(x, {
                        left: h,
                        top: p,
                        blur: v,
                        color: g,
                        opacity: f
                    })),
                    e.globals.dom.elGraphical.add(x)
                }
            }
        }, {
            key: "drawYCrosshairs",
            value: function() {
                var e = this.w
                  , t = new w(this.ctx)
                  , a = e.config.yaxis[0].crosshairs
                  , i = e.globals.barPadForNumericAxis;
                if (e.config.yaxis[0].crosshairs.show) {
                    var n = t.drawLine(-i, 0, e.globals.gridWidth + i, 0, a.stroke.color, a.stroke.dashArray, a.stroke.width);
                    n.attr({
                        class: "apexcharts-ycrosshairs"
                    }),
                    e.globals.dom.elGraphical.add(n)
                }
                var r = t.drawLine(-i, 0, e.globals.gridWidth + i, 0, a.stroke.color, 0, 0);
                r.attr({
                    class: "apexcharts-ycrosshairs-hidden"
                }),
                e.globals.dom.elGraphical.add(r)
            }
        }]),
        e
    }()
      , te = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "checkResponsiveConfig",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = a.config;
                if (0 !== i.responsive.length) {
                    var n = i.responsive.slice();
                    n.sort((function(e, t) {
                        return e.breakpoint > t.breakpoint ? 1 : t.breakpoint > e.breakpoint ? -1 : 0
                    }
                    )).reverse();
                    var r = new B({})
                      , o = function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
                          , i = n[0].breakpoint
                          , o = window.innerWidth > 0 ? window.innerWidth : screen.width;
                        if (o > i) {
                            var s = k.extendArrayProps(r, a.globals.initialConfig, a);
                            e = b.extend(s, e),
                            e = b.extend(a.config, e),
                            t.overrideResponsiveOptions(e)
                        } else
                            for (var l = 0; l < n.length; l++)
                                o < n[l].breakpoint && (e = k.extendArrayProps(r, n[l].options, a),
                                e = b.extend(a.config, e),
                                t.overrideResponsiveOptions(e))
                    };
                    if (e) {
                        var s = k.extendArrayProps(r, e, a);
                        s = b.extend(a.config, s),
                        o(s = b.extend(s, e))
                    } else
                        o({})
                }
            }
        }, {
            key: "overrideResponsiveOptions",
            value: function(e) {
                var t = new B(e).init({
                    responsiveOverride: !0
                });
                this.w.config = t
            }
        }]),
        e
    }()
      , ae = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.colors = [],
            this.w = t.w;
            var a = this.w;
            this.isColorFn = !1,
            this.isHeatmapDistributed = "treemap" === a.config.chart.type && a.config.plotOptions.treemap.distributed || "heatmap" === a.config.chart.type && a.config.plotOptions.heatmap.distributed,
            this.isBarDistributed = a.config.plotOptions.bar.distributed && ("bar" === a.config.chart.type || "rangeBar" === a.config.chart.type)
        }
        return s(e, [{
            key: "init",
            value: function() {
                this.setDefaultColors()
            }
        }, {
            key: "setDefaultColors",
            value: function() {
                var e, t = this, a = this.w, i = new b;
                if (a.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(a.config.theme.mode)),
                void 0 === a.config.colors || 0 === (null === (e = a.config.colors) || void 0 === e ? void 0 : e.length) ? a.globals.colors = this.predefined() : (a.globals.colors = a.config.colors,
                Array.isArray(a.config.colors) && a.config.colors.length > 0 && "function" == typeof a.config.colors[0] && (a.globals.colors = a.config.series.map((function(e, i) {
                    var n = a.config.colors[i];
                    return n || (n = a.config.colors[0]),
                    "function" == typeof n ? (t.isColorFn = !0,
                    n({
                        value: a.globals.axisCharts ? a.globals.series[i][0] ? a.globals.series[i][0] : 0 : a.globals.series[i],
                        seriesIndex: i,
                        dataPointIndex: i,
                        w: a
                    })) : n
                }
                )))),
                a.globals.seriesColors.map((function(e, t) {
                    e && (a.globals.colors[t] = e)
                }
                )),
                a.config.theme.monochrome.enabled) {
                    var n = []
                      , r = a.globals.series.length;
                    (this.isBarDistributed || this.isHeatmapDistributed) && (r = a.globals.series[0].length * a.globals.series.length);
                    for (var o = a.config.theme.monochrome.color, s = 1 / (r / a.config.theme.monochrome.shadeIntensity), l = a.config.theme.monochrome.shadeTo, c = 0, u = 0; u < r; u++) {
                        var d = void 0;
                        "dark" === l ? (d = i.shadeColor(-1 * c, o),
                        c += s) : (d = i.shadeColor(c, o),
                        c += s),
                        n.push(d)
                    }
                    a.globals.colors = n.slice()
                }
                var h = a.globals.colors.slice();
                this.pushExtraColors(a.globals.colors),
                ["fill", "stroke"].forEach((function(e) {
                    void 0 === a.config[e].colors ? a.globals[e].colors = t.isColorFn ? a.config.colors : h : a.globals[e].colors = a.config[e].colors.slice(),
                    t.pushExtraColors(a.globals[e].colors)
                }
                )),
                void 0 === a.config.dataLabels.style.colors ? a.globals.dataLabels.style.colors = h : a.globals.dataLabels.style.colors = a.config.dataLabels.style.colors.slice(),
                this.pushExtraColors(a.globals.dataLabels.style.colors, 50),
                void 0 === a.config.plotOptions.radar.polygons.fill.colors ? a.globals.radarPolygons.fill.colors = ["dark" === a.config.theme.mode ? "#424242" : "none"] : a.globals.radarPolygons.fill.colors = a.config.plotOptions.radar.polygons.fill.colors.slice(),
                this.pushExtraColors(a.globals.radarPolygons.fill.colors, 20),
                void 0 === a.config.markers.colors ? a.globals.markers.colors = h : a.globals.markers.colors = a.config.markers.colors.slice(),
                this.pushExtraColors(a.globals.markers.colors)
            }
        }, {
            key: "pushExtraColors",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , i = this.w
                  , n = t || i.globals.series.length;
                if (null === a && (a = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === i.config.chart.type && i.config.plotOptions.heatmap.colorScale.inverse),
                a && i.globals.series.length && (n = i.globals.series[i.globals.maxValsInArrayIndex].length * i.globals.series.length),
                e.length < n)
                    for (var r = n - e.length, o = 0; o < r; o++)
                        e.push(e[o])
            }
        }, {
            key: "updateThemeOptions",
            value: function(e) {
                e.chart = e.chart || {},
                e.tooltip = e.tooltip || {};
                var t = e.theme.mode || "light"
                  , a = e.theme.palette ? e.theme.palette : "dark" === t ? "palette4" : "palette1"
                  , i = e.chart.foreColor ? e.chart.foreColor : "dark" === t ? "#f6f7f8" : "#373d3f";
                return e.tooltip.theme = t,
                e.chart.foreColor = i,
                e.theme.palette = a,
                e
            }
        }, {
            key: "predefined",
            value: function() {
                switch (this.w.config.theme.palette) {
                case "palette1":
                default:
                    this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                    break;
                case "palette2":
                    this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                    break;
                case "palette3":
                    this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                    break;
                case "palette4":
                    this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                    break;
                case "palette5":
                    this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                    break;
                case "palette6":
                    this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                    break;
                case "palette7":
                    this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                    break;
                case "palette8":
                    this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                    break;
                case "palette9":
                    this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                    break;
                case "palette10":
                    this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"]
                }
                return this.colors
            }
        }]),
        e
    }()
      , ie = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "draw",
            value: function() {
                this.drawTitleSubtitle("title"),
                this.drawTitleSubtitle("subtitle")
            }
        }, {
            key: "drawTitleSubtitle",
            value: function(e) {
                var t = this.w
                  , a = "title" === e ? t.config.title : t.config.subtitle
                  , i = t.globals.svgWidth / 2
                  , n = a.offsetY
                  , r = "middle";
                if ("left" === a.align ? (i = 10,
                r = "start") : "right" === a.align && (i = t.globals.svgWidth - 10,
                r = "end"),
                i += a.offsetX,
                n = n + parseInt(a.style.fontSize, 10) + a.margin / 2,
                void 0 !== a.text) {
                    var o = new w(this.ctx).drawText({
                        x: i,
                        y: n,
                        text: a.text,
                        textAnchor: r,
                        fontSize: a.style.fontSize,
                        fontFamily: a.style.fontFamily,
                        fontWeight: a.style.fontWeight,
                        foreColor: a.style.color,
                        opacity: 1
                    });
                    o.node.setAttribute("class", "apexcharts-".concat(e, "-text")),
                    t.globals.dom.Paper.add(o)
                }
            }
        }]),
        e
    }()
      , ne = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.dCtx = t
        }
        return s(e, [{
            key: "getTitleSubtitleCoords",
            value: function(e) {
                var t = this.w
                  , a = 0
                  , i = 0
                  , n = "title" === e ? t.config.title.floating : t.config.subtitle.floating
                  , r = t.globals.dom.baseEl.querySelector(".apexcharts-".concat(e, "-text"));
                if (null !== r && !n) {
                    var o = r.getBoundingClientRect();
                    a = o.width,
                    i = t.globals.axisCharts ? o.height + 5 : o.height
                }
                return {
                    width: a,
                    height: i
                }
            }
        }, {
            key: "getLegendsRect",
            value: function() {
                var e = this.w
                  , t = e.globals.dom.elLegendWrap;
                e.config.legend.height || "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || (t.style.maxHeight = e.globals.svgHeight / 2 + "px");
                var a = Object.assign({}, b.getBoundingClientRect(t));
                return null !== t && !e.config.legend.floating && e.config.legend.show ? this.dCtx.lgRect = {
                    x: a.x,
                    y: a.y,
                    height: a.height,
                    width: 0 === a.height ? 0 : a.width
                } : this.dCtx.lgRect = {
                    x: 0,
                    y: 0,
                    height: 0,
                    width: 0
                },
                "left" !== e.config.legend.position && "right" !== e.config.legend.position || 1.5 * this.dCtx.lgRect.width > e.globals.svgWidth && (this.dCtx.lgRect.width = e.globals.svgWidth / 1.5),
                this.dCtx.lgRect
            }
        }, {
            key: "getLargestStringFromMultiArr",
            value: function(e, t) {
                var a = e;
                if (this.w.globals.isMultiLineX) {
                    var i = t.map((function(e, t) {
                        return Array.isArray(e) ? e.length : 1
                    }
                    ))
                      , n = Math.max.apply(Math, g(i));
                    a = t[i.indexOf(n)]
                }
                return a
            }
        }]),
        e
    }()
      , re = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.dCtx = t
        }
        return s(e, [{
            key: "getxAxisLabelsCoords",
            value: function() {
                var e, t = this.w, a = t.globals.labels.slice();
                if (t.config.xaxis.convertedCatToNumeric && 0 === a.length && (a = t.globals.categoryLabels),
                t.globals.timescaleLabels.length > 0) {
                    var i = this.getxAxisTimeScaleLabelsCoords();
                    e = {
                        width: i.width,
                        height: i.height
                    },
                    t.globals.rotateXLabels = !1
                } else {
                    this.dCtx.lgWidthForSideLegends = "left" !== t.config.legend.position && "right" !== t.config.legend.position || t.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                    var n = t.globals.xLabelFormatter
                      , r = b.getLargestStringFromArr(a)
                      , o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, a);
                    t.globals.isBarHorizontal && (o = r = t.globals.yAxisScale[0].result.reduce((function(e, t) {
                        return e.length > t.length ? e : t
                    }
                    ), 0));
                    var s = new E(this.dCtx.ctx)
                      , l = r;
                    r = s.xLabelFormat(n, r, l, {
                        i: void 0,
                        dateFormatter: new T(this.dCtx.ctx).formatDate,
                        w: t
                    }),
                    o = s.xLabelFormat(n, o, l, {
                        i: void 0,
                        dateFormatter: new T(this.dCtx.ctx).formatDate,
                        w: t
                    }),
                    (t.config.xaxis.convertedCatToNumeric && void 0 === r || "" === String(r).trim()) && (o = r = "1");
                    var c = new w(this.dCtx.ctx)
                      , u = c.getTextRects(r, t.config.xaxis.labels.style.fontSize)
                      , d = u;
                    if (r !== o && (d = c.getTextRects(o, t.config.xaxis.labels.style.fontSize)),
                    (e = {
                        width: u.width >= d.width ? u.width : d.width,
                        height: u.height >= d.height ? u.height : d.height
                    }).width * a.length > t.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== t.config.xaxis.labels.rotate || t.config.xaxis.labels.rotateAlways) {
                        if (!t.globals.isBarHorizontal) {
                            t.globals.rotateXLabels = !0;
                            var h = function(e) {
                                return c.getTextRects(e, t.config.xaxis.labels.style.fontSize, t.config.xaxis.labels.style.fontFamily, "rotate(".concat(t.config.xaxis.labels.rotate, " 0 0)"), !1)
                            };
                            u = h(r),
                            r !== o && (d = h(o)),
                            e.height = (u.height > d.height ? u.height : d.height) / 1.5,
                            e.width = u.width > d.width ? u.width : d.width
                        }
                    } else
                        t.globals.rotateXLabels = !1
                }
                return t.config.xaxis.labels.show || (e = {
                    width: 0,
                    height: 0
                }),
                {
                    width: e.width,
                    height: e.height
                }
            }
        }, {
            key: "getxAxisGroupLabelsCoords",
            value: function() {
                var e, t = this.w;
                if (!t.globals.hasXaxisGroups)
                    return {
                        width: 0,
                        height: 0
                    };
                var a, i = (null === (e = t.config.xaxis.group.style) || void 0 === e ? void 0 : e.fontSize) || t.config.xaxis.labels.style.fontSize, n = t.globals.groups.map((function(e) {
                    return e.title
                }
                )), r = b.getLargestStringFromArr(n), o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, n), s = new w(this.dCtx.ctx), l = s.getTextRects(r, i), c = l;
                return r !== o && (c = s.getTextRects(o, i)),
                a = {
                    width: l.width >= c.width ? l.width : c.width,
                    height: l.height >= c.height ? l.height : c.height
                },
                t.config.xaxis.labels.show || (a = {
                    width: 0,
                    height: 0
                }),
                {
                    width: a.width,
                    height: a.height
                }
            }
        }, {
            key: "getxAxisTitleCoords",
            value: function() {
                var e = this.w
                  , t = 0
                  , a = 0;
                if (void 0 !== e.config.xaxis.title.text) {
                    var i = new w(this.dCtx.ctx).getTextRects(e.config.xaxis.title.text, e.config.xaxis.title.style.fontSize);
                    t = i.width,
                    a = i.height
                }
                return {
                    width: t,
                    height: a
                }
            }
        }, {
            key: "getxAxisTimeScaleLabelsCoords",
            value: function() {
                var e, t = this.w;
                this.dCtx.timescaleLabels = t.globals.timescaleLabels.slice();
                var a = this.dCtx.timescaleLabels.map((function(e) {
                    return e.value
                }
                ))
                  , i = a.reduce((function(e, t) {
                    return void 0 === e ? 0 : e.length > t.length ? e : t
                }
                ), 0);
                return 1.05 * (e = new w(this.dCtx.ctx).getTextRects(i, t.config.xaxis.labels.style.fontSize)).width * a.length > t.globals.gridWidth && 0 !== t.config.xaxis.labels.rotate && (t.globals.overlappingXLabels = !0),
                e
            }
        }, {
            key: "additionalPaddingXLabels",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = a.globals
                  , n = a.config
                  , r = n.xaxis.type
                  , o = e.width;
                i.skipLastTimelinelabel = !1,
                i.skipFirstTimelinelabel = !1;
                var s = a.config.yaxis[0].opposite && a.globals.isBarHorizontal;
                n.yaxis.forEach((function(e, l) {
                    s ? (t.dCtx.gridPad.left < o && (t.dCtx.xPadLeft = o / 2 + 1),
                    t.dCtx.xPadRight = o / 2 + 1) : function(e, s) {
                        var l;
                        n.yaxis.length > 1 && (l = s,
                        -1 !== i.collapsedSeriesIndices.indexOf(l)) || function(e) {
                            if (t.dCtx.timescaleLabels && t.dCtx.timescaleLabels.length) {
                                var s = t.dCtx.timescaleLabels[0]
                                  , l = t.dCtx.timescaleLabels[t.dCtx.timescaleLabels.length - 1].position + o / 1.75 - t.dCtx.yAxisWidthRight
                                  , c = s.position - o / 1.75 + t.dCtx.yAxisWidthLeft
                                  , u = "right" === a.config.legend.position && t.dCtx.lgRect.width > 0 ? t.dCtx.lgRect.width : 0;
                                l > i.svgWidth - i.translateX - u && (i.skipLastTimelinelabel = !0),
                                c < -(e.show && !e.floating || "bar" !== n.chart.type && "candlestick" !== n.chart.type && "rangeBar" !== n.chart.type && "boxPlot" !== n.chart.type ? 10 : o / 1.75) && (i.skipFirstTimelinelabel = !0)
                            } else
                                "datetime" === r ? t.dCtx.gridPad.right < o && !i.rotateXLabels && (i.skipLastTimelinelabel = !0) : "datetime" !== r && t.dCtx.gridPad.right < o / 2 - t.dCtx.yAxisWidthRight && !i.rotateXLabels && !a.config.xaxis.labels.trim && ("between" !== a.config.xaxis.tickPlacement || a.globals.isBarHorizontal) && (t.dCtx.xPadRight = o / 2 + 1)
                        }(e)
                    }(e, l)
                }
                ))
            }
        }]),
        e
    }()
      , oe = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.dCtx = t
        }
        return s(e, [{
            key: "getyAxisLabelsCoords",
            value: function() {
                var e = this
                  , t = this.w
                  , a = []
                  , i = 10
                  , n = new W(this.dCtx.ctx);
                return t.config.yaxis.map((function(r, o) {
                    var s = {
                        seriesIndex: o,
                        dataPointIndex: -1,
                        w: t
                    }
                      , l = t.globals.yAxisScale[o]
                      , c = 0;
                    if (!n.isYAxisHidden(o) && r.labels.show && void 0 !== r.labels.minWidth && (c = r.labels.minWidth),
                    !n.isYAxisHidden(o) && r.labels.show && l.result.length) {
                        var u = t.globals.yLabelFormatters[o]
                          , d = l.niceMin === Number.MIN_VALUE ? 0 : l.niceMin
                          , h = l.result.reduce((function(e, t) {
                            var a, i;
                            return (null === (a = String(u(e, s))) || void 0 === a ? void 0 : a.length) > (null === (i = String(u(t, s))) || void 0 === i ? void 0 : i.length) ? e : t
                        }
                        ), d)
                          , p = h = u(h, s);
                        if (void 0 !== h && 0 !== h.length || (h = l.niceMax),
                        t.globals.isBarHorizontal) {
                            i = 0;
                            var v = t.globals.labels.slice();
                            h = b.getLargestStringFromArr(v),
                            h = u(h, {
                                seriesIndex: o,
                                dataPointIndex: -1,
                                w: t
                            }),
                            p = e.dCtx.dimHelpers.getLargestStringFromMultiArr(h, v)
                        }
                        var g = new w(e.dCtx.ctx)
                          , f = "rotate(".concat(r.labels.rotate, " 0 0)")
                          , m = g.getTextRects(h, r.labels.style.fontSize, r.labels.style.fontFamily, f, !1)
                          , x = m;
                        h !== p && (x = g.getTextRects(p, r.labels.style.fontSize, r.labels.style.fontFamily, f, !1)),
                        a.push({
                            width: (c > x.width || c > m.width ? c : x.width > m.width ? x.width : m.width) + i,
                            height: x.height > m.height ? x.height : m.height
                        })
                    } else
                        a.push({
                            width: 0,
                            height: 0
                        })
                }
                )),
                a
            }
        }, {
            key: "getyAxisTitleCoords",
            value: function() {
                var e = this
                  , t = this.w
                  , a = [];
                return t.config.yaxis.map((function(t, i) {
                    if (t.show && void 0 !== t.title.text) {
                        var n = new w(e.dCtx.ctx)
                          , r = "rotate(".concat(t.title.rotate, " 0 0)")
                          , o = n.getTextRects(t.title.text, t.title.style.fontSize, t.title.style.fontFamily, r, !1);
                        a.push({
                            width: o.width,
                            height: o.height
                        })
                    } else
                        a.push({
                            width: 0,
                            height: 0
                        })
                }
                )),
                a
            }
        }, {
            key: "getTotalYAxisWidth",
            value: function() {
                var e = this.w
                  , t = 0
                  , a = 0
                  , i = 0
                  , n = e.globals.yAxisScale.length > 1 ? 10 : 0
                  , r = new W(this.dCtx.ctx)
                  , o = function(o, s) {
                    var l, c = e.config.yaxis[s].floating, u = 0;
                    o.width > 0 && !c ? (u = o.width + n,
                    l = s,
                    e.globals.ignoreYAxisIndexes.indexOf(l) > -1 && (u = u - o.width - n)) : u = c || r.isYAxisHidden(s) ? 0 : 5,
                    e.config.yaxis[s].opposite ? i += u : a += u,
                    t += u
                };
                return e.globals.yLabelsCoords.map((function(e, t) {
                    o(e, t)
                }
                )),
                e.globals.yTitleCoords.map((function(e, t) {
                    o(e, t)
                }
                )),
                e.globals.isBarHorizontal && !e.config.yaxis[0].floating && (t = e.globals.yLabelsCoords[0].width + e.globals.yTitleCoords[0].width + 15),
                this.dCtx.yAxisWidthLeft = a,
                this.dCtx.yAxisWidthRight = i,
                t
            }
        }]),
        e
    }()
      , se = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.dCtx = t
        }
        return s(e, [{
            key: "gridPadForColumnsInNumericAxis",
            value: function(e) {
                var t = this.w;
                if (t.globals.noData || t.globals.allSeriesCollapsed)
                    return 0;
                var a = function(e) {
                    return "bar" === e || "rangeBar" === e || "candlestick" === e || "boxPlot" === e
                }
                  , i = t.config.chart.type
                  , n = 0
                  , r = a(i) ? t.config.series.length : 1;
                if (t.globals.comboBarCount > 0 && (r = t.globals.comboBarCount),
                t.globals.collapsedSeries.forEach((function(e) {
                    a(e.type) && (r -= 1)
                }
                )),
                t.config.chart.stacked && (r = 1),
                (a(i) || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && r > 0) {
                    var o, s, l = Math.abs(t.globals.initialMaxX - t.globals.initialMinX);
                    l <= 3 && (l = t.globals.dataPoints),
                    o = l / e,
                    t.globals.minXDiff && t.globals.minXDiff / o > 0 && (s = t.globals.minXDiff / o),
                    s > e / 2 && (s /= 2),
                    (n = s / r * parseInt(t.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (n = 1),
                    n = n / (r > 1 ? 1 : 1.5) + 5,
                    t.globals.barPadForNumericAxis = n
                }
                return n
            }
        }, {
            key: "gridPadFortitleSubtitle",
            value: function() {
                var e = this
                  , t = this.w
                  , a = t.globals
                  , i = this.dCtx.isSparkline || !t.globals.axisCharts ? 0 : 10;
                ["title", "subtitle"].forEach((function(a) {
                    void 0 !== t.config[a].text ? i += t.config[a].margin : i += e.dCtx.isSparkline || !t.globals.axisCharts ? 0 : 5
                }
                )),
                !t.config.legend.show || "bottom" !== t.config.legend.position || t.config.legend.floating || t.globals.axisCharts || (i += 10);
                var n = this.dCtx.dimHelpers.getTitleSubtitleCoords("title")
                  , r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                a.gridHeight = a.gridHeight - n.height - r.height - i,
                a.translateY = a.translateY + n.height + r.height + i
            }
        }, {
            key: "setGridXPosForDualYAxis",
            value: function(e, t) {
                var a = this.w
                  , i = new W(this.dCtx.ctx);
                a.config.yaxis.map((function(n, r) {
                    -1 !== a.globals.ignoreYAxisIndexes.indexOf(r) || n.floating || i.isYAxisHidden(r) || (n.opposite && (a.globals.translateX = a.globals.translateX - (t[r].width + e[r].width) - parseInt(a.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12),
                    a.globals.translateX < 2 && (a.globals.translateX = 2))
                }
                ))
            }
        }]),
        e
    }()
      , le = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.lgRect = {},
            this.yAxisWidth = 0,
            this.yAxisWidthLeft = 0,
            this.yAxisWidthRight = 0,
            this.xAxisHeight = 0,
            this.isSparkline = this.w.config.chart.sparkline.enabled,
            this.dimHelpers = new ne(this),
            this.dimYAxis = new oe(this),
            this.dimXAxis = new re(this),
            this.dimGrid = new se(this),
            this.lgWidthForSideLegends = 0,
            this.gridPad = this.w.config.grid.padding,
            this.xPadRight = 0,
            this.xPadLeft = 0
        }
        return s(e, [{
            key: "plotCoords",
            value: function() {
                var e = this
                  , t = this.w
                  , a = t.globals;
                this.lgRect = this.dimHelpers.getLegendsRect(),
                this.isSparkline && ((t.config.markers.discrete.length > 0 || t.config.markers.size > 0) && Object.entries(this.gridPad).forEach((function(t) {
                    var a = v(t, 2)
                      , i = a[0]
                      , n = a[1];
                    e.gridPad[i] = Math.max(n, e.w.globals.markers.largestSize / 1.5)
                }
                )),
                this.gridPad.top = Math.max(t.config.stroke.width / 2, this.gridPad.top),
                this.gridPad.bottom = Math.max(t.config.stroke.width / 2, this.gridPad.bottom)),
                a.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(),
                this.dimGrid.gridPadFortitleSubtitle(),
                a.gridHeight = a.gridHeight - this.gridPad.top - this.gridPad.bottom,
                a.gridWidth = a.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                var i = this.dimGrid.gridPadForColumnsInNumericAxis(a.gridWidth);
                a.gridWidth = a.gridWidth - 2 * i,
                a.translateX = a.translateX + this.gridPad.left + this.xPadLeft + (i > 0 ? i + 4 : 0),
                a.translateY = a.translateY + this.gridPad.top
            }
        }, {
            key: "setDimensionsForAxisCharts",
            value: function() {
                var e = this
                  , t = this.w
                  , a = t.globals
                  , i = this.dimYAxis.getyAxisLabelsCoords()
                  , n = this.dimYAxis.getyAxisTitleCoords();
                t.globals.yLabelsCoords = [],
                t.globals.yTitleCoords = [],
                t.config.yaxis.map((function(e, a) {
                    t.globals.yLabelsCoords.push({
                        width: i[a].width,
                        index: a
                    }),
                    t.globals.yTitleCoords.push({
                        width: n[a].width,
                        index: a
                    })
                }
                )),
                this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                var r = this.dimXAxis.getxAxisLabelsCoords()
                  , o = this.dimXAxis.getxAxisGroupLabelsCoords()
                  , s = this.dimXAxis.getxAxisTitleCoords();
                this.conditionalChecksForAxisCoords(r, s, o),
                a.translateXAxisY = t.globals.rotateXLabels ? this.xAxisHeight / 8 : -4,
                a.translateXAxisX = t.globals.rotateXLabels && t.globals.isXNumeric && t.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0,
                t.globals.isBarHorizontal && (a.rotateXLabels = !1,
                a.translateXAxisY = parseInt(t.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1),
                a.translateXAxisY = a.translateXAxisY + t.config.xaxis.labels.offsetY,
                a.translateXAxisX = a.translateXAxisX + t.config.xaxis.labels.offsetX;
                var l = this.yAxisWidth
                  , c = this.xAxisHeight;
                a.xAxisLabelsHeight = this.xAxisHeight - s.height,
                a.xAxisGroupLabelsHeight = a.xAxisLabelsHeight - r.height,
                a.xAxisLabelsWidth = this.xAxisWidth,
                a.xAxisHeight = this.xAxisHeight;
                var u = 10;
                ("radar" === t.config.chart.type || this.isSparkline) && (l = 0,
                c = a.goldenPadding),
                this.isSparkline && (this.lgRect = {
                    height: 0,
                    width: 0
                }),
                (this.isSparkline || "treemap" === t.config.chart.type) && (l = 0,
                c = 0,
                u = 0),
                this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r);
                var d = function() {
                    a.translateX = l,
                    a.gridHeight = a.svgHeight - e.lgRect.height - c - (e.isSparkline || "treemap" === t.config.chart.type ? 0 : t.globals.rotateXLabels ? 10 : 15),
                    a.gridWidth = a.svgWidth - l
                };
                switch ("top" === t.config.xaxis.position && (u = a.xAxisHeight - t.config.xaxis.axisTicks.height - 5),
                t.config.legend.position) {
                case "bottom":
                    a.translateY = u,
                    d();
                    break;
                case "top":
                    a.translateY = this.lgRect.height + u,
                    d();
                    break;
                case "left":
                    a.translateY = u,
                    a.translateX = this.lgRect.width + l,
                    a.gridHeight = a.svgHeight - c - 12,
                    a.gridWidth = a.svgWidth - this.lgRect.width - l;
                    break;
                case "right":
                    a.translateY = u,
                    a.translateX = l,
                    a.gridHeight = a.svgHeight - c - 12,
                    a.gridWidth = a.svgWidth - this.lgRect.width - l - 5;
                    break;
                default:
                    throw new Error("Legend position not supported")
                }
                this.dimGrid.setGridXPosForDualYAxis(n, i),
                new Z(this.ctx).setYAxisXPosition(i, n)
            }
        }, {
            key: "setDimensionsForNonAxisCharts",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , a = e.config
                  , i = 0;
                e.config.legend.show && !e.config.legend.floating && (i = 20);
                var n = "pie" === a.chart.type || "polarArea" === a.chart.type || "donut" === a.chart.type ? "pie" : "radialBar"
                  , r = a.plotOptions[n].offsetY
                  , o = a.plotOptions[n].offsetX;
                if (!a.legend.show || a.legend.floating)
                    return t.gridHeight = t.svgHeight - a.grid.padding.left + a.grid.padding.right,
                    t.gridWidth = t.gridHeight,
                    t.translateY = r,
                    void (t.translateX = o + (t.svgWidth - t.gridWidth) / 2);
                switch (a.legend.position) {
                case "bottom":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding,
                    t.gridWidth = t.svgWidth,
                    t.translateY = r - 10,
                    t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case "top":
                    t.gridHeight = t.svgHeight - this.lgRect.height - t.goldenPadding,
                    t.gridWidth = t.svgWidth,
                    t.translateY = this.lgRect.height + r + 10,
                    t.translateX = o + (t.svgWidth - t.gridWidth) / 2;
                    break;
                case "left":
                    t.gridWidth = t.svgWidth - this.lgRect.width - i,
                    t.gridHeight = "auto" !== a.chart.height ? t.svgHeight : t.gridWidth,
                    t.translateY = r,
                    t.translateX = o + this.lgRect.width + i;
                    break;
                case "right":
                    t.gridWidth = t.svgWidth - this.lgRect.width - i - 5,
                    t.gridHeight = "auto" !== a.chart.height ? t.svgHeight : t.gridWidth,
                    t.translateY = r,
                    t.translateX = o + 10;
                    break;
                default:
                    throw new Error("Legend position not supported")
                }
            }
        }, {
            key: "conditionalChecksForAxisCoords",
            value: function(e, t, a) {
                var i = this.w
                  , n = i.globals.hasXaxisGroups ? 2 : 1
                  , r = a.height + e.height + t.height
                  , o = i.globals.isMultiLineX ? 1.2 : i.globals.LINE_HEIGHT_RATIO
                  , s = i.globals.rotateXLabels ? 22 : 10
                  , l = i.globals.rotateXLabels && "bottom" === i.config.legend.position ? 10 : 0;
                this.xAxisHeight = r * o + n * s + l,
                this.xAxisWidth = e.width,
                this.xAxisHeight - t.height > i.config.xaxis.labels.maxHeight && (this.xAxisHeight = i.config.xaxis.labels.maxHeight),
                i.config.xaxis.labels.minHeight && this.xAxisHeight < i.config.xaxis.labels.minHeight && (this.xAxisHeight = i.config.xaxis.labels.minHeight),
                i.config.xaxis.floating && (this.xAxisHeight = 0);
                var c = 0
                  , u = 0;
                i.config.yaxis.forEach((function(e) {
                    c += e.labels.minWidth,
                    u += e.labels.maxWidth
                }
                )),
                this.yAxisWidth < c && (this.yAxisWidth = c),
                this.yAxisWidth > u && (this.yAxisWidth = u)
            }
        }]),
        e
    }()
      , ce = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.lgCtx = t
        }
        return s(e, [{
            key: "getLegendStyles",
            value: function() {
                var e, t, a, i = document.createElement("style");
                i.setAttribute("type", "text/css");
                var n = (null === (e = this.lgCtx.ctx) || void 0 === e || null === (t = e.opts) || void 0 === t || null === (a = t.chart) || void 0 === a ? void 0 : a.nonce) || this.w.config.chart.nonce;
                n && i.setAttribute("nonce", n);
                var r = document.createTextNode("\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n      }\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: inline-block;\n        cursor: pointer;\n        margin-right: 3px;\n        border-style: solid;\n      }\n\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\n        display: inline-block;\n      }\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }");
                return i.appendChild(r),
                i
            }
        }, {
            key: "getLegendBBox",
            value: function() {
                var e = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect()
                  , t = e.width;
                return {
                    clwh: e.height,
                    clww: t
                }
            }
        }, {
            key: "appendToForeignObject",
            value: function() {
                this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles())
            }
        }, {
            key: "toggleDataSeries",
            value: function(e, t) {
                var a = this
                  , i = this.w;
                if (i.globals.axisCharts || "radialBar" === i.config.chart.type) {
                    i.globals.resized = !0;
                    var n = null
                      , r = null;
                    i.globals.risingSeries = [],
                    i.globals.axisCharts ? (n = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "']")),
                    r = parseInt(n.getAttribute("data:realIndex"), 10)) : (n = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(e + 1, "']")),
                    r = parseInt(n.getAttribute("rel"), 10) - 1),
                    t ? [{
                        cs: i.globals.collapsedSeries,
                        csi: i.globals.collapsedSeriesIndices
                    }, {
                        cs: i.globals.ancillaryCollapsedSeries,
                        csi: i.globals.ancillaryCollapsedSeriesIndices
                    }].forEach((function(e) {
                        a.riseCollapsedSeries(e.cs, e.csi, r)
                    }
                    )) : this.hideSeries({
                        seriesEl: n,
                        realIndex: r
                    })
                } else {
                    var o = i.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(e + 1, "'] path"))
                      , s = i.config.chart.type;
                    if ("pie" === s || "polarArea" === s || "donut" === s) {
                        var l = i.config.plotOptions.pie.donut.labels;
                        new w(this.lgCtx.ctx).pathMouseDown(o.members[0], null),
                        this.lgCtx.ctx.pie.printDataLabelsInner(o.members[0].node, l)
                    }
                    o.fire("click")
                }
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                var t = e.seriesEl
                  , a = e.realIndex
                  , i = this.w
                  , n = b.clone(i.config.series);
                if (i.globals.axisCharts) {
                    var r = !1;
                    if (i.config.yaxis[a] && i.config.yaxis[a].show && i.config.yaxis[a].showAlways && (r = !0,
                    i.globals.ancillaryCollapsedSeriesIndices.indexOf(a) < 0 && (i.globals.ancillaryCollapsedSeries.push({
                        index: a,
                        data: n[a].data.slice(),
                        type: t.parentNode.className.baseVal.split("-")[1]
                    }),
                    i.globals.ancillaryCollapsedSeriesIndices.push(a))),
                    !r) {
                        i.globals.collapsedSeries.push({
                            index: a,
                            data: n[a].data.slice(),
                            type: t.parentNode.className.baseVal.split("-")[1]
                        }),
                        i.globals.collapsedSeriesIndices.push(a);
                        var o = i.globals.risingSeries.indexOf(a);
                        i.globals.risingSeries.splice(o, 1)
                    }
                } else
                    i.globals.collapsedSeries.push({
                        index: a,
                        data: n[a]
                    }),
                    i.globals.collapsedSeriesIndices.push(a);
                for (var s = t.childNodes, l = 0; l < s.length; l++)
                    s[l].classList.contains("apexcharts-series-markers-wrap") && (s[l].classList.contains("apexcharts-hide") ? s[l].classList.remove("apexcharts-hide") : s[l].classList.add("apexcharts-hide"));
                i.globals.allSeriesCollapsed = i.globals.collapsedSeries.length === i.config.series.length,
                n = this._getSeriesBasedOnCollapsedState(n),
                this.lgCtx.ctx.updateHelpers._updateSeries(n, i.config.chart.animations.dynamicAnimation.enabled)
            }
        }, {
            key: "riseCollapsedSeries",
            value: function(e, t, a) {
                var i = this.w
                  , n = b.clone(i.config.series);
                if (e.length > 0) {
                    for (var r = 0; r < e.length; r++)
                        e[r].index === a && (i.globals.axisCharts ? (n[a].data = e[r].data.slice(),
                        e.splice(r, 1),
                        t.splice(r, 1),
                        i.globals.risingSeries.push(a)) : (n[a] = e[r].data,
                        e.splice(r, 1),
                        t.splice(r, 1),
                        i.globals.risingSeries.push(a)));
                    n = this._getSeriesBasedOnCollapsedState(n),
                    this.lgCtx.ctx.updateHelpers._updateSeries(n, i.config.chart.animations.dynamicAnimation.enabled)
                }
            }
        }, {
            key: "_getSeriesBasedOnCollapsedState",
            value: function(e) {
                var t = this.w;
                return t.globals.axisCharts ? e.forEach((function(a, i) {
                    t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i].data = [])
                }
                )) : e.forEach((function(a, i) {
                    t.globals.collapsedSeriesIndices.indexOf(i) > -1 && (e[i] = 0)
                }
                )),
                e
            }
        }]),
        e
    }()
      , ue = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.onLegendClick = this.onLegendClick.bind(this),
            this.onLegendHovered = this.onLegendHovered.bind(this),
            this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length,
            this.legendHelpers = new ce(this)
        }
        return s(e, [{
            key: "init",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , a = e.config;
                if ((a.legend.showForSingleSeries && 1 === t.series.length || this.isBarsDistributed || t.series.length > 1 || !t.axisCharts) && a.legend.show) {
                    for (; t.dom.elLegendWrap.firstChild; )
                        t.dom.elLegendWrap.removeChild(t.dom.elLegendWrap.firstChild);
                    this.drawLegends(),
                    b.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(),
                    "bottom" === a.legend.position || "top" === a.legend.position ? this.legendAlignHorizontal() : "right" !== a.legend.position && "left" !== a.legend.position || this.legendAlignVertical()
                }
            }
        }, {
            key: "drawLegends",
            value: function() {
                var e = this
                  , t = this.w
                  , a = t.config.legend.fontFamily
                  , i = t.globals.seriesNames
                  , n = t.globals.colors.slice();
                if ("heatmap" === t.config.chart.type) {
                    var r = t.config.plotOptions.heatmap.colorScale.ranges;
                    i = r.map((function(e) {
                        return e.name ? e.name : e.from + " - " + e.to
                    }
                    )),
                    n = r.map((function(e) {
                        return e.color
                    }
                    ))
                } else
                    this.isBarsDistributed && (i = t.globals.labels.slice());
                t.config.legend.customLegendItems.length && (i = t.config.legend.customLegendItems);
                for (var o = t.globals.legendFormatter, s = t.config.legend.inverseOrder, l = s ? i.length - 1 : 0; s ? l >= 0 : l <= i.length - 1; s ? l-- : l++) {
                    var c, u = o(i[l], {
                        seriesIndex: l,
                        w: t
                    }), d = !1, h = !1;
                    if (t.globals.collapsedSeries.length > 0)
                        for (var p = 0; p < t.globals.collapsedSeries.length; p++)
                            t.globals.collapsedSeries[p].index === l && (d = !0);
                    if (t.globals.ancillaryCollapsedSeriesIndices.length > 0)
                        for (var v = 0; v < t.globals.ancillaryCollapsedSeriesIndices.length; v++)
                            t.globals.ancillaryCollapsedSeriesIndices[v] === l && (h = !0);
                    var g = document.createElement("span");
                    g.classList.add("apexcharts-legend-marker");
                    var f = t.config.legend.markers.offsetX
                      , m = t.config.legend.markers.offsetY
                      , x = t.config.legend.markers.height
                      , y = t.config.legend.markers.width
                      , S = t.config.legend.markers.strokeWidth
                      , C = t.config.legend.markers.strokeColor
                      , A = t.config.legend.markers.radius
                      , P = g.style;
                    P.background = n[l],
                    P.color = n[l],
                    P.setProperty("background", n[l], "important"),
                    t.config.legend.markers.fillColors && t.config.legend.markers.fillColors[l] && (P.background = t.config.legend.markers.fillColors[l]),
                    void 0 !== t.globals.seriesColors[l] && (P.background = t.globals.seriesColors[l],
                    P.color = t.globals.seriesColors[l]),
                    P.height = Array.isArray(x) ? parseFloat(x[l]) + "px" : parseFloat(x) + "px",
                    P.width = Array.isArray(y) ? parseFloat(y[l]) + "px" : parseFloat(y) + "px",
                    P.left = (Array.isArray(f) ? parseFloat(f[l]) : parseFloat(f)) + "px",
                    P.top = (Array.isArray(m) ? parseFloat(m[l]) : parseFloat(m)) + "px",
                    P.borderWidth = Array.isArray(S) ? S[l] : S,
                    P.borderColor = Array.isArray(C) ? C[l] : C,
                    P.borderRadius = Array.isArray(A) ? parseFloat(A[l]) + "px" : parseFloat(A) + "px",
                    t.config.legend.markers.customHTML && (Array.isArray(t.config.legend.markers.customHTML) ? t.config.legend.markers.customHTML[l] && (g.innerHTML = t.config.legend.markers.customHTML[l]()) : g.innerHTML = t.config.legend.markers.customHTML()),
                    w.setAttrs(g, {
                        rel: l + 1,
                        "data:collapsed": d || h
                    }),
                    (d || h) && g.classList.add("apexcharts-inactive-legend");
                    var L = document.createElement("div")
                      , I = document.createElement("span");
                    I.classList.add("apexcharts-legend-text"),
                    I.innerHTML = Array.isArray(u) ? u.join(" ") : u;
                    var _ = t.config.legend.labels.useSeriesColors ? t.globals.colors[l] : Array.isArray(t.config.legend.labels.colors) ? null === (c = t.config.legend.labels.colors) || void 0 === c ? void 0 : c[l] : t.config.legend.labels.colors;
                    _ || (_ = t.config.chart.foreColor),
                    I.style.color = _,
                    I.style.fontSize = parseFloat(t.config.legend.fontSize) + "px",
                    I.style.fontWeight = t.config.legend.fontWeight,
                    I.style.fontFamily = a || t.config.chart.fontFamily,
                    w.setAttrs(I, {
                        rel: l + 1,
                        i: l,
                        "data:default-text": encodeURIComponent(u),
                        "data:collapsed": d || h
                    }),
                    L.appendChild(g),
                    L.appendChild(I);
                    var T = new k(this.ctx);
                    t.config.legend.showForZeroSeries || 0 === T.getSeriesTotalByIndex(l) && T.seriesHaveSameValues(l) && !T.isSeriesNull(l) && -1 === t.globals.collapsedSeriesIndices.indexOf(l) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && L.classList.add("apexcharts-hidden-zero-series"),
                    t.config.legend.showForNullSeries || T.isSeriesNull(l) && -1 === t.globals.collapsedSeriesIndices.indexOf(l) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && L.classList.add("apexcharts-hidden-null-series"),
                    t.globals.dom.elLegendWrap.appendChild(L),
                    t.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(t.config.legend.horizontalAlign)),
                    t.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + t.config.legend.position),
                    L.classList.add("apexcharts-legend-series"),
                    L.style.margin = "".concat(t.config.legend.itemMargin.vertical, "px ").concat(t.config.legend.itemMargin.horizontal, "px"),
                    t.globals.dom.elLegendWrap.style.width = t.config.legend.width ? t.config.legend.width + "px" : "",
                    t.globals.dom.elLegendWrap.style.height = t.config.legend.height ? t.config.legend.height + "px" : "",
                    w.setAttrs(L, {
                        rel: l + 1,
                        seriesName: b.escapeString(i[l]),
                        "data:collapsed": d || h
                    }),
                    (d || h) && L.classList.add("apexcharts-inactive-legend"),
                    t.config.legend.onItemClick.toggleDataSeries || L.classList.add("apexcharts-no-click")
                }
                t.globals.dom.elWrap.addEventListener("click", e.onLegendClick, !0),
                t.config.legend.onItemHover.highlightDataSeries && 0 === t.config.legend.customLegendItems.length && (t.globals.dom.elWrap.addEventListener("mousemove", e.onLegendHovered, !0),
                t.globals.dom.elWrap.addEventListener("mouseout", e.onLegendHovered, !0))
            }
        }, {
            key: "setLegendWrapXY",
            value: function(e, t) {
                var a = this.w
                  , i = a.globals.dom.elLegendWrap
                  , n = i.getBoundingClientRect()
                  , r = 0
                  , o = 0;
                if ("bottom" === a.config.legend.position)
                    o += a.globals.svgHeight - n.height / 2;
                else if ("top" === a.config.legend.position) {
                    var s = new le(this.ctx)
                      , l = s.dimHelpers.getTitleSubtitleCoords("title").height
                      , c = s.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                    o = o + (l > 0 ? l - 10 : 0) + (c > 0 ? c - 10 : 0)
                }
                i.style.position = "absolute",
                r = r + e + a.config.legend.offsetX,
                o = o + t + a.config.legend.offsetY,
                i.style.left = r + "px",
                i.style.top = o + "px",
                "bottom" === a.config.legend.position ? (i.style.top = "auto",
                i.style.bottom = 5 - a.config.legend.offsetY + "px") : "right" === a.config.legend.position && (i.style.left = "auto",
                i.style.right = 25 + a.config.legend.offsetX + "px"),
                ["width", "height"].forEach((function(e) {
                    i.style[e] && (i.style[e] = parseInt(a.config.legend[e], 10) + "px")
                }
                ))
            }
        }, {
            key: "legendAlignHorizontal",
            value: function() {
                var e = this.w;
                e.globals.dom.elLegendWrap.style.right = 0;
                var t = this.legendHelpers.getLegendBBox()
                  , a = new le(this.ctx)
                  , i = a.dimHelpers.getTitleSubtitleCoords("title")
                  , n = a.dimHelpers.getTitleSubtitleCoords("subtitle")
                  , r = 0;
                "bottom" === e.config.legend.position ? r = -t.clwh / 1.8 : "top" === e.config.legend.position && (r = i.height + n.height + e.config.title.margin + e.config.subtitle.margin - 10),
                this.setLegendWrapXY(20, r)
            }
        }, {
            key: "legendAlignVertical",
            value: function() {
                var e = this.w
                  , t = this.legendHelpers.getLegendBBox()
                  , a = 0;
                "left" === e.config.legend.position && (a = 20),
                "right" === e.config.legend.position && (a = e.globals.svgWidth - t.clww - 10),
                this.setLegendWrapXY(a, 20)
            }
        }, {
            key: "onLegendHovered",
            value: function(e) {
                var t = this.w
                  , a = e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker");
                if ("heatmap" === t.config.chart.type || this.isBarsDistributed) {
                    if (a) {
                        var i = parseInt(e.target.getAttribute("rel"), 10) - 1;
                        this.ctx.events.fireEvent("legendHover", [this.ctx, i, this.w]),
                        new X(this.ctx).highlightRangeInSeries(e, e.target)
                    }
                } else
                    !e.target.classList.contains("apexcharts-inactive-legend") && a && new X(this.ctx).toggleSeriesOnHover(e, e.target)
            }
        }, {
            key: "onLegendClick",
            value: function(e) {
                var t = this.w;
                if (!t.config.legend.customLegendItems.length && (e.target.classList.contains("apexcharts-legend-series") || e.target.classList.contains("apexcharts-legend-text") || e.target.classList.contains("apexcharts-legend-marker"))) {
                    var a = parseInt(e.target.getAttribute("rel"), 10) - 1
                      , i = "true" === e.target.getAttribute("data:collapsed")
                      , n = this.w.config.chart.events.legendClick;
                    "function" == typeof n && n(this.ctx, a, this.w),
                    this.ctx.events.fireEvent("legendClick", [this.ctx, a, this.w]);
                    var r = this.w.config.legend.markers.onClick;
                    "function" == typeof r && e.target.classList.contains("apexcharts-legend-marker") && (r(this.ctx, a, this.w),
                    this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, a, this.w])),
                    "treemap" !== t.config.chart.type && "heatmap" !== t.config.chart.type && !this.isBarsDistributed && t.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(a, i)
                }
            }
        }]),
        e
    }()
      , de = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w;
            var a = this.w;
            this.ev = this.w.config.chart.events,
            this.selectedClass = "apexcharts-selected",
            this.localeValues = this.w.globals.locale.toolbar,
            this.minX = a.globals.minX,
            this.maxX = a.globals.maxX
        }
        return s(e, [{
            key: "createToolbar",
            value: function() {
                var e = this
                  , t = this.w
                  , a = function() {
                    return document.createElement("div")
                }
                  , i = a();
                if (i.setAttribute("class", "apexcharts-toolbar"),
                i.style.top = t.config.chart.toolbar.offsetY + "px",
                i.style.right = 3 - t.config.chart.toolbar.offsetX + "px",
                t.globals.dom.elWrap.appendChild(i),
                this.elZoom = a(),
                this.elZoomIn = a(),
                this.elZoomOut = a(),
                this.elPan = a(),
                this.elSelection = a(),
                this.elZoomReset = a(),
                this.elMenuIcon = a(),
                this.elMenu = a(),
                this.elCustomIcons = [],
                this.t = t.config.chart.toolbar.tools,
                Array.isArray(this.t.customIcons))
                    for (var n = 0; n < this.t.customIcons.length; n++)
                        this.elCustomIcons.push(a());
                var r = []
                  , o = function(a, i, n) {
                    var o = a.toLowerCase();
                    e.t[o] && t.config.chart.zoom.enabled && r.push({
                        el: i,
                        icon: "string" == typeof e.t[o] ? e.t[o] : n,
                        title: e.localeValues[a],
                        class: "apexcharts-".concat(o, "-icon")
                    })
                };
                o("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'),
                o("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                var s = function(a) {
                    e.t[a] && t.config.chart[a].enabled && r.push({
                        el: "zoom" === a ? e.elZoom : e.elSelection,
                        icon: "string" == typeof e.t[a] ? e.t[a] : "zoom" === a ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                        title: e.localeValues["zoom" === a ? "selectionZoom" : "selection"],
                        class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(a, "-icon")
                    })
                };
                s("zoom"),
                s("selection"),
                this.t.pan && t.config.chart.zoom.enabled && r.push({
                    el: this.elPan,
                    icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                    title: this.localeValues.pan,
                    class: t.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                }),
                o("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'),
                this.t.download && r.push({
                    el: this.elMenuIcon,
                    icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                    title: this.localeValues.menu,
                    class: "apexcharts-menu-icon"
                });
                for (var l = 0; l < this.elCustomIcons.length; l++)
                    r.push({
                        el: this.elCustomIcons[l],
                        icon: this.t.customIcons[l].icon,
                        title: this.t.customIcons[l].title,
                        index: this.t.customIcons[l].index,
                        class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
                    });
                r.forEach((function(e, t) {
                    e.index && b.moveIndexInArray(r, t, e.index)
                }
                ));
                for (var c = 0; c < r.length; c++)
                    w.setAttrs(r[c].el, {
                        class: r[c].class,
                        title: r[c].title
                    }),
                    r[c].el.innerHTML = r[c].icon,
                    i.appendChild(r[c].el);
                this._createHamburgerMenu(i),
                t.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : t.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : t.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass),
                this.addToolbarEventListeners()
            }
        }, {
            key: "_createHamburgerMenu",
            value: function(e) {
                this.elMenuItems = [],
                e.appendChild(this.elMenu),
                w.setAttrs(this.elMenu, {
                    class: "apexcharts-menu"
                });
                for (var t = [{
                    name: "exportSVG",
                    title: this.localeValues.exportToSVG
                }, {
                    name: "exportPNG",
                    title: this.localeValues.exportToPNG
                }, {
                    name: "exportCSV",
                    title: this.localeValues.exportToCSV
                }], a = 0; a < t.length; a++)
                    this.elMenuItems.push(document.createElement("div")),
                    this.elMenuItems[a].innerHTML = t[a].title,
                    w.setAttrs(this.elMenuItems[a], {
                        class: "apexcharts-menu-item ".concat(t[a].name),
                        title: t[a].title
                    }),
                    this.elMenu.appendChild(this.elMenuItems[a])
            }
        }, {
            key: "addToolbarEventListeners",
            value: function() {
                var e = this;
                this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)),
                this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")),
                this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")),
                this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)),
                this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)),
                this.elPan.addEventListener("click", this.togglePanning.bind(this)),
                this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)),
                this.elMenuItems.forEach((function(t) {
                    t.classList.contains("exportSVG") ? t.addEventListener("click", e.handleDownload.bind(e, "svg")) : t.classList.contains("exportPNG") ? t.addEventListener("click", e.handleDownload.bind(e, "png")) : t.classList.contains("exportCSV") && t.addEventListener("click", e.handleDownload.bind(e, "csv"))
                }
                ));
                for (var t = 0; t < this.t.customIcons.length; t++)
                    this.elCustomIcons[t].addEventListener("click", this.t.customIcons[t].click.bind(this, this.ctx, this.ctx.w))
            }
        }, {
            key: "toggleZoomSelection",
            value: function(e) {
                this.ctx.getSyncedCharts().forEach((function(t) {
                    t.ctx.toolbar.toggleOtherControls();
                    var a = "selection" === e ? t.ctx.toolbar.elSelection : t.ctx.toolbar.elZoom
                      , i = "selection" === e ? "selectionEnabled" : "zoomEnabled";
                    t.w.globals[i] = !t.w.globals[i],
                    a.classList.contains(t.ctx.toolbar.selectedClass) ? a.classList.remove(t.ctx.toolbar.selectedClass) : a.classList.add(t.ctx.toolbar.selectedClass)
                }
                ))
            }
        }, {
            key: "getToolbarIconsReference",
            value: function() {
                var e = this.w;
                this.elZoom || (this.elZoom = e.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")),
                this.elPan || (this.elPan = e.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")),
                this.elSelection || (this.elSelection = e.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
            }
        }, {
            key: "enableZoomPanFromToolbar",
            value: function(e) {
                this.toggleOtherControls(),
                "pan" === e ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                var t = "pan" === e ? this.elPan : this.elZoom
                  , a = "pan" === e ? this.elZoom : this.elPan;
                t && t.classList.add(this.selectedClass),
                a && a.classList.remove(this.selectedClass)
            }
        }, {
            key: "togglePanning",
            value: function() {
                this.ctx.getSyncedCharts().forEach((function(e) {
                    e.ctx.toolbar.toggleOtherControls(),
                    e.w.globals.panEnabled = !e.w.globals.panEnabled,
                    e.ctx.toolbar.elPan.classList.contains(e.ctx.toolbar.selectedClass) ? e.ctx.toolbar.elPan.classList.remove(e.ctx.toolbar.selectedClass) : e.ctx.toolbar.elPan.classList.add(e.ctx.toolbar.selectedClass)
                }
                ))
            }
        }, {
            key: "toggleOtherControls",
            value: function() {
                var e = this
                  , t = this.w;
                t.globals.panEnabled = !1,
                t.globals.zoomEnabled = !1,
                t.globals.selectionEnabled = !1,
                this.getToolbarIconsReference(),
                [this.elPan, this.elSelection, this.elZoom].forEach((function(t) {
                    t && t.classList.remove(e.selectedClass)
                }
                ))
            }
        }, {
            key: "handleZoomIn",
            value: function() {
                var e = this.w;
                e.globals.isRangeBar && (this.minX = e.globals.minY,
                this.maxX = e.globals.maxY);
                var t = (this.minX + this.maxX) / 2
                  , a = (this.minX + t) / 2
                  , i = (this.maxX + t) / 2
                  , n = this._getNewMinXMaxX(a, i);
                e.globals.disableZoomIn || this.zoomUpdateOptions(n.minX, n.maxX)
            }
        }, {
            key: "handleZoomOut",
            value: function() {
                var e = this.w;
                if (e.globals.isRangeBar && (this.minX = e.globals.minY,
                this.maxX = e.globals.maxY),
                !("datetime" === e.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
                    var t = (this.minX + this.maxX) / 2
                      , a = this.minX - (t - this.minX)
                      , i = this.maxX - (t - this.maxX)
                      , n = this._getNewMinXMaxX(a, i);
                    e.globals.disableZoomOut || this.zoomUpdateOptions(n.minX, n.maxX)
                }
            }
        }, {
            key: "_getNewMinXMaxX",
            value: function(e, t) {
                var a = this.w.config.xaxis.convertedCatToNumeric;
                return {
                    minX: a ? Math.floor(e) : e,
                    maxX: a ? Math.floor(t) : t
                }
            }
        }, {
            key: "zoomUpdateOptions",
            value: function(e, t) {
                var a = this.w;
                if (void 0 !== e || void 0 !== t) {
                    if (!(a.config.xaxis.convertedCatToNumeric && (e < 1 && (e = 1,
                    t = a.globals.dataPoints),
                    t - e < 2))) {
                        var i = {
                            min: e,
                            max: t
                        }
                          , n = this.getBeforeZoomRange(i);
                        n && (i = n.xaxis);
                        var r = {
                            xaxis: i
                        }
                          , o = b.clone(a.globals.initialConfig.yaxis);
                        a.config.chart.zoom.autoScaleYaxis && (o = new U(this.ctx).autoScaleY(this.ctx, o, {
                            xaxis: i
                        })),
                        a.config.chart.group || (r.yaxis = o),
                        this.w.globals.zoomed = !0,
                        this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled),
                        this.zoomCallback(i, o)
                    }
                } else
                    this.handleZoomReset()
            }
        }, {
            key: "zoomCallback",
            value: function(e, t) {
                "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
                    xaxis: e,
                    yaxis: t
                })
            }
        }, {
            key: "getBeforeZoomRange",
            value: function(e, t) {
                var a = null;
                return "function" == typeof this.ev.beforeZoom && (a = this.ev.beforeZoom(this, {
                    xaxis: e,
                    yaxis: t
                })),
                a
            }
        }, {
            key: "toggleMenu",
            value: function() {
                var e = this;
                window.setTimeout((function() {
                    e.elMenu.classList.contains("apexcharts-menu-open") ? e.elMenu.classList.remove("apexcharts-menu-open") : e.elMenu.classList.add("apexcharts-menu-open")
                }
                ), 0)
            }
        }, {
            key: "handleDownload",
            value: function(e) {
                var t = this.w
                  , a = new G(this.ctx);
                switch (e) {
                case "svg":
                    a.exportToSVG(this.ctx);
                    break;
                case "png":
                    a.exportToPng(this.ctx);
                    break;
                case "csv":
                    a.exportToCSV({
                        series: t.config.series,
                        columnDelimiter: t.config.chart.toolbar.export.csv.columnDelimiter
                    })
                }
            }
        }, {
            key: "handleZoomReset",
            value: function(e) {
                this.ctx.getSyncedCharts().forEach((function(e) {
                    var t = e.w;
                    if (t.globals.lastXAxis.min = t.globals.initialConfig.xaxis.min,
                    t.globals.lastXAxis.max = t.globals.initialConfig.xaxis.max,
                    e.updateHelpers.revertDefaultAxisMinMax(),
                    "function" == typeof t.config.chart.events.beforeResetZoom) {
                        var a = t.config.chart.events.beforeResetZoom(e, t);
                        a && e.updateHelpers.revertDefaultAxisMinMax(a)
                    }
                    "function" == typeof t.config.chart.events.zoomed && e.ctx.toolbar.zoomCallback({
                        min: t.config.xaxis.min,
                        max: t.config.xaxis.max
                    }),
                    t.globals.zoomed = !1;
                    var i = e.ctx.series.emptyCollapsedSeries(b.clone(t.globals.initialSeries));
                    e.updateHelpers._updateSeries(i, t.config.chart.animations.dynamicAnimation.enabled)
                }
                ))
            }
        }, {
            key: "destroy",
            value: function() {
                this.elZoom = null,
                this.elZoomIn = null,
                this.elZoomOut = null,
                this.elPan = null,
                this.elSelection = null,
                this.elZoomReset = null,
                this.elMenuIcon = null
            }
        }]),
        e
    }()
      , he = function() {
        c(t, de);
        var e = p(t);
        function t(a) {
            var i;
            return r(this, t),
            (i = e.call(this, a)).ctx = a,
            i.w = a.w,
            i.dragged = !1,
            i.graphics = new w(i.ctx),
            i.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"],
            i.clientX = 0,
            i.clientY = 0,
            i.startX = 0,
            i.endX = 0,
            i.dragX = 0,
            i.startY = 0,
            i.endY = 0,
            i.dragY = 0,
            i.moveDirection = "none",
            i
        }
        return s(t, [{
            key: "init",
            value: function(e) {
                var t = this
                  , a = e.xyRatios
                  , i = this.w
                  , n = this;
                this.xyRatios = a,
                this.zoomRect = this.graphics.drawRect(0, 0, 0, 0),
                this.selectionRect = this.graphics.drawRect(0, 0, 0, 0),
                this.gridRect = i.globals.dom.baseEl.querySelector(".apexcharts-grid"),
                this.zoomRect.node.classList.add("apexcharts-zoom-rect"),
                this.selectionRect.node.classList.add("apexcharts-selection-rect"),
                i.globals.dom.elGraphical.add(this.zoomRect),
                i.globals.dom.elGraphical.add(this.selectionRect),
                "x" === i.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                    minX: 0,
                    minY: 0,
                    maxX: i.globals.gridWidth,
                    maxY: i.globals.gridHeight
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === i.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                    minX: 0,
                    maxX: i.globals.gridWidth
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")),
                this.preselectedSelection(),
                this.hoverArea = i.globals.dom.baseEl.querySelector("".concat(i.globals.chartClass, " .apexcharts-svg")),
                this.hoverArea.classList.add("apexcharts-zoomable"),
                this.eventList.forEach((function(e) {
                    t.hoverArea.addEventListener(e, n.svgMouseEvents.bind(n, a), {
                        capture: !1,
                        passive: !0
                    })
                }
                ))
            }
        }, {
            key: "destroy",
            value: function() {
                this.slDraggableRect && (this.slDraggableRect.draggable(!1),
                this.slDraggableRect.off(),
                this.selectionRect.off()),
                this.selectionRect = null,
                this.zoomRect = null,
                this.gridRect = null
            }
        }, {
            key: "svgMouseEvents",
            value: function(e, t) {
                var a = this.w
                  , i = this
                  , n = this.ctx.toolbar
                  , r = a.globals.zoomEnabled ? a.config.chart.zoom.type : a.config.chart.selection.type
                  , o = a.config.chart.toolbar.autoSelected;
                if (t.shiftKey ? (this.shiftWasPressed = !0,
                n.enableZoomPanFromToolbar("pan" === o ? "zoom" : "pan")) : this.shiftWasPressed && (n.enableZoomPanFromToolbar(o),
                this.shiftWasPressed = !1),
                t.target) {
                    var s, l = t.target.classList;
                    if (t.target.parentNode && null !== t.target.parentNode && (s = t.target.parentNode.classList),
                    !(l.contains("apexcharts-selection-rect") || l.contains("apexcharts-legend-marker") || l.contains("apexcharts-legend-text") || s && s.contains("apexcharts-toolbar"))) {
                        if (i.clientX = "touchmove" === t.type || "touchstart" === t.type ? t.touches[0].clientX : "touchend" === t.type ? t.changedTouches[0].clientX : t.clientX,
                        i.clientY = "touchmove" === t.type || "touchstart" === t.type ? t.touches[0].clientY : "touchend" === t.type ? t.changedTouches[0].clientY : t.clientY,
                        "mousedown" === t.type && 1 === t.which) {
                            var c = i.gridRect.getBoundingClientRect();
                            i.startX = i.clientX - c.left,
                            i.startY = i.clientY - c.top,
                            i.dragged = !1,
                            i.w.globals.mousedown = !0
                        }
                        if (("mousemove" === t.type && 1 === t.which || "touchmove" === t.type) && (i.dragged = !0,
                        a.globals.panEnabled ? (a.globals.selection = null,
                        i.w.globals.mousedown && i.panDragging({
                            context: i,
                            zoomtype: r,
                            xyRatios: e
                        })) : (i.w.globals.mousedown && a.globals.zoomEnabled || i.w.globals.mousedown && a.globals.selectionEnabled) && (i.selection = i.selectionDrawing({
                            context: i,
                            zoomtype: r
                        }))),
                        "mouseup" === t.type || "touchend" === t.type || "mouseleave" === t.type) {
                            var u = i.gridRect.getBoundingClientRect();
                            i.w.globals.mousedown && (i.endX = i.clientX - u.left,
                            i.endY = i.clientY - u.top,
                            i.dragX = Math.abs(i.endX - i.startX),
                            i.dragY = Math.abs(i.endY - i.startY),
                            (a.globals.zoomEnabled || a.globals.selectionEnabled) && i.selectionDrawn({
                                context: i,
                                zoomtype: r
                            }),
                            a.globals.panEnabled && a.config.xaxis.convertedCatToNumeric && i.delayedPanScrolled()),
                            a.globals.zoomEnabled && i.hideSelectionRect(this.selectionRect),
                            i.dragged = !1,
                            i.w.globals.mousedown = !1
                        }
                        this.makeSelectionRectDraggable()
                    }
                }
            }
        }, {
            key: "makeSelectionRectDraggable",
            value: function() {
                var e = this.w;
                if (this.selectionRect) {
                    var t = this.selectionRect.node.getBoundingClientRect();
                    t.width > 0 && t.height > 0 && this.slDraggableRect.selectize({
                        points: "l, r",
                        pointSize: 8,
                        pointType: "rect"
                    }).resize({
                        constraint: {
                            minX: 0,
                            minY: 0,
                            maxX: e.globals.gridWidth,
                            maxY: e.globals.gridHeight
                        }
                    }).on("resizing", this.selectionDragging.bind(this, "resizing"))
                }
            }
        }, {
            key: "preselectedSelection",
            value: function() {
                var e = this.w
                  , t = this.xyRatios;
                if (!e.globals.zoomEnabled)
                    if (void 0 !== e.globals.selection && null !== e.globals.selection)
                        this.drawSelectionRect(e.globals.selection);
                    else if (void 0 !== e.config.chart.selection.xaxis.min && void 0 !== e.config.chart.selection.xaxis.max) {
                        var a = (e.config.chart.selection.xaxis.min - e.globals.minX) / t.xRatio
                          , i = e.globals.gridWidth - (e.globals.maxX - e.config.chart.selection.xaxis.max) / t.xRatio - a;
                        e.globals.isRangeBar && (a = (e.config.chart.selection.xaxis.min - e.globals.yAxisScale[0].niceMin) / t.invertedYRatio,
                        i = (e.config.chart.selection.xaxis.max - e.config.chart.selection.xaxis.min) / t.invertedYRatio);
                        var n = {
                            x: a,
                            y: 0,
                            width: i,
                            height: e.globals.gridHeight,
                            translateX: 0,
                            translateY: 0,
                            selectionEnabled: !0
                        };
                        this.drawSelectionRect(n),
                        this.makeSelectionRectDraggable(),
                        "function" == typeof e.config.chart.events.selection && e.config.chart.events.selection(this.ctx, {
                            xaxis: {
                                min: e.config.chart.selection.xaxis.min,
                                max: e.config.chart.selection.xaxis.max
                            },
                            yaxis: {}
                        })
                    }
            }
        }, {
            key: "drawSelectionRect",
            value: function(e) {
                var t = e.x
                  , a = e.y
                  , i = e.width
                  , n = e.height
                  , r = e.translateX
                  , o = void 0 === r ? 0 : r
                  , s = e.translateY
                  , l = void 0 === s ? 0 : s
                  , c = this.w
                  , u = this.zoomRect
                  , d = this.selectionRect;
                if (this.dragged || null !== c.globals.selection) {
                    var h = {
                        transform: "translate(" + o + ", " + l + ")"
                    };
                    c.globals.zoomEnabled && this.dragged && (i < 0 && (i = 1),
                    u.attr({
                        x: t,
                        y: a,
                        width: i,
                        height: n,
                        fill: c.config.chart.zoom.zoomedArea.fill.color,
                        "fill-opacity": c.config.chart.zoom.zoomedArea.fill.opacity,
                        stroke: c.config.chart.zoom.zoomedArea.stroke.color,
                        "stroke-width": c.config.chart.zoom.zoomedArea.stroke.width,
                        "stroke-opacity": c.config.chart.zoom.zoomedArea.stroke.opacity
                    }),
                    w.setAttrs(u.node, h)),
                    c.globals.selectionEnabled && (d.attr({
                        x: t,
                        y: a,
                        width: i > 0 ? i : 0,
                        height: n > 0 ? n : 0,
                        fill: c.config.chart.selection.fill.color,
                        "fill-opacity": c.config.chart.selection.fill.opacity,
                        stroke: c.config.chart.selection.stroke.color,
                        "stroke-width": c.config.chart.selection.stroke.width,
                        "stroke-dasharray": c.config.chart.selection.stroke.dashArray,
                        "stroke-opacity": c.config.chart.selection.stroke.opacity
                    }),
                    w.setAttrs(d.node, h))
                }
            }
        }, {
            key: "hideSelectionRect",
            value: function(e) {
                e && e.attr({
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                })
            }
        }, {
            key: "selectionDrawing",
            value: function(e) {
                var t, a = e.context, i = e.zoomtype, n = this.w, r = a, o = this.gridRect.getBoundingClientRect(), s = r.startX - 1, l = r.startY, c = !1, u = !1, d = r.clientX - o.left - s, h = r.clientY - o.top - l;
                return Math.abs(d + s) > n.globals.gridWidth ? d = n.globals.gridWidth - s : r.clientX - o.left < 0 && (d = s),
                s > r.clientX - o.left && (c = !0,
                d = Math.abs(d)),
                l > r.clientY - o.top && (u = !0,
                h = Math.abs(h)),
                t = "x" === i ? {
                    x: c ? s - d : s,
                    y: 0,
                    width: d,
                    height: n.globals.gridHeight
                } : "y" === i ? {
                    x: 0,
                    y: u ? l - h : l,
                    width: n.globals.gridWidth,
                    height: h
                } : {
                    x: c ? s - d : s,
                    y: u ? l - h : l,
                    width: d,
                    height: h
                },
                r.drawSelectionRect(t),
                r.selectionDragging("resizing"),
                t
            }
        }, {
            key: "selectionDragging",
            value: function(e, t) {
                var a = this
                  , i = this.w
                  , n = this.xyRatios
                  , r = this.selectionRect
                  , o = 0;
                "resizing" === e && (o = 30);
                var s = function(e) {
                    return parseFloat(r.node.getAttribute(e))
                }
                  , l = {
                    x: s("x"),
                    y: s("y"),
                    width: s("width"),
                    height: s("height")
                };
                i.globals.selection = l,
                "function" == typeof i.config.chart.events.selection && i.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer),
                this.w.globals.selectionResizeTimer = window.setTimeout((function() {
                    var e, t, o, s, l = a.gridRect.getBoundingClientRect(), c = r.node.getBoundingClientRect();
                    i.globals.isRangeBar ? (e = i.globals.yAxisScale[0].niceMin + (c.left - l.left) * n.invertedYRatio,
                    t = i.globals.yAxisScale[0].niceMin + (c.right - l.left) * n.invertedYRatio,
                    o = 0,
                    s = 1) : (e = i.globals.xAxisScale.niceMin + (c.left - l.left) * n.xRatio,
                    t = i.globals.xAxisScale.niceMin + (c.right - l.left) * n.xRatio,
                    o = i.globals.yAxisScale[0].niceMin + (l.bottom - c.bottom) * n.yRatio[0],
                    s = i.globals.yAxisScale[0].niceMax - (c.top - l.top) * n.yRatio[0]);
                    var u = {
                        xaxis: {
                            min: e,
                            max: t
                        },
                        yaxis: {
                            min: o,
                            max: s
                        }
                    };
                    i.config.chart.events.selection(a.ctx, u),
                    i.config.chart.brush.enabled && void 0 !== i.config.chart.events.brushScrolled && i.config.chart.events.brushScrolled(a.ctx, u)
                }
                ), o))
            }
        }, {
            key: "selectionDrawn",
            value: function(e) {
                var t = e.context
                  , a = e.zoomtype
                  , i = this.w
                  , n = t
                  , r = this.xyRatios
                  , o = this.ctx.toolbar;
                if (n.startX > n.endX) {
                    var s = n.startX;
                    n.startX = n.endX,
                    n.endX = s
                }
                if (n.startY > n.endY) {
                    var l = n.startY;
                    n.startY = n.endY,
                    n.endY = l
                }
                var c = void 0
                  , u = void 0;
                i.globals.isRangeBar ? (c = i.globals.yAxisScale[0].niceMin + n.startX * r.invertedYRatio,
                u = i.globals.yAxisScale[0].niceMin + n.endX * r.invertedYRatio) : (c = i.globals.xAxisScale.niceMin + n.startX * r.xRatio,
                u = i.globals.xAxisScale.niceMin + n.endX * r.xRatio);
                var d = []
                  , h = [];
                if (i.config.yaxis.forEach((function(e, t) {
                    d.push(i.globals.yAxisScale[t].niceMax - r.yRatio[t] * n.startY),
                    h.push(i.globals.yAxisScale[t].niceMax - r.yRatio[t] * n.endY)
                }
                )),
                n.dragged && (n.dragX > 10 || n.dragY > 10) && c !== u)
                    if (i.globals.zoomEnabled) {
                        var p = b.clone(i.globals.initialConfig.yaxis)
                          , v = b.clone(i.globals.initialConfig.xaxis);
                        if (i.globals.zoomed = !0,
                        i.config.xaxis.convertedCatToNumeric && (c = Math.floor(c),
                        u = Math.floor(u),
                        c < 1 && (c = 1,
                        u = i.globals.dataPoints),
                        u - c < 2 && (u = c + 1)),
                        "xy" !== a && "x" !== a || (v = {
                            min: c,
                            max: u
                        }),
                        "xy" !== a && "y" !== a || p.forEach((function(e, t) {
                            p[t].min = h[t],
                            p[t].max = d[t]
                        }
                        )),
                        i.config.chart.zoom.autoScaleYaxis) {
                            var g = new U(n.ctx);
                            p = g.autoScaleY(n.ctx, p, {
                                xaxis: v
                            })
                        }
                        if (o) {
                            var f = o.getBeforeZoomRange(v, p);
                            f && (v = f.xaxis ? f.xaxis : v,
                            p = f.yaxis ? f.yaxis : p)
                        }
                        var m = {
                            xaxis: v
                        };
                        i.config.chart.group || (m.yaxis = p),
                        n.ctx.updateHelpers._updateOptions(m, !1, n.w.config.chart.animations.dynamicAnimation.enabled),
                        "function" == typeof i.config.chart.events.zoomed && o.zoomCallback(v, p)
                    } else if (i.globals.selectionEnabled) {
                        var x, y = null;
                        x = {
                            min: c,
                            max: u
                        },
                        "xy" !== a && "y" !== a || (y = b.clone(i.config.yaxis)).forEach((function(e, t) {
                            y[t].min = h[t],
                            y[t].max = d[t]
                        }
                        )),
                        i.globals.selection = n.selection,
                        "function" == typeof i.config.chart.events.selection && i.config.chart.events.selection(n.ctx, {
                            xaxis: x,
                            yaxis: y
                        })
                    }
            }
        }, {
            key: "panDragging",
            value: function(e) {
                var t = e.context
                  , a = this.w
                  , i = t;
                if (void 0 !== a.globals.lastClientPosition.x) {
                    var n = a.globals.lastClientPosition.x - i.clientX
                      , r = a.globals.lastClientPosition.y - i.clientY;
                    Math.abs(n) > Math.abs(r) && n > 0 ? this.moveDirection = "left" : Math.abs(n) > Math.abs(r) && n < 0 ? this.moveDirection = "right" : Math.abs(r) > Math.abs(n) && r > 0 ? this.moveDirection = "up" : Math.abs(r) > Math.abs(n) && r < 0 && (this.moveDirection = "down")
                }
                a.globals.lastClientPosition = {
                    x: i.clientX,
                    y: i.clientY
                };
                var o = a.globals.isRangeBar ? a.globals.minY : a.globals.minX
                  , s = a.globals.isRangeBar ? a.globals.maxY : a.globals.maxX;
                a.config.xaxis.convertedCatToNumeric || i.panScrolled(o, s)
            }
        }, {
            key: "delayedPanScrolled",
            value: function() {
                var e = this.w
                  , t = e.globals.minX
                  , a = e.globals.maxX
                  , i = (e.globals.maxX - e.globals.minX) / 2;
                "left" === this.moveDirection ? (t = e.globals.minX + i,
                a = e.globals.maxX + i) : "right" === this.moveDirection && (t = e.globals.minX - i,
                a = e.globals.maxX - i),
                t = Math.floor(t),
                a = Math.floor(a),
                this.updateScrolledChart({
                    xaxis: {
                        min: t,
                        max: a
                    }
                }, t, a)
            }
        }, {
            key: "panScrolled",
            value: function(e, t) {
                var a = this.w
                  , i = this.xyRatios
                  , n = b.clone(a.globals.initialConfig.yaxis)
                  , r = i.xRatio
                  , o = a.globals.minX
                  , s = a.globals.maxX;
                a.globals.isRangeBar && (r = i.invertedYRatio,
                o = a.globals.minY,
                s = a.globals.maxY),
                "left" === this.moveDirection ? (e = o + a.globals.gridWidth / 15 * r,
                t = s + a.globals.gridWidth / 15 * r) : "right" === this.moveDirection && (e = o - a.globals.gridWidth / 15 * r,
                t = s - a.globals.gridWidth / 15 * r),
                a.globals.isRangeBar || (e < a.globals.initialMinX || t > a.globals.initialMaxX) && (e = o,
                t = s);
                var l = {
                    min: e,
                    max: t
                };
                a.config.chart.zoom.autoScaleYaxis && (n = new U(this.ctx).autoScaleY(this.ctx, n, {
                    xaxis: l
                }));
                var c = {
                    xaxis: {
                        min: e,
                        max: t
                    }
                };
                a.config.chart.group || (c.yaxis = n),
                this.updateScrolledChart(c, e, t)
            }
        }, {
            key: "updateScrolledChart",
            value: function(e, t, a) {
                var i = this.w;
                this.ctx.updateHelpers._updateOptions(e, !1, !1),
                "function" == typeof i.config.chart.events.scrolled && i.config.chart.events.scrolled(this.ctx, {
                    xaxis: {
                        min: t,
                        max: a
                    }
                })
            }
        }]),
        t
    }()
      , pe = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.ttCtx = t,
            this.ctx = t.ctx
        }
        return s(e, [{
            key: "getNearestValues",
            value: function(e) {
                var t = e.hoverArea
                  , a = e.elGrid
                  , i = e.clientX
                  , n = e.clientY
                  , r = this.w
                  , o = a.getBoundingClientRect()
                  , s = o.width
                  , l = o.height
                  , c = s / (r.globals.dataPoints - 1)
                  , u = l / r.globals.dataPoints
                  , d = this.hasBars();
                !r.globals.comboCharts && !d || r.config.xaxis.convertedCatToNumeric || (c = s / r.globals.dataPoints);
                var h = i - o.left - r.globals.barPadForNumericAxis
                  , p = n - o.top;
                h < 0 || p < 0 || h > s || p > l ? (t.classList.remove("hovering-zoom"),
                t.classList.remove("hovering-pan")) : r.globals.zoomEnabled ? (t.classList.remove("hovering-pan"),
                t.classList.add("hovering-zoom")) : r.globals.panEnabled && (t.classList.remove("hovering-zoom"),
                t.classList.add("hovering-pan"));
                var v = Math.round(h / c)
                  , g = Math.floor(p / u);
                d && !r.config.xaxis.convertedCatToNumeric && (v = Math.ceil(h / c),
                v -= 1);
                var f = null
                  , m = null
                  , x = r.globals.seriesXvalues.map((function(e) {
                    return e.filter((function(e) {
                        return b.isNumber(e)
                    }
                    ))
                }
                ))
                  , y = r.globals.seriesYvalues.map((function(e) {
                    return e.filter((function(e) {
                        return b.isNumber(e)
                    }
                    ))
                }
                ));
                if (r.globals.isXNumeric) {
                    var w = this.ttCtx.getElGrid().getBoundingClientRect()
                      , k = h * (w.width / s)
                      , S = p * (w.height / l);
                    f = (m = this.closestInMultiArray(k, S, x, y)).index,
                    v = m.j,
                    null !== f && (x = r.globals.seriesXvalues[f],
                    v = (m = this.closestInArray(k, x)).index)
                }
                return r.globals.capturedSeriesIndex = null === f ? -1 : f,
                (!v || v < 1) && (v = 0),
                r.globals.isBarHorizontal ? r.globals.capturedDataPointIndex = g : r.globals.capturedDataPointIndex = v,
                {
                    capturedSeries: f,
                    j: r.globals.isBarHorizontal ? g : v,
                    hoverX: h,
                    hoverY: p
                }
            }
        }, {
            key: "closestInMultiArray",
            value: function(e, t, a, i) {
                var n = this.w
                  , r = 0
                  , o = null
                  , s = -1;
                n.globals.series.length > 1 ? r = this.getFirstActiveXArray(a) : o = 0;
                var l = a[r][0]
                  , c = Math.abs(e - l);
                if (a.forEach((function(t) {
                    t.forEach((function(t, a) {
                        var i = Math.abs(e - t);
                        i <= c && (c = i,
                        s = a)
                    }
                    ))
                }
                )),
                -1 !== s) {
                    var u = i[r][s]
                      , d = Math.abs(t - u);
                    o = r,
                    i.forEach((function(e, a) {
                        var i = Math.abs(t - e[s]);
                        i <= d && (d = i,
                        o = a)
                    }
                    ))
                }
                return {
                    index: o,
                    j: s
                }
            }
        }, {
            key: "getFirstActiveXArray",
            value: function(e) {
                for (var t = this.w, a = 0, i = e.map((function(e, t) {
                    return e.length > 0 ? t : -1
                }
                )), n = 0; n < i.length; n++)
                    if (-1 !== i[n] && -1 === t.globals.collapsedSeriesIndices.indexOf(n) && -1 === t.globals.ancillaryCollapsedSeriesIndices.indexOf(n)) {
                        a = i[n];
                        break
                    }
                return a
            }
        }, {
            key: "closestInArray",
            value: function(e, t) {
                for (var a = t[0], i = null, n = Math.abs(e - a), r = 0; r < t.length; r++) {
                    var o = Math.abs(e - t[r]);
                    o < n && (n = o,
                    i = r)
                }
                return {
                    index: i
                }
            }
        }, {
            key: "isXoverlap",
            value: function(e) {
                var t = []
                  , a = this.w.globals.seriesX.filter((function(e) {
                    return void 0 !== e[0]
                }
                ));
                if (a.length > 0)
                    for (var i = 0; i < a.length - 1; i++)
                        void 0 !== a[i][e] && void 0 !== a[i + 1][e] && a[i][e] !== a[i + 1][e] && t.push("unEqual");
                return 0 === t.length
            }
        }, {
            key: "isInitialSeriesSameLen",
            value: function() {
                for (var e = !0, t = this.w.globals.initialSeries, a = 0; a < t.length - 1; a++)
                    if (t[a].data.length !== t[a + 1].data.length) {
                        e = !1;
                        break
                    }
                return e
            }
        }, {
            key: "getBarsHeight",
            value: function(e) {
                return g(e).reduce((function(e, t) {
                    return e + t.getBBox().height
                }
                ), 0)
            }
        }, {
            key: "getElMarkers",
            value: function(e) {
                return "number" == typeof e ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *")
            }
        }, {
            key: "getAllMarkers",
            value: function() {
                var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                (e = g(e)).sort((function(e, t) {
                    var a = Number(e.getAttribute("data:realIndex"))
                      , i = Number(t.getAttribute("data:realIndex"));
                    return i < a ? 1 : i > a ? -1 : 0
                }
                ));
                var t = [];
                return e.forEach((function(e) {
                    t.push(e.querySelector(".apexcharts-marker"))
                }
                )),
                t
            }
        }, {
            key: "hasMarkers",
            value: function(e) {
                return this.getElMarkers(e).length > 0
            }
        }, {
            key: "getElBars",
            value: function() {
                return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
            }
        }, {
            key: "hasBars",
            value: function() {
                return this.getElBars().length > 0
            }
        }, {
            key: "getHoverMarkerSize",
            value: function(e) {
                var t = this.w
                  , a = t.config.markers.hover.size;
                return void 0 === a && (a = t.globals.markers.size[e] + t.config.markers.hover.sizeOffset),
                a
            }
        }, {
            key: "toggleAllTooltipSeriesGroups",
            value: function(e) {
                var t = this.w
                  , a = this.ttCtx;
                0 === a.allTooltipSeriesGroups.length && (a.allTooltipSeriesGroups = t.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                for (var i = a.allTooltipSeriesGroups, n = 0; n < i.length; n++)
                    "enable" === e ? (i[n].classList.add("apexcharts-active"),
                    i[n].style.display = t.config.tooltip.items.display) : (i[n].classList.remove("apexcharts-active"),
                    i[n].style.display = "none")
            }
        }]),
        e
    }()
      , ve = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.ctx = t.ctx,
            this.ttCtx = t,
            this.tooltipUtil = new pe(t)
        }
        return s(e, [{
            key: "drawSeriesTexts",
            value: function(e) {
                var t = e.shared
                  , a = void 0 === t || t
                  , i = e.ttItems
                  , n = e.i
                  , r = void 0 === n ? 0 : n
                  , o = e.j
                  , s = void 0 === o ? null : o
                  , l = e.y1
                  , c = e.y2
                  , u = e.e
                  , d = this.w;
                void 0 !== d.config.tooltip.custom ? this.handleCustomTooltip({
                    i: r,
                    j: s,
                    y1: l,
                    y2: c,
                    w: d
                }) : this.toggleActiveInactiveSeries(a);
                var h = this.getValuesToPrint({
                    i: r,
                    j: s
                });
                this.printLabels({
                    i: r,
                    j: s,
                    values: h,
                    ttItems: i,
                    shared: a,
                    e: u
                });
                var p = this.ttCtx.getElTooltip();
                this.ttCtx.tooltipRect.ttWidth = p.getBoundingClientRect().width,
                this.ttCtx.tooltipRect.ttHeight = p.getBoundingClientRect().height
            }
        }, {
            key: "printLabels",
            value: function(e) {
                var t, a = this, n = e.i, r = e.j, o = e.values, s = e.ttItems, l = e.shared, c = e.e, u = this.w, d = [], h = function(e) {
                    return u.globals.seriesGoals[e] && u.globals.seriesGoals[e][r] && Array.isArray(u.globals.seriesGoals[e][r])
                }, p = o.xVal, v = o.zVal, g = o.xAxisTTVal, f = "", m = u.globals.colors[n];
                null !== r && u.config.plotOptions.bar.distributed && (m = u.globals.colors[r]);
                for (var b = function(e, o) {
                    var b = a.getFormatters(n);
                    f = a.getSeriesName({
                        fn: b.yLbTitleFormatter,
                        index: n,
                        seriesIndex: n,
                        j: r
                    }),
                    "treemap" === u.config.chart.type && (f = b.yLbTitleFormatter(String(u.config.series[n].data[r].x), {
                        series: u.globals.series,
                        seriesIndex: n,
                        dataPointIndex: r,
                        w: u
                    }));
                    var x = u.config.tooltip.inverseOrder ? o : e;
                    if (u.globals.axisCharts) {
                        var y = function(e) {
                            var t, a, i, n;
                            return u.globals.isRangeData ? b.yLbFormatter(null === (t = u.globals.seriesRangeStart) || void 0 === t || null === (a = t[e]) || void 0 === a ? void 0 : a[r], {
                                series: u.globals.seriesRangeStart,
                                seriesIndex: e,
                                dataPointIndex: r,
                                w: u
                            }) + " - " + b.yLbFormatter(null === (i = u.globals.seriesRangeEnd) || void 0 === i || null === (n = i[e]) || void 0 === n ? void 0 : n[r], {
                                series: u.globals.seriesRangeEnd,
                                seriesIndex: e,
                                dataPointIndex: r,
                                w: u
                            }) : b.yLbFormatter(u.globals.series[e][r], {
                                series: u.globals.series,
                                seriesIndex: e,
                                dataPointIndex: r,
                                w: u
                            })
                        };
                        if (l)
                            b = a.getFormatters(x),
                            f = a.getSeriesName({
                                fn: b.yLbTitleFormatter,
                                index: x,
                                seriesIndex: n,
                                j: r
                            }),
                            m = u.globals.colors[x],
                            t = y(x),
                            h(x) && (d = u.globals.seriesGoals[x][r].map((function(e) {
                                return {
                                    attrs: e,
                                    val: b.yLbFormatter(e.value, {
                                        seriesIndex: x,
                                        dataPointIndex: r,
                                        w: u
                                    })
                                }
                            }
                            )));
                        else {
                            var w, k = null == c || null === (w = c.target) || void 0 === w ? void 0 : w.getAttribute("fill");
                            k && (m = -1 !== k.indexOf("url") ? document.querySelector(k.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : k),
                            t = y(n),
                            h(n) && Array.isArray(u.globals.seriesGoals[n][r]) && (d = u.globals.seriesGoals[n][r].map((function(e) {
                                return {
                                    attrs: e,
                                    val: b.yLbFormatter(e.value, {
                                        seriesIndex: n,
                                        dataPointIndex: r,
                                        w: u
                                    })
                                }
                            }
                            )))
                        }
                    }
                    null === r && (t = b.yLbFormatter(u.globals.series[n], i(i({}, u), {}, {
                        seriesIndex: n,
                        dataPointIndex: n
                    }))),
                    a.DOMHandling({
                        i: n,
                        t: x,
                        j: r,
                        ttItems: s,
                        values: {
                            val: t,
                            goalVals: d,
                            xVal: p,
                            xAxisTTVal: g,
                            zVal: v
                        },
                        seriesName: f,
                        shared: l,
                        pColor: m
                    })
                }, x = 0, y = u.globals.series.length - 1; x < u.globals.series.length; x++,
                y--)
                    b(x, y)
            }
        }, {
            key: "getFormatters",
            value: function(e) {
                var t, a = this.w, i = a.globals.yLabelFormatters[e];
                return void 0 !== a.globals.ttVal ? Array.isArray(a.globals.ttVal) ? (i = a.globals.ttVal[e] && a.globals.ttVal[e].formatter,
                t = a.globals.ttVal[e] && a.globals.ttVal[e].title && a.globals.ttVal[e].title.formatter) : (i = a.globals.ttVal.formatter,
                "function" == typeof a.globals.ttVal.title.formatter && (t = a.globals.ttVal.title.formatter)) : t = a.config.tooltip.y.title.formatter,
                "function" != typeof i && (i = a.globals.yLabelFormatters[0] ? a.globals.yLabelFormatters[0] : function(e) {
                    return e
                }
                ),
                "function" != typeof t && (t = function(e) {
                    return e
                }
                ),
                {
                    yLbFormatter: i,
                    yLbTitleFormatter: t
                }
            }
        }, {
            key: "getSeriesName",
            value: function(e) {
                var t = e.fn
                  , a = e.index
                  , i = e.seriesIndex
                  , n = e.j
                  , r = this.w;
                return t(String(r.globals.seriesNames[a]), {
                    series: r.globals.series,
                    seriesIndex: i,
                    dataPointIndex: n,
                    w: r
                })
            }
        }, {
            key: "DOMHandling",
            value: function(e) {
                e.i;
                var t = e.t
                  , a = e.j
                  , i = e.ttItems
                  , n = e.values
                  , r = e.seriesName
                  , o = e.shared
                  , s = e.pColor
                  , l = this.w
                  , c = this.ttCtx
                  , u = n.val
                  , d = n.goalVals
                  , h = n.xVal
                  , p = n.xAxisTTVal
                  , v = n.zVal
                  , g = null;
                g = i[t].children,
                l.config.tooltip.fillSeriesColor && (i[t].style.backgroundColor = s,
                g[0].style.display = "none"),
                c.showTooltipTitle && (null === c.tooltipTitle && (c.tooltipTitle = l.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")),
                c.tooltipTitle.innerHTML = h),
                c.isXAxisTooltipEnabled && (c.xaxisTooltipText.innerHTML = "" !== p ? p : h);
                var f = i[t].querySelector(".apexcharts-tooltip-text-y-label");
                f && (f.innerHTML = r || "");
                var m = i[t].querySelector(".apexcharts-tooltip-text-y-value");
                m && (m.innerHTML = void 0 !== u ? u : ""),
                g[0] && g[0].classList.contains("apexcharts-tooltip-marker") && (l.config.tooltip.marker.fillColors && Array.isArray(l.config.tooltip.marker.fillColors) && (s = l.config.tooltip.marker.fillColors[t]),
                g[0].style.backgroundColor = s),
                l.config.tooltip.marker.show || (g[0].style.display = "none");
                var b = i[t].querySelector(".apexcharts-tooltip-text-goals-label")
                  , x = i[t].querySelector(".apexcharts-tooltip-text-goals-value");
                if (d.length && l.globals.seriesGoals[t]) {
                    var y = function() {
                        var e = "<div >"
                          , t = "<div>";
                        d.forEach((function(a, i) {
                            e += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(a.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(a.attrs.name, "</div>"),
                            t += "<div>".concat(a.val, "</div>")
                        }
                        )),
                        b.innerHTML = e + "</div>",
                        x.innerHTML = t + "</div>"
                    };
                    o ? l.globals.seriesGoals[t][a] && Array.isArray(l.globals.seriesGoals[t][a]) ? y() : (b.innerHTML = "",
                    x.innerHTML = "") : y()
                } else
                    b.innerHTML = "",
                    x.innerHTML = "";
                if (null !== v && (i[t].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l.config.tooltip.z.title,
                i[t].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== v ? v : ""),
                o && g[0]) {
                    if (l.config.tooltip.hideEmptySeries) {
                        var w = i[t].querySelector(".apexcharts-tooltip-marker")
                          , k = i[t].querySelector(".apexcharts-tooltip-text");
                        0 == parseFloat(u) ? (w.style.display = "none",
                        k.style.display = "none") : (w.style.display = "block",
                        k.style.display = "block")
                    }
                    null == u || l.globals.ancillaryCollapsedSeriesIndices.indexOf(t) > -1 || l.globals.collapsedSeriesIndices.indexOf(t) > -1 ? g[0].parentNode.style.display = "none" : g[0].parentNode.style.display = l.config.tooltip.items.display
                }
            }
        }, {
            key: "toggleActiveInactiveSeries",
            value: function(e) {
                var t = this.w;
                if (e)
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                else {
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                    var a = t.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                    a && (a.classList.add("apexcharts-active"),
                    a.style.display = t.config.tooltip.items.display)
                }
            }
        }, {
            key: "getValuesToPrint",
            value: function(e) {
                var t = e.i
                  , a = e.j
                  , i = this.w
                  , n = this.ctx.series.filteredSeriesX()
                  , r = ""
                  , o = ""
                  , s = null
                  , l = null
                  , c = {
                    series: i.globals.series,
                    seriesIndex: t,
                    dataPointIndex: a,
                    w: i
                }
                  , u = i.globals.ttZFormatter;
                null === a ? l = i.globals.series[t] : i.globals.isXNumeric && "treemap" !== i.config.chart.type ? (r = n[t][a],
                0 === n[t].length && (r = n[this.tooltipUtil.getFirstActiveXArray(n)][a])) : r = void 0 !== i.globals.labels[a] ? i.globals.labels[a] : "";
                var d = r;
                return r = i.globals.isXNumeric && "datetime" === i.config.xaxis.type ? new E(this.ctx).xLabelFormat(i.globals.ttKeyFormatter, d, d, {
                    i: void 0,
                    dateFormatter: new T(this.ctx).formatDate,
                    w: this.w
                }) : i.globals.isBarHorizontal ? i.globals.yLabelFormatters[0](d, c) : i.globals.xLabelFormatter(d, c),
                void 0 !== i.config.tooltip.x.formatter && (r = i.globals.ttKeyFormatter(d, c)),
                i.globals.seriesZ.length > 0 && i.globals.seriesZ[t].length > 0 && (s = u(i.globals.seriesZ[t][a], i)),
                o = "function" == typeof i.config.xaxis.tooltip.formatter ? i.globals.xaxisTooltipFormatter(d, c) : r,
                {
                    val: Array.isArray(l) ? l.join(" ") : l,
                    xVal: Array.isArray(r) ? r.join(" ") : r,
                    xAxisTTVal: Array.isArray(o) ? o.join(" ") : o,
                    zVal: s
                }
            }
        }, {
            key: "handleCustomTooltip",
            value: function(e) {
                var t = e.i
                  , a = e.j
                  , i = e.y1
                  , n = e.y2
                  , r = e.w
                  , o = this.ttCtx.getElTooltip()
                  , s = r.config.tooltip.custom;
                Array.isArray(s) && s[t] && (s = s[t]),
                o.innerHTML = s({
                    ctx: this.ctx,
                    series: r.globals.series,
                    seriesIndex: t,
                    dataPointIndex: a,
                    y1: i,
                    y2: n,
                    w: r
                })
            }
        }]),
        e
    }()
      , ge = function() {
        function e(t) {
            r(this, e),
            this.ttCtx = t,
            this.ctx = t.ctx,
            this.w = t.w
        }
        return s(e, [{
            key: "moveXCrosshairs",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null
                  , a = this.ttCtx
                  , i = this.w
                  , n = a.getElXCrosshairs()
                  , r = e - a.xcrosshairsWidth / 2
                  , o = i.globals.labels.slice().length;
                if (null !== t && (r = i.globals.gridWidth / o * t),
                null === n || i.globals.isBarHorizontal || (n.setAttribute("x", r),
                n.setAttribute("x1", r),
                n.setAttribute("x2", r),
                n.setAttribute("y2", i.globals.gridHeight),
                n.classList.add("apexcharts-active")),
                r < 0 && (r = 0),
                r > i.globals.gridWidth && (r = i.globals.gridWidth),
                a.isXAxisTooltipEnabled) {
                    var s = r;
                    "tickWidth" !== i.config.xaxis.crosshairs.width && "barWidth" !== i.config.xaxis.crosshairs.width || (s = r + a.xcrosshairsWidth / 2),
                    this.moveXAxisTooltip(s)
                }
            }
        }, {
            key: "moveYCrosshairs",
            value: function(e) {
                var t = this.ttCtx;
                null !== t.ycrosshairs && w.setAttrs(t.ycrosshairs, {
                    y1: e,
                    y2: e
                }),
                null !== t.ycrosshairsHidden && w.setAttrs(t.ycrosshairsHidden, {
                    y1: e,
                    y2: e
                })
            }
        }, {
            key: "moveXAxisTooltip",
            value: function(e) {
                var t = this.w
                  , a = this.ttCtx;
                if (null !== a.xaxisTooltip && 0 !== a.xcrosshairsWidth) {
                    a.xaxisTooltip.classList.add("apexcharts-active");
                    var i, n = a.xaxisOffY + t.config.xaxis.tooltip.offsetY + t.globals.translateY + 1 + t.config.xaxis.offsetY;
                    if (e -= a.xaxisTooltip.getBoundingClientRect().width / 2,
                    !isNaN(e))
                        e += t.globals.translateX,
                        i = new w(this.ctx).getTextRects(a.xaxisTooltipText.innerHTML),
                        a.xaxisTooltipText.style.minWidth = i.width + "px",
                        a.xaxisTooltip.style.left = e + "px",
                        a.xaxisTooltip.style.top = n + "px"
                }
            }
        }, {
            key: "moveYAxisTooltip",
            value: function(e) {
                var t = this.w
                  , a = this.ttCtx;
                null === a.yaxisTTEls && (a.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                var i = parseInt(a.ycrosshairsHidden.getAttribute("y1"), 10)
                  , n = t.globals.translateY + i
                  , r = a.yaxisTTEls[e].getBoundingClientRect().height
                  , o = t.globals.translateYAxisX[e] - 2;
                t.config.yaxis[e].opposite && (o -= 26),
                n -= r / 2,
                -1 === t.globals.ignoreYAxisIndexes.indexOf(e) ? (a.yaxisTTEls[e].classList.add("apexcharts-active"),
                a.yaxisTTEls[e].style.top = n + "px",
                a.yaxisTTEls[e].style.left = o + t.config.yaxis[e].tooltip.offsetX + "px") : a.yaxisTTEls[e].classList.remove("apexcharts-active")
            }
        }, {
            key: "moveTooltip",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , i = this.w
                  , n = this.ttCtx
                  , r = n.getElTooltip()
                  , o = n.tooltipRect
                  , s = null !== a ? parseFloat(a) : 1
                  , l = parseFloat(e) + s + 5
                  , c = parseFloat(t) + s / 2;
                if (l > i.globals.gridWidth / 2 && (l = l - o.ttWidth - s - 10),
                l > i.globals.gridWidth - o.ttWidth - 10 && (l = i.globals.gridWidth - o.ttWidth),
                l < -20 && (l = -20),
                i.config.tooltip.followCursor) {
                    var u = n.getElGrid().getBoundingClientRect();
                    (l = n.e.clientX - u.left) > i.globals.gridWidth / 2 && (l -= n.tooltipRect.ttWidth),
                    (c = n.e.clientY + i.globals.translateY - u.top) > i.globals.gridHeight / 2 && (c -= n.tooltipRect.ttHeight)
                } else
                    i.globals.isBarHorizontal || o.ttHeight / 2 + c > i.globals.gridHeight && (c = i.globals.gridHeight - o.ttHeight + i.globals.translateY);
                isNaN(l) || (l += i.globals.translateX,
                r.style.left = l + "px",
                r.style.top = c + "px")
            }
        }, {
            key: "moveMarkers",
            value: function(e, t) {
                var a = this.w
                  , i = this.ttCtx;
                if (a.globals.markers.size[e] > 0)
                    for (var n = a.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-marker")), r = 0; r < n.length; r++)
                        parseInt(n[r].getAttribute("rel"), 10) === t && (i.marker.resetPointsSize(),
                        i.marker.enlargeCurrentPoint(t, n[r]));
                else
                    i.marker.resetPointsSize(),
                    this.moveDynamicPointOnHover(t, e)
            }
        }, {
            key: "moveDynamicPointOnHover",
            value: function(e, t) {
                var a, i, n = this.w, r = this.ttCtx, o = n.globals.pointsArray, s = r.tooltipUtil.getHoverMarkerSize(t), l = n.config.series[t].type;
                if (!l || "column" !== l && "candlestick" !== l && "boxPlot" !== l) {
                    a = o[t][e][0],
                    i = o[t][e][1] ? o[t][e][1] : 0;
                    var c = n.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-series-markers circle"));
                    c && i < n.globals.gridHeight && i > 0 && (c.setAttribute("r", s),
                    c.setAttribute("cx", a),
                    c.setAttribute("cy", i)),
                    this.moveXCrosshairs(a),
                    r.fixedTooltip || this.moveTooltip(a, i, s)
                }
            }
        }, {
            key: "moveDynamicPointsOnHover",
            value: function(e) {
                var t, a = this.ttCtx, i = a.w, n = 0, r = 0, o = i.globals.pointsArray;
                t = new X(this.ctx).getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
                var s = a.tooltipUtil.getHoverMarkerSize(t);
                o[t] && (n = o[t][e][0],
                r = o[t][e][1]);
                var l = a.tooltipUtil.getAllMarkers();
                if (null !== l)
                    for (var c = 0; c < i.globals.series.length; c++) {
                        var u = o[c];
                        if (i.globals.comboCharts && void 0 === u && l.splice(c, 0, null),
                        u && u.length) {
                            var d = o[c][e][1]
                              , h = void 0;
                            if (l[c].setAttribute("cx", n),
                            "rangeArea" === i.config.chart.type && !i.globals.comboCharts) {
                                var p = e + i.globals.series[c].length;
                                h = o[c][p][1],
                                d -= Math.abs(d - h) / 2
                            }
                            null !== d && !isNaN(d) && d < i.globals.gridHeight + s && d + s > 0 ? (l[c] && l[c].setAttribute("r", s),
                            l[c] && l[c].setAttribute("cy", d)) : l[c] && l[c].setAttribute("r", 0)
                        }
                    }
                this.moveXCrosshairs(n),
                a.fixedTooltip || this.moveTooltip(n, r || i.globals.gridHeight, s)
            }
        }, {
            key: "moveStickyTooltipOverBars",
            value: function(e, t) {
                var a = this.w
                  , i = this.ttCtx
                  , n = a.globals.columnSeries ? a.globals.columnSeries.length : a.globals.series.length
                  , r = n >= 2 && n % 2 == 0 ? Math.floor(n / 2) : Math.floor(n / 2) + 1;
                a.globals.isBarHorizontal && (r = new X(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
                var o = a.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r, "'] path[j='").concat(e, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(e, "']"));
                o || "number" != typeof t || (o = a.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(t, "'] path[j='").concat(e, "']")));
                var s = o ? parseFloat(o.getAttribute("cx")) : 0
                  , l = o ? parseFloat(o.getAttribute("cy")) : 0
                  , c = o ? parseFloat(o.getAttribute("barWidth")) : 0
                  , u = i.getElGrid().getBoundingClientRect()
                  , d = o && (o.classList.contains("apexcharts-candlestick-area") || o.classList.contains("apexcharts-boxPlot-area"));
                a.globals.isXNumeric ? (o && !d && (s -= n % 2 != 0 ? c / 2 : 0),
                o && d && a.globals.comboCharts && (s -= c / 2)) : a.globals.isBarHorizontal || (s = i.xAxisTicksPositions[e - 1] + i.dataPointsDividedWidth / 2,
                isNaN(s) && (s = i.xAxisTicksPositions[e] - i.dataPointsDividedWidth / 2)),
                a.globals.isBarHorizontal ? l -= i.tooltipRect.ttHeight : a.config.tooltip.followCursor ? l = i.e.clientY - u.top - i.tooltipRect.ttHeight / 2 : l + i.tooltipRect.ttHeight + 15 > a.globals.gridHeight && (l = a.globals.gridHeight),
                a.globals.isBarHorizontal || this.moveXCrosshairs(s),
                i.fixedTooltip || this.moveTooltip(s, l || a.globals.gridHeight)
            }
        }]),
        e
    }()
      , fe = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.ttCtx = t,
            this.ctx = t.ctx,
            this.tooltipPosition = new ge(t)
        }
        return s(e, [{
            key: "drawDynamicPoints",
            value: function() {
                var e = this.w
                  , t = new w(this.ctx)
                  , a = new N(this.ctx)
                  , i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                i = g(i),
                e.config.chart.stacked && i.sort((function(e, t) {
                    return parseFloat(e.getAttribute("data:realIndex")) - parseFloat(t.getAttribute("data:realIndex"))
                }
                ));
                for (var n = 0; n < i.length; n++) {
                    var r = i[n].querySelector(".apexcharts-series-markers-wrap");
                    if (null !== r) {
                        var o = void 0
                          , s = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                        "line" !== e.config.chart.type && "area" !== e.config.chart.type || e.globals.comboCharts || e.config.tooltip.intersect || (s += " no-pointer-events");
                        var l = a.getMarkerConfig({
                            cssClass: s,
                            seriesIndex: Number(r.getAttribute("data:realIndex"))
                        });
                        (o = t.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
                        var c = document.createElementNS(e.globals.SVGNS, "g");
                        c.classList.add("apexcharts-series-markers"),
                        c.appendChild(o.node),
                        r.appendChild(c)
                    }
                }
            }
        }, {
            key: "enlargeCurrentPoint",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null
                  , i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null
                  , n = this.w;
                "bubble" !== n.config.chart.type && this.newPointSize(e, t);
                var r = t.getAttribute("cx")
                  , o = t.getAttribute("cy");
                if (null !== a && null !== i && (r = a,
                o = i),
                this.tooltipPosition.moveXCrosshairs(r),
                !this.fixedTooltip) {
                    if ("radar" === n.config.chart.type) {
                        var s = this.ttCtx.getElGrid().getBoundingClientRect();
                        r = this.ttCtx.e.clientX - s.left
                    }
                    this.tooltipPosition.moveTooltip(r, o, n.config.markers.hover.size)
                }
            }
        }, {
            key: "enlargePoints",
            value: function(e) {
                for (var t = this.w, a = this, i = this.ttCtx, n = e, r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o = t.config.markers.hover.size, s = 0; s < r.length; s++) {
                    var l = r[s].getAttribute("rel")
                      , c = r[s].getAttribute("index");
                    if (void 0 === o && (o = t.globals.markers.size[c] + t.config.markers.hover.sizeOffset),
                    n === parseInt(l, 10)) {
                        a.newPointSize(n, r[s]);
                        var u = r[s].getAttribute("cx")
                          , d = r[s].getAttribute("cy");
                        a.tooltipPosition.moveXCrosshairs(u),
                        i.fixedTooltip || a.tooltipPosition.moveTooltip(u, d, o)
                    } else
                        a.oldPointSize(r[s])
                }
            }
        }, {
            key: "newPointSize",
            value: function(e, t) {
                var a = this.w
                  , i = a.config.markers.hover.size
                  , n = 0 === e ? t.parentNode.firstChild : t.parentNode.lastChild;
                if ("0" !== n.getAttribute("default-marker-size")) {
                    var r = parseInt(n.getAttribute("index"), 10);
                    void 0 === i && (i = a.globals.markers.size[r] + a.config.markers.hover.sizeOffset),
                    i < 0 && (i = 0),
                    n.setAttribute("r", i)
                }
            }
        }, {
            key: "oldPointSize",
            value: function(e) {
                var t = parseFloat(e.getAttribute("default-marker-size"));
                e.setAttribute("r", t)
            }
        }, {
            key: "resetPointsSize",
            value: function() {
                for (var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), t = 0; t < e.length; t++) {
                    var a = parseFloat(e[t].getAttribute("default-marker-size"));
                    b.isNumber(a) && a >= 0 ? e[t].setAttribute("r", a) : e[t].setAttribute("r", 0)
                }
            }
        }]),
        e
    }()
      , me = function() {
        function e(t) {
            r(this, e),
            this.w = t.w;
            var a = this.w;
            this.ttCtx = t,
            this.isVerticalGroupedRangeBar = !a.globals.isBarHorizontal && "rangeBar" === a.config.chart.type && a.config.plotOptions.bar.rangeBarGroupRows
        }
        return s(e, [{
            key: "getAttr",
            value: function(e, t) {
                return parseFloat(e.target.getAttribute(t))
            }
        }, {
            key: "handleHeatTreeTooltip",
            value: function(e) {
                var t = e.e
                  , a = e.opt
                  , i = e.x
                  , n = e.y
                  , r = e.type
                  , o = this.ttCtx
                  , s = this.w;
                if (t.target.classList.contains("apexcharts-".concat(r, "-rect"))) {
                    var l = this.getAttr(t, "i")
                      , c = this.getAttr(t, "j")
                      , u = this.getAttr(t, "cx")
                      , d = this.getAttr(t, "cy")
                      , h = this.getAttr(t, "width")
                      , p = this.getAttr(t, "height");
                    if (o.tooltipLabels.drawSeriesTexts({
                        ttItems: a.ttItems,
                        i: l,
                        j: c,
                        shared: !1,
                        e: t
                    }),
                    s.globals.capturedSeriesIndex = l,
                    s.globals.capturedDataPointIndex = c,
                    i = u + o.tooltipRect.ttWidth / 2 + h,
                    n = d + o.tooltipRect.ttHeight / 2 - p / 2,
                    o.tooltipPosition.moveXCrosshairs(u + h / 2),
                    i > s.globals.gridWidth / 2 && (i = u - o.tooltipRect.ttWidth / 2 + h),
                    o.w.config.tooltip.followCursor) {
                        var v = s.globals.dom.elWrap.getBoundingClientRect();
                        i = s.globals.clientX - v.left - (i > s.globals.gridWidth / 2 ? o.tooltipRect.ttWidth : 0),
                        n = s.globals.clientY - v.top - (n > s.globals.gridHeight / 2 ? o.tooltipRect.ttHeight : 0)
                    }
                }
                return {
                    x: i,
                    y: n
                }
            }
        }, {
            key: "handleMarkerTooltip",
            value: function(e) {
                var t, a, i = e.e, n = e.opt, r = e.x, o = e.y, s = this.w, l = this.ttCtx;
                if (i.target.classList.contains("apexcharts-marker")) {
                    var c = parseInt(n.paths.getAttribute("cx"), 10)
                      , u = parseInt(n.paths.getAttribute("cy"), 10)
                      , d = parseFloat(n.paths.getAttribute("val"));
                    if (a = parseInt(n.paths.getAttribute("rel"), 10),
                    t = parseInt(n.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1,
                    l.intersect) {
                        var h = b.findAncestor(n.paths, "apexcharts-series");
                        h && (t = parseInt(h.getAttribute("data:realIndex"), 10))
                    }
                    if (l.tooltipLabels.drawSeriesTexts({
                        ttItems: n.ttItems,
                        i: t,
                        j: a,
                        shared: !l.showOnIntersect && s.config.tooltip.shared,
                        e: i
                    }),
                    "mouseup" === i.type && l.markerClick(i, t, a),
                    s.globals.capturedSeriesIndex = t,
                    s.globals.capturedDataPointIndex = a,
                    r = c,
                    o = u + s.globals.translateY - 1.4 * l.tooltipRect.ttHeight,
                    l.w.config.tooltip.followCursor) {
                        var p = l.getElGrid().getBoundingClientRect();
                        o = l.e.clientY + s.globals.translateY - p.top
                    }
                    d < 0 && (o = u),
                    l.marker.enlargeCurrentPoint(a, n.paths, r, o)
                }
                return {
                    x: r,
                    y: o
                }
            }
        }, {
            key: "handleBarTooltip",
            value: function(e) {
                var t, a, i = e.e, n = e.opt, r = this.w, o = this.ttCtx, s = o.getElTooltip(), l = 0, c = 0, u = 0, d = this.getBarTooltipXY({
                    e: i,
                    opt: n
                });
                t = d.i;
                var h = d.barHeight
                  , p = d.j;
                r.globals.capturedSeriesIndex = t,
                r.globals.capturedDataPointIndex = p,
                r.globals.isBarHorizontal && o.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (c = d.x,
                u = d.y,
                a = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[t] : r.config.stroke.width,
                l = c) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2),
                isNaN(u) && (u = r.globals.svgHeight - o.tooltipRect.ttHeight);
                var v = parseInt(n.paths.parentNode.getAttribute("data:realIndex"), 10)
                  , g = r.globals.isMultipleYAxis ? r.config.yaxis[v] && r.config.yaxis[v].reversed : r.config.yaxis[0].reversed;
                if (c + o.tooltipRect.ttWidth > r.globals.gridWidth && !g ? c -= o.tooltipRect.ttWidth : c < 0 && (c = 0),
                o.w.config.tooltip.followCursor) {
                    var f = o.getElGrid().getBoundingClientRect();
                    u = o.e.clientY - f.top
                }
                null === o.tooltip && (o.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")),
                r.config.tooltip.shared || (r.globals.comboBarCount > 0 ? o.tooltipPosition.moveXCrosshairs(l + a / 2) : o.tooltipPosition.moveXCrosshairs(l)),
                !o.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && o.tooltipUtil.hasBars()) && (g && (c -= o.tooltipRect.ttWidth) < 0 && (c = 0),
                !g || r.globals.isBarHorizontal && o.tooltipUtil.hasBars() || (u = u + h - 2 * (r.globals.series[t][p] < 0 ? h : 0)),
                u = u + r.globals.translateY - o.tooltipRect.ttHeight / 2,
                s.style.left = c + r.globals.translateX + "px",
                s.style.top = u + "px")
            }
        }, {
            key: "getBarTooltipXY",
            value: function(e) {
                var t = this
                  , a = e.e
                  , i = e.opt
                  , n = this.w
                  , r = null
                  , o = this.ttCtx
                  , s = 0
                  , l = 0
                  , c = 0
                  , u = 0
                  , d = 0
                  , h = a.target.classList;
                if (h.contains("apexcharts-bar-area") || h.contains("apexcharts-candlestick-area") || h.contains("apexcharts-boxPlot-area") || h.contains("apexcharts-rangebar-area")) {
                    var p = a.target
                      , v = p.getBoundingClientRect()
                      , g = i.elGrid.getBoundingClientRect()
                      , f = v.height;
                    d = v.height;
                    var m = v.width
                      , b = parseInt(p.getAttribute("cx"), 10)
                      , x = parseInt(p.getAttribute("cy"), 10);
                    u = parseFloat(p.getAttribute("barWidth"));
                    var y = "touchmove" === a.type ? a.touches[0].clientX : a.clientX;
                    r = parseInt(p.getAttribute("j"), 10),
                    s = parseInt(p.parentNode.getAttribute("rel"), 10) - 1;
                    var w = p.getAttribute("data-range-y1")
                      , k = p.getAttribute("data-range-y2");
                    n.globals.comboCharts && (s = parseInt(p.parentNode.getAttribute("data:realIndex"), 10));
                    var S = function(e) {
                        return n.globals.isXNumeric ? b - m / 2 : t.isVerticalGroupedRangeBar ? b + m / 2 : b - o.dataPointsDividedWidth + m / 2
                    }
                      , C = function() {
                        return x - o.dataPointsDividedHeight + f / 2 - o.tooltipRect.ttHeight / 2
                    };
                    o.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: s,
                        j: r,
                        y1: w ? parseInt(w, 10) : null,
                        y2: k ? parseInt(k, 10) : null,
                        shared: !o.showOnIntersect && n.config.tooltip.shared,
                        e: a
                    }),
                    n.config.tooltip.followCursor ? n.globals.isBarHorizontal ? (l = y - g.left + 15,
                    c = C()) : (l = S(),
                    c = a.clientY - g.top - o.tooltipRect.ttHeight / 2 - 15) : n.globals.isBarHorizontal ? ((l = b) < o.xyRatios.baseLineInvertedY && (l = b - o.tooltipRect.ttWidth),
                    c = C()) : (l = S(),
                    c = x)
                }
                return {
                    x: l,
                    y: c,
                    barHeight: d,
                    barWidth: u,
                    i: s,
                    j: r
                }
            }
        }]),
        e
    }()
      , be = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.ttCtx = t
        }
        return s(e, [{
            key: "drawXaxisTooltip",
            value: function() {
                var e = this.w
                  , t = this.ttCtx
                  , a = "bottom" === e.config.xaxis.position;
                t.xaxisOffY = a ? e.globals.gridHeight + 1 : -e.globals.xAxisHeight - e.config.xaxis.axisTicks.height + 3;
                var i = a ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top"
                  , n = e.globals.dom.elWrap;
                t.isXAxisTooltipEnabled && null === e.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (t.xaxisTooltip = document.createElement("div"),
                t.xaxisTooltip.setAttribute("class", i + " apexcharts-theme-" + e.config.tooltip.theme),
                n.appendChild(t.xaxisTooltip),
                t.xaxisTooltipText = document.createElement("div"),
                t.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"),
                t.xaxisTooltipText.style.fontFamily = e.config.xaxis.tooltip.style.fontFamily || e.config.chart.fontFamily,
                t.xaxisTooltipText.style.fontSize = e.config.xaxis.tooltip.style.fontSize,
                t.xaxisTooltip.appendChild(t.xaxisTooltipText))
            }
        }, {
            key: "drawYaxisTooltip",
            value: function() {
                for (var e = this.w, t = this.ttCtx, a = function(a) {
                    var i = e.config.yaxis[a].opposite || e.config.yaxis[a].crosshairs.opposite;
                    t.yaxisOffX = i ? e.globals.gridWidth + 1 : 1;
                    var n = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(a, i ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                    e.globals.yAxisSameScaleIndices.map((function(t, i) {
                        t.map((function(t, i) {
                            i === a && (n += e.config.yaxis[i].show ? " " : " apexcharts-yaxistooltip-hidden")
                        }
                        ))
                    }
                    ));
                    var r = e.globals.dom.elWrap;
                    null === e.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(a)) && (t.yaxisTooltip = document.createElement("div"),
                    t.yaxisTooltip.setAttribute("class", n + " apexcharts-theme-" + e.config.tooltip.theme),
                    r.appendChild(t.yaxisTooltip),
                    0 === a && (t.yaxisTooltipText = []),
                    t.yaxisTooltipText[a] = document.createElement("div"),
                    t.yaxisTooltipText[a].classList.add("apexcharts-yaxistooltip-text"),
                    t.yaxisTooltip.appendChild(t.yaxisTooltipText[a]))
                }, i = 0; i < e.config.yaxis.length; i++)
                    a(i)
            }
        }, {
            key: "setXCrosshairWidth",
            value: function() {
                var e = this.w
                  , t = this.ttCtx
                  , a = t.getElXCrosshairs();
                if (t.xcrosshairsWidth = parseInt(e.config.xaxis.crosshairs.width, 10),
                e.globals.comboCharts) {
                    var i = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== i && "barWidth" === e.config.xaxis.crosshairs.width) {
                        var n = parseFloat(i.getAttribute("barWidth"));
                        t.xcrosshairsWidth = n
                    } else if ("tickWidth" === e.config.xaxis.crosshairs.width) {
                        var r = e.globals.labels.length;
                        t.xcrosshairsWidth = e.globals.gridWidth / r
                    }
                } else if ("tickWidth" === e.config.xaxis.crosshairs.width) {
                    var o = e.globals.labels.length;
                    t.xcrosshairsWidth = e.globals.gridWidth / o
                } else if ("barWidth" === e.config.xaxis.crosshairs.width) {
                    var s = e.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== s) {
                        var l = parseFloat(s.getAttribute("barWidth"));
                        t.xcrosshairsWidth = l
                    } else
                        t.xcrosshairsWidth = 1
                }
                e.globals.isBarHorizontal && (t.xcrosshairsWidth = 0),
                null !== a && t.xcrosshairsWidth > 0 && a.setAttribute("width", t.xcrosshairsWidth)
            }
        }, {
            key: "handleYCrosshair",
            value: function() {
                var e = this.w
                  , t = this.ttCtx;
                t.ycrosshairs = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"),
                t.ycrosshairsHidden = e.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
            }
        }, {
            key: "drawYaxisTooltipText",
            value: function(e, t, a) {
                var i = this.ttCtx
                  , n = this.w
                  , r = n.globals.yLabelFormatters[e];
                if (i.yaxisTooltips[e]) {
                    var o = i.getElGrid().getBoundingClientRect()
                      , s = (t - o.top) * a.yRatio[e]
                      , l = n.globals.maxYArr[e] - n.globals.minYArr[e]
                      , c = n.globals.minYArr[e] + (l - s);
                    i.tooltipPosition.moveYCrosshairs(t - o.top),
                    i.yaxisTooltipText[e].innerHTML = r(c),
                    i.tooltipPosition.moveYAxisTooltip(e)
                }
            }
        }]),
        e
    }()
      , xe = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w;
            var a = this.w;
            this.tConfig = a.config.tooltip,
            this.tooltipUtil = new pe(this),
            this.tooltipLabels = new ve(this),
            this.tooltipPosition = new ge(this),
            this.marker = new fe(this),
            this.intersect = new me(this),
            this.axesTooltip = new be(this),
            this.showOnIntersect = this.tConfig.intersect,
            this.showTooltipTitle = this.tConfig.x.show,
            this.fixedTooltip = this.tConfig.fixed.enabled,
            this.xaxisTooltip = null,
            this.yaxisTTEls = null,
            this.isBarShared = !a.globals.isBarHorizontal && this.tConfig.shared,
            this.lastHoverTime = Date.now()
        }
        return s(e, [{
            key: "getElTooltip",
            value: function(e) {
                return e || (e = this),
                e.w.globals.dom.baseEl ? e.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
            }
        }, {
            key: "getElXCrosshairs",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
            }
        }, {
            key: "getElGrid",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
            }
        }, {
            key: "drawTooltip",
            value: function(e) {
                var t = this.w;
                this.xyRatios = e,
                this.isXAxisTooltipEnabled = t.config.xaxis.tooltip.enabled && t.globals.axisCharts,
                this.yaxisTooltips = t.config.yaxis.map((function(e, a) {
                    return !!(e.show && e.tooltip.enabled && t.globals.axisCharts)
                }
                )),
                this.allTooltipSeriesGroups = [],
                t.globals.axisCharts || (this.showTooltipTitle = !1);
                var a = document.createElement("div");
                if (a.classList.add("apexcharts-tooltip"),
                t.config.tooltip.cssClass && a.classList.add(t.config.tooltip.cssClass),
                a.classList.add("apexcharts-theme-".concat(this.tConfig.theme)),
                t.globals.dom.elWrap.appendChild(a),
                t.globals.axisCharts) {
                    this.axesTooltip.drawXaxisTooltip(),
                    this.axesTooltip.drawYaxisTooltip(),
                    this.axesTooltip.setXCrosshairWidth(),
                    this.axesTooltip.handleYCrosshair();
                    var i = new j(this.ctx);
                    this.xAxisTicksPositions = i.getXAxisTicksPositions()
                }
                if (!t.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== t.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0),
                0 !== t.config.markers.size && 0 !== t.globals.markers.largestSize || this.marker.drawDynamicPoints(this),
                t.globals.collapsedSeries.length !== t.globals.series.length) {
                    this.dataPointsDividedHeight = t.globals.gridHeight / t.globals.dataPoints,
                    this.dataPointsDividedWidth = t.globals.gridWidth / t.globals.dataPoints,
                    this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"),
                    this.tooltipTitle.classList.add("apexcharts-tooltip-title"),
                    this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || t.config.chart.fontFamily,
                    this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize,
                    a.appendChild(this.tooltipTitle));
                    var n = t.globals.series.length;
                    (t.globals.xyCharts || t.globals.comboCharts) && this.tConfig.shared && (n = this.showOnIntersect ? 1 : t.globals.series.length),
                    this.legendLabels = t.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"),
                    this.ttItems = this.createTTElements(n),
                    this.addSVGEvents()
                }
            }
        }, {
            key: "createTTElements",
            value: function(e) {
                for (var t = this, a = this.w, i = [], n = this.getElTooltip(), r = function(r) {
                    var o = document.createElement("div");
                    o.classList.add("apexcharts-tooltip-series-group"),
                    o.style.order = a.config.tooltip.inverseOrder ? e - r : r + 1,
                    t.tConfig.shared && t.tConfig.enabledOnSeries && Array.isArray(t.tConfig.enabledOnSeries) && t.tConfig.enabledOnSeries.indexOf(r) < 0 && o.classList.add("apexcharts-tooltip-series-group-hidden");
                    var s = document.createElement("span");
                    s.classList.add("apexcharts-tooltip-marker"),
                    s.style.backgroundColor = a.globals.colors[r],
                    o.appendChild(s);
                    var l = document.createElement("div");
                    l.classList.add("apexcharts-tooltip-text"),
                    l.style.fontFamily = t.tConfig.style.fontFamily || a.config.chart.fontFamily,
                    l.style.fontSize = t.tConfig.style.fontSize,
                    ["y", "goals", "z"].forEach((function(e) {
                        var t = document.createElement("div");
                        t.classList.add("apexcharts-tooltip-".concat(e, "-group"));
                        var a = document.createElement("span");
                        a.classList.add("apexcharts-tooltip-text-".concat(e, "-label")),
                        t.appendChild(a);
                        var i = document.createElement("span");
                        i.classList.add("apexcharts-tooltip-text-".concat(e, "-value")),
                        t.appendChild(i),
                        l.appendChild(t)
                    }
                    )),
                    o.appendChild(l),
                    n.appendChild(o),
                    i.push(o)
                }, o = 0; o < e; o++)
                    r(o);
                return i
            }
        }, {
            key: "addSVGEvents",
            value: function() {
                var e = this.w
                  , t = e.config.chart.type
                  , a = this.getElTooltip()
                  , i = !("bar" !== t && "candlestick" !== t && "boxPlot" !== t && "rangeBar" !== t)
                  , n = "area" === t || "line" === t || "scatter" === t || "bubble" === t || "radar" === t
                  , r = e.globals.dom.Paper.node
                  , o = this.getElGrid();
                o && (this.seriesBound = o.getBoundingClientRect());
                var s, l = [], c = [], u = {
                    hoverArea: r,
                    elGrid: o,
                    tooltipEl: a,
                    tooltipY: l,
                    tooltipX: c,
                    ttItems: this.ttItems
                };
                if (e.globals.axisCharts && (n ? s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : i ? s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== t && "treemap" !== t || (s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")),
                s && s.length))
                    for (var d = 0; d < s.length; d++)
                        l.push(s[d].getAttribute("cy")),
                        c.push(s[d].getAttribute("cx"));
                if (e.globals.xyCharts && !this.showOnIntersect || e.globals.comboCharts && !this.showOnIntersect || i && this.tooltipUtil.hasBars() && this.tConfig.shared)
                    this.addPathsEventListeners([r], u);
                else if (i && !e.globals.comboCharts || n && this.showOnIntersect)
                    this.addDatapointEventsListeners(u);
                else if (!e.globals.axisCharts || "heatmap" === t || "treemap" === t) {
                    var h = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                    this.addPathsEventListeners(h, u)
                }
                if (this.showOnIntersect) {
                    var p = e.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                    p.length > 0 && this.addPathsEventListeners(p, u),
                    this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(u)
                }
            }
        }, {
            key: "drawFixedTooltipRect",
            value: function() {
                var e = this.w
                  , t = this.getElTooltip()
                  , a = t.getBoundingClientRect()
                  , i = a.width + 10
                  , n = a.height + 10
                  , r = this.tConfig.fixed.offsetX
                  , o = this.tConfig.fixed.offsetY
                  , s = this.tConfig.fixed.position.toLowerCase();
                return s.indexOf("right") > -1 && (r = r + e.globals.svgWidth - i + 10),
                s.indexOf("bottom") > -1 && (o = o + e.globals.svgHeight - n - 10),
                t.style.left = r + "px",
                t.style.top = o + "px",
                {
                    x: r,
                    y: o,
                    ttWidth: i,
                    ttHeight: n
                }
            }
        }, {
            key: "addDatapointEventsListeners",
            value: function(e) {
                var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
                this.addPathsEventListeners(t, e)
            }
        }, {
            key: "addPathsEventListeners",
            value: function(e, t) {
                for (var a = this, i = function(i) {
                    var n = {
                        paths: e[i],
                        tooltipEl: t.tooltipEl,
                        tooltipY: t.tooltipY,
                        tooltipX: t.tooltipX,
                        elGrid: t.elGrid,
                        hoverArea: t.hoverArea,
                        ttItems: t.ttItems
                    };
                    ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map((function(t) {
                        return e[i].addEventListener(t, a.onSeriesHover.bind(a, n), {
                            capture: !1,
                            passive: !0
                        })
                    }
                    ))
                }, n = 0; n < e.length; n++)
                    i(n)
            }
        }, {
            key: "onSeriesHover",
            value: function(e, t) {
                var a = this
                  , i = Date.now() - this.lastHoverTime;
                i >= 100 ? this.seriesHover(e, t) : (clearTimeout(this.seriesHoverTimeout),
                this.seriesHoverTimeout = setTimeout((function() {
                    a.seriesHover(e, t)
                }
                ), 100 - i))
            }
        }, {
            key: "seriesHover",
            value: function(e, t) {
                var a = this;
                this.lastHoverTime = Date.now();
                var i = []
                  , n = this.w;
                n.config.chart.group && (i = this.ctx.getGroupedCharts()),
                n.globals.axisCharts && (n.globals.minX === -1 / 0 && n.globals.maxX === 1 / 0 || 0 === n.globals.dataPoints) || (i.length ? i.forEach((function(i) {
                    var n = a.getElTooltip(i)
                      , r = {
                        paths: e.paths,
                        tooltipEl: n,
                        tooltipY: e.tooltipY,
                        tooltipX: e.tooltipX,
                        elGrid: e.elGrid,
                        hoverArea: e.hoverArea,
                        ttItems: i.w.globals.tooltip.ttItems
                    };
                    i.w.globals.minX === a.w.globals.minX && i.w.globals.maxX === a.w.globals.maxX && i.w.globals.tooltip.seriesHoverByContext({
                        chartCtx: i,
                        ttCtx: i.w.globals.tooltip,
                        opt: r,
                        e: t
                    })
                }
                )) : this.seriesHoverByContext({
                    chartCtx: this.ctx,
                    ttCtx: this.w.globals.tooltip,
                    opt: e,
                    e: t
                }))
            }
        }, {
            key: "seriesHoverByContext",
            value: function(e) {
                var t = e.chartCtx
                  , a = e.ttCtx
                  , i = e.opt
                  , n = e.e
                  , r = t.w
                  , o = this.getElTooltip();
                o && (a.tooltipRect = {
                    x: 0,
                    y: 0,
                    ttWidth: o.getBoundingClientRect().width,
                    ttHeight: o.getBoundingClientRect().height
                },
                a.e = n,
                a.tooltipUtil.hasBars() && !r.globals.comboCharts && !a.isBarShared && this.tConfig.onDatasetHover.highlightDataSeries && new X(t).toggleSeriesOnHover(n, n.target.parentNode),
                a.fixedTooltip && a.drawFixedTooltipRect(),
                r.globals.axisCharts ? a.axisChartsTooltips({
                    e: n,
                    opt: i,
                    tooltipRect: a.tooltipRect
                }) : a.nonAxisChartsTooltips({
                    e: n,
                    opt: i,
                    tooltipRect: a.tooltipRect
                }))
            }
        }, {
            key: "axisChartsTooltips",
            value: function(e) {
                var t, a, i = e.e, n = e.opt, r = this.w, o = n.elGrid.getBoundingClientRect(), s = "touchmove" === i.type ? i.touches[0].clientX : i.clientX, l = "touchmove" === i.type ? i.touches[0].clientY : i.clientY;
                if (this.clientY = l,
                this.clientX = s,
                r.globals.capturedSeriesIndex = -1,
                r.globals.capturedDataPointIndex = -1,
                l < o.top || l > o.top + o.height)
                    this.handleMouseOut(n);
                else {
                    if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
                        var c = parseInt(n.paths.getAttribute("index"), 10);
                        if (this.tConfig.enabledOnSeries.indexOf(c) < 0)
                            return void this.handleMouseOut(n)
                    }
                    var u = this.getElTooltip()
                      , d = this.getElXCrosshairs()
                      , h = r.globals.xyCharts || "bar" === r.config.chart.type && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();
                    if ("mousemove" === i.type || "touchmove" === i.type || "mouseup" === i.type) {
                        if (r.globals.collapsedSeries.length + r.globals.ancillaryCollapsedSeries.length === r.globals.series.length)
                            return;
                        null !== d && d.classList.add("apexcharts-active");
                        var p = this.yaxisTooltips.filter((function(e) {
                            return !0 === e
                        }
                        ));
                        if (null !== this.ycrosshairs && p.length && this.ycrosshairs.classList.add("apexcharts-active"),
                        h && !this.showOnIntersect)
                            this.handleStickyTooltip(i, s, l, n);
                        else if ("heatmap" === r.config.chart.type || "treemap" === r.config.chart.type) {
                            var v = this.intersect.handleHeatTreeTooltip({
                                e: i,
                                opt: n,
                                x: t,
                                y: a,
                                type: r.config.chart.type
                            });
                            t = v.x,
                            a = v.y,
                            u.style.left = t + "px",
                            u.style.top = a + "px"
                        } else
                            this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                                e: i,
                                opt: n
                            }),
                            this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                                e: i,
                                opt: n,
                                x: t,
                                y: a
                            });
                        if (this.yaxisTooltips.length)
                            for (var g = 0; g < r.config.yaxis.length; g++)
                                this.axesTooltip.drawYaxisTooltipText(g, l, this.xyRatios);
                        n.tooltipEl.classList.add("apexcharts-active")
                    } else
                        "mouseout" !== i.type && "touchend" !== i.type || this.handleMouseOut(n)
                }
            }
        }, {
            key: "nonAxisChartsTooltips",
            value: function(e) {
                var t = e.e
                  , a = e.opt
                  , i = e.tooltipRect
                  , n = this.w
                  , r = a.paths.getAttribute("rel")
                  , o = this.getElTooltip()
                  , s = n.globals.dom.elWrap.getBoundingClientRect();
                if ("mousemove" === t.type || "touchmove" === t.type) {
                    o.classList.add("apexcharts-active"),
                    this.tooltipLabels.drawSeriesTexts({
                        ttItems: a.ttItems,
                        i: parseInt(r, 10) - 1,
                        shared: !1
                    });
                    var l = n.globals.clientX - s.left - i.ttWidth / 2
                      , c = n.globals.clientY - s.top - i.ttHeight - 10;
                    if (o.style.left = l + "px",
                    o.style.top = c + "px",
                    n.config.legend.tooltipHoverFormatter) {
                        var u = r - 1
                          , d = (0,
                        n.config.legend.tooltipHoverFormatter)(this.legendLabels[u].getAttribute("data:default-text"), {
                            seriesIndex: u,
                            dataPointIndex: u,
                            w: n
                        });
                        this.legendLabels[u].innerHTML = d
                    }
                } else
                    "mouseout" !== t.type && "touchend" !== t.type || (o.classList.remove("apexcharts-active"),
                    n.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(e) {
                        var t = e.getAttribute("data:default-text");
                        e.innerHTML = decodeURIComponent(t)
                    }
                    )))
            }
        }, {
            key: "handleStickyTooltip",
            value: function(e, t, a, i) {
                var n = this.w
                  , r = this.tooltipUtil.getNearestValues({
                    context: this,
                    hoverArea: i.hoverArea,
                    elGrid: i.elGrid,
                    clientX: t,
                    clientY: a
                })
                  , o = r.j
                  , s = r.capturedSeries;
                n.globals.collapsedSeriesIndices.includes(s) && (s = null);
                var l = i.elGrid.getBoundingClientRect();
                if (r.hoverX < 0 || r.hoverX > l.width)
                    this.handleMouseOut(i);
                else if (null !== s)
                    this.handleStickyCapturedSeries(e, s, i, o);
                else if (this.tooltipUtil.isXoverlap(o) || n.globals.isBarHorizontal) {
                    var c = n.globals.series.findIndex((function(e, t) {
                        return !n.globals.collapsedSeriesIndices.includes(t)
                    }
                    ));
                    this.create(e, this, c, o, i.ttItems)
                }
            }
        }, {
            key: "handleStickyCapturedSeries",
            value: function(e, t, a, i) {
                var n = this.w;
                if (this.tConfig.shared || null !== n.globals.series[t][i]) {
                    if (void 0 !== n.globals.series[t][i])
                        this.tConfig.shared && this.tooltipUtil.isXoverlap(i) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(e, this, t, i, a.ttItems) : this.create(e, this, t, i, a.ttItems, !1);
                    else if (this.tooltipUtil.isXoverlap(i)) {
                        var r = n.globals.series.findIndex((function(e, t) {
                            return !n.globals.collapsedSeriesIndices.includes(t)
                        }
                        ));
                        this.create(e, this, r, i, a.ttItems)
                    }
                } else
                    this.handleMouseOut(a)
            }
        }, {
            key: "deactivateHoverFilter",
            value: function() {
                for (var e = this.w, t = new w(this.ctx), a = e.globals.dom.Paper.select(".apexcharts-bar-area"), i = 0; i < a.length; i++)
                    t.pathMouseLeave(a[i])
            }
        }, {
            key: "handleMouseOut",
            value: function(e) {
                var t = this.w
                  , a = this.getElXCrosshairs();
                if (e.tooltipEl.classList.remove("apexcharts-active"),
                this.deactivateHoverFilter(),
                "bubble" !== t.config.chart.type && this.marker.resetPointsSize(),
                null !== a && a.classList.remove("apexcharts-active"),
                null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"),
                this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"),
                this.yaxisTooltips.length) {
                    null === this.yaxisTTEls && (this.yaxisTTEls = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                    for (var i = 0; i < this.yaxisTTEls.length; i++)
                        this.yaxisTTEls[i].classList.remove("apexcharts-active")
                }
                t.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(e) {
                    var t = e.getAttribute("data:default-text");
                    e.innerHTML = decodeURIComponent(t)
                }
                ))
            }
        }, {
            key: "markerClick",
            value: function(e, t, a) {
                var i = this.w;
                "function" == typeof i.config.chart.events.markerClick && i.config.chart.events.markerClick(e, this.ctx, {
                    seriesIndex: t,
                    dataPointIndex: a,
                    w: i
                }),
                this.ctx.events.fireEvent("markerClick", [e, this.ctx, {
                    seriesIndex: t,
                    dataPointIndex: a,
                    w: i
                }])
            }
        }, {
            key: "create",
            value: function(e, t, a, n, r) {
                var o, s, l, c, u, d, h, p, v, g, f, m, b, x, y, k, S = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, C = this.w, A = t;
                "mouseup" === e.type && this.markerClick(e, a, n),
                null === S && (S = this.tConfig.shared);
                var P = this.tooltipUtil.hasMarkers(a)
                  , L = this.tooltipUtil.getElBars();
                if (C.config.legend.tooltipHoverFormatter) {
                    var I = C.config.legend.tooltipHoverFormatter
                      , _ = Array.from(this.legendLabels);
                    _.forEach((function(e) {
                        var t = e.getAttribute("data:default-text");
                        e.innerHTML = decodeURIComponent(t)
                    }
                    ));
                    for (var T = 0; T < _.length; T++) {
                        var E = _[T]
                          , O = parseInt(E.getAttribute("i"), 10)
                          , V = decodeURIComponent(E.getAttribute("data:default-text"))
                          , F = I(V, {
                            seriesIndex: S ? O : a,
                            dataPointIndex: n,
                            w: C
                        });
                        if (S)
                            E.innerHTML = C.globals.collapsedSeriesIndices.indexOf(O) < 0 ? F : V;
                        else if (E.innerHTML = O === a ? F : V,
                        a === O)
                            break
                    }
                }
                var B = i(i({
                    ttItems: r,
                    i: a,
                    j: n
                }, void 0 !== (null === (o = C.globals.seriesRange) || void 0 === o || null === (s = o[a]) || void 0 === s || null === (l = s[n]) || void 0 === l || null === (c = l.y[0]) || void 0 === c ? void 0 : c.y1) && {
                    y1: null === (u = C.globals.seriesRange) || void 0 === u || null === (d = u[a]) || void 0 === d || null === (h = d[n]) || void 0 === h || null === (p = h.y[0]) || void 0 === p ? void 0 : p.y1
                }), void 0 !== (null === (v = C.globals.seriesRange) || void 0 === v || null === (g = v[a]) || void 0 === g || null === (f = g[n]) || void 0 === f || null === (m = f.y[0]) || void 0 === m ? void 0 : m.y2) && {
                    y2: null === (b = C.globals.seriesRange) || void 0 === b || null === (x = b[a]) || void 0 === x || null === (y = x[n]) || void 0 === y || null === (k = y.y[0]) || void 0 === k ? void 0 : k.y2
                });
                if (S) {
                    if (A.tooltipLabels.drawSeriesTexts(i(i({}, B), {}, {
                        shared: !this.showOnIntersect && this.tConfig.shared
                    })),
                    P)
                        C.globals.markers.largestSize > 0 ? A.marker.enlargePoints(n) : A.tooltipPosition.moveDynamicPointsOnHover(n);
                    else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(L),
                    this.barSeriesHeight > 0)) {
                        var M = new w(this.ctx)
                          , D = C.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(n, "']"));
                        this.deactivateHoverFilter(),
                        this.tooltipPosition.moveStickyTooltipOverBars(n, a);
                        for (var R = 0; R < D.length; R++)
                            M.pathMouseEnter(D[R])
                    }
                } else
                    A.tooltipLabels.drawSeriesTexts(i({
                        shared: !1
                    }, B)),
                    this.tooltipUtil.hasBars() && A.tooltipPosition.moveStickyTooltipOverBars(n, a),
                    P && A.tooltipPosition.moveMarkers(a, n)
            }
        }]),
        e
    }()
      , ye = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.barCtx = t,
            this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter,
            this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter)
        }
        return s(e, [{
            key: "handleBarDataLabels",
            value: function(e) {
                var t = e.x
                  , a = e.y
                  , i = e.y1
                  , n = e.y2
                  , r = e.i
                  , o = e.j
                  , s = e.realIndex
                  , l = e.groupIndex
                  , c = e.series
                  , u = e.barHeight
                  , d = e.barWidth
                  , h = e.barXPosition
                  , p = e.barYPosition
                  , v = e.visibleSeries
                  , g = e.renderedPath
                  , f = this.w
                  , m = new w(this.barCtx.ctx)
                  , b = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[s] : this.barCtx.strokeWidth
                  , x = t + parseFloat(d * v)
                  , y = a + parseFloat(u * v);
                f.globals.isXNumeric && !f.globals.isBarHorizontal && (x = t + parseFloat(d * (v + 1)),
                y = a + parseFloat(u * (v + 1)) - b);
                var k, S, C = null, A = t, P = a, L = f.config.dataLabels, I = this.barCtx.barOptions.dataLabels, _ = this.barCtx.barOptions.dataLabels.total;
                void 0 !== p && this.barCtx.isRangeBar && (y = p,
                P = p),
                void 0 !== h && this.barCtx.isVerticalGroupedRangeBar && (x = h,
                A = h);
                var T = L.offsetX
                  , E = L.offsetY
                  , O = {
                    width: 0,
                    height: 0
                };
                if (f.config.dataLabels.enabled) {
                    var V = this.barCtx.series[r][o];
                    O = m.getTextRects(f.globals.yLabelFormatters[0](V), parseFloat(L.style.fontSize))
                }
                var F = {
                    x: t,
                    y: a,
                    i: r,
                    j: o,
                    realIndex: s,
                    groupIndex: l || -1,
                    renderedPath: g,
                    bcx: x,
                    bcy: y,
                    barHeight: u,
                    barWidth: d,
                    textRects: O,
                    strokeWidth: b,
                    dataLabelsX: A,
                    dataLabelsY: P,
                    dataLabelsConfig: L,
                    barDataLabelsConfig: I,
                    barTotalDataLabelsConfig: _,
                    offX: T,
                    offY: E
                };
                return S = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(F) : this.calculateColumnsDataLabelsPosition(F),
                g.attr({
                    cy: S.bcy,
                    cx: S.bcx,
                    j: o,
                    val: c[r][o],
                    barHeight: u,
                    barWidth: d
                }),
                k = this.drawCalculatedDataLabels({
                    x: S.dataLabelsX,
                    y: S.dataLabelsY,
                    val: this.barCtx.isRangeBar ? [i, n] : c[r][o],
                    i: s,
                    j: o,
                    barWidth: d,
                    barHeight: u,
                    textRects: O,
                    dataLabelsConfig: L
                }),
                f.config.chart.stacked && _.enabled && (C = this.drawTotalDataLabels({
                    x: S.totalDataLabelsX,
                    y: S.totalDataLabelsY,
                    barWidth: d,
                    barHeight: u,
                    realIndex: s,
                    textAnchor: S.totalDataLabelsAnchor,
                    val: this.getStackedTotalDataLabel({
                        realIndex: s,
                        j: o
                    }),
                    dataLabelsConfig: L,
                    barTotalDataLabelsConfig: _
                })),
                {
                    dataLabels: k,
                    totalDataLabels: C
                }
            }
        }, {
            key: "getStackedTotalDataLabel",
            value: function(e) {
                var t = e.realIndex
                  , a = e.j
                  , n = this.w
                  , r = this.barCtx.stackedSeriesTotals[a];
                return this.totalFormatter && (r = this.totalFormatter(r, i(i({}, n), {}, {
                    seriesIndex: t,
                    dataPointIndex: a,
                    w: n
                }))),
                r
            }
        }, {
            key: "calculateColumnsDataLabelsPosition",
            value: function(e) {
                var t, a, i = this.w, n = e.i, r = e.j, o = e.realIndex, s = e.groupIndex, l = e.y, c = e.bcx, u = e.barWidth, d = e.barHeight, h = e.textRects, p = e.dataLabelsX, v = e.dataLabelsY, g = e.dataLabelsConfig, f = e.barDataLabelsConfig, m = e.barTotalDataLabelsConfig, b = e.strokeWidth, x = e.offX, y = e.offY;
                d = Math.abs(d);
                var k = "vertical" === i.config.plotOptions.bar.dataLabels.orientation
                  , S = this.barCtx.barHelpers.getZeroValueEncounters({
                    i: n,
                    j: r
                }).zeroEncounters;
                c = c - b / 2 + (-1 !== s ? s * u : 0);
                var C = i.globals.gridWidth / i.globals.dataPoints;
                this.barCtx.isVerticalGroupedRangeBar ? p += u / 2 : (p = i.globals.isXNumeric ? c - u / 2 + x : c - C + u / 2 + x,
                S > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (p -= u * S)),
                k && (p = p + h.height / 2 - b / 2 - 2);
                var A = this.barCtx.series[n][r] < 0
                  , P = l;
                switch (this.barCtx.isReversed && (P = l - d + (A ? 2 * d : 0),
                l -= d),
                f.position) {
                case "center":
                    v = k ? A ? P - d / 2 + y : P + d / 2 - y : A ? P - d / 2 + h.height / 2 + y : P + d / 2 + h.height / 2 - y;
                    break;
                case "bottom":
                    v = k ? A ? P - d + y : P + d - y : A ? P - d + h.height + b + y : P + d - h.height / 2 + b - y;
                    break;
                case "top":
                    v = k ? A ? P + y : P - y : A ? P - h.height / 2 - y : P + h.height + y
                }
                if (this.barCtx.lastActiveBarSerieIndex === o && m.enabled) {
                    var L = new w(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                        realIndex: o,
                        j: r
                    }), g.fontSize);
                    t = A ? P - L.height / 2 - y - m.offsetY + 18 : P + L.height + y + m.offsetY - 18,
                    a = p + m.offsetX
                }
                return i.config.chart.stacked || (v < 0 ? v = 0 + b : v + h.height / 3 > i.globals.gridHeight && (v = i.globals.gridHeight - b)),
                {
                    bcx: c,
                    bcy: l,
                    dataLabelsX: p,
                    dataLabelsY: v,
                    totalDataLabelsX: a,
                    totalDataLabelsY: t,
                    totalDataLabelsAnchor: "middle"
                }
            }
        }, {
            key: "calculateBarsDataLabelsPosition",
            value: function(e) {
                var t = this.w
                  , a = e.x
                  , i = e.i
                  , n = e.j
                  , r = e.realIndex
                  , o = e.groupIndex
                  , s = e.bcy
                  , l = e.barHeight
                  , c = e.barWidth
                  , u = e.textRects
                  , d = e.dataLabelsX
                  , h = e.strokeWidth
                  , p = e.dataLabelsConfig
                  , v = e.barDataLabelsConfig
                  , g = e.barTotalDataLabelsConfig
                  , f = e.offX
                  , m = e.offY
                  , b = t.globals.gridHeight / t.globals.dataPoints;
                c = Math.abs(c);
                var x, y, k = (s += -1 !== o ? o * l : 0) - (this.barCtx.isRangeBar ? 0 : b) + l / 2 + u.height / 2 + m - 3, S = "start", C = this.barCtx.series[i][n] < 0, A = a;
                switch (this.barCtx.isReversed && (A = a + c - (C ? 2 * c : 0),
                a = t.globals.gridWidth - c),
                v.position) {
                case "center":
                    d = C ? A + c / 2 - f : Math.max(u.width / 2, A - c / 2) + f;
                    break;
                case "bottom":
                    d = C ? A + c - h - Math.round(u.width / 2) - f : A - c + h + Math.round(u.width / 2) + f;
                    break;
                case "top":
                    d = C ? A - h + Math.round(u.width / 2) - f : A - h - Math.round(u.width / 2) + f
                }
                if (this.barCtx.lastActiveBarSerieIndex === r && g.enabled) {
                    var P = new w(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({
                        realIndex: r,
                        j: n
                    }), p.fontSize);
                    C ? (x = A - h + Math.round(P.width / 2) - f - g.offsetX - 15,
                    S = "end") : x = A - h - Math.round(P.width / 2) + f + g.offsetX + 15,
                    y = k + g.offsetY
                }
                return t.config.chart.stacked || (d < 0 ? d = d + u.width + h : d + u.width / 2 > t.globals.gridWidth && (d = t.globals.gridWidth - u.width - h)),
                {
                    bcx: a,
                    bcy: s,
                    dataLabelsX: d,
                    dataLabelsY: k,
                    totalDataLabelsX: x,
                    totalDataLabelsY: y,
                    totalDataLabelsAnchor: S
                }
            }
        }, {
            key: "drawCalculatedDataLabels",
            value: function(e) {
                var t = e.x
                  , a = e.y
                  , n = e.val
                  , r = e.i
                  , o = e.j
                  , s = e.textRects
                  , l = e.barHeight
                  , c = e.barWidth
                  , u = e.dataLabelsConfig
                  , d = this.w
                  , h = "rotate(0)";
                "vertical" === d.config.plotOptions.bar.dataLabels.orientation && (h = "rotate(-90, ".concat(t, ", ").concat(a, ")"));
                var p = new H(this.barCtx.ctx)
                  , v = new w(this.barCtx.ctx)
                  , g = u.formatter
                  , f = null
                  , m = d.globals.collapsedSeriesIndices.indexOf(r) > -1;
                if (u.enabled && !m) {
                    f = v.group({
                        class: "apexcharts-data-labels",
                        transform: h
                    });
                    var b = "";
                    void 0 !== n && (b = g(n, i(i({}, d), {}, {
                        seriesIndex: r,
                        dataPointIndex: o,
                        w: d
                    }))),
                    !n && d.config.plotOptions.bar.hideZeroBarsWhenGrouped && (b = "");
                    var x = d.globals.series[r][o] < 0
                      , y = d.config.plotOptions.bar.dataLabels.position;
                    "vertical" === d.config.plotOptions.bar.dataLabels.orientation && ("top" === y && (u.textAnchor = x ? "end" : "start"),
                    "center" === y && (u.textAnchor = "middle"),
                    "bottom" === y && (u.textAnchor = x ? "end" : "start")),
                    this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && c < v.getTextRects(b, parseFloat(u.style.fontSize)).width && (b = ""),
                    d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? s.width / 1.6 > Math.abs(c) && (b = "") : s.height / 1.6 > Math.abs(l) && (b = ""));
                    var k = i({}, u);
                    this.barCtx.isHorizontal && n < 0 && ("start" === u.textAnchor ? k.textAnchor = "end" : "end" === u.textAnchor && (k.textAnchor = "start")),
                    p.plotDataLabelsText({
                        x: t,
                        y: a,
                        text: b,
                        i: r,
                        j: o,
                        parent: f,
                        dataLabelsConfig: k,
                        alwaysDrawDataLabel: !0,
                        offsetCorrection: !0
                    })
                }
                return f
            }
        }, {
            key: "drawTotalDataLabels",
            value: function(e) {
                var t, a = e.x, i = e.y, n = e.val, r = e.barWidth, o = e.barHeight, s = e.realIndex, l = e.textAnchor, c = e.barTotalDataLabelsConfig, u = this.w, d = new w(this.barCtx.ctx);
                return c.enabled && void 0 !== a && void 0 !== i && this.barCtx.lastActiveBarSerieIndex === s && (t = d.drawText({
                    x: a - (!u.globals.isBarHorizontal && u.globals.seriesGroups.length ? r / u.globals.seriesGroups.length : 0),
                    y: i - (u.globals.isBarHorizontal && u.globals.seriesGroups.length ? o / u.globals.seriesGroups.length : 0),
                    foreColor: c.style.color,
                    text: n,
                    textAnchor: l,
                    fontFamily: c.style.fontFamily,
                    fontSize: c.style.fontSize,
                    fontWeight: c.style.fontWeight
                })),
                t
            }
        }]),
        e
    }()
      , we = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.barCtx = t
        }
        return s(e, [{
            key: "initVariables",
            value: function(e) {
                var t = this.w;
                this.barCtx.series = e,
                this.barCtx.totalItems = 0,
                this.barCtx.seriesLen = 0,
                this.barCtx.visibleI = -1,
                this.barCtx.visibleItems = 1;
                for (var a = 0; a < e.length; a++)
                    if (e[a].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1,
                    this.barCtx.totalItems += e[a].length),
                    t.globals.isXNumeric)
                        for (var i = 0; i < e[a].length; i++)
                            t.globals.seriesX[a][i] > t.globals.minX && t.globals.seriesX[a][i] < t.globals.maxX && this.barCtx.visibleItems++;
                    else
                        this.barCtx.visibleItems = t.globals.dataPoints;
                0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1),
                this.barCtx.zeroSerieses = [],
                t.globals.comboCharts || this.checkZeroSeries({
                    series: e
                })
            }
        }, {
            key: "initialPositions",
            value: function() {
                var e, t, a, i, n, r, o, s, l = this.w, c = l.globals.dataPoints;
                this.barCtx.isRangeBar && (c = l.globals.labels.length);
                var u = this.barCtx.seriesLen;
                if (l.config.plotOptions.bar.rangeBarGroupRows && (u = 1),
                this.barCtx.isHorizontal)
                    n = (a = l.globals.gridHeight / c) / u,
                    l.globals.isXNumeric && (n = (a = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen),
                    n = n * parseInt(this.barCtx.barOptions.barHeight, 10) / 100,
                    -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (n = parseInt(this.barCtx.barOptions.barHeight, 10)),
                    s = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0),
                    this.barCtx.isFunnel && (s = l.globals.gridWidth / 2),
                    t = (a - n * this.barCtx.seriesLen) / 2;
                else {
                    if (i = l.globals.gridWidth / this.barCtx.visibleItems,
                    l.config.xaxis.convertedCatToNumeric && (i = l.globals.gridWidth / l.globals.dataPoints),
                    r = i / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100,
                    l.globals.isXNumeric) {
                        var d = this.barCtx.xRatio;
                        l.globals.minXDiff && .5 !== l.globals.minXDiff && l.globals.minXDiff / d > 0 && (i = l.globals.minXDiff / d),
                        (r = i / u * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1)
                    }
                    -1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (r = parseInt(this.barCtx.barOptions.columnWidth, 10)),
                    o = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0),
                    e = l.globals.padHorizontal + (i - r * this.barCtx.seriesLen) / 2
                }
                return l.globals.barHeight = n,
                l.globals.barWidth = r,
                {
                    x: e,
                    y: t,
                    yDivision: a,
                    xDivision: i,
                    barHeight: n,
                    barWidth: r,
                    zeroH: o,
                    zeroW: s
                }
            }
        }, {
            key: "initializeStackedPrevVars",
            value: function(e) {
                var t = e.w;
                t.globals.hasSeriesGroups ? t.globals.seriesGroups.forEach((function(t) {
                    e[t] || (e[t] = {}),
                    e[t].prevY = [],
                    e[t].prevX = [],
                    e[t].prevYF = [],
                    e[t].prevXF = [],
                    e[t].prevYVal = [],
                    e[t].prevXVal = []
                }
                )) : (e.prevY = [],
                e.prevX = [],
                e.prevYF = [],
                e.prevXF = [],
                e.prevYVal = [],
                e.prevXVal = [])
            }
        }, {
            key: "initializeStackedXYVars",
            value: function(e) {
                var t = e.w;
                t.globals.hasSeriesGroups ? t.globals.seriesGroups.forEach((function(t) {
                    e[t] || (e[t] = {}),
                    e[t].xArrj = [],
                    e[t].xArrjF = [],
                    e[t].xArrjVal = [],
                    e[t].yArrj = [],
                    e[t].yArrjF = [],
                    e[t].yArrjVal = []
                }
                )) : (e.xArrj = [],
                e.xArrjF = [],
                e.xArrjVal = [],
                e.yArrj = [],
                e.yArrjF = [],
                e.yArrjVal = [])
            }
        }, {
            key: "getPathFillColor",
            value: function(e, t, a, i) {
                var n, r, o, s, l = this.w, c = new R(this.barCtx.ctx), u = null, d = this.barCtx.barOptions.distributed ? a : t;
                return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map((function(i) {
                    e[t][a] >= i.from && e[t][a] <= i.to && (u = i.color)
                }
                )),
                l.config.series[t].data[a] && l.config.series[t].data[a].fillColor && (u = l.config.series[t].data[a].fillColor),
                c.fillPath({
                    seriesNumber: this.barCtx.barOptions.distributed ? d : i,
                    dataPointIndex: a,
                    color: u,
                    value: e[t][a],
                    fillConfig: null === (n = l.config.series[t].data[a]) || void 0 === n ? void 0 : n.fill,
                    fillType: null !== (r = l.config.series[t].data[a]) && void 0 !== r && null !== (o = r.fill) && void 0 !== o && o.type ? null === (s = l.config.series[t].data[a]) || void 0 === s ? void 0 : s.fill.type : Array.isArray(l.config.fill.type) ? l.config.fill.type[t] : l.config.fill.type
                })
            }
        }, {
            key: "getStrokeWidth",
            value: function(e, t, a) {
                var i = 0
                  , n = this.w;
                return void 0 === this.barCtx.series[e][t] || null === this.barCtx.series[e][t] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1,
                n.config.stroke.show && (this.barCtx.isNullValue || (i = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[a] : this.barCtx.strokeWidth)),
                i
            }
        }, {
            key: "shouldApplyRadius",
            value: function(e) {
                var t = this.w
                  , a = !1;
                return t.config.plotOptions.bar.borderRadius > 0 && (t.config.chart.stacked && "last" === t.config.plotOptions.bar.borderRadiusWhenStacked ? this.barCtx.lastActiveBarSerieIndex === e && (a = !0) : a = !0),
                a
            }
        }, {
            key: "barBackground",
            value: function(e) {
                var t = e.j
                  , a = e.i
                  , i = e.x1
                  , n = e.x2
                  , r = e.y1
                  , o = e.y2
                  , s = e.elSeries
                  , l = this.w
                  , c = new w(this.barCtx.ctx)
                  , u = new X(this.barCtx.ctx).getActiveConfigSeriesIndex();
                if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && u === a) {
                    t >= this.barCtx.barOptions.colors.backgroundBarColors.length && (t %= this.barCtx.barOptions.colors.backgroundBarColors.length);
                    var d = this.barCtx.barOptions.colors.backgroundBarColors[t]
                      , h = c.drawRect(void 0 !== i ? i : 0, void 0 !== r ? r : 0, void 0 !== n ? n : l.globals.gridWidth, void 0 !== o ? o : l.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d, this.barCtx.barOptions.colors.backgroundBarOpacity);
                    s.add(h),
                    h.node.classList.add("apexcharts-backgroundBar")
                }
            }
        }, {
            key: "getColumnPaths",
            value: function(e) {
                var t, a = e.barWidth, i = e.barXPosition, n = e.y1, r = e.y2, o = e.strokeWidth, s = e.seriesGroup, l = e.realIndex, c = e.i, u = e.j, d = e.w, h = new w(this.barCtx.ctx);
                (o = Array.isArray(o) ? o[l] : o) || (o = 0);
                var p = a
                  , v = i;
                null !== (t = d.config.series[l].data[u]) && void 0 !== t && t.columnWidthOffset && (v = i - d.config.series[l].data[u].columnWidthOffset / 2,
                p = a + d.config.series[l].data[u].columnWidthOffset);
                var g = v
                  , f = v + p;
                n += .001,
                r += .001;
                var m = h.move(g, n)
                  , b = h.move(g, n)
                  , x = h.line(f - o, n);
                if (d.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(l, u, !1)),
                m = m + h.line(g, r) + h.line(f - o, r) + h.line(f - o, n) + ("around" === d.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                b = b + h.line(g, n) + x + x + x + x + x + h.line(g, n) + ("around" === d.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                this.shouldApplyRadius(l) && (m = h.roundPathCorners(m, d.config.plotOptions.bar.borderRadius)),
                d.config.chart.stacked) {
                    var y = this.barCtx;
                    d.globals.hasSeriesGroups && s && (y = this.barCtx[s]),
                    y.yArrj.push(r),
                    y.yArrjF.push(Math.abs(n - r)),
                    y.yArrjVal.push(this.barCtx.series[c][u])
                }
                return {
                    pathTo: m,
                    pathFrom: b
                }
            }
        }, {
            key: "getBarpaths",
            value: function(e) {
                var t, a = e.barYPosition, i = e.barHeight, n = e.x1, r = e.x2, o = e.strokeWidth, s = e.seriesGroup, l = e.realIndex, c = e.i, u = e.j, d = e.w, h = new w(this.barCtx.ctx);
                (o = Array.isArray(o) ? o[l] : o) || (o = 0);
                var p = a
                  , v = i;
                null !== (t = d.config.series[l].data[u]) && void 0 !== t && t.barHeightOffset && (p = a - d.config.series[l].data[u].barHeightOffset / 2,
                v = i + d.config.series[l].data[u].barHeightOffset);
                var g = p
                  , f = p + v;
                n += .001,
                r += .001;
                var m = h.move(n, g)
                  , b = h.move(n, g);
                d.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(l, u, !1));
                var x = h.line(n, f - o);
                if (m = m + h.line(r, g) + h.line(r, f - o) + x + ("around" === d.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                b = b + h.line(n, g) + x + x + x + x + x + h.line(n, g) + ("around" === d.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z"),
                this.shouldApplyRadius(l) && (m = h.roundPathCorners(m, d.config.plotOptions.bar.borderRadius)),
                d.config.chart.stacked) {
                    var y = this.barCtx;
                    d.globals.hasSeriesGroups && s && (y = this.barCtx[s]),
                    y.xArrj.push(r),
                    y.xArrjF.push(Math.abs(n - r)),
                    y.xArrjVal.push(this.barCtx.series[c][u])
                }
                return {
                    pathTo: m,
                    pathFrom: b
                }
            }
        }, {
            key: "checkZeroSeries",
            value: function(e) {
                for (var t = e.series, a = this.w, i = 0; i < t.length; i++) {
                    for (var n = 0, r = 0; r < t[a.globals.maxValsInArrayIndex].length; r++)
                        n += t[i][r];
                    0 === n && this.barCtx.zeroSerieses.push(i)
                }
            }
        }, {
            key: "getXForValue",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] && !arguments[2] ? null : t;
                return null != e && (a = t + e / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? e / this.barCtx.invertedYRatio : 0)),
                a
            }
        }, {
            key: "getYForValue",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] && !arguments[2] ? null : t;
                return null != e && (a = t - e / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? e / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)),
                a
            }
        }, {
            key: "getGoalValues",
            value: function(e, t, a, n, r) {
                var o = this
                  , s = this.w
                  , c = []
                  , u = function(i, n) {
                    var r;
                    c.push((l(r = {}, e, "x" === e ? o.getXForValue(i, t, !1) : o.getYForValue(i, a, !1)),
                    l(r, "attrs", n),
                    r))
                };
                if (s.globals.seriesGoals[n] && s.globals.seriesGoals[n][r] && Array.isArray(s.globals.seriesGoals[n][r]) && s.globals.seriesGoals[n][r].forEach((function(e) {
                    u(e.value, e)
                }
                )),
                this.barCtx.barOptions.isDumbbell && s.globals.seriesRange.length) {
                    var d = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : s.globals.colors
                      , h = {
                        strokeHeight: "x" === e ? 0 : s.globals.markers.size[n],
                        strokeWidth: "x" === e ? s.globals.markers.size[n] : 0,
                        strokeDashArray: 0,
                        strokeLineCap: "round",
                        strokeColor: Array.isArray(d[n]) ? d[n][0] : d[n]
                    };
                    u(s.globals.seriesRangeStart[n][r], h),
                    u(s.globals.seriesRangeEnd[n][r], i(i({}, h), {}, {
                        strokeColor: Array.isArray(d[n]) ? d[n][1] : d[n]
                    }))
                }
                return c
            }
        }, {
            key: "drawGoalLine",
            value: function(e) {
                var t = e.barXPosition
                  , a = e.barYPosition
                  , i = e.goalX
                  , n = e.goalY
                  , r = e.barWidth
                  , o = e.barHeight
                  , s = new w(this.barCtx.ctx)
                  , l = s.group({
                    className: "apexcharts-bar-goals-groups"
                });
                l.node.classList.add("apexcharts-element-hidden"),
                this.barCtx.w.globals.delayedElements.push({
                    el: l.node
                }),
                l.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
                var c = null;
                return this.barCtx.isHorizontal ? Array.isArray(i) && i.forEach((function(e) {
                    var t = void 0 !== e.attrs.strokeHeight ? e.attrs.strokeHeight : o / 2
                      , i = a + t + o / 2;
                    c = s.drawLine(e.x, i - 2 * t, e.x, i, e.attrs.strokeColor ? e.attrs.strokeColor : void 0, e.attrs.strokeDashArray, e.attrs.strokeWidth ? e.attrs.strokeWidth : 2, e.attrs.strokeLineCap),
                    l.add(c)
                }
                )) : Array.isArray(n) && n.forEach((function(e) {
                    var a = void 0 !== e.attrs.strokeWidth ? e.attrs.strokeWidth : r / 2
                      , i = t + a + r / 2;
                    c = s.drawLine(i - 2 * a, e.y, i, e.y, e.attrs.strokeColor ? e.attrs.strokeColor : void 0, e.attrs.strokeDashArray, e.attrs.strokeHeight ? e.attrs.strokeHeight : 2, e.attrs.strokeLineCap),
                    l.add(c)
                }
                )),
                l
            }
        }, {
            key: "drawBarShadow",
            value: function(e) {
                var t = e.prevPaths
                  , a = e.currPaths
                  , i = e.color
                  , n = this.w
                  , r = t.x
                  , o = t.x1
                  , s = t.barYPosition
                  , l = a.x
                  , c = a.x1
                  , u = a.barYPosition
                  , d = s + a.barHeight
                  , h = new w(this.barCtx.ctx)
                  , p = new b
                  , v = h.move(o, d) + h.line(r, d) + h.line(l, u) + h.line(c, u) + h.line(o, d) + ("around" === n.config.plotOptions.bar.borderRadiusApplication ? " Z" : " z");
                return h.drawPath({
                    d: v,
                    fill: p.shadeColor(.5, b.rgb2hex(i)),
                    stroke: "none",
                    strokeWidth: 0,
                    fillOpacity: 1,
                    classes: "apexcharts-bar-shadows"
                })
            }
        }, {
            key: "getZeroValueEncounters",
            value: function(e) {
                var t = e.i
                  , a = e.j
                  , i = this.w
                  , n = 0
                  , r = 0;
                return i.globals.seriesPercent.forEach((function(e, i) {
                    e[a] && n++,
                    i < t && 0 === e[a] && r++
                }
                )),
                {
                    nonZeroColumns: n,
                    zeroEncounters: r
                }
            }
        }]),
        e
    }()
      , ke = function() {
        function e(t, a) {
            r(this, e),
            this.ctx = t,
            this.w = t.w;
            var i = this.w;
            this.barOptions = i.config.plotOptions.bar,
            this.isHorizontal = this.barOptions.horizontal,
            this.strokeWidth = i.config.stroke.width,
            this.isNullValue = !1,
            this.isRangeBar = i.globals.seriesRange.length && this.isHorizontal,
            this.isVerticalGroupedRangeBar = !i.globals.isBarHorizontal && i.globals.seriesRange.length && i.config.plotOptions.bar.rangeBarGroupRows,
            this.isFunnel = this.barOptions.isFunnel,
            this.xyRatios = a,
            null !== this.xyRatios && (this.xRatio = a.xRatio,
            this.yRatio = a.yRatio,
            this.invertedXRatio = a.invertedXRatio,
            this.invertedYRatio = a.invertedYRatio,
            this.baseLineY = a.baseLineY,
            this.baseLineInvertedY = a.baseLineInvertedY),
            this.yaxisIndex = 0,
            this.seriesLen = 0,
            this.pathArr = [];
            var n = new X(this.ctx);
            this.lastActiveBarSerieIndex = n.getActiveConfigSeriesIndex("desc", ["bar", "column"]);
            var o = n.getBarSeriesIndices()
              , s = new k(this.ctx);
            this.stackedSeriesTotals = s.getStackedSeriesTotals(this.w.config.series.map((function(e, t) {
                return -1 === o.indexOf(t) ? t : -1
            }
            )).filter((function(e) {
                return -1 !== e
            }
            ))),
            this.barHelpers = new we(this)
        }
        return s(e, [{
            key: "draw",
            value: function(e, t) {
                var a = this.w
                  , n = new w(this.ctx)
                  , r = new k(this.ctx,a);
                e = r.getLogSeries(e),
                this.series = e,
                this.yRatio = r.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(e);
                var o = n.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                });
                a.config.dataLabels.enabled && (this.totalItems,
                this.barOptions.dataLabels.maxItems);
                for (var s = 0, l = 0; s < e.length; s++,
                l++) {
                    var c, u, d, h, p = void 0, v = void 0, g = [], f = [], m = a.globals.comboCharts ? t[s] : s, x = n.group({
                        class: "apexcharts-series",
                        rel: s + 1,
                        seriesName: b.escapeString(a.globals.seriesNames[m]),
                        "data:realIndex": m
                    });
                    this.ctx.series.addCollapsedClassToSeries(x, m),
                    e[s].length > 0 && (this.visibleI = this.visibleI + 1);
                    var y = 0
                      , S = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = m),
                    this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed;
                    var C = this.barHelpers.initialPositions();
                    v = C.y,
                    y = C.barHeight,
                    u = C.yDivision,
                    h = C.zeroW,
                    p = C.x,
                    S = C.barWidth,
                    c = C.xDivision,
                    d = C.zeroH,
                    this.horizontal || f.push(p + S / 2);
                    var A = n.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": m
                    });
                    a.globals.delayedElements.push({
                        el: A.node
                    }),
                    A.node.classList.add("apexcharts-element-hidden");
                    var P = n.group({
                        class: "apexcharts-bar-goals-markers"
                    })
                      , L = n.group({
                        class: "apexcharts-bar-shadows"
                    });
                    a.globals.delayedElements.push({
                        el: L.node
                    }),
                    L.node.classList.add("apexcharts-element-hidden");
                    for (var I = 0; I < a.globals.dataPoints; I++) {
                        var _ = this.barHelpers.getStrokeWidth(s, I, m)
                          , T = null
                          , E = {
                            indexes: {
                                i: s,
                                j: I,
                                realIndex: m,
                                bc: l
                            },
                            x: p,
                            y: v,
                            strokeWidth: _,
                            elSeries: x
                        };
                        this.isHorizontal ? (T = this.drawBarPaths(i(i({}, E), {}, {
                            barHeight: y,
                            zeroW: h,
                            yDivision: u
                        })),
                        S = this.series[s][I] / this.invertedYRatio) : (T = this.drawColumnPaths(i(i({}, E), {}, {
                            xDivision: c,
                            barWidth: S,
                            zeroH: d
                        })),
                        y = this.series[s][I] / this.yRatio[this.yaxisIndex]);
                        var O = this.barHelpers.getPathFillColor(e, s, I, m);
                        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && I > 0) {
                            var V = this.barHelpers.drawBarShadow({
                                color: "string" == typeof O && -1 === (null == O ? void 0 : O.indexOf("url")) ? O : b.hexToRgba(a.globals.colors[s]),
                                prevPaths: this.pathArr[this.pathArr.length - 1],
                                currPaths: T
                            });
                            V && L.add(V)
                        }
                        this.pathArr.push(T);
                        var F = this.barHelpers.drawGoalLine({
                            barXPosition: T.barXPosition,
                            barYPosition: T.barYPosition,
                            goalX: T.goalX,
                            goalY: T.goalY,
                            barHeight: y,
                            barWidth: S
                        });
                        F && P.add(F),
                        v = T.y,
                        p = T.x,
                        I > 0 && f.push(p + S / 2),
                        g.push(v),
                        this.renderSeries({
                            realIndex: m,
                            pathFill: O,
                            j: I,
                            i: s,
                            pathFrom: T.pathFrom,
                            pathTo: T.pathTo,
                            strokeWidth: _,
                            elSeries: x,
                            x: p,
                            y: v,
                            series: e,
                            barHeight: T.barHeight ? T.barHeight : y,
                            barWidth: T.barWidth ? T.barWidth : S,
                            elDataLabelsWrap: A,
                            elGoalsMarkers: P,
                            elBarShadows: L,
                            visibleSeries: this.visibleI,
                            type: "bar"
                        })
                    }
                    a.globals.seriesXvalues[m] = f,
                    a.globals.seriesYvalues[m] = g,
                    o.add(x)
                }
                return o
            }
        }, {
            key: "renderSeries",
            value: function(e) {
                var t = e.realIndex
                  , a = e.pathFill
                  , i = e.lineFill
                  , n = e.j
                  , r = e.i
                  , o = e.groupIndex
                  , s = e.pathFrom
                  , l = e.pathTo
                  , c = e.strokeWidth
                  , u = e.elSeries
                  , d = e.x
                  , h = e.y
                  , p = e.y1
                  , v = e.y2
                  , g = e.series
                  , f = e.barHeight
                  , m = e.barWidth
                  , b = e.barXPosition
                  , x = e.barYPosition
                  , k = e.elDataLabelsWrap
                  , S = e.elGoalsMarkers
                  , C = e.elBarShadows
                  , A = e.visibleSeries
                  , P = e.type
                  , L = this.w
                  , I = new w(this.ctx);
                i || (i = this.barOptions.distributed ? L.globals.stroke.colors[n] : L.globals.stroke.colors[t]),
                L.config.series[r].data[n] && L.config.series[r].data[n].strokeColor && (i = L.config.series[r].data[n].strokeColor),
                this.isNullValue && (a = "none");
                var _ = n / L.config.chart.animations.animateGradually.delay * (L.config.chart.animations.speed / L.globals.dataPoints) / 2.4
                  , T = I.renderPaths({
                    i: r,
                    j: n,
                    realIndex: t,
                    pathFrom: s,
                    pathTo: l,
                    stroke: i,
                    strokeWidth: c,
                    strokeLineCap: L.config.stroke.lineCap,
                    fill: a,
                    animationDelay: _,
                    initialSpeed: L.config.chart.animations.speed,
                    dataChangeSpeed: L.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(P, "-area")
                });
                T.attr("clip-path", "url(#gridRectMask".concat(L.globals.cuid, ")"));
                var E = L.config.forecastDataPoints;
                E.count > 0 && n >= L.globals.dataPoints - E.count && (T.node.setAttribute("stroke-dasharray", E.dashArray),
                T.node.setAttribute("stroke-width", E.strokeWidth),
                T.node.setAttribute("fill-opacity", E.fillOpacity)),
                void 0 !== p && void 0 !== v && (T.attr("data-range-y1", p),
                T.attr("data-range-y2", v)),
                new y(this.ctx).setSelectionFilter(T, t, n),
                u.add(T);
                var O = new ye(this).handleBarDataLabels({
                    x: d,
                    y: h,
                    y1: p,
                    y2: v,
                    i: r,
                    j: n,
                    series: g,
                    realIndex: t,
                    groupIndex: o,
                    barHeight: f,
                    barWidth: m,
                    barXPosition: b,
                    barYPosition: x,
                    renderedPath: T,
                    visibleSeries: A
                });
                return null !== O.dataLabels && k.add(O.dataLabels),
                O.totalDataLabels && k.add(O.totalDataLabels),
                u.add(k),
                S && u.add(S),
                C && u.add(C),
                u
            }
        }, {
            key: "drawBarPaths",
            value: function(e) {
                var t, a = e.indexes, i = e.barHeight, n = e.strokeWidth, r = e.zeroW, o = e.x, s = e.y, l = e.yDivision, c = e.elSeries, u = this.w, d = a.i, h = a.j;
                if (u.globals.isXNumeric)
                    t = (s = (u.globals.seriesX[d][h] - u.globals.minX) / this.invertedXRatio - i) + i * this.visibleI;
                else if (u.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
                    var p = 0
                      , v = 0;
                    u.globals.seriesPercent.forEach((function(e, t) {
                        e[h] && p++,
                        t < d && 0 === e[h] && v++
                    }
                    )),
                    p > 0 && (i = this.seriesLen * i / p),
                    t = s + i * this.visibleI,
                    t -= i * v
                } else
                    t = s + i * this.visibleI;
                this.isFunnel && (r -= (this.barHelpers.getXForValue(this.series[d][h], r) - r) / 2),
                o = this.barHelpers.getXForValue(this.series[d][h], r);
                var g = this.barHelpers.getBarpaths({
                    barYPosition: t,
                    barHeight: i,
                    x1: r,
                    x2: o,
                    strokeWidth: n,
                    series: this.series,
                    realIndex: a.realIndex,
                    i: d,
                    j: h,
                    w: u
                });
                return u.globals.isXNumeric || (s += l),
                this.barHelpers.barBackground({
                    j: h,
                    i: d,
                    y1: t - i * this.visibleI,
                    y2: i * this.seriesLen,
                    elSeries: c
                }),
                {
                    pathTo: g.pathTo,
                    pathFrom: g.pathFrom,
                    x1: r,
                    x: o,
                    y: s,
                    goalX: this.barHelpers.getGoalValues("x", r, null, d, h),
                    barYPosition: t,
                    barHeight: i
                }
            }
        }, {
            key: "drawColumnPaths",
            value: function(e) {
                var t, a = e.indexes, i = e.x, n = e.y, r = e.xDivision, o = e.barWidth, s = e.zeroH, l = e.strokeWidth, c = e.elSeries, u = this.w, d = a.realIndex, h = a.i, p = a.j, v = a.bc;
                if (u.globals.isXNumeric) {
                    var g = this.getBarXForNumericXAxis({
                        x: i,
                        j: p,
                        realIndex: d,
                        barWidth: o
                    });
                    i = g.x,
                    t = g.barXPosition
                } else if (u.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
                    var f = this.barHelpers.getZeroValueEncounters({
                        i: h,
                        j: p
                    })
                      , m = f.nonZeroColumns
                      , b = f.zeroEncounters;
                    m > 0 && (o = this.seriesLen * o / m),
                    t = i + o * this.visibleI,
                    t -= o * b
                } else
                    t = i + o * this.visibleI;
                n = this.barHelpers.getYForValue(this.series[h][p], s);
                var x = this.barHelpers.getColumnPaths({
                    barXPosition: t,
                    barWidth: o,
                    y1: s,
                    y2: n,
                    strokeWidth: l,
                    series: this.series,
                    realIndex: a.realIndex,
                    i: h,
                    j: p,
                    w: u
                });
                return u.globals.isXNumeric || (i += r),
                this.barHelpers.barBackground({
                    bc: v,
                    j: p,
                    i: h,
                    x1: t - l / 2 - o * this.visibleI,
                    x2: o * this.seriesLen + l / 2,
                    elSeries: c
                }),
                {
                    pathTo: x.pathTo,
                    pathFrom: x.pathFrom,
                    x: i,
                    y: n,
                    goalY: this.barHelpers.getGoalValues("y", null, s, h, p),
                    barXPosition: t,
                    barWidth: o
                }
            }
        }, {
            key: "getBarXForNumericXAxis",
            value: function(e) {
                var t = e.x
                  , a = e.barWidth
                  , i = e.realIndex
                  , n = e.j
                  , r = this.w
                  , o = i;
                return r.globals.seriesX[i].length || (o = r.globals.maxValsInArrayIndex),
                r.globals.seriesX[o][n] && (t = (r.globals.seriesX[o][n] - r.globals.minX) / this.xRatio - a * this.seriesLen / 2),
                {
                    barXPosition: t + a * this.visibleI,
                    x: t
                }
            }
        }, {
            key: "getPreviousPath",
            value: function(e, t) {
                for (var a, i = this.w, n = 0; n < i.globals.previousPaths.length; n++) {
                    var r = i.globals.previousPaths[n];
                    r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(e, 10) && void 0 !== i.globals.previousPaths[n].paths[t] && (a = i.globals.previousPaths[n].paths[t].d)
                }
                return a
            }
        }]),
        e
    }()
      , Se = function() {
        c(t, ke);
        var e = p(t);
        function t() {
            return r(this, t),
            e.apply(this, arguments)
        }
        return s(t, [{
            key: "draw",
            value: function(e, t) {
                var a = this
                  , n = this.w;
                this.graphics = new w(this.ctx),
                this.bar = new ke(this.ctx,this.xyRatios);
                var r = new k(this.ctx,n);
                e = r.getLogSeries(e),
                this.yRatio = r.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(e),
                "100%" === n.config.chart.stackType && (e = n.globals.seriesPercent.slice()),
                this.series = e,
                this.barHelpers.initializeStackedPrevVars(this);
                for (var o = this.graphics.group({
                    class: "apexcharts-bar-series apexcharts-plot-series"
                }), s = 0, l = 0, c = function(r, c) {
                    var u = void 0
                      , d = void 0
                      , h = void 0
                      , p = void 0
                      , v = -1;
                    a.groupCtx = a,
                    n.globals.seriesGroups.forEach((function(e, t) {
                        e.indexOf(n.config.series[r].name) > -1 && (v = t)
                    }
                    )),
                    -1 !== v && (a.groupCtx = a[n.globals.seriesGroups[v]]);
                    var g = []
                      , f = []
                      , m = n.globals.comboCharts ? t[r] : r;
                    a.yRatio.length > 1 && (a.yaxisIndex = m),
                    a.isReversed = n.config.yaxis[a.yaxisIndex] && n.config.yaxis[a.yaxisIndex].reversed;
                    var x = a.graphics.group({
                        class: "apexcharts-series",
                        seriesName: b.escapeString(n.globals.seriesNames[m]),
                        rel: r + 1,
                        "data:realIndex": m
                    });
                    a.ctx.series.addCollapsedClassToSeries(x, m);
                    var y = a.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": m
                    })
                      , w = a.graphics.group({
                        class: "apexcharts-bar-goals-markers"
                    })
                      , k = 0
                      , S = 0
                      , C = a.initialPositions(s, l, u, d, h, p);
                    l = C.y,
                    k = C.barHeight,
                    d = C.yDivision,
                    p = C.zeroW,
                    s = C.x,
                    S = C.barWidth,
                    u = C.xDivision,
                    h = C.zeroH,
                    n.globals.barHeight = k,
                    n.globals.barWidth = S,
                    a.barHelpers.initializeStackedXYVars(a),
                    1 === a.groupCtx.prevY.length && a.groupCtx.prevY[0].every((function(e) {
                        return isNaN(e)
                    }
                    )) && (a.groupCtx.prevY[0] = a.groupCtx.prevY[0].map((function(e) {
                        return h
                    }
                    )),
                    a.groupCtx.prevYF[0] = a.groupCtx.prevYF[0].map((function(e) {
                        return 0
                    }
                    )));
                    for (var A = 0; A < n.globals.dataPoints; A++) {
                        var P = a.barHelpers.getStrokeWidth(r, A, m)
                          , L = {
                            indexes: {
                                i: r,
                                j: A,
                                realIndex: m,
                                bc: c
                            },
                            strokeWidth: P,
                            x: s,
                            y: l,
                            elSeries: x,
                            groupIndex: v,
                            seriesGroup: n.globals.seriesGroups[v]
                        }
                          , I = null;
                        a.isHorizontal ? (I = a.drawStackedBarPaths(i(i({}, L), {}, {
                            zeroW: p,
                            barHeight: k,
                            yDivision: d
                        })),
                        S = a.series[r][A] / a.invertedYRatio) : (I = a.drawStackedColumnPaths(i(i({}, L), {}, {
                            xDivision: u,
                            barWidth: S,
                            zeroH: h
                        })),
                        k = a.series[r][A] / a.yRatio[a.yaxisIndex]);
                        var _ = a.barHelpers.drawGoalLine({
                            barXPosition: I.barXPosition,
                            barYPosition: I.barYPosition,
                            goalX: I.goalX,
                            goalY: I.goalY,
                            barHeight: k,
                            barWidth: S
                        });
                        _ && w.add(_),
                        l = I.y,
                        s = I.x,
                        g.push(s),
                        f.push(l);
                        var T = a.barHelpers.getPathFillColor(e, r, A, m);
                        x = a.renderSeries({
                            realIndex: m,
                            pathFill: T,
                            j: A,
                            i: r,
                            groupIndex: v,
                            pathFrom: I.pathFrom,
                            pathTo: I.pathTo,
                            strokeWidth: P,
                            elSeries: x,
                            x: s,
                            y: l,
                            series: e,
                            barHeight: k,
                            barWidth: S,
                            elDataLabelsWrap: y,
                            elGoalsMarkers: w,
                            type: "bar",
                            visibleSeries: 0
                        })
                    }
                    n.globals.seriesXvalues[m] = g,
                    n.globals.seriesYvalues[m] = f,
                    a.groupCtx.prevY.push(a.groupCtx.yArrj),
                    a.groupCtx.prevYF.push(a.groupCtx.yArrjF),
                    a.groupCtx.prevYVal.push(a.groupCtx.yArrjVal),
                    a.groupCtx.prevX.push(a.groupCtx.xArrj),
                    a.groupCtx.prevXF.push(a.groupCtx.xArrjF),
                    a.groupCtx.prevXVal.push(a.groupCtx.xArrjVal),
                    o.add(x)
                }, u = 0, d = 0; u < e.length; u++,
                d++)
                    c(u, d);
                return o
            }
        }, {
            key: "initialPositions",
            value: function(e, t, a, i, n, r) {
                var o, s, l, c, u = this.w;
                return this.isHorizontal ? (l = (l = i = u.globals.gridHeight / u.globals.dataPoints) * parseInt(u.config.plotOptions.bar.barHeight, 10) / 100,
                -1 === String(u.config.plotOptions.bar.barHeight).indexOf("%") && (l = parseInt(u.config.plotOptions.bar.barHeight, 10)),
                r = this.baseLineInvertedY + u.globals.padHorizontal + (this.isReversed ? u.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0),
                t = (i - l) / 2) : (c = a = u.globals.gridWidth / u.globals.dataPoints,
                c = u.globals.isXNumeric && u.globals.dataPoints > 1 ? (a = u.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : c * parseInt(u.config.plotOptions.bar.columnWidth, 10) / 100,
                -1 === String(u.config.plotOptions.bar.columnWidth).indexOf("%") && (c = parseInt(u.config.plotOptions.bar.columnWidth, 10)),
                n = u.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? u.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0),
                e = u.globals.padHorizontal + (a - c) / 2),
                {
                    x: e,
                    y: t,
                    yDivision: i,
                    xDivision: a,
                    barHeight: null !== (o = u.globals.seriesGroups) && void 0 !== o && o.length ? l / u.globals.seriesGroups.length : l,
                    barWidth: null !== (s = u.globals.seriesGroups) && void 0 !== s && s.length ? c / u.globals.seriesGroups.length : c,
                    zeroH: n,
                    zeroW: r
                }
            }
        }, {
            key: "drawStackedBarPaths",
            value: function(e) {
                for (var t, a = e.indexes, i = e.barHeight, n = e.strokeWidth, r = e.zeroW, o = e.x, s = e.y, l = e.groupIndex, c = e.seriesGroup, u = e.yDivision, d = e.elSeries, h = this.w, p = s + (-1 !== l ? l * i : 0), v = a.i, g = a.j, f = 0, m = 0; m < this.groupCtx.prevXF.length; m++)
                    f += this.groupCtx.prevXF[m][g];
                var b = v;
                if (c && (b = c.indexOf(h.config.series[v].name)),
                b > 0) {
                    var x = r;
                    this.groupCtx.prevXVal[b - 1][g] < 0 ? x = this.series[v][g] >= 0 ? this.groupCtx.prevX[b - 1][g] + f - 2 * (this.isReversed ? f : 0) : this.groupCtx.prevX[b - 1][g] : this.groupCtx.prevXVal[b - 1][g] >= 0 && (x = this.series[v][g] >= 0 ? this.groupCtx.prevX[b - 1][g] : this.groupCtx.prevX[b - 1][g] - f + 2 * (this.isReversed ? f : 0)),
                    t = x
                } else
                    t = r;
                o = null === this.series[v][g] ? t : t + this.series[v][g] / this.invertedYRatio - 2 * (this.isReversed ? this.series[v][g] / this.invertedYRatio : 0);
                var y = this.barHelpers.getBarpaths({
                    barYPosition: p,
                    barHeight: i,
                    x1: t,
                    x2: o,
                    strokeWidth: n,
                    series: this.series,
                    realIndex: a.realIndex,
                    seriesGroup: c,
                    i: v,
                    j: g,
                    w: h
                });
                return this.barHelpers.barBackground({
                    j: g,
                    i: v,
                    y1: p,
                    y2: i,
                    elSeries: d
                }),
                s += u,
                {
                    pathTo: y.pathTo,
                    pathFrom: y.pathFrom,
                    goalX: this.barHelpers.getGoalValues("x", r, null, v, g),
                    barYPosition: p,
                    x: o,
                    y: s
                }
            }
        }, {
            key: "drawStackedColumnPaths",
            value: function(e) {
                var t = e.indexes
                  , a = e.x
                  , i = e.y
                  , n = e.xDivision
                  , r = e.barWidth
                  , o = e.zeroH
                  , s = e.groupIndex
                  , l = e.seriesGroup
                  , c = e.elSeries
                  , u = this.w
                  , d = t.i
                  , h = t.j
                  , p = t.bc;
                if (u.globals.isXNumeric) {
                    var v = u.globals.seriesX[d][h];
                    v || (v = 0),
                    a = (v - u.globals.minX) / this.xRatio - r / 2,
                    u.globals.seriesGroups.length && (a = (v - u.globals.minX) / this.xRatio - r / 2 * u.globals.seriesGroups.length)
                }
                for (var g, f = a + (-1 !== s ? s * r : 0), m = 0, b = 0; b < this.groupCtx.prevYF.length; b++)
                    m += isNaN(this.groupCtx.prevYF[b][h]) ? 0 : this.groupCtx.prevYF[b][h];
                var x = d;
                if (l && (x = l.indexOf(u.config.series[d].name)),
                x > 0 && !u.globals.isXNumeric || x > 0 && u.globals.isXNumeric && u.globals.seriesX[d - 1][h] === u.globals.seriesX[d][h]) {
                    var y, w, k, S = Math.min(this.yRatio.length + 1, d + 1);
                    if (void 0 !== this.groupCtx.prevY[x - 1] && this.groupCtx.prevY[x - 1].length)
                        for (var C = 1; C < S; C++) {
                            var A;
                            if (!isNaN(null === (A = this.groupCtx.prevY[x - C]) || void 0 === A ? void 0 : A[h])) {
                                k = this.groupCtx.prevY[x - C][h];
                                break
                            }
                        }
                    for (var P = 1; P < S; P++) {
                        var L, I;
                        if ((null === (L = this.groupCtx.prevYVal[x - P]) || void 0 === L ? void 0 : L[h]) < 0) {
                            w = this.series[d][h] >= 0 ? k - m + 2 * (this.isReversed ? m : 0) : k;
                            break
                        }
                        if ((null === (I = this.groupCtx.prevYVal[x - P]) || void 0 === I ? void 0 : I[h]) >= 0) {
                            w = this.series[d][h] >= 0 ? k : k + m - 2 * (this.isReversed ? m : 0);
                            break
                        }
                    }
                    void 0 === w && (w = u.globals.gridHeight),
                    g = null !== (y = this.groupCtx.prevYF[0]) && void 0 !== y && y.every((function(e) {
                        return 0 === e
                    }
                    )) && this.groupCtx.prevYF.slice(1, x).every((function(e) {
                        return e.every((function(e) {
                            return isNaN(e)
                        }
                        ))
                    }
                    )) ? o : w
                } else
                    g = o;
                i = this.series[d][h] ? g - this.series[d][h] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[d][h] / this.yRatio[this.yaxisIndex] : 0) : g;
                var _ = this.barHelpers.getColumnPaths({
                    barXPosition: f,
                    barWidth: r,
                    y1: g,
                    y2: i,
                    yRatio: this.yRatio[this.yaxisIndex],
                    strokeWidth: this.strokeWidth,
                    series: this.series,
                    seriesGroup: l,
                    realIndex: t.realIndex,
                    i: d,
                    j: h,
                    w: u
                });
                return this.barHelpers.barBackground({
                    bc: p,
                    j: h,
                    i: d,
                    x1: f,
                    x2: r,
                    elSeries: c
                }),
                a += n,
                {
                    pathTo: _.pathTo,
                    pathFrom: _.pathFrom,
                    goalY: this.barHelpers.getGoalValues("y", null, o, d, h),
                    barXPosition: f,
                    x: u.globals.isXNumeric ? a - n : a,
                    y: i
                }
            }
        }]),
        t
    }()
      , Ce = function() {
        c(t, ke);
        var e = p(t);
        function t() {
            return r(this, t),
            e.apply(this, arguments)
        }
        return s(t, [{
            key: "draw",
            value: function(e, t, a) {
                var n = this
                  , r = this.w
                  , o = new w(this.ctx)
                  , s = r.globals.comboCharts ? t : r.config.chart.type
                  , l = new R(this.ctx);
                this.candlestickOptions = this.w.config.plotOptions.candlestick,
                this.boxOptions = this.w.config.plotOptions.boxPlot,
                this.isHorizontal = r.config.plotOptions.bar.horizontal;
                var c = new k(this.ctx,r);
                e = c.getLogSeries(e),
                this.series = e,
                this.yRatio = c.getLogYRatios(this.yRatio),
                this.barHelpers.initVariables(e);
                for (var u = o.group({
                    class: "apexcharts-".concat(s, "-series apexcharts-plot-series")
                }), d = function(t) {
                    n.isBoxPlot = "boxPlot" === r.config.chart.type || "boxPlot" === r.config.series[t].type;
                    var s, c, d, h, p, v, g = void 0, f = void 0, m = [], x = [], y = r.globals.comboCharts ? a[t] : t, w = o.group({
                        class: "apexcharts-series",
                        seriesName: b.escapeString(r.globals.seriesNames[y]),
                        rel: t + 1,
                        "data:realIndex": y
                    });
                    n.ctx.series.addCollapsedClassToSeries(w, y),
                    e[t].length > 0 && (n.visibleI = n.visibleI + 1),
                    n.yRatio.length > 1 && (n.yaxisIndex = y);
                    var k = n.barHelpers.initialPositions();
                    f = k.y,
                    p = k.barHeight,
                    c = k.yDivision,
                    h = k.zeroW,
                    g = k.x,
                    v = k.barWidth,
                    s = k.xDivision,
                    d = k.zeroH,
                    x.push(g + v / 2);
                    for (var S = o.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": y
                    }), C = function(a) {
                        var o = n.barHelpers.getStrokeWidth(t, a, y)
                          , u = null
                          , b = {
                            indexes: {
                                i: t,
                                j: a,
                                realIndex: y
                            },
                            x: g,
                            y: f,
                            strokeWidth: o,
                            elSeries: w
                        };
                        u = n.isHorizontal ? n.drawHorizontalBoxPaths(i(i({}, b), {}, {
                            yDivision: c,
                            barHeight: p,
                            zeroW: h
                        })) : n.drawVerticalBoxPaths(i(i({}, b), {}, {
                            xDivision: s,
                            barWidth: v,
                            zeroH: d
                        })),
                        f = u.y,
                        g = u.x,
                        a > 0 && x.push(g + v / 2),
                        m.push(f),
                        u.pathTo.forEach((function(i, s) {
                            var c = !n.isBoxPlot && n.candlestickOptions.wick.useFillColor ? u.color[s] : r.globals.stroke.colors[t]
                              , d = l.fillPath({
                                seriesNumber: y,
                                dataPointIndex: a,
                                color: u.color[s],
                                value: e[t][a]
                            });
                            n.renderSeries({
                                realIndex: y,
                                pathFill: d,
                                lineFill: c,
                                j: a,
                                i: t,
                                pathFrom: u.pathFrom,
                                pathTo: i,
                                strokeWidth: o,
                                elSeries: w,
                                x: g,
                                y: f,
                                series: e,
                                barHeight: p,
                                barWidth: v,
                                elDataLabelsWrap: S,
                                visibleSeries: n.visibleI,
                                type: r.config.chart.type
                            })
                        }
                        ))
                    }, A = 0; A < r.globals.dataPoints; A++)
                        C(A);
                    r.globals.seriesXvalues[y] = x,
                    r.globals.seriesYvalues[y] = m,
                    u.add(w)
                }, h = 0; h < e.length; h++)
                    d(h);
                return u
            }
        }, {
            key: "drawVerticalBoxPaths",
            value: function(e) {
                var t = e.indexes
                  , a = e.x;
                e.y;
                var i = e.xDivision
                  , n = e.barWidth
                  , r = e.zeroH
                  , o = e.strokeWidth
                  , s = this.w
                  , l = new w(this.ctx)
                  , c = t.i
                  , u = t.j
                  , d = !0
                  , h = s.config.plotOptions.candlestick.colors.upward
                  , p = s.config.plotOptions.candlestick.colors.downward
                  , v = "";
                this.isBoxPlot && (v = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                var g = this.yRatio[this.yaxisIndex]
                  , f = t.realIndex
                  , m = this.getOHLCValue(f, u)
                  , b = r
                  , x = r;
                m.o > m.c && (d = !1);
                var y = Math.min(m.o, m.c)
                  , k = Math.max(m.o, m.c)
                  , S = m.m;
                s.globals.isXNumeric && (a = (s.globals.seriesX[f][u] - s.globals.minX) / this.xRatio - n / 2);
                var C = a + n * this.visibleI;
                void 0 === this.series[c][u] || null === this.series[c][u] ? (y = r,
                k = r) : (y = r - y / g,
                k = r - k / g,
                b = r - m.h / g,
                x = r - m.l / g,
                S = r - m.m / g);
                var A = l.move(C, r)
                  , P = l.move(C + n / 2, y);
                return s.globals.previousPaths.length > 0 && (P = this.getPreviousPath(f, u, !0)),
                A = this.isBoxPlot ? [l.move(C, y) + l.line(C + n / 2, y) + l.line(C + n / 2, b) + l.line(C + n / 4, b) + l.line(C + n - n / 4, b) + l.line(C + n / 2, b) + l.line(C + n / 2, y) + l.line(C + n, y) + l.line(C + n, S) + l.line(C, S) + l.line(C, y + o / 2), l.move(C, S) + l.line(C + n, S) + l.line(C + n, k) + l.line(C + n / 2, k) + l.line(C + n / 2, x) + l.line(C + n - n / 4, x) + l.line(C + n / 4, x) + l.line(C + n / 2, x) + l.line(C + n / 2, k) + l.line(C, k) + l.line(C, S) + "z"] : [l.move(C, k) + l.line(C + n / 2, k) + l.line(C + n / 2, b) + l.line(C + n / 2, k) + l.line(C + n, k) + l.line(C + n, y) + l.line(C + n / 2, y) + l.line(C + n / 2, x) + l.line(C + n / 2, y) + l.line(C, y) + l.line(C, k - o / 2)],
                P += l.move(C, y),
                s.globals.isXNumeric || (a += i),
                {
                    pathTo: A,
                    pathFrom: P,
                    x: a,
                    y: k,
                    barXPosition: C,
                    color: this.isBoxPlot ? v : d ? [h] : [p]
                }
            }
        }, {
            key: "drawHorizontalBoxPaths",
            value: function(e) {
                var t = e.indexes;
                e.x;
                var a = e.y
                  , i = e.yDivision
                  , n = e.barHeight
                  , r = e.zeroW
                  , o = e.strokeWidth
                  , s = this.w
                  , l = new w(this.ctx)
                  , c = t.i
                  , u = t.j
                  , d = this.boxOptions.colors.lower;
                this.isBoxPlot && (d = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                var h = this.invertedYRatio
                  , p = t.realIndex
                  , v = this.getOHLCValue(p, u)
                  , g = r
                  , f = r
                  , m = Math.min(v.o, v.c)
                  , b = Math.max(v.o, v.c)
                  , x = v.m;
                s.globals.isXNumeric && (a = (s.globals.seriesX[p][u] - s.globals.minX) / this.invertedXRatio - n / 2);
                var y = a + n * this.visibleI;
                void 0 === this.series[c][u] || null === this.series[c][u] ? (m = r,
                b = r) : (m = r + m / h,
                b = r + b / h,
                g = r + v.h / h,
                f = r + v.l / h,
                x = r + v.m / h);
                var k = l.move(r, y)
                  , S = l.move(m, y + n / 2);
                return s.globals.previousPaths.length > 0 && (S = this.getPreviousPath(p, u, !0)),
                k = [l.move(m, y) + l.line(m, y + n / 2) + l.line(g, y + n / 2) + l.line(g, y + n / 2 - n / 4) + l.line(g, y + n / 2 + n / 4) + l.line(g, y + n / 2) + l.line(m, y + n / 2) + l.line(m, y + n) + l.line(x, y + n) + l.line(x, y) + l.line(m + o / 2, y), l.move(x, y) + l.line(x, y + n) + l.line(b, y + n) + l.line(b, y + n / 2) + l.line(f, y + n / 2) + l.line(f, y + n - n / 4) + l.line(f, y + n / 4) + l.line(f, y + n / 2) + l.line(b, y + n / 2) + l.line(b, y) + l.line(x, y) + "z"],
                S += l.move(m, y),
                s.globals.isXNumeric || (a += i),
                {
                    pathTo: k,
                    pathFrom: S,
                    x: b,
                    y: a,
                    barYPosition: y,
                    color: d
                }
            }
        }, {
            key: "getOHLCValue",
            value: function(e, t) {
                var a = this.w;
                return {
                    o: this.isBoxPlot ? a.globals.seriesCandleH[e][t] : a.globals.seriesCandleO[e][t],
                    h: this.isBoxPlot ? a.globals.seriesCandleO[e][t] : a.globals.seriesCandleH[e][t],
                    m: a.globals.seriesCandleM[e][t],
                    l: this.isBoxPlot ? a.globals.seriesCandleC[e][t] : a.globals.seriesCandleL[e][t],
                    c: this.isBoxPlot ? a.globals.seriesCandleL[e][t] : a.globals.seriesCandleC[e][t]
                }
            }
        }]),
        t
    }()
      , Ae = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "checkColorRange",
            value: function() {
                var e = this.w
                  , t = !1
                  , a = e.config.plotOptions[e.config.chart.type];
                return a.colorScale.ranges.length > 0 && a.colorScale.ranges.map((function(e, a) {
                    e.from <= 0 && (t = !0)
                }
                )),
                t
            }
        }, {
            key: "getShadeColor",
            value: function(e, t, a, i) {
                var n = this.w
                  , r = 1
                  , o = n.config.plotOptions[e].shadeIntensity
                  , s = this.determineColor(e, t, a);
                n.globals.hasNegs || i ? r = n.config.plotOptions[e].reverseNegativeShade ? s.percent < 0 ? s.percent / 100 * (1.25 * o) : (1 - s.percent / 100) * (1.25 * o) : s.percent <= 0 ? 1 - (1 + s.percent / 100) * o : (1 - s.percent / 100) * o : (r = 1 - s.percent / 100,
                "treemap" === e && (r = (1 - s.percent / 100) * (1.25 * o)));
                var l = s.color
                  , c = new b;
                return n.config.plotOptions[e].enableShades && (l = "dark" === this.w.config.theme.mode ? b.hexToRgba(c.shadeColor(-1 * r, s.color), n.config.fill.opacity) : b.hexToRgba(c.shadeColor(r, s.color), n.config.fill.opacity)),
                {
                    color: l,
                    colorProps: s
                }
            }
        }, {
            key: "determineColor",
            value: function(e, t, a) {
                var i = this.w
                  , n = i.globals.series[t][a]
                  , r = i.config.plotOptions[e]
                  , o = r.colorScale.inverse ? a : t;
                r.distributed && "treemap" === i.config.chart.type && (o = a);
                var s = i.globals.colors[o]
                  , l = null
                  , c = Math.min.apply(Math, g(i.globals.series[t]))
                  , u = Math.max.apply(Math, g(i.globals.series[t]));
                r.distributed || "heatmap" !== e || (c = i.globals.minY,
                u = i.globals.maxY),
                void 0 !== r.colorScale.min && (c = r.colorScale.min < i.globals.minY ? r.colorScale.min : i.globals.minY,
                u = r.colorScale.max > i.globals.maxY ? r.colorScale.max : i.globals.maxY);
                var d = Math.abs(u) + Math.abs(c)
                  , h = 100 * n / (0 === d ? d - 1e-6 : d);
                return r.colorScale.ranges.length > 0 && r.colorScale.ranges.map((function(e, t) {
                    if (n >= e.from && n <= e.to) {
                        s = e.color,
                        l = e.foreColor ? e.foreColor : null,
                        c = e.from,
                        u = e.to;
                        var a = Math.abs(u) + Math.abs(c);
                        h = 100 * n / (0 === a ? a - 1e-6 : a)
                    }
                }
                )),
                {
                    color: s,
                    foreColor: l,
                    percent: h
                }
            }
        }, {
            key: "calculateDataLabels",
            value: function(e) {
                var t = e.text
                  , a = e.x
                  , i = e.y
                  , n = e.i
                  , r = e.j
                  , o = e.colorProps
                  , s = e.fontSize
                  , l = this.w.config.dataLabels
                  , c = new w(this.ctx)
                  , u = new H(this.ctx)
                  , d = null;
                if (l.enabled) {
                    d = c.group({
                        class: "apexcharts-data-labels"
                    });
                    var h = l.offsetX
                      , p = l.offsetY
                      , v = a + h
                      , g = i + parseFloat(l.style.fontSize) / 3 + p;
                    u.plotDataLabelsText({
                        x: v,
                        y: g,
                        text: t,
                        i: n,
                        j: r,
                        color: o.foreColor,
                        parent: d,
                        fontSize: s,
                        dataLabelsConfig: l
                    })
                }
                return d
            }
        }, {
            key: "addListeners",
            value: function(e) {
                var t = new w(this.ctx);
                e.node.addEventListener("mouseenter", t.pathMouseEnter.bind(this, e)),
                e.node.addEventListener("mouseleave", t.pathMouseLeave.bind(this, e)),
                e.node.addEventListener("mousedown", t.pathMouseDown.bind(this, e))
            }
        }]),
        e
    }()
      , Pe = function() {
        function e(t, a) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.xRatio = a.xRatio,
            this.yRatio = a.yRatio,
            this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation,
            this.helpers = new Ae(t),
            this.rectRadius = this.w.config.plotOptions.heatmap.radius,
            this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
        }
        return s(e, [{
            key: "draw",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx)
                  , i = a.group({
                    class: "apexcharts-heatmap"
                });
                i.attr("clip-path", "url(#gridRectMask".concat(t.globals.cuid, ")"));
                var n = t.globals.gridWidth / t.globals.dataPoints
                  , r = t.globals.gridHeight / t.globals.series.length
                  , o = 0
                  , s = !1;
                this.negRange = this.helpers.checkColorRange();
                var l = e.slice();
                t.config.yaxis[0].reversed && (s = !0,
                l.reverse());
                for (var c = s ? 0 : l.length - 1; s ? c < l.length : c >= 0; s ? c++ : c--) {
                    var u = a.group({
                        class: "apexcharts-series apexcharts-heatmap-series",
                        seriesName: b.escapeString(t.globals.seriesNames[c]),
                        rel: c + 1,
                        "data:realIndex": c
                    });
                    if (this.ctx.series.addCollapsedClassToSeries(u, c),
                    t.config.chart.dropShadow.enabled) {
                        var d = t.config.chart.dropShadow;
                        new y(this.ctx).dropShadow(u, d, c)
                    }
                    for (var h = 0, p = t.config.plotOptions.heatmap.shadeIntensity, v = 0; v < l[c].length; v++) {
                        var g = this.helpers.getShadeColor(t.config.chart.type, c, v, this.negRange)
                          , f = g.color
                          , m = g.colorProps;
                        "image" === t.config.fill.type && (f = new R(this.ctx).fillPath({
                            seriesNumber: c,
                            dataPointIndex: v,
                            opacity: t.globals.hasNegs ? m.percent < 0 ? 1 - (1 + m.percent / 100) : p + m.percent / 100 : m.percent / 100,
                            patternID: b.randomId(),
                            width: t.config.fill.image.width ? t.config.fill.image.width : n,
                            height: t.config.fill.image.height ? t.config.fill.image.height : r
                        }));
                        var x = this.rectRadius
                          , k = a.drawRect(h, o, n, r, x);
                        if (k.attr({
                            cx: h,
                            cy: o
                        }),
                        k.node.classList.add("apexcharts-heatmap-rect"),
                        u.add(k),
                        k.attr({
                            fill: f,
                            i: c,
                            index: c,
                            j: v,
                            val: e[c][v],
                            "stroke-width": this.strokeWidth,
                            stroke: t.config.plotOptions.heatmap.useFillColorAsStroke ? f : t.globals.stroke.colors[0],
                            color: f
                        }),
                        this.helpers.addListeners(k),
                        t.config.chart.animations.enabled && !t.globals.dataChanged) {
                            var S = 1;
                            t.globals.resized || (S = t.config.chart.animations.speed),
                            this.animateHeatMap(k, h, o, n, r, S)
                        }
                        if (t.globals.dataChanged) {
                            var C = 1;
                            if (this.dynamicAnim.enabled && t.globals.shouldAnimate) {
                                C = this.dynamicAnim.speed;
                                var A = t.globals.previousPaths[c] && t.globals.previousPaths[c][v] && t.globals.previousPaths[c][v].color;
                                A || (A = "rgba(255, 255, 255, 0)"),
                                this.animateHeatColor(k, b.isColorHex(A) ? A : b.rgb2hex(A), b.isColorHex(f) ? f : b.rgb2hex(f), C)
                            }
                        }
                        var P = (0,
                        t.config.dataLabels.formatter)(t.globals.series[c][v], {
                            value: t.globals.series[c][v],
                            seriesIndex: c,
                            dataPointIndex: v,
                            w: t
                        })
                          , L = this.helpers.calculateDataLabels({
                            text: P,
                            x: h + n / 2,
                            y: o + r / 2,
                            i: c,
                            j: v,
                            colorProps: m,
                            series: l
                        });
                        null !== L && u.add(L),
                        h += n
                    }
                    o += r,
                    i.add(u)
                }
                var I = t.globals.yAxisScale[0].result.slice();
                return t.config.yaxis[0].reversed ? I.unshift("") : I.push(""),
                t.globals.yAxisScale[0].result = I,
                i
            }
        }, {
            key: "animateHeatMap",
            value: function(e, t, a, i, n, r) {
                var o = new x(this.ctx);
                o.animateRect(e, {
                    x: t + i / 2,
                    y: a + n / 2,
                    width: 0,
                    height: 0
                }, {
                    x: t,
                    y: a,
                    width: i,
                    height: n
                }, r, (function() {
                    o.animationCompleted(e)
                }
                ))
            }
        }, {
            key: "animateHeatColor",
            value: function(e, t, a, i) {
                e.attr({
                    fill: t
                }).animate(i).attr({
                    fill: a
                })
            }
        }]),
        e
    }()
      , Le = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "drawYAxisTexts",
            value: function(e, t, a, i) {
                var n = this.w
                  , r = n.config.yaxis[0]
                  , o = n.globals.yLabelFormatters[0];
                return new w(this.ctx).drawText({
                    x: e + r.labels.offsetX,
                    y: t + r.labels.offsetY,
                    text: o(i, a),
                    textAnchor: "middle",
                    fontSize: r.labels.style.fontSize,
                    fontFamily: r.labels.style.fontFamily,
                    foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[a] : r.labels.style.colors
                })
            }
        }]),
        e
    }()
      , Ie = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w;
            var a = this.w;
            this.chartType = this.w.config.chart.type,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled,
            this.animBeginArr = [0],
            this.animDur = 0,
            this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels,
            this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors,
            this.defaultSize = Math.min(a.globals.gridWidth, a.globals.gridHeight),
            this.centerY = this.defaultSize / 2,
            this.centerX = a.globals.gridWidth / 2,
            "radialBar" === a.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(a.config.plotOptions.pie.endAngle - a.config.plotOptions.pie.startAngle),
            this.initialAngle = a.config.plotOptions.pie.startAngle % this.fullAngle,
            a.globals.radialSize = this.defaultSize / 2.05 - a.config.stroke.width - (a.config.chart.sparkline.enabled ? 0 : a.config.chart.dropShadow.blur),
            this.donutSize = a.globals.radialSize * parseInt(a.config.plotOptions.pie.donut.size, 10) / 100,
            this.maxY = 0,
            this.sliceLabels = [],
            this.sliceSizes = [],
            this.prevSectorAngleArr = []
        }
        return s(e, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = new w(this.ctx);
                if (this.ret = i.group({
                    class: "apexcharts-pie"
                }),
                a.globals.noData)
                    return this.ret;
                for (var n = 0, r = 0; r < e.length; r++)
                    n += b.negToZero(e[r]);
                var o = []
                  , s = i.group();
                0 === n && (n = 1e-5),
                e.forEach((function(e) {
                    t.maxY = Math.max(t.maxY, e)
                }
                )),
                a.config.yaxis[0].max && (this.maxY = a.config.yaxis[0].max),
                "back" === a.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
                for (var l = 0; l < e.length; l++) {
                    var c = this.fullAngle * b.negToZero(e[l]) / n;
                    o.push(c),
                    "polarArea" === this.chartType ? (o[l] = this.fullAngle / e.length,
                    this.sliceSizes.push(a.globals.radialSize * e[l] / this.maxY)) : this.sliceSizes.push(a.globals.radialSize)
                }
                if (a.globals.dataChanged) {
                    for (var u, d = 0, h = 0; h < a.globals.previousPaths.length; h++)
                        d += b.negToZero(a.globals.previousPaths[h]);
                    for (var p = 0; p < a.globals.previousPaths.length; p++)
                        u = this.fullAngle * b.negToZero(a.globals.previousPaths[p]) / d,
                        this.prevSectorAngleArr.push(u)
                }
                this.donutSize < 0 && (this.donutSize = 0);
                var v = a.config.plotOptions.pie.customScale
                  , g = a.globals.gridWidth / 2
                  , f = a.globals.gridHeight / 2
                  , m = g - a.globals.gridWidth / 2 * v
                  , x = f - a.globals.gridHeight / 2 * v;
                if ("donut" === this.chartType) {
                    var y = i.drawCircle(this.donutSize);
                    y.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: a.config.plotOptions.pie.donut.background ? a.config.plotOptions.pie.donut.background : "transparent"
                    }),
                    s.add(y)
                }
                var k = this.drawArcs(o, e);
                if (this.sliceLabels.forEach((function(e) {
                    k.add(e)
                }
                )),
                s.attr({
                    transform: "translate(".concat(m, ", ").concat(x, ") scale(").concat(v, ")")
                }),
                s.add(k),
                this.ret.add(s),
                this.donutDataLabels.show) {
                    var S = this.renderInnerDataLabels(this.donutDataLabels, {
                        hollowSize: this.donutSize,
                        centerX: this.centerX,
                        centerY: this.centerY,
                        opacity: this.donutDataLabels.show,
                        translateX: m,
                        translateY: x
                    });
                    this.ret.add(S)
                }
                return "front" === a.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret),
                this.ret
            }
        }, {
            key: "drawArcs",
            value: function(e, t) {
                var a = this.w
                  , i = new y(this.ctx)
                  , n = new w(this.ctx)
                  , r = new R(this.ctx)
                  , o = n.group({
                    class: "apexcharts-slices"
                })
                  , s = this.initialAngle
                  , l = this.initialAngle
                  , c = this.initialAngle
                  , u = this.initialAngle;
                this.strokeWidth = a.config.stroke.show ? a.config.stroke.width : 0;
                for (var d = 0; d < e.length; d++) {
                    var h = n.group({
                        class: "apexcharts-series apexcharts-pie-series",
                        seriesName: b.escapeString(a.globals.seriesNames[d]),
                        rel: d + 1,
                        "data:realIndex": d
                    });
                    o.add(h),
                    l = u,
                    c = (s = c) + e[d],
                    u = l + this.prevSectorAngleArr[d];
                    var p = c < s ? this.fullAngle + c - s : c - s
                      , v = r.fillPath({
                        seriesNumber: d,
                        size: this.sliceSizes[d],
                        value: t[d]
                    })
                      , g = this.getChangedPath(l, u)
                      , f = n.drawPath({
                        d: g,
                        stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d] : this.lineColorArr,
                        strokeWidth: 0,
                        fill: v,
                        fillOpacity: a.config.fill.opacity,
                        classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d)
                    });
                    if (f.attr({
                        index: 0,
                        j: d
                    }),
                    i.setSelectionFilter(f, 0, d),
                    a.config.chart.dropShadow.enabled) {
                        var m = a.config.chart.dropShadow;
                        i.dropShadow(f, m, d)
                    }
                    this.addListeners(f, this.donutDataLabels),
                    w.setAttrs(f.node, {
                        "data:angle": p,
                        "data:startAngle": s,
                        "data:strokeWidth": this.strokeWidth,
                        "data:value": t[d]
                    });
                    var x = {
                        x: 0,
                        y: 0
                    };
                    "pie" === this.chartType || "polarArea" === this.chartType ? x = b.polarToCartesian(this.centerX, this.centerY, a.globals.radialSize / 1.25 + a.config.plotOptions.pie.dataLabels.offset, (s + p / 2) % this.fullAngle) : "donut" === this.chartType && (x = b.polarToCartesian(this.centerX, this.centerY, (a.globals.radialSize + this.donutSize) / 2 + a.config.plotOptions.pie.dataLabels.offset, (s + p / 2) % this.fullAngle)),
                    h.add(f);
                    var k = 0;
                    if (!this.initialAnim || a.globals.resized || a.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (k = p / this.fullAngle * a.config.chart.animations.speed) && (k = 1),
                    this.animDur = k + this.animDur,
                    this.animBeginArr.push(this.animDur)),
                    this.dynamicAnim && a.globals.dataChanged ? this.animatePaths(f, {
                        size: this.sliceSizes[d],
                        endAngle: c,
                        startAngle: s,
                        prevStartAngle: l,
                        prevEndAngle: u,
                        animateStartingPos: !0,
                        i: d,
                        animBeginArr: this.animBeginArr,
                        shouldSetPrevPaths: !0,
                        dur: a.config.chart.animations.dynamicAnimation.speed
                    }) : this.animatePaths(f, {
                        size: this.sliceSizes[d],
                        endAngle: c,
                        startAngle: s,
                        i: d,
                        totalItems: e.length - 1,
                        animBeginArr: this.animBeginArr,
                        dur: k
                    }),
                    a.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && f.click(this.pieClicked.bind(this, d)),
                    void 0 !== a.globals.selectedDataPoints[0] && a.globals.selectedDataPoints[0].indexOf(d) > -1 && this.pieClicked(d),
                    a.config.dataLabels.enabled) {
                        var S = x.x
                          , C = x.y
                          , A = 100 * p / this.fullAngle + "%";
                        if (0 !== p && a.config.plotOptions.pie.dataLabels.minAngleToShowLabel < e[d]) {
                            var P = a.config.dataLabels.formatter;
                            void 0 !== P && (A = P(a.globals.seriesPercent[d][0], {
                                seriesIndex: d,
                                w: a
                            }));
                            var L = a.globals.dataLabels.style.colors[d]
                              , I = n.group({
                                class: "apexcharts-datalabels"
                            })
                              , _ = n.drawText({
                                x: S,
                                y: C,
                                text: A,
                                textAnchor: "middle",
                                fontSize: a.config.dataLabels.style.fontSize,
                                fontFamily: a.config.dataLabels.style.fontFamily,
                                fontWeight: a.config.dataLabels.style.fontWeight,
                                foreColor: L
                            });
                            if (I.add(_),
                            a.config.dataLabels.dropShadow.enabled) {
                                var T = a.config.dataLabels.dropShadow;
                                i.dropShadow(_, T)
                            }
                            _.node.classList.add("apexcharts-pie-label"),
                            a.config.chart.animations.animate && !1 === a.globals.resized && (_.node.classList.add("apexcharts-pie-label-delay"),
                            _.node.style.animationDelay = a.config.chart.animations.speed / 940 + "s"),
                            this.sliceLabels.push(I)
                        }
                    }
                }
                return o
            }
        }, {
            key: "addListeners",
            value: function(e, t) {
                var a = new w(this.ctx);
                e.node.addEventListener("mouseenter", a.pathMouseEnter.bind(this, e)),
                e.node.addEventListener("mouseleave", a.pathMouseLeave.bind(this, e)),
                e.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, e.node, t)),
                e.node.addEventListener("mousedown", a.pathMouseDown.bind(this, e)),
                this.donutDataLabels.total.showAlways || (e.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, e.node, t)),
                e.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, e.node, t)))
            }
        }, {
            key: "animatePaths",
            value: function(e, t) {
                var a = this.w
                  , i = t.endAngle < t.startAngle ? this.fullAngle + t.endAngle - t.startAngle : t.endAngle - t.startAngle
                  , n = i
                  , r = t.startAngle
                  , o = t.startAngle;
                void 0 !== t.prevStartAngle && void 0 !== t.prevEndAngle && (r = t.prevEndAngle,
                n = t.prevEndAngle < t.prevStartAngle ? this.fullAngle + t.prevEndAngle - t.prevStartAngle : t.prevEndAngle - t.prevStartAngle),
                t.i === a.config.series.length - 1 && (i + o > this.fullAngle ? t.endAngle = t.endAngle - (i + o) : i + o < this.fullAngle && (t.endAngle = t.endAngle + (this.fullAngle - (i + o)))),
                i === this.fullAngle && (i = this.fullAngle - .01),
                this.animateArc(e, r, o, i, n, t)
            }
        }, {
            key: "animateArc",
            value: function(e, t, a, i, n, r) {
                var o, s = this, l = this.w, c = new x(this.ctx), u = r.size;
                (isNaN(t) || isNaN(n)) && (t = a,
                n = i,
                r.dur = 0);
                var d = i
                  , h = a
                  , p = t < a ? this.fullAngle + t - a : t - a;
                l.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (o = s.getPiePath({
                    me: s,
                    startAngle: r.prevStartAngle,
                    angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
                    size: u
                }),
                e.attr({
                    d: o
                })),
                0 !== r.dur ? e.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll((function() {
                    "pie" !== s.chartType && "donut" !== s.chartType && "polarArea" !== s.chartType || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({
                        "stroke-width": s.strokeWidth
                    }),
                    r.i === l.config.series.length - 1 && c.animationCompleted(e)
                }
                )).during((function(l) {
                    d = p + (i - p) * l,
                    r.animateStartingPos && (d = n + (i - n) * l,
                    h = t - n + (a - (t - n)) * l),
                    o = s.getPiePath({
                        me: s,
                        startAngle: h,
                        angle: d,
                        size: u
                    }),
                    e.node.setAttribute("data:pathOrig", o),
                    e.attr({
                        d: o
                    })
                }
                )) : (o = s.getPiePath({
                    me: s,
                    startAngle: h,
                    angle: i,
                    size: u
                }),
                r.isTrack || (l.globals.animationEnded = !0),
                e.node.setAttribute("data:pathOrig", o),
                e.attr({
                    d: o,
                    "stroke-width": s.strokeWidth
                }))
            }
        }, {
            key: "pieClicked",
            value: function(e) {
                var t, a = this.w, i = this, n = i.sliceSizes[e] + (a.config.plotOptions.pie.expandOnClick ? 4 : 0), r = a.globals.dom.Paper.select(".apexcharts-".concat(i.chartType.toLowerCase(), "-slice-").concat(e)).members[0];
                if ("true" !== r.attr("data:pieClicked")) {
                    var o = a.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                    Array.prototype.forEach.call(o, (function(e) {
                        e.setAttribute("data:pieClicked", "false");
                        var t = e.getAttribute("data:pathOrig");
                        t && e.setAttribute("d", t)
                    }
                    )),
                    r.attr("data:pieClicked", "true");
                    var s = parseInt(r.attr("data:startAngle"), 10)
                      , l = parseInt(r.attr("data:angle"), 10);
                    t = i.getPiePath({
                        me: i,
                        startAngle: s,
                        angle: l,
                        size: n
                    }),
                    360 !== l && r.plot(t)
                } else {
                    r.attr({
                        "data:pieClicked": "false"
                    }),
                    this.revertDataLabelsInner(r.node, this.donutDataLabels);
                    var c = r.attr("data:pathOrig");
                    r.attr({
                        d: c
                    })
                }
            }
        }, {
            key: "getChangedPath",
            value: function(e, t) {
                var a = "";
                return this.dynamicAnim && this.w.globals.dataChanged && (a = this.getPiePath({
                    me: this,
                    startAngle: e,
                    angle: t - e,
                    size: this.size
                })),
                a
            }
        }, {
            key: "getPiePath",
            value: function(e) {
                var t, a = e.me, i = e.startAngle, n = e.angle, r = e.size, o = new w(this.ctx), s = i, l = Math.PI * (s - 90) / 180, c = n + i;
                Math.ceil(c) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (c = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01),
                Math.ceil(c) > this.fullAngle && (c -= this.fullAngle);
                var u = Math.PI * (c - 90) / 180
                  , d = a.centerX + r * Math.cos(l)
                  , h = a.centerY + r * Math.sin(l)
                  , p = a.centerX + r * Math.cos(u)
                  , v = a.centerY + r * Math.sin(u)
                  , g = b.polarToCartesian(a.centerX, a.centerY, a.donutSize, c)
                  , f = b.polarToCartesian(a.centerX, a.centerY, a.donutSize, s)
                  , m = n > 180 ? 1 : 0
                  , x = ["M", d, h, "A", r, r, 0, m, 1, p, v];
                return t = "donut" === a.chartType ? [].concat(x, ["L", g.x, g.y, "A", a.donutSize, a.donutSize, 0, m, 0, f.x, f.y, "L", d, h, "z"]).join(" ") : "pie" === a.chartType || "polarArea" === a.chartType ? [].concat(x, ["L", a.centerX, a.centerY, "L", d, h]).join(" ") : [].concat(x).join(" "),
                o.roundPathCorners(t, 2 * this.strokeWidth)
            }
        }, {
            key: "drawPolarElements",
            value: function(e) {
                var t = this.w
                  , a = new U(this.ctx)
                  , i = new w(this.ctx)
                  , n = new Le(this.ctx)
                  , r = i.group()
                  , o = i.group()
                  , s = a.niceScale(0, Math.ceil(this.maxY), t.config.yaxis[0].tickAmount, 0, !0)
                  , l = s.result.reverse()
                  , c = s.result.length;
                this.maxY = s.niceMax;
                for (var u = t.globals.radialSize, d = u / (c - 1), h = 0; h < c - 1; h++) {
                    var p = i.drawCircle(u);
                    if (p.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: "none",
                        "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth,
                        stroke: t.config.plotOptions.polarArea.rings.strokeColor
                    }),
                    t.config.yaxis[0].show) {
                        var v = n.drawYAxisTexts(this.centerX, this.centerY - u + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, h, l[h]);
                        o.add(v)
                    }
                    r.add(p),
                    u -= d
                }
                this.drawSpokes(e),
                e.add(r),
                e.add(o)
            }
        }, {
            key: "renderInnerDataLabels",
            value: function(e, t) {
                var a = this.w
                  , i = new w(this.ctx)
                  , n = i.group({
                    class: "apexcharts-datalabels-group",
                    transform: "translate(".concat(t.translateX ? t.translateX : 0, ", ").concat(t.translateY ? t.translateY : 0, ") scale(").concat(a.config.plotOptions.pie.customScale, ")")
                })
                  , r = e.total.show;
                n.node.style.opacity = t.opacity;
                var o, s, l = t.centerX, c = t.centerY;
                o = void 0 === e.name.color ? a.globals.colors[0] : e.name.color;
                var u = e.name.fontSize
                  , d = e.name.fontFamily
                  , h = e.name.fontWeight;
                s = void 0 === e.value.color ? a.config.chart.foreColor : e.value.color;
                var p = e.value.formatter
                  , v = ""
                  , g = "";
                if (r ? (o = e.total.color,
                u = e.total.fontSize,
                d = e.total.fontFamily,
                h = e.total.fontWeight,
                g = e.total.label,
                v = e.total.formatter(a)) : 1 === a.globals.series.length && (v = p(a.globals.series[0], a),
                g = a.globals.seriesNames[0]),
                g && (g = e.name.formatter(g, e.total.show, a)),
                e.name.show) {
                    var f = i.drawText({
                        x: l,
                        y: c + parseFloat(e.name.offsetY),
                        text: g,
                        textAnchor: "middle",
                        foreColor: o,
                        fontSize: u,
                        fontWeight: h,
                        fontFamily: d
                    });
                    f.node.classList.add("apexcharts-datalabel-label"),
                    n.add(f)
                }
                if (e.value.show) {
                    var m = e.name.show ? parseFloat(e.value.offsetY) + 16 : e.value.offsetY
                      , b = i.drawText({
                        x: l,
                        y: c + m,
                        text: v,
                        textAnchor: "middle",
                        foreColor: s,
                        fontWeight: e.value.fontWeight,
                        fontSize: e.value.fontSize,
                        fontFamily: e.value.fontFamily
                    });
                    b.node.classList.add("apexcharts-datalabel-value"),
                    n.add(b)
                }
                return n
            }
        }, {
            key: "printInnerLabels",
            value: function(e, t, a, i) {
                var n, r = this.w;
                i ? n = void 0 === e.name.color ? r.globals.colors[parseInt(i.parentNode.getAttribute("rel"), 10) - 1] : e.name.color : r.globals.series.length > 1 && e.total.show && (n = e.total.color);
                var o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label")
                  , s = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                a = (0,
                e.value.formatter)(a, r),
                i || "function" != typeof e.total.formatter || (a = e.total.formatter(r));
                var l = t === e.total.label;
                t = e.name.formatter(t, l, r),
                null !== o && (o.textContent = t),
                null !== s && (s.textContent = a),
                null !== o && (o.style.fill = n)
            }
        }, {
            key: "printDataLabelsInner",
            value: function(e, t) {
                var a = this.w
                  , i = e.getAttribute("data:value")
                  , n = a.globals.seriesNames[parseInt(e.parentNode.getAttribute("rel"), 10) - 1];
                a.globals.series.length > 1 && this.printInnerLabels(t, n, i, e);
                var r = a.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                null !== r && (r.style.opacity = 1)
            }
        }, {
            key: "drawSpokes",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = new w(this.ctx)
                  , n = a.config.plotOptions.polarArea.spokes;
                if (0 !== n.strokeWidth) {
                    for (var r = [], o = 360 / a.globals.series.length, s = 0; s < a.globals.series.length; s++)
                        r.push(b.polarToCartesian(this.centerX, this.centerY, a.globals.radialSize, a.config.plotOptions.pie.startAngle + o * s));
                    r.forEach((function(a, r) {
                        var o = i.drawLine(a.x, a.y, t.centerX, t.centerY, Array.isArray(n.connectorColors) ? n.connectorColors[r] : n.connectorColors);
                        e.add(o)
                    }
                    ))
                }
            }
        }, {
            key: "revertDataLabelsInner",
            value: function(e, t, a) {
                var i = this
                  , n = this.w
                  , r = n.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group")
                  , o = !1
                  , s = n.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area")
                  , l = function(e) {
                    var a = e.makeSliceOut
                      , n = e.printLabel;
                    Array.prototype.forEach.call(s, (function(e) {
                        "true" === e.getAttribute("data:pieClicked") && (a && (o = !0),
                        n && i.printDataLabelsInner(e, t))
                    }
                    ))
                };
                if (l({
                    makeSliceOut: !0,
                    printLabel: !1
                }),
                t.total.show && n.globals.series.length > 1)
                    o && !t.total.showAlways ? l({
                        makeSliceOut: !1,
                        printLabel: !0
                    }) : this.printInnerLabels(t, t.total.label, t.total.formatter(n));
                else if (l({
                    makeSliceOut: !1,
                    printLabel: !0
                }),
                !o)
                    if (n.globals.selectedDataPoints.length && n.globals.series.length > 1)
                        if (n.globals.selectedDataPoints[0].length > 0) {
                            var c = n.globals.selectedDataPoints[0]
                              , u = n.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c));
                            this.printDataLabelsInner(u, t)
                        } else
                            r && n.globals.selectedDataPoints.length && 0 === n.globals.selectedDataPoints[0].length && (r.style.opacity = 0);
                    else
                        r && n.globals.series.length > 1 && (r.style.opacity = 0)
            }
        }]),
        e
    }()
      , _e = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.chartType = this.w.config.chart.type,
            this.initialAnim = this.w.config.chart.animations.enabled,
            this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled,
            this.animDur = 0;
            var a = this.w;
            this.graphics = new w(this.ctx),
            this.lineColorArr = void 0 !== a.globals.stroke.colors ? a.globals.stroke.colors : a.globals.colors,
            this.defaultSize = a.globals.svgHeight < a.globals.svgWidth ? a.globals.gridHeight + 1.5 * a.globals.goldenPadding : a.globals.gridWidth,
            this.isLog = a.config.yaxis[0].logarithmic,
            this.coreUtils = new k(this.ctx),
            this.maxValue = this.isLog ? this.coreUtils.getLogVal(a.globals.maxY, 0) : a.globals.maxY,
            this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : a.globals.minY,
            this.polygons = a.config.plotOptions.radar.polygons,
            this.strokeWidth = a.config.stroke.show ? a.config.stroke.width : 0,
            this.size = this.defaultSize / 2.1 - this.strokeWidth - a.config.chart.dropShadow.blur,
            a.config.xaxis.labels.show && (this.size = this.size - a.globals.xAxisLabelsWidth / 1.75),
            void 0 !== a.config.plotOptions.radar.size && (this.size = a.config.plotOptions.radar.size),
            this.dataRadiusOfPercent = [],
            this.dataRadius = [],
            this.angleArr = [],
            this.yaxisLabelsTextsPos = []
        }
        return s(e, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , a = this.w
                  , n = new R(this.ctx)
                  , r = []
                  , o = new H(this.ctx);
                e.length && (this.dataPointsLen = e[a.globals.maxValsInArrayIndex].length),
                this.disAngle = 2 * Math.PI / this.dataPointsLen;
                var s = a.globals.gridWidth / 2
                  , l = a.globals.gridHeight / 2
                  , c = s + a.config.plotOptions.radar.offsetX
                  , u = l + a.config.plotOptions.radar.offsetY
                  , d = this.graphics.group({
                    class: "apexcharts-radar-series apexcharts-plot-series",
                    transform: "translate(".concat(c || 0, ", ").concat(u || 0, ")")
                })
                  , h = []
                  , p = null
                  , v = null;
                if (this.yaxisLabels = this.graphics.group({
                    class: "apexcharts-yaxis"
                }),
                e.forEach((function(e, s) {
                    var l = e.length === a.globals.dataPoints
                      , c = t.graphics.group().attr({
                        class: "apexcharts-series",
                        "data:longestSeries": l,
                        seriesName: b.escapeString(a.globals.seriesNames[s]),
                        rel: s + 1,
                        "data:realIndex": s
                    });
                    t.dataRadiusOfPercent[s] = [],
                    t.dataRadius[s] = [],
                    t.angleArr[s] = [],
                    e.forEach((function(e, a) {
                        var i = Math.abs(t.maxValue - t.minValue);
                        e += Math.abs(t.minValue),
                        t.isLog && (e = t.coreUtils.getLogVal(e, 0)),
                        t.dataRadiusOfPercent[s][a] = e / i,
                        t.dataRadius[s][a] = t.dataRadiusOfPercent[s][a] * t.size,
                        t.angleArr[s][a] = a * t.disAngle
                    }
                    )),
                    h = t.getDataPointsPos(t.dataRadius[s], t.angleArr[s]);
                    var u = t.createPaths(h, {
                        x: 0,
                        y: 0
                    });
                    p = t.graphics.group({
                        class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
                    }),
                    v = t.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": s
                    }),
                    a.globals.delayedElements.push({
                        el: p.node,
                        index: s
                    });
                    var d = {
                        i: s,
                        realIndex: s,
                        animationDelay: s,
                        initialSpeed: a.config.chart.animations.speed,
                        dataChangeSpeed: a.config.chart.animations.dynamicAnimation.speed,
                        className: "apexcharts-radar",
                        shouldClipToGrid: !1,
                        bindEventsOnPaths: !1,
                        stroke: a.globals.stroke.colors[s],
                        strokeLineCap: a.config.stroke.lineCap
                    }
                      , g = null;
                    a.globals.previousPaths.length > 0 && (g = t.getPreviousPath(s));
                    for (var f = 0; f < u.linePathsTo.length; f++) {
                        var m = t.graphics.renderPaths(i(i({}, d), {}, {
                            pathFrom: null === g ? u.linePathsFrom[f] : g,
                            pathTo: u.linePathsTo[f],
                            strokeWidth: Array.isArray(t.strokeWidth) ? t.strokeWidth[s] : t.strokeWidth,
                            fill: "none",
                            drawShadow: !1
                        }));
                        c.add(m);
                        var x = n.fillPath({
                            seriesNumber: s
                        })
                          , w = t.graphics.renderPaths(i(i({}, d), {}, {
                            pathFrom: null === g ? u.areaPathsFrom[f] : g,
                            pathTo: u.areaPathsTo[f],
                            strokeWidth: 0,
                            fill: x,
                            drawShadow: !1
                        }));
                        if (a.config.chart.dropShadow.enabled) {
                            var k = new y(t.ctx)
                              , S = a.config.chart.dropShadow;
                            k.dropShadow(w, Object.assign({}, S, {
                                noUserSpaceOnUse: !0
                            }), s)
                        }
                        c.add(w)
                    }
                    e.forEach((function(e, n) {
                        var r = new N(t.ctx).getMarkerConfig({
                            cssClass: "apexcharts-marker",
                            seriesIndex: s,
                            dataPointIndex: n
                        })
                          , l = t.graphics.drawMarker(h[n].x, h[n].y, r);
                        l.attr("rel", n),
                        l.attr("j", n),
                        l.attr("index", s),
                        l.node.setAttribute("default-marker-size", r.pSize);
                        var u = t.graphics.group({
                            class: "apexcharts-series-markers"
                        });
                        u && u.add(l),
                        p.add(u),
                        c.add(p);
                        var d = a.config.dataLabels;
                        if (d.enabled) {
                            var g = d.formatter(a.globals.series[s][n], {
                                seriesIndex: s,
                                dataPointIndex: n,
                                w: a
                            });
                            o.plotDataLabelsText({
                                x: h[n].x,
                                y: h[n].y,
                                text: g,
                                textAnchor: "middle",
                                i: s,
                                j: s,
                                parent: v,
                                offsetCorrection: !1,
                                dataLabelsConfig: i({}, d)
                            })
                        }
                        c.add(v)
                    }
                    )),
                    r.push(c)
                }
                )),
                this.drawPolygons({
                    parent: d
                }),
                a.config.xaxis.labels.show) {
                    var g = this.drawXAxisTexts();
                    d.add(g)
                }
                return r.forEach((function(e) {
                    d.add(e)
                }
                )),
                d.add(this.yaxisLabels),
                d
            }
        }, {
            key: "drawPolygons",
            value: function(e) {
                for (var t = this, a = this.w, i = e.parent, n = new Le(this.ctx), r = a.globals.yAxisScale[0].result.reverse(), o = r.length, s = [], l = this.size / (o - 1), c = 0; c < o; c++)
                    s[c] = l * c;
                s.reverse();
                var u = []
                  , d = [];
                s.forEach((function(e, a) {
                    var i = b.getPolygonPos(e, t.dataPointsLen)
                      , n = "";
                    i.forEach((function(e, i) {
                        if (0 === a) {
                            var r = t.graphics.drawLine(e.x, e.y, 0, 0, Array.isArray(t.polygons.connectorColors) ? t.polygons.connectorColors[i] : t.polygons.connectorColors);
                            d.push(r)
                        }
                        0 === i && t.yaxisLabelsTextsPos.push({
                            x: e.x,
                            y: e.y
                        }),
                        n += e.x + "," + e.y + " "
                    }
                    )),
                    u.push(n)
                }
                )),
                u.forEach((function(e, n) {
                    var r = t.polygons.strokeColors
                      , o = t.polygons.strokeWidth
                      , s = t.graphics.drawPolygon(e, Array.isArray(r) ? r[n] : r, Array.isArray(o) ? o[n] : o, a.globals.radarPolygons.fill.colors[n]);
                    i.add(s)
                }
                )),
                d.forEach((function(e) {
                    i.add(e)
                }
                )),
                a.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach((function(e, a) {
                    var i = n.drawYAxisTexts(e.x, e.y, a, r[a]);
                    t.yaxisLabels.add(i)
                }
                ))
            }
        }, {
            key: "drawXAxisTexts",
            value: function() {
                var e = this
                  , t = this.w
                  , a = t.config.xaxis.labels
                  , n = this.graphics.group({
                    class: "apexcharts-xaxis"
                })
                  , r = b.getPolygonPos(this.size, this.dataPointsLen);
                return t.globals.labels.forEach((function(o, s) {
                    var l = t.config.xaxis.labels.formatter
                      , c = new H(e.ctx);
                    if (r[s]) {
                        var u = e.getTextPos(r[s], e.size)
                          , d = l(o, {
                            seriesIndex: -1,
                            dataPointIndex: s,
                            w: t
                        });
                        c.plotDataLabelsText({
                            x: u.newX,
                            y: u.newY,
                            text: d,
                            textAnchor: u.textAnchor,
                            i: s,
                            j: s,
                            parent: n,
                            color: Array.isArray(a.style.colors) && a.style.colors[s] ? a.style.colors[s] : "#a8a8a8",
                            dataLabelsConfig: i({
                                textAnchor: u.textAnchor,
                                dropShadow: {
                                    enabled: !1
                                }
                            }, a),
                            offsetCorrection: !1
                        })
                    }
                }
                )),
                n
            }
        }, {
            key: "createPaths",
            value: function(e, t) {
                var a = this
                  , i = []
                  , n = []
                  , r = []
                  , o = [];
                if (e.length) {
                    n = [this.graphics.move(t.x, t.y)],
                    o = [this.graphics.move(t.x, t.y)];
                    var s = this.graphics.move(e[0].x, e[0].y)
                      , l = this.graphics.move(e[0].x, e[0].y);
                    e.forEach((function(t, i) {
                        s += a.graphics.line(t.x, t.y),
                        l += a.graphics.line(t.x, t.y),
                        i === e.length - 1 && (s += "Z",
                        l += "Z")
                    }
                    )),
                    i.push(s),
                    r.push(l)
                }
                return {
                    linePathsFrom: n,
                    linePathsTo: i,
                    areaPathsFrom: o,
                    areaPathsTo: r
                }
            }
        }, {
            key: "getTextPos",
            value: function(e, t) {
                var a = "middle"
                  , i = e.x
                  , n = e.y;
                return Math.abs(e.x) >= 10 ? e.x > 0 ? (a = "start",
                i += 10) : e.x < 0 && (a = "end",
                i -= 10) : a = "middle",
                Math.abs(e.y) >= t - 10 && (e.y < 0 ? n -= 10 : e.y > 0 && (n += 10)),
                {
                    textAnchor: a,
                    newX: i,
                    newY: n
                }
            }
        }, {
            key: "getPreviousPath",
            value: function(e) {
                for (var t = this.w, a = null, i = 0; i < t.globals.previousPaths.length; i++) {
                    var n = t.globals.previousPaths[i];
                    n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(e, 10) && void 0 !== t.globals.previousPaths[i].paths[0] && (a = t.globals.previousPaths[i].paths[0].d)
                }
                return a
            }
        }, {
            key: "getDataPointsPos",
            value: function(e, t) {
                var a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                e = e || [],
                t = t || [];
                for (var i = [], n = 0; n < a; n++) {
                    var r = {};
                    r.x = e[n] * Math.sin(t[n]),
                    r.y = -e[n] * Math.cos(t[n]),
                    i.push(r)
                }
                return i
            }
        }]),
        e
    }()
      , Te = function() {
        c(t, Ie);
        var e = p(t);
        function t(a) {
            var i;
            r(this, t),
            (i = e.call(this, a)).ctx = a,
            i.w = a.w,
            i.animBeginArr = [0],
            i.animDur = 0;
            var n = i.w;
            return i.startAngle = n.config.plotOptions.radialBar.startAngle,
            i.endAngle = n.config.plotOptions.radialBar.endAngle,
            i.totalAngle = Math.abs(n.config.plotOptions.radialBar.endAngle - n.config.plotOptions.radialBar.startAngle),
            i.trackStartAngle = n.config.plotOptions.radialBar.track.startAngle,
            i.trackEndAngle = n.config.plotOptions.radialBar.track.endAngle,
            i.barLabels = i.w.config.plotOptions.radialBar.barLabels,
            i.donutDataLabels = i.w.config.plotOptions.radialBar.dataLabels,
            i.radialDataLabels = i.donutDataLabels,
            i.trackStartAngle || (i.trackStartAngle = i.startAngle),
            i.trackEndAngle || (i.trackEndAngle = i.endAngle),
            360 === i.endAngle && (i.endAngle = 359.99),
            i.margin = parseInt(n.config.plotOptions.radialBar.track.margin, 10),
            i.onBarLabelClick = i.onBarLabelClick.bind(h(i)),
            i
        }
        return s(t, [{
            key: "draw",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx)
                  , i = a.group({
                    class: "apexcharts-radialbar"
                });
                if (t.globals.noData)
                    return i;
                var n = a.group()
                  , r = this.defaultSize / 2
                  , o = t.globals.gridWidth / 2
                  , s = this.defaultSize / 2.05;
                t.config.chart.sparkline.enabled || (s = s - t.config.stroke.width - t.config.chart.dropShadow.blur);
                var l = t.globals.fill.colors;
                if (t.config.plotOptions.radialBar.track.show) {
                    var c = this.drawTracks({
                        size: s,
                        centerX: o,
                        centerY: r,
                        colorArr: l,
                        series: e
                    });
                    n.add(c)
                }
                var u = this.drawArcs({
                    size: s,
                    centerX: o,
                    centerY: r,
                    colorArr: l,
                    series: e
                })
                  , d = 360;
                t.config.plotOptions.radialBar.startAngle < 0 && (d = this.totalAngle);
                var h = (360 - d) / 360;
                if (t.globals.radialSize = s - s * h,
                this.radialDataLabels.value.show) {
                    var p = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                    t.globals.radialSize += p * h
                }
                return n.add(u.g),
                "front" === t.config.plotOptions.radialBar.hollow.position && (u.g.add(u.elHollow),
                u.dataLabels && u.g.add(u.dataLabels)),
                i.add(n),
                i
            }
        }, {
            key: "drawTracks",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx)
                  , i = a.group({
                    class: "apexcharts-tracks"
                })
                  , n = new y(this.ctx)
                  , r = new R(this.ctx)
                  , o = this.getStrokeWidth(e);
                e.size = e.size - o / 2;
                for (var s = 0; s < e.series.length; s++) {
                    var l = a.group({
                        class: "apexcharts-radialbar-track apexcharts-track"
                    });
                    i.add(l),
                    l.attr({
                        rel: s + 1
                    }),
                    e.size = e.size - o - this.margin;
                    var c = t.config.plotOptions.radialBar.track
                      , u = r.fillPath({
                        seriesNumber: 0,
                        size: e.size,
                        fillColors: Array.isArray(c.background) ? c.background[s] : c.background,
                        solid: !0
                    })
                      , d = this.trackStartAngle
                      , h = this.trackEndAngle;
                    Math.abs(h) + Math.abs(d) >= 360 && (h = 360 - Math.abs(this.startAngle) - .1);
                    var p = a.drawPath({
                        d: "",
                        stroke: u,
                        strokeWidth: o * parseInt(c.strokeWidth, 10) / 100,
                        fill: "none",
                        strokeOpacity: c.opacity,
                        classes: "apexcharts-radialbar-area"
                    });
                    if (c.dropShadow.enabled) {
                        var v = c.dropShadow;
                        n.dropShadow(p, v)
                    }
                    l.add(p),
                    p.attr("id", "apexcharts-radialbarTrack-" + s),
                    this.animatePaths(p, {
                        centerX: e.centerX,
                        centerY: e.centerY,
                        endAngle: h,
                        startAngle: d,
                        size: e.size,
                        i: s,
                        totalItems: 2,
                        animBeginArr: 0,
                        dur: 0,
                        isTrack: !0,
                        easing: t.globals.easing
                    })
                }
                return i
            }
        }, {
            key: "drawArcs",
            value: function(e) {
                var t = this.w
                  , a = new w(this.ctx)
                  , i = new R(this.ctx)
                  , n = new y(this.ctx)
                  , r = a.group()
                  , o = this.getStrokeWidth(e);
                e.size = e.size - o / 2;
                var s = t.config.plotOptions.radialBar.hollow.background
                  , l = e.size - o * e.series.length - this.margin * e.series.length - o * parseInt(t.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2
                  , c = l - t.config.plotOptions.radialBar.hollow.margin;
                void 0 !== t.config.plotOptions.radialBar.hollow.image && (s = this.drawHollowImage(e, r, l, s));
                var u = this.drawHollow({
                    size: c,
                    centerX: e.centerX,
                    centerY: e.centerY,
                    fill: s || "transparent"
                });
                if (t.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
                    var d = t.config.plotOptions.radialBar.hollow.dropShadow;
                    n.dropShadow(u, d)
                }
                var h = 1;
                !this.radialDataLabels.total.show && t.globals.series.length > 1 && (h = 0);
                var p = null;
                this.radialDataLabels.show && (p = this.renderInnerDataLabels(this.radialDataLabels, {
                    hollowSize: l,
                    centerX: e.centerX,
                    centerY: e.centerY,
                    opacity: h
                })),
                "back" === t.config.plotOptions.radialBar.hollow.position && (r.add(u),
                p && r.add(p));
                var v = !1;
                t.config.plotOptions.radialBar.inverseOrder && (v = !0);
                for (var g = v ? e.series.length - 1 : 0; v ? g >= 0 : g < e.series.length; v ? g-- : g++) {
                    var f = a.group({
                        class: "apexcharts-series apexcharts-radial-series",
                        seriesName: b.escapeString(t.globals.seriesNames[g])
                    });
                    r.add(f),
                    f.attr({
                        rel: g + 1,
                        "data:realIndex": g
                    }),
                    this.ctx.series.addCollapsedClassToSeries(f, g),
                    e.size = e.size - o - this.margin;
                    var m = i.fillPath({
                        seriesNumber: g,
                        size: e.size,
                        value: e.series[g]
                    })
                      , x = this.startAngle
                      , k = void 0
                      , S = b.negToZero(e.series[g] > 100 ? 100 : e.series[g]) / 100
                      , C = Math.round(this.totalAngle * S) + this.startAngle
                      , A = void 0;
                    t.globals.dataChanged && (k = this.startAngle,
                    A = Math.round(this.totalAngle * b.negToZero(t.globals.previousPaths[g]) / 100) + k),
                    Math.abs(C) + Math.abs(x) >= 360 && (C -= .01),
                    Math.abs(A) + Math.abs(k) >= 360 && (A -= .01);
                    var P = C - x
                      , L = Array.isArray(t.config.stroke.dashArray) ? t.config.stroke.dashArray[g] : t.config.stroke.dashArray
                      , I = a.drawPath({
                        d: "",
                        stroke: m,
                        strokeWidth: o,
                        fill: "none",
                        fillOpacity: t.config.fill.opacity,
                        classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + g,
                        strokeDashArray: L
                    });
                    if (w.setAttrs(I.node, {
                        "data:angle": P,
                        "data:value": e.series[g]
                    }),
                    t.config.chart.dropShadow.enabled) {
                        var _ = t.config.chart.dropShadow;
                        n.dropShadow(I, _, g)
                    }
                    if (n.setSelectionFilter(I, 0, g),
                    this.addListeners(I, this.radialDataLabels),
                    f.add(I),
                    I.attr({
                        index: 0,
                        j: g
                    }),
                    this.barLabels.enabled) {
                        var T = b.polarToCartesian(e.centerX, e.centerY, e.size, x)
                          , E = this.barLabels.formatter(t.globals.seriesNames[g], {
                            seriesIndex: g,
                            w: t
                        })
                          , O = ["apexcharts-radialbar-label"];
                        this.barLabels.onClick || O.push("apexcharts-no-click");
                        var V = this.barLabels.useSeriesColors ? t.globals.colors[g] : t.config.chart.foreColor;
                        V || (V = t.config.chart.foreColor);
                        var F = T.x - this.barLabels.margin
                          , B = T.y
                          , M = a.drawText({
                            x: F,
                            y: B,
                            text: E,
                            textAnchor: "end",
                            dominantBaseline: "middle",
                            fontFamily: this.barLabels.fontFamily,
                            fontWeight: this.barLabels.fontWeight,
                            fontSize: this.barLabels.fontSize,
                            foreColor: V,
                            cssClass: O.join(" ")
                        });
                        M.on("click", this.onBarLabelClick),
                        M.attr({
                            rel: g + 1
                        }),
                        0 !== x && M.attr({
                            "transform-origin": "".concat(F, " ").concat(B),
                            transform: "rotate(".concat(x, " 0 0)")
                        }),
                        f.add(M)
                    }
                    var D = 0;
                    !this.initialAnim || t.globals.resized || t.globals.dataChanged || (D = t.config.chart.animations.speed),
                    t.globals.dataChanged && (D = t.config.chart.animations.dynamicAnimation.speed),
                    this.animDur = D / (1.2 * e.series.length) + this.animDur,
                    this.animBeginArr.push(this.animDur),
                    this.animatePaths(I, {
                        centerX: e.centerX,
                        centerY: e.centerY,
                        endAngle: C,
                        startAngle: x,
                        prevEndAngle: A,
                        prevStartAngle: k,
                        size: e.size,
                        i: g,
                        totalItems: 2,
                        animBeginArr: this.animBeginArr,
                        dur: D,
                        shouldSetPrevPaths: !0,
                        easing: t.globals.easing
                    })
                }
                return {
                    g: r,
                    elHollow: u,
                    dataLabels: p
                }
            }
        }, {
            key: "drawHollow",
            value: function(e) {
                var t = new w(this.ctx).drawCircle(2 * e.size);
                return t.attr({
                    class: "apexcharts-radialbar-hollow",
                    cx: e.centerX,
                    cy: e.centerY,
                    r: e.size,
                    fill: e.fill
                }),
                t
            }
        }, {
            key: "drawHollowImage",
            value: function(e, t, a, i) {
                var n = this.w
                  , r = new R(this.ctx)
                  , o = b.randomId()
                  , s = n.config.plotOptions.radialBar.hollow.image;
                if (n.config.plotOptions.radialBar.hollow.imageClipped)
                    r.clippedImgArea({
                        width: a,
                        height: a,
                        image: s,
                        patternID: "pattern".concat(n.globals.cuid).concat(o)
                    }),
                    i = "url(#pattern".concat(n.globals.cuid).concat(o, ")");
                else {
                    var l = n.config.plotOptions.radialBar.hollow.imageWidth
                      , c = n.config.plotOptions.radialBar.hollow.imageHeight;
                    if (void 0 === l && void 0 === c) {
                        var u = n.globals.dom.Paper.image(s).loaded((function(t) {
                            this.move(e.centerX - t.width / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX, e.centerY - t.height / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY)
                        }
                        ));
                        t.add(u)
                    } else {
                        var d = n.globals.dom.Paper.image(s).loaded((function(t) {
                            this.move(e.centerX - l / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetX, e.centerY - c / 2 + n.config.plotOptions.radialBar.hollow.imageOffsetY),
                            this.size(l, c)
                        }
                        ));
                        t.add(d)
                    }
                }
                return i
            }
        }, {
            key: "getStrokeWidth",
            value: function(e) {
                var t = this.w;
                return e.size * (100 - parseInt(t.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (e.series.length + 1) - this.margin
            }
        }, {
            key: "onBarLabelClick",
            value: function(e) {
                var t = parseInt(e.target.getAttribute("rel"), 10) - 1
                  , a = this.barLabels.onClick
                  , i = this.w;
                a && a(i.globals.seriesNames[t], {
                    w: i,
                    seriesIndex: t
                })
            }
        }]),
        t
    }()
      , Ee = function() {
        c(t, ke);
        var e = p(t);
        function t() {
            return r(this, t),
            e.apply(this, arguments)
        }
        return s(t, [{
            key: "draw",
            value: function(e, t) {
                var a = this.w
                  , n = new w(this.ctx);
                this.rangeBarOptions = this.w.config.plotOptions.rangeBar,
                this.series = e,
                this.seriesRangeStart = a.globals.seriesRangeStart,
                this.seriesRangeEnd = a.globals.seriesRangeEnd,
                this.barHelpers.initVariables(e);
                for (var r = n.group({
                    class: "apexcharts-rangebar-series apexcharts-plot-series"
                }), o = 0; o < e.length; o++) {
                    var s, c, u, d, h = void 0, p = void 0, v = a.globals.comboCharts ? t[o] : o, g = n.group({
                        class: "apexcharts-series",
                        seriesName: b.escapeString(a.globals.seriesNames[v]),
                        rel: o + 1,
                        "data:realIndex": v
                    });
                    this.ctx.series.addCollapsedClassToSeries(g, v),
                    e[o].length > 0 && (this.visibleI = this.visibleI + 1);
                    var f = 0
                      , m = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = v);
                    var x = this.barHelpers.initialPositions();
                    p = x.y,
                    d = x.zeroW,
                    h = x.x,
                    m = x.barWidth,
                    f = x.barHeight,
                    s = x.xDivision,
                    c = x.yDivision,
                    u = x.zeroH;
                    for (var y = n.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": v
                    }), k = n.group({
                        class: "apexcharts-rangebar-goals-markers"
                    }), S = 0; S < a.globals.dataPoints; S++) {
                        var C, A = this.barHelpers.getStrokeWidth(o, S, v), P = this.seriesRangeStart[o][S], L = this.seriesRangeEnd[o][S], I = null, _ = null, T = null, E = {
                            x: h,
                            y: p,
                            strokeWidth: A,
                            elSeries: g
                        }, O = this.seriesLen;
                        if (a.config.plotOptions.bar.rangeBarGroupRows && (O = 1),
                        void 0 === a.config.series[o].data[S])
                            break;
                        if (this.isHorizontal) {
                            T = p + f * this.visibleI;
                            var V = (c - f * O) / 2;
                            if (a.config.series[o].data[S].x) {
                                var F = this.detectOverlappingBars({
                                    i: o,
                                    j: S,
                                    barYPosition: T,
                                    srty: V,
                                    barHeight: f,
                                    yDivision: c,
                                    initPositions: x
                                });
                                f = F.barHeight,
                                T = F.barYPosition
                            }
                            m = (I = this.drawRangeBarPaths(i({
                                indexes: {
                                    i: o,
                                    j: S,
                                    realIndex: v
                                },
                                barHeight: f,
                                barYPosition: T,
                                zeroW: d,
                                yDivision: c,
                                y1: P,
                                y2: L
                            }, E))).barWidth
                        } else {
                            a.globals.isXNumeric && (h = (a.globals.seriesX[o][S] - a.globals.minX) / this.xRatio - m / 2),
                            _ = h + m * this.visibleI;
                            var B = (s - m * O) / 2;
                            if (a.config.series[o].data[S].x) {
                                var M = this.detectOverlappingBars({
                                    i: o,
                                    j: S,
                                    barXPosition: _,
                                    srtx: B,
                                    barWidth: m,
                                    xDivision: s,
                                    initPositions: x
                                });
                                m = M.barWidth,
                                _ = M.barXPosition
                            }
                            f = (I = this.drawRangeColumnPaths(i({
                                indexes: {
                                    i: o,
                                    j: S,
                                    realIndex: v
                                },
                                barWidth: m,
                                barXPosition: _,
                                zeroH: u,
                                xDivision: s
                            }, E))).barHeight
                        }
                        var D = this.barHelpers.drawGoalLine({
                            barXPosition: I.barXPosition,
                            barYPosition: T,
                            goalX: I.goalX,
                            goalY: I.goalY,
                            barHeight: f,
                            barWidth: m
                        });
                        D && k.add(D),
                        p = I.y,
                        h = I.x;
                        var R = this.barHelpers.getPathFillColor(e, o, S, v)
                          , N = a.globals.stroke.colors[v];
                        this.renderSeries((l(C = {
                            realIndex: v,
                            pathFill: R,
                            lineFill: N,
                            j: S,
                            i: o,
                            x: h,
                            y: p,
                            y1: P,
                            y2: L,
                            pathFrom: I.pathFrom,
                            pathTo: I.pathTo,
                            strokeWidth: A,
                            elSeries: g,
                            series: e,
                            barHeight: f,
                            barWidth: m,
                            barXPosition: _,
                            barYPosition: T
                        }, "barWidth", m),
                        l(C, "elDataLabelsWrap", y),
                        l(C, "elGoalsMarkers", k),
                        l(C, "visibleSeries", this.visibleI),
                        l(C, "type", "rangebar"),
                        C))
                    }
                    r.add(g)
                }
                return r
            }
        }, {
            key: "detectOverlappingBars",
            value: function(e) {
                var t = e.i
                  , a = e.j
                  , i = e.barYPosition
                  , n = e.barXPosition
                  , r = e.srty
                  , o = e.srtx
                  , s = e.barHeight
                  , l = e.barWidth
                  , c = e.yDivision
                  , u = e.xDivision
                  , d = e.initPositions
                  , h = this.w
                  , p = []
                  , v = h.config.series[t].data[a].rangeName
                  , g = h.config.series[t].data[a].x
                  , f = Array.isArray(g) ? g.join(" ") : g
                  , m = h.globals.labels.map((function(e) {
                    return Array.isArray(e) ? e.join(" ") : e
                }
                )).indexOf(f)
                  , b = h.globals.seriesRange[t].findIndex((function(e) {
                    return e.x === f && e.overlaps.length > 0
                }
                ));
                return this.isHorizontal ? (i = h.config.plotOptions.bar.rangeBarGroupRows ? r + c * m : r + s * this.visibleI + c * m,
                b > -1 && !h.config.plotOptions.bar.rangeBarOverlap && (p = h.globals.seriesRange[t][b].overlaps).indexOf(v) > -1 && (i = (s = d.barHeight / p.length) * this.visibleI + c * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + s * (this.visibleI + p.indexOf(v)) + c * m)) : (m > -1 && (n = h.config.plotOptions.bar.rangeBarGroupRows ? o + u * m : o + l * this.visibleI + u * m),
                b > -1 && !h.config.plotOptions.bar.rangeBarOverlap && (p = h.globals.seriesRange[t][b].overlaps).indexOf(v) > -1 && (n = (l = d.barWidth / p.length) * this.visibleI + u * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l * (this.visibleI + p.indexOf(v)) + u * m)),
                {
                    barYPosition: i,
                    barXPosition: n,
                    barHeight: s,
                    barWidth: l
                }
            }
        }, {
            key: "drawRangeColumnPaths",
            value: function(e) {
                var t = e.indexes
                  , a = e.x
                  , i = e.xDivision
                  , n = e.barWidth
                  , r = e.barXPosition
                  , o = e.zeroH
                  , s = this.w
                  , l = t.i
                  , c = t.j
                  , u = this.yRatio[this.yaxisIndex]
                  , d = t.realIndex
                  , h = this.getRangeValue(d, c)
                  , p = Math.min(h.start, h.end)
                  , v = Math.max(h.start, h.end);
                void 0 === this.series[l][c] || null === this.series[l][c] ? p = o : (p = o - p / u,
                v = o - v / u);
                var g = Math.abs(v - p)
                  , f = this.barHelpers.getColumnPaths({
                    barXPosition: r,
                    barWidth: n,
                    y1: p,
                    y2: v,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    realIndex: t.realIndex,
                    i: d,
                    j: c,
                    w: s
                });
                if (s.globals.isXNumeric) {
                    var m = this.getBarXForNumericXAxis({
                        x: a,
                        j: c,
                        realIndex: d,
                        barWidth: n
                    });
                    a = m.x,
                    r = m.barXPosition
                } else
                    a += i;
                return {
                    pathTo: f.pathTo,
                    pathFrom: f.pathFrom,
                    barHeight: g,
                    x: a,
                    y: v,
                    goalY: this.barHelpers.getGoalValues("y", null, o, l, c),
                    barXPosition: r
                }
            }
        }, {
            key: "drawRangeBarPaths",
            value: function(e) {
                var t = e.indexes
                  , a = e.y
                  , i = e.y1
                  , n = e.y2
                  , r = e.yDivision
                  , o = e.barHeight
                  , s = e.barYPosition
                  , l = e.zeroW
                  , c = this.w
                  , u = l + i / this.invertedYRatio
                  , d = l + n / this.invertedYRatio
                  , h = Math.abs(d - u)
                  , p = this.barHelpers.getBarpaths({
                    barYPosition: s,
                    barHeight: o,
                    x1: u,
                    x2: d,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    i: t.realIndex,
                    realIndex: t.realIndex,
                    j: t.j,
                    w: c
                });
                return c.globals.isXNumeric || (a += r),
                {
                    pathTo: p.pathTo,
                    pathFrom: p.pathFrom,
                    barWidth: h,
                    x: d,
                    goalX: this.barHelpers.getGoalValues("x", l, null, t.realIndex, t.j),
                    y: a
                }
            }
        }, {
            key: "getRangeValue",
            value: function(e, t) {
                var a = this.w;
                return {
                    start: a.globals.seriesRangeStart[e][t],
                    end: a.globals.seriesRangeEnd[e][t]
                }
            }
        }]),
        t
    }()
      , Oe = function() {
        function e(t) {
            r(this, e),
            this.w = t.w,
            this.lineCtx = t
        }
        return s(e, [{
            key: "sameValueSeriesFix",
            value: function(e, t) {
                var a = this.w;
                if (("gradient" === a.config.fill.type || "gradient" === a.config.fill.type[e]) && new k(this.lineCtx.ctx,a).seriesHaveSameValues(e)) {
                    var i = t[e].slice();
                    i[i.length - 1] = i[i.length - 1] + 1e-6,
                    t[e] = i
                }
                return t
            }
        }, {
            key: "calculatePoints",
            value: function(e) {
                var t = e.series
                  , a = e.realIndex
                  , i = e.x
                  , n = e.y
                  , r = e.i
                  , o = e.j
                  , s = e.prevY
                  , l = this.w
                  , c = []
                  , u = [];
                if (0 === o) {
                    var d = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX;
                    l.globals.isXNumeric && (d = (l.globals.seriesX[a][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX),
                    c.push(d),
                    u.push(b.isNumber(t[r][0]) ? s + l.config.markers.offsetY : null),
                    c.push(i + l.config.markers.offsetX),
                    u.push(b.isNumber(t[r][o + 1]) ? n + l.config.markers.offsetY : null)
                } else
                    c.push(i + l.config.markers.offsetX),
                    u.push(b.isNumber(t[r][o + 1]) ? n + l.config.markers.offsetY : null);
                return {
                    x: c,
                    y: u
                }
            }
        }, {
            key: "checkPreviousPaths",
            value: function(e) {
                for (var t = e.pathFromLine, a = e.pathFromArea, i = e.realIndex, n = this.w, r = 0; r < n.globals.previousPaths.length; r++) {
                    var o = n.globals.previousPaths[r];
                    ("line" === o.type || "area" === o.type) && o.paths.length > 0 && parseInt(o.realIndex, 10) === parseInt(i, 10) && ("line" === o.type ? (this.lineCtx.appendPathFrom = !1,
                    t = n.globals.previousPaths[r].paths[0].d) : "area" === o.type && (this.lineCtx.appendPathFrom = !1,
                    a = n.globals.previousPaths[r].paths[0].d,
                    n.config.stroke.show && n.globals.previousPaths[r].paths[1] && (t = n.globals.previousPaths[r].paths[1].d)))
                }
                return {
                    pathFromLine: t,
                    pathFromArea: a
                }
            }
        }, {
            key: "determineFirstPrevY",
            value: function(e) {
                var t, a, i = e.i, n = e.series, r = e.prevY, o = e.lineYPosition, s = this.w, l = s.config.chart.stacked && !s.globals.comboCharts || s.config.chart.stacked && s.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (t = this.w.config.series[i]) || void 0 === t ? void 0 : t.type));
                if (void 0 !== (null === (a = n[i]) || void 0 === a ? void 0 : a[0]))
                    r = (o = l && i > 0 ? this.lineCtx.prevSeriesY[i - 1][0] : this.lineCtx.zeroY) - n[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? n[i][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                else if (l && i > 0 && void 0 === n[i][0])
                    for (var c = i - 1; c >= 0; c--)
                        if (null !== n[c][0] && void 0 !== n[c][0]) {
                            r = o = this.lineCtx.prevSeriesY[c][0];
                            break
                        }
                return {
                    prevY: r,
                    lineYPosition: o
                }
            }
        }]),
        e
    }()
      , Ve = function(e) {
        for (var t = "", a = 0; a < e.length; a++) {
            var i = e[a]
              , n = i.length;
            n > 4 ? (t += "C".concat(i[0], ", ").concat(i[1]),
            t += ", ".concat(i[2], ", ").concat(i[3]),
            t += ", ".concat(i[4], ", ").concat(i[5])) : n > 2 && (t += "S".concat(i[0], ", ").concat(i[1]),
            t += ", ".concat(i[2], ", ").concat(i[3]))
        }
        return t
    }
      , Fe = function(e) {
        var t = function(e) {
            for (var t, a, i, n, r = function(e) {
                for (var t = [], a = e[0], i = e[1], n = t[0] = Be(a, i), r = 1, o = e.length - 1; r < o; r++)
                    a = i,
                    i = e[r + 1],
                    t[r] = .5 * (n + (n = Be(a, i)));
                return t[r] = n,
                t
            }(e), o = e.length - 1, s = [], l = 0; l < o; l++)
                i = Be(e[l], e[l + 1]),
                Math.abs(i) < 1e-6 ? r[l] = r[l + 1] = 0 : (n = (t = r[l] / i) * t + (a = r[l + 1] / i) * a) > 9 && (n = 3 * i / Math.sqrt(n),
                r[l] = n * t,
                r[l + 1] = n * a);
            for (var c = 0; c <= o; c++)
                n = (e[Math.min(o, c + 1)][0] - e[Math.max(0, c - 1)][0]) / (6 * (1 + r[c] * r[c])),
                s.push([n || 0, r[c] * n || 0]);
            return s
        }(e)
          , a = e[1]
          , i = e[0]
          , n = []
          , r = t[1]
          , o = t[0];
        n.push(i, [i[0] + o[0], i[1] + o[1], a[0] - r[0], a[1] - r[1], a[0], a[1]]);
        for (var s = 2, l = t.length; s < l; s++) {
            var c = e[s]
              , u = t[s];
            n.push([c[0] - u[0], c[1] - u[1], c[0], c[1]])
        }
        return n
    };
    function Be(e, t) {
        return (t[1] - e[1]) / (t[0] - e[0])
    }
    var Me = function() {
        function e(t, a, i) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.xyRatios = a,
            this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || i,
            this.scatter = new z(this.ctx),
            this.noNegatives = this.w.globals.minX === Number.MAX_VALUE,
            this.lineHelpers = new Oe(this),
            this.markers = new N(this.ctx),
            this.prevSeriesY = [],
            this.categoryAxisCorrection = 0,
            this.yaxisIndex = 0
        }
        return s(e, [{
            key: "draw",
            value: function(e, t, a, n) {
                var r, o = this.w, s = new w(this.ctx), l = o.globals.comboCharts ? t : o.config.chart.type, c = s.group({
                    class: "apexcharts-".concat(l, "-series apexcharts-plot-series")
                }), u = new k(this.ctx,o);
                this.yRatio = this.xyRatios.yRatio,
                this.zRatio = this.xyRatios.zRatio,
                this.xRatio = this.xyRatios.xRatio,
                this.baseLineY = this.xyRatios.baseLineY,
                e = u.getLogSeries(e),
                this.yRatio = u.getLogYRatios(this.yRatio);
                for (var d = [], h = 0; h < e.length; h++) {
                    e = this.lineHelpers.sameValueSeriesFix(h, e);
                    var p = o.globals.comboCharts ? a[h] : h;
                    this._initSerieVariables(e, h, p);
                    var v = []
                      , g = []
                      , f = []
                      , m = o.globals.padHorizontal + this.categoryAxisCorrection;
                    this.ctx.series.addCollapsedClassToSeries(this.elSeries, p),
                    o.globals.isXNumeric && o.globals.seriesX.length > 0 && (m = (o.globals.seriesX[p][0] - o.globals.minX) / this.xRatio),
                    f.push(m);
                    var b, x = m, y = void 0, S = x, C = this.zeroY, A = this.zeroY;
                    C = this.lineHelpers.determineFirstPrevY({
                        i: h,
                        series: e,
                        prevY: C,
                        lineYPosition: 0
                    }).prevY,
                    "monotonCubic" === o.config.stroke.curve && null === e[h][0] ? v.push(null) : v.push(C),
                    b = C,
                    "rangeArea" === l && (y = A = this.lineHelpers.determineFirstPrevY({
                        i: h,
                        series: n,
                        prevY: A,
                        lineYPosition: 0
                    }).prevY,
                    g.push(A));
                    var P = {
                        type: l,
                        series: e,
                        realIndex: p,
                        i: h,
                        x: m,
                        y: 1,
                        pX: x,
                        pY: b,
                        pathsFrom: this._calculatePathsFrom({
                            type: l,
                            series: e,
                            i: h,
                            realIndex: p,
                            prevX: S,
                            prevY: C,
                            prevY2: A
                        }),
                        linePaths: [],
                        areaPaths: [],
                        seriesIndex: a,
                        lineYPosition: 0,
                        xArrj: f,
                        yArrj: v,
                        y2Arrj: g,
                        seriesRangeEnd: n
                    }
                      , L = this._iterateOverDataPoints(i(i({}, P), {}, {
                        iterations: "rangeArea" === l ? e[h].length - 1 : void 0,
                        isRangeStart: !0
                    }));
                    if ("rangeArea" === l) {
                        var I = this._calculatePathsFrom({
                            series: n,
                            i: h,
                            realIndex: p,
                            prevX: S,
                            prevY: A
                        })
                          , _ = this._iterateOverDataPoints(i(i({}, P), {}, {
                            series: n,
                            pY: y,
                            pathsFrom: I,
                            iterations: n[h].length - 1,
                            isRangeStart: !1
                        }));
                        L.linePaths[0] = _.linePath + L.linePath,
                        L.pathFromLine = _.pathFromLine + L.pathFromLine
                    }
                    this._handlePaths({
                        type: l,
                        realIndex: p,
                        i: h,
                        paths: L
                    }),
                    this.elSeries.add(this.elPointsMain),
                    this.elSeries.add(this.elDataLabelsWrap),
                    d.push(this.elSeries)
                }
                if (void 0 !== (null === (r = o.config.series[0]) || void 0 === r ? void 0 : r.zIndex) && d.sort((function(e, t) {
                    return Number(e.node.getAttribute("zIndex")) - Number(t.node.getAttribute("zIndex"))
                }
                )),
                o.config.chart.stacked)
                    for (var T = d.length; T > 0; T--)
                        c.add(d[T - 1]);
                else
                    for (var E = 0; E < d.length; E++)
                        c.add(d[E]);
                return c
            }
        }, {
            key: "_initSerieVariables",
            value: function(e, t, a) {
                var i = this.w
                  , n = new w(this.ctx);
                this.xDivision = i.globals.gridWidth / (i.globals.dataPoints - ("on" === i.config.xaxis.tickPlacement ? 1 : 0)),
                this.strokeWidth = Array.isArray(i.config.stroke.width) ? i.config.stroke.width[a] : i.config.stroke.width,
                this.yRatio.length > 1 && (this.yaxisIndex = a),
                this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed,
                this.zeroY = i.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? i.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0),
                this.areaBottomY = this.zeroY,
                (this.zeroY > i.globals.gridHeight || "end" === i.config.plotOptions.area.fillTo) && (this.areaBottomY = i.globals.gridHeight),
                this.categoryAxisCorrection = this.xDivision / 2,
                this.elSeries = n.group({
                    class: "apexcharts-series",
                    zIndex: void 0 !== i.config.series[a].zIndex ? i.config.series[a].zIndex : a,
                    seriesName: b.escapeString(i.globals.seriesNames[a])
                }),
                this.elPointsMain = n.group({
                    class: "apexcharts-series-markers-wrap",
                    "data:realIndex": a
                }),
                this.elDataLabelsWrap = n.group({
                    class: "apexcharts-datalabels",
                    "data:realIndex": a
                });
                var r = e[t].length === i.globals.dataPoints;
                this.elSeries.attr({
                    "data:longestSeries": r,
                    rel: t + 1,
                    "data:realIndex": a
                }),
                this.appendPathFrom = !0
            }
        }, {
            key: "_calculatePathsFrom",
            value: function(e) {
                var t, a, i, n, r = e.type, o = e.series, s = e.i, l = e.realIndex, c = e.prevX, u = e.prevY, d = e.prevY2, h = this.w, p = new w(this.ctx);
                if (null === o[s][0]) {
                    for (var v = 0; v < o[s].length; v++)
                        if (null !== o[s][v]) {
                            c = this.xDivision * v,
                            u = this.zeroY - o[s][v] / this.yRatio[this.yaxisIndex],
                            t = p.move(c, u),
                            a = p.move(c, this.areaBottomY);
                            break
                        }
                } else
                    t = p.move(c, u),
                    "rangeArea" === r && (t = p.move(c, d) + p.line(c, u)),
                    a = p.move(c, this.areaBottomY) + p.line(c, u);
                if (i = p.move(-1, this.zeroY) + p.line(-1, this.zeroY),
                n = p.move(-1, this.zeroY) + p.line(-1, this.zeroY),
                h.globals.previousPaths.length > 0) {
                    var g = this.lineHelpers.checkPreviousPaths({
                        pathFromLine: i,
                        pathFromArea: n,
                        realIndex: l
                    });
                    i = g.pathFromLine,
                    n = g.pathFromArea
                }
                return {
                    prevX: c,
                    prevY: u,
                    linePath: t,
                    areaPath: a,
                    pathFromLine: i,
                    pathFromArea: n
                }
            }
        }, {
            key: "_handlePaths",
            value: function(e) {
                var t = e.type
                  , a = e.realIndex
                  , n = e.i
                  , r = e.paths
                  , o = this.w
                  , s = new w(this.ctx)
                  , l = new R(this.ctx);
                this.prevSeriesY.push(r.yArrj),
                o.globals.seriesXvalues[a] = r.xArrj,
                o.globals.seriesYvalues[a] = r.yArrj;
                var c = o.config.forecastDataPoints;
                if (c.count > 0 && "rangeArea" !== t) {
                    var u = o.globals.seriesXvalues[a][o.globals.seriesXvalues[a].length - c.count - 1]
                      , d = s.drawRect(u, 0, o.globals.gridWidth, o.globals.gridHeight, 0);
                    o.globals.dom.elForecastMask.appendChild(d.node);
                    var h = s.drawRect(0, 0, u, o.globals.gridHeight, 0);
                    o.globals.dom.elNonForecastMask.appendChild(h.node)
                }
                this.pointsChart || o.globals.delayedElements.push({
                    el: this.elPointsMain.node,
                    index: a
                });
                var p = {
                    i: n,
                    realIndex: a,
                    animationDelay: n,
                    initialSpeed: o.config.chart.animations.speed,
                    dataChangeSpeed: o.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(t)
                };
                if ("area" === t)
                    for (var v = l.fillPath({
                        seriesNumber: a
                    }), g = 0; g < r.areaPaths.length; g++) {
                        var f = s.renderPaths(i(i({}, p), {}, {
                            pathFrom: r.pathFromArea,
                            pathTo: r.areaPaths[g],
                            stroke: "none",
                            strokeWidth: 0,
                            strokeLineCap: null,
                            fill: v
                        }));
                        this.elSeries.add(f)
                    }
                if (o.config.stroke.show && !this.pointsChart) {
                    var m = null;
                    if ("line" === t)
                        m = l.fillPath({
                            seriesNumber: a,
                            i: n
                        });
                    else if ("solid" === o.config.stroke.fill.type)
                        m = o.globals.stroke.colors[a];
                    else {
                        var b = o.config.fill;
                        o.config.fill = o.config.stroke.fill,
                        m = l.fillPath({
                            seriesNumber: a,
                            i: n
                        }),
                        o.config.fill = b
                    }
                    for (var x = 0; x < r.linePaths.length; x++) {
                        var y = m;
                        "rangeArea" === t && (y = l.fillPath({
                            seriesNumber: a
                        }));
                        var k = i(i({}, p), {}, {
                            pathFrom: r.pathFromLine,
                            pathTo: r.linePaths[x],
                            stroke: m,
                            strokeWidth: this.strokeWidth,
                            strokeLineCap: o.config.stroke.lineCap,
                            fill: "rangeArea" === t ? y : "none"
                        })
                          , S = s.renderPaths(k);
                        if (this.elSeries.add(S),
                        S.attr("fill-rule", "evenodd"),
                        c.count > 0 && "rangeArea" !== t) {
                            var C = s.renderPaths(k);
                            C.node.setAttribute("stroke-dasharray", c.dashArray),
                            c.strokeWidth && C.node.setAttribute("stroke-width", c.strokeWidth),
                            this.elSeries.add(C),
                            C.attr("clip-path", "url(#forecastMask".concat(o.globals.cuid, ")")),
                            S.attr("clip-path", "url(#nonForecastMask".concat(o.globals.cuid, ")"))
                        }
                    }
                }
            }
        }, {
            key: "_iterateOverDataPoints",
            value: function(e) {
                var t, a = this, i = e.type, n = e.series, r = e.iterations, o = e.realIndex, s = e.i, l = e.x, c = e.y, u = e.pX, d = e.pY, h = e.pathsFrom, p = e.linePaths, v = e.areaPaths, g = e.seriesIndex, f = e.lineYPosition, m = e.xArrj, x = e.yArrj, y = e.y2Arrj, k = e.isRangeStart, S = e.seriesRangeEnd, C = this.w, A = new w(this.ctx), P = this.yRatio, L = h.prevY, I = h.linePath, _ = h.areaPath, T = h.pathFromLine, E = h.pathFromArea, O = b.isNumber(C.globals.minYArr[o]) ? C.globals.minYArr[o] : C.globals.minY;
                r || (r = C.globals.dataPoints > 1 ? C.globals.dataPoints - 1 : C.globals.dataPoints);
                for (var V = function(e, t) {
                    return t - e / P[a.yaxisIndex] + 2 * (a.isReversed ? e / P[a.yaxisIndex] : 0)
                }, F = c, B = C.config.chart.stacked && !C.globals.comboCharts || C.config.chart.stacked && C.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (t = this.w.config.series[o]) || void 0 === t ? void 0 : t.type)), M = 0; M < r; M++) {
                    var D = void 0 === n[s][M + 1] || null === n[s][M + 1];
                    if (C.globals.isXNumeric) {
                        var R = C.globals.seriesX[o][M + 1];
                        void 0 === C.globals.seriesX[o][M + 1] && (R = C.globals.seriesX[o][r - 1]),
                        l = (R - C.globals.minX) / this.xRatio
                    } else
                        l += this.xDivision;
                    f = B && s > 0 && C.globals.collapsedSeries.length < C.config.series.length - 1 ? this.prevSeriesY[function(e) {
                        for (var t = e, a = 0; a < C.globals.series.length; a++)
                            if (C.globals.collapsedSeriesIndices.indexOf(e) > -1) {
                                t--;
                                break
                            }
                        return t >= 0 ? t : 0
                    }(s - 1)][M + 1] : this.zeroY,
                    D ? c = V(O, f) : (c = V(n[s][M + 1], f),
                    "rangeArea" === i && (F = V(S[s][M + 1], f))),
                    m.push(l),
                    D && "smooth" === C.config.stroke.curve ? x.push(null) : x.push(c),
                    y.push(F);
                    var N = this.lineHelpers.calculatePoints({
                        series: n,
                        x: l,
                        y: c,
                        realIndex: o,
                        i: s,
                        j: M,
                        prevY: L
                    })
                      , z = this._createPaths({
                        type: i,
                        series: n,
                        i: s,
                        realIndex: o,
                        j: M,
                        x: l,
                        y: c,
                        y2: F,
                        xArrj: m,
                        yArrj: x,
                        y2Arrj: y,
                        pX: u,
                        pY: d,
                        linePath: I,
                        areaPath: _,
                        linePaths: p,
                        areaPaths: v,
                        seriesIndex: g,
                        isRangeStart: k
                    });
                    v = z.areaPaths,
                    p = z.linePaths,
                    u = z.pX,
                    d = z.pY,
                    _ = z.areaPath,
                    I = z.linePath,
                    !this.appendPathFrom || "monotoneCubic" === C.config.stroke.curve && "rangeArea" === i || (T += A.line(l, this.zeroY),
                    E += A.line(l, this.zeroY)),
                    this.handleNullDataPoints(n, N, s, M, o),
                    this._handleMarkersAndLabels({
                        type: i,
                        pointsPos: N,
                        i: s,
                        j: M,
                        realIndex: o,
                        isRangeStart: k
                    })
                }
                return {
                    yArrj: x,
                    xArrj: m,
                    pathFromArea: E,
                    areaPaths: v,
                    pathFromLine: T,
                    linePaths: p,
                    linePath: I,
                    areaPath: _
                }
            }
        }, {
            key: "_handleMarkersAndLabels",
            value: function(e) {
                var t = e.type
                  , a = e.pointsPos
                  , i = e.isRangeStart
                  , n = e.i
                  , r = e.j
                  , o = e.realIndex
                  , s = this.w
                  , l = new H(this.ctx);
                if (this.pointsChart)
                    this.scatter.draw(this.elSeries, r, {
                        realIndex: o,
                        pointsPos: a,
                        zRatio: this.zRatio,
                        elParent: this.elPointsMain
                    });
                else {
                    s.globals.series[n].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                    var c = this.markers.plotChartMarkers(a, o, r + 1);
                    null !== c && this.elPointsMain.add(c)
                }
                var u = l.drawDataLabel({
                    type: t,
                    isRangeStart: i,
                    pos: a,
                    i: o,
                    j: r + 1
                });
                null !== u && this.elDataLabelsWrap.add(u)
            }
        }, {
            key: "_createPaths",
            value: function(e) {
                var t = e.type
                  , a = e.series
                  , i = e.i
                  , n = e.realIndex
                  , r = e.j
                  , o = e.x
                  , s = e.y
                  , l = e.xArrj
                  , c = e.yArrj
                  , u = e.y2
                  , d = e.y2Arrj
                  , h = e.pX
                  , p = e.pY
                  , v = e.linePath
                  , g = e.areaPath
                  , f = e.linePaths
                  , m = e.areaPaths
                  , b = e.seriesIndex
                  , x = e.isRangeStart
                  , y = this.w
                  , k = new w(this.ctx)
                  , S = y.config.stroke.curve
                  , C = this.areaBottomY;
                if (Array.isArray(y.config.stroke.curve) && (S = Array.isArray(b) ? y.config.stroke.curve[b[i]] : y.config.stroke.curve[i]),
                "rangeArea" === t && (y.globals.hasNullValues || y.config.forecastDataPoints.count > 0) && "monotoneCubic" === S && (S = "straight"),
                "monotoneCubic" === S) {
                    var A = "rangeArea" === t ? l.length === y.globals.dataPoints : r === a[i].length - 2
                      , P = l.map((function(e, t) {
                        return [l[t], c[t]]
                    }
                    )).filter((function(e) {
                        return null !== e[1]
                    }
                    ));
                    if (A && P.length > 1) {
                        var L = Fe(P);
                        if (v += Ve(L),
                        null === a[i][0] ? g = v : g += Ve(L),
                        "rangeArea" === t && x) {
                            v += k.line(l[l.length - 1], d[d.length - 1]);
                            var I = l.slice().reverse()
                              , _ = d.slice().reverse()
                              , T = I.map((function(e, t) {
                                return [I[t], _[t]]
                            }
                            ))
                              , E = Fe(T);
                            g = v += Ve(E)
                        } else
                            g += k.line(P[P.length - 1][0], C) + k.line(P[0][0], C) + k.move(P[0][0], P[0][1]) + "z";
                        f.push(v),
                        m.push(g)
                    }
                } else if ("smooth" === S) {
                    var O = .35 * (o - h);
                    y.globals.hasNullValues ? (null !== a[i][r] && (null !== a[i][r + 1] ? (v = k.move(h, p) + k.curve(h + O, p, o - O, s, o + 1, s),
                    g = k.move(h + 1, p) + k.curve(h + O, p, o - O, s, o + 1, s) + k.line(o, C) + k.line(h, C) + "z") : (v = k.move(h, p),
                    g = k.move(h, p) + "z")),
                    f.push(v),
                    m.push(g)) : (v += k.curve(h + O, p, o - O, s, o, s),
                    g += k.curve(h + O, p, o - O, s, o, s)),
                    h = o,
                    p = s,
                    r === a[i].length - 2 && (g = g + k.curve(h, p, o, s, o, C) + k.move(o, s) + "z",
                    "rangeArea" === t && x ? v = v + k.curve(h, p, o, s, o, u) + k.move(o, u) + "z" : y.globals.hasNullValues || (f.push(v),
                    m.push(g)))
                } else {
                    if (null === a[i][r + 1]) {
                        v += k.move(o, s);
                        var V = y.globals.isXNumeric ? (y.globals.seriesX[n][r] - y.globals.minX) / this.xRatio : o - this.xDivision;
                        g = g + k.line(V, C) + k.move(o, s) + "z"
                    }
                    null === a[i][r] && (v += k.move(o, s),
                    g += k.move(o, C)),
                    "stepline" === S ? (v = v + k.line(o, null, "H") + k.line(null, s, "V"),
                    g = g + k.line(o, null, "H") + k.line(null, s, "V")) : "straight" === S && (v += k.line(o, s),
                    g += k.line(o, s)),
                    r === a[i].length - 2 && (g = g + k.line(o, C) + k.move(o, s) + "z",
                    "rangeArea" === t && x ? v = v + k.line(o, u) + k.move(o, u) + "z" : (f.push(v),
                    m.push(g)))
                }
                return {
                    linePaths: f,
                    areaPaths: m,
                    pX: h,
                    pY: p,
                    linePath: v,
                    areaPath: g
                }
            }
        }, {
            key: "handleNullDataPoints",
            value: function(e, t, a, i, n) {
                var r = this.w;
                if (null === e[a][i] && r.config.markers.showNullDataPoints || 1 === e[a].length) {
                    var o = this.markers.plotChartMarkers(t, n, i + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0);
                    null !== o && this.elPointsMain.add(o)
                }
            }
        }]),
        e
    }();
    window.TreemapSquared = {},
    window.TreemapSquared.generate = function() {
        function e(t, a, i, n) {
            this.xoffset = t,
            this.yoffset = a,
            this.height = n,
            this.width = i,
            this.shortestEdge = function() {
                return Math.min(this.height, this.width)
            }
            ,
            this.getCoordinates = function(e) {
                var t, a = [], i = this.xoffset, n = this.yoffset, o = r(e) / this.height, s = r(e) / this.width;
                if (this.width >= this.height)
                    for (t = 0; t < e.length; t++)
                        a.push([i, n, i + o, n + e[t] / o]),
                        n += e[t] / o;
                else
                    for (t = 0; t < e.length; t++)
                        a.push([i, n, i + e[t] / s, n + s]),
                        i += e[t] / s;
                return a
            }
            ,
            this.cutArea = function(t) {
                var a;
                if (this.width >= this.height) {
                    var i = t / this.height
                      , n = this.width - i;
                    a = new e(this.xoffset + i,this.yoffset,n,this.height)
                } else {
                    var r = t / this.width
                      , o = this.height - r;
                    a = new e(this.xoffset,this.yoffset + r,this.width,o)
                }
                return a
            }
        }
        function t(t, i, n, o, s) {
            return o = void 0 === o ? 0 : o,
            s = void 0 === s ? 0 : s,
            function(e) {
                var t, a, i = [];
                for (t = 0; t < e.length; t++)
                    for (a = 0; a < e[t].length; a++)
                        i.push(e[t][a]);
                return i
            }(a(function(e, t) {
                var a, i = [], n = t / r(e);
                for (a = 0; a < e.length; a++)
                    i[a] = e[a] * n;
                return i
            }(t, i * n), [], new e(o,s,i,n), []))
        }
        function a(e, t, n, o) {
            var s, l, c, u, d, h, p;
            if (0 !== e.length)
                return s = n.shortestEdge(),
                u = t,
                d = l = e[0],
                h = s,
                0 === u.length || ((p = u.slice()).push(d),
                i(u, h) >= i(p, h)) ? (t.push(l),
                a(e.slice(1), t, n, o)) : (c = n.cutArea(r(t), o),
                o.push(n.getCoordinates(t)),
                a(e, [], c, o)),
                o;
            o.push(n.getCoordinates(t))
        }
        function i(e, t) {
            var a = Math.min.apply(Math, e)
              , i = Math.max.apply(Math, e)
              , n = r(e);
            return Math.max(Math.pow(t, 2) * i / Math.pow(n, 2), Math.pow(n, 2) / (Math.pow(t, 2) * a))
        }
        function n(e) {
            return e && e.constructor === Array
        }
        function r(e) {
            var t, a = 0;
            for (t = 0; t < e.length; t++)
                a += e[t];
            return a
        }
        function o(e) {
            var t, a = 0;
            if (n(e[0]))
                for (t = 0; t < e.length; t++)
                    a += o(e[t]);
            else
                a = r(e);
            return a
        }
        return function e(a, i, r, s, l) {
            s = void 0 === s ? 0 : s,
            l = void 0 === l ? 0 : l;
            var c, u, d = [], h = [];
            if (n(a[0])) {
                for (u = 0; u < a.length; u++)
                    d[u] = o(a[u]);
                for (c = t(d, i, r, s, l),
                u = 0; u < a.length; u++)
                    h.push(e(a[u], c[u][2] - c[u][0], c[u][3] - c[u][1], c[u][0], c[u][1]))
            } else
                h = t(a, i, r, s, l);
            return h
        }
    }();
    var De, Re, Ne = function() {
        function e(t, a) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.strokeWidth = this.w.config.stroke.width,
            this.helpers = new Ae(t),
            this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation,
            this.labels = []
        }
        return s(e, [{
            key: "draw",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = new w(this.ctx)
                  , n = new R(this.ctx)
                  , r = i.group({
                    class: "apexcharts-treemap"
                });
                if (a.globals.noData)
                    return r;
                var o = [];
                return e.forEach((function(e) {
                    var t = e.map((function(e) {
                        return Math.abs(e)
                    }
                    ));
                    o.push(t)
                }
                )),
                this.negRange = this.helpers.checkColorRange(),
                a.config.series.forEach((function(e, a) {
                    e.data.forEach((function(e) {
                        Array.isArray(t.labels[a]) || (t.labels[a] = []),
                        t.labels[a].push(e.x)
                    }
                    ))
                }
                )),
                window.TreemapSquared.generate(o, a.globals.gridWidth, a.globals.gridHeight).forEach((function(o, s) {
                    var l = i.group({
                        class: "apexcharts-series apexcharts-treemap-series",
                        seriesName: b.escapeString(a.globals.seriesNames[s]),
                        rel: s + 1,
                        "data:realIndex": s
                    });
                    if (a.config.chart.dropShadow.enabled) {
                        var c = a.config.chart.dropShadow;
                        new y(t.ctx).dropShadow(r, c, s)
                    }
                    var u = i.group({
                        class: "apexcharts-data-labels"
                    });
                    o.forEach((function(r, o) {
                        var c = r[0]
                          , u = r[1]
                          , d = r[2]
                          , h = r[3]
                          , p = i.drawRect(c, u, d - c, h - u, a.config.plotOptions.treemap.borderRadius, "#fff", 1, t.strokeWidth, a.config.plotOptions.treemap.useFillColorAsStroke ? g : a.globals.stroke.colors[s]);
                        p.attr({
                            cx: c,
                            cy: u,
                            index: s,
                            i: s,
                            j: o,
                            width: d - c,
                            height: h - u
                        });
                        var v = t.helpers.getShadeColor(a.config.chart.type, s, o, t.negRange)
                          , g = v.color;
                        void 0 !== a.config.series[s].data[o] && a.config.series[s].data[o].fillColor && (g = a.config.series[s].data[o].fillColor);
                        var f = n.fillPath({
                            color: g,
                            seriesNumber: s,
                            dataPointIndex: o
                        });
                        p.node.classList.add("apexcharts-treemap-rect"),
                        p.attr({
                            fill: f
                        }),
                        t.helpers.addListeners(p);
                        var m = {
                            x: c + (d - c) / 2,
                            y: u + (h - u) / 2,
                            width: 0,
                            height: 0
                        }
                          , b = {
                            x: c,
                            y: u,
                            width: d - c,
                            height: h - u
                        };
                        if (a.config.chart.animations.enabled && !a.globals.dataChanged) {
                            var x = 1;
                            a.globals.resized || (x = a.config.chart.animations.speed),
                            t.animateTreemap(p, m, b, x)
                        }
                        if (a.globals.dataChanged) {
                            var y = 1;
                            t.dynamicAnim.enabled && a.globals.shouldAnimate && (y = t.dynamicAnim.speed,
                            a.globals.previousPaths[s] && a.globals.previousPaths[s][o] && a.globals.previousPaths[s][o].rect && (m = a.globals.previousPaths[s][o].rect),
                            t.animateTreemap(p, m, b, y))
                        }
                        var w = t.getFontSize(r)
                          , k = a.config.dataLabels.formatter(t.labels[s][o], {
                            value: a.globals.series[s][o],
                            seriesIndex: s,
                            dataPointIndex: o,
                            w: a
                        });
                        "truncate" === a.config.plotOptions.treemap.dataLabels.format && (w = parseInt(a.config.dataLabels.style.fontSize, 10),
                        k = t.truncateLabels(k, w, c, u, d, h));
                        var S = t.helpers.calculateDataLabels({
                            text: k,
                            x: (c + d) / 2,
                            y: (u + h) / 2 + t.strokeWidth / 2 + w / 3,
                            i: s,
                            j: o,
                            colorProps: v,
                            fontSize: w,
                            series: e
                        });
                        a.config.dataLabels.enabled && S && t.rotateToFitLabel(S, w, k, c, u, d, h),
                        l.add(p),
                        null !== S && l.add(S)
                    }
                    )),
                    l.add(u),
                    r.add(l)
                }
                )),
                r
            }
        }, {
            key: "getFontSize",
            value: function(e) {
                var t, a, i = this.w, n = function e(t) {
                    var a, i = 0;
                    if (Array.isArray(t[0]))
                        for (a = 0; a < t.length; a++)
                            i += e(t[a]);
                    else
                        for (a = 0; a < t.length; a++)
                            i += t[a].length;
                    return i
                }(this.labels) / function e(t) {
                    var a, i = 0;
                    if (Array.isArray(t[0]))
                        for (a = 0; a < t.length; a++)
                            i += e(t[a]);
                    else
                        for (a = 0; a < t.length; a++)
                            i += 1;
                    return i
                }(this.labels);
                return t = (e[2] - e[0]) * (e[3] - e[1]),
                a = Math.pow(t, .5),
                Math.min(a / n, parseInt(i.config.dataLabels.style.fontSize, 10))
            }
        }, {
            key: "rotateToFitLabel",
            value: function(e, t, a, i, n, r, o) {
                var s = new w(this.ctx)
                  , l = s.getTextRects(a, t);
                if (l.width + this.w.config.stroke.width + 5 > r - i && l.width <= o - n) {
                    var c = s.rotateAroundCenter(e.node);
                    e.node.setAttribute("transform", "rotate(-90 ".concat(c.x, " ").concat(c.y, ") translate(").concat(l.height / 3, ")"))
                }
            }
        }, {
            key: "truncateLabels",
            value: function(e, t, a, i, n, r) {
                var o = new w(this.ctx)
                  , s = o.getTextRects(e, t).width + this.w.config.stroke.width + 5 > n - a && r - i > n - a ? r - i : n - a
                  , l = o.getTextBasedOnMaxWidth({
                    text: e,
                    maxWidth: s,
                    fontSize: t
                });
                return e.length !== l.length && s / t < 5 ? "" : l
            }
        }, {
            key: "animateTreemap",
            value: function(e, t, a, i) {
                var n = new x(this.ctx);
                n.animateRect(e, {
                    x: t.x,
                    y: t.y,
                    width: t.width,
                    height: t.height
                }, {
                    x: a.x,
                    y: a.y,
                    width: a.width,
                    height: a.height
                }, i, (function() {
                    n.animationCompleted(e)
                }
                ))
            }
        }]),
        e
    }(), ze = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w,
            this.timeScaleArray = [],
            this.utc = this.w.config.xaxis.labels.datetimeUTC
        }
        return s(e, [{
            key: "calculateTimeScaleTicks",
            value: function(e, t) {
                var a = this
                  , n = this.w;
                if (n.globals.allSeriesCollapsed)
                    return n.globals.labels = [],
                    n.globals.timescaleLabels = [],
                    [];
                var r = new T(this.ctx)
                  , o = (t - e) / 864e5;
                this.determineInterval(o),
                n.globals.disableZoomIn = !1,
                n.globals.disableZoomOut = !1,
                o < .00011574074074074075 ? n.globals.disableZoomIn = !0 : o > 5e4 && (n.globals.disableZoomOut = !0);
                var s = r.getTimeUnitsfromTimestamp(e, t, this.utc)
                  , l = n.globals.gridWidth / o
                  , c = l / 24
                  , u = c / 60
                  , d = u / 60
                  , h = Math.floor(24 * o)
                  , p = Math.floor(1440 * o)
                  , v = Math.floor(86400 * o)
                  , g = Math.floor(o)
                  , f = Math.floor(o / 30)
                  , m = Math.floor(o / 365)
                  , b = {
                    minMillisecond: s.minMillisecond,
                    minSecond: s.minSecond,
                    minMinute: s.minMinute,
                    minHour: s.minHour,
                    minDate: s.minDate,
                    minMonth: s.minMonth,
                    minYear: s.minYear
                }
                  , x = {
                    firstVal: b,
                    currentMillisecond: b.minMillisecond,
                    currentSecond: b.minSecond,
                    currentMinute: b.minMinute,
                    currentHour: b.minHour,
                    currentMonthDate: b.minDate,
                    currentDate: b.minDate,
                    currentMonth: b.minMonth,
                    currentYear: b.minYear,
                    daysWidthOnXAxis: l,
                    hoursWidthOnXAxis: c,
                    minutesWidthOnXAxis: u,
                    secondsWidthOnXAxis: d,
                    numberOfSeconds: v,
                    numberOfMinutes: p,
                    numberOfHours: h,
                    numberOfDays: g,
                    numberOfMonths: f,
                    numberOfYears: m
                };
                switch (this.tickInterval) {
                case "years":
                    this.generateYearScale(x);
                    break;
                case "months":
                case "half_year":
                    this.generateMonthScale(x);
                    break;
                case "months_days":
                case "months_fortnight":
                case "days":
                case "week_days":
                    this.generateDayScale(x);
                    break;
                case "hours":
                    this.generateHourScale(x);
                    break;
                case "minutes_fives":
                case "minutes":
                    this.generateMinuteScale(x);
                    break;
                case "seconds_tens":
                case "seconds_fives":
                case "seconds":
                    this.generateSecondScale(x)
                }
                var y = this.timeScaleArray.map((function(e) {
                    var t = {
                        position: e.position,
                        unit: e.unit,
                        year: e.year,
                        day: e.day ? e.day : 1,
                        hour: e.hour ? e.hour : 0,
                        month: e.month + 1
                    };
                    return "month" === e.unit ? i(i({}, t), {}, {
                        day: 1,
                        value: e.value + 1
                    }) : "day" === e.unit || "hour" === e.unit ? i(i({}, t), {}, {
                        value: e.value
                    }) : "minute" === e.unit ? i(i({}, t), {}, {
                        value: e.value,
                        minute: e.value
                    }) : "second" === e.unit ? i(i({}, t), {}, {
                        value: e.value,
                        minute: e.minute,
                        second: e.second
                    }) : e
                }
                ));
                return y.filter((function(e) {
                    var t = 1
                      , i = Math.ceil(n.globals.gridWidth / 120)
                      , r = e.value;
                    void 0 !== n.config.xaxis.tickAmount && (i = n.config.xaxis.tickAmount),
                    y.length > i && (t = Math.floor(y.length / i));
                    var o = !1
                      , s = !1;
                    switch (a.tickInterval) {
                    case "years":
                        "year" === e.unit && (o = !0);
                        break;
                    case "half_year":
                        t = 7,
                        "year" === e.unit && (o = !0);
                        break;
                    case "months":
                        t = 1,
                        "year" === e.unit && (o = !0);
                        break;
                    case "months_fortnight":
                        t = 15,
                        "year" !== e.unit && "month" !== e.unit || (o = !0),
                        30 === r && (s = !0);
                        break;
                    case "months_days":
                        t = 10,
                        "month" === e.unit && (o = !0),
                        30 === r && (s = !0);
                        break;
                    case "week_days":
                        t = 8,
                        "month" === e.unit && (o = !0);
                        break;
                    case "days":
                        t = 1,
                        "month" === e.unit && (o = !0);
                        break;
                    case "hours":
                        "day" === e.unit && (o = !0);
                        break;
                    case "minutes_fives":
                    case "seconds_fives":
                        r % 5 != 0 && (s = !0);
                        break;
                    case "seconds_tens":
                        r % 10 != 0 && (s = !0)
                    }
                    if ("hours" === a.tickInterval || "minutes_fives" === a.tickInterval || "seconds_tens" === a.tickInterval || "seconds_fives" === a.tickInterval) {
                        if (!s)
                            return !0
                    } else if ((r % t == 0 || o) && !s)
                        return !0
                }
                ))
            }
        }, {
            key: "recalcDimensionsBasedOnFormat",
            value: function(e, t) {
                var a = this.w
                  , i = this.formatDates(e)
                  , n = this.removeOverlappingTS(i);
                a.globals.timescaleLabels = n.slice(),
                new le(this.ctx).plotCoords()
            }
        }, {
            key: "determineInterval",
            value: function(e) {
                var t = 24 * e
                  , a = 60 * t;
                switch (!0) {
                case e / 365 > 5:
                    this.tickInterval = "years";
                    break;
                case e > 800:
                    this.tickInterval = "half_year";
                    break;
                case e > 180:
                    this.tickInterval = "months";
                    break;
                case e > 90:
                    this.tickInterval = "months_fortnight";
                    break;
                case e > 60:
                    this.tickInterval = "months_days";
                    break;
                case e > 30:
                    this.tickInterval = "week_days";
                    break;
                case e > 2:
                    this.tickInterval = "days";
                    break;
                case t > 2.4:
                    this.tickInterval = "hours";
                    break;
                case a > 15:
                    this.tickInterval = "minutes_fives";
                    break;
                case a > 5:
                    this.tickInterval = "minutes";
                    break;
                case a > 1:
                    this.tickInterval = "seconds_tens";
                    break;
                case 60 * a > 20:
                    this.tickInterval = "seconds_fives";
                    break;
                default:
                    this.tickInterval = "seconds"
                }
            }
        }, {
            key: "generateYearScale",
            value: function(e) {
                var t = e.firstVal
                  , a = e.currentMonth
                  , i = e.currentYear
                  , n = e.daysWidthOnXAxis
                  , r = e.numberOfYears
                  , o = t.minYear
                  , s = 0
                  , l = new T(this.ctx)
                  , c = "year";
                if (t.minDate > 1 || t.minMonth > 0) {
                    var u = l.determineRemainingDaysOfYear(t.minYear, t.minMonth, t.minDate);
                    s = (l.determineDaysOfYear(t.minYear) - u + 1) * n,
                    o = t.minYear + 1,
                    this.timeScaleArray.push({
                        position: s,
                        value: o,
                        unit: c,
                        year: o,
                        month: b.monthMod(a + 1)
                    })
                } else
                    1 === t.minDate && 0 === t.minMonth && this.timeScaleArray.push({
                        position: s,
                        value: o,
                        unit: c,
                        year: i,
                        month: b.monthMod(a + 1)
                    });
                for (var d = o, h = s, p = 0; p < r; p++)
                    d++,
                    h = l.determineDaysOfYear(d - 1) * n + h,
                    this.timeScaleArray.push({
                        position: h,
                        value: d,
                        unit: c,
                        year: d,
                        month: 1
                    })
            }
        }, {
            key: "generateMonthScale",
            value: function(e) {
                var t = e.firstVal
                  , a = e.currentMonthDate
                  , i = e.currentMonth
                  , n = e.currentYear
                  , r = e.daysWidthOnXAxis
                  , o = e.numberOfMonths
                  , s = i
                  , l = 0
                  , c = new T(this.ctx)
                  , u = "month"
                  , d = 0;
                if (t.minDate > 1) {
                    l = (c.determineDaysOfMonths(i + 1, t.minYear) - a + 1) * r,
                    s = b.monthMod(i + 1);
                    var h = n + d
                      , p = b.monthMod(s)
                      , v = s;
                    0 === s && (u = "year",
                    v = h,
                    p = 1,
                    h += d += 1),
                    this.timeScaleArray.push({
                        position: l,
                        value: v,
                        unit: u,
                        year: h,
                        month: p
                    })
                } else
                    this.timeScaleArray.push({
                        position: l,
                        value: s,
                        unit: u,
                        year: n,
                        month: b.monthMod(i)
                    });
                for (var g = s + 1, f = l, m = 0, x = 1; m < o; m++,
                x++) {
                    0 === (g = b.monthMod(g)) ? (u = "year",
                    d += 1) : u = "month";
                    var y = this._getYear(n, g, d);
                    f = c.determineDaysOfMonths(g, y) * r + f;
                    var w = 0 === g ? y : g;
                    this.timeScaleArray.push({
                        position: f,
                        value: w,
                        unit: u,
                        year: y,
                        month: 0 === g ? 1 : g
                    }),
                    g++
                }
            }
        }, {
            key: "generateDayScale",
            value: function(e) {
                var t = e.firstVal
                  , a = e.currentMonth
                  , i = e.currentYear
                  , n = e.hoursWidthOnXAxis
                  , r = e.numberOfDays
                  , o = new T(this.ctx)
                  , s = "day"
                  , l = t.minDate + 1
                  , c = l
                  , u = function(e, t, a) {
                    return e > o.determineDaysOfMonths(t + 1, a) && (c = 1,
                    s = "month",
                    h = t += 1),
                    t
                }
                  , d = (24 - t.minHour) * n
                  , h = l
                  , p = u(c, a, i);
                0 === t.minHour && 1 === t.minDate ? (d = 0,
                h = b.monthMod(t.minMonth),
                s = "month",
                c = t.minDate) : 1 !== t.minDate && 0 === t.minHour && 0 === t.minMinute && (d = 0,
                l = t.minDate,
                h = l,
                p = u(c = l, a, i)),
                this.timeScaleArray.push({
                    position: d,
                    value: h,
                    unit: s,
                    year: this._getYear(i, p, 0),
                    month: b.monthMod(p),
                    day: c
                });
                for (var v = d, g = 0; g < r; g++) {
                    s = "day",
                    p = u(c += 1, p, this._getYear(i, p, 0));
                    var f = this._getYear(i, p, 0);
                    v = 24 * n + v;
                    var m = 1 === c ? b.monthMod(p) : c;
                    this.timeScaleArray.push({
                        position: v,
                        value: m,
                        unit: s,
                        year: f,
                        month: b.monthMod(p),
                        day: m
                    })
                }
            }
        }, {
            key: "generateHourScale",
            value: function(e) {
                var t = e.firstVal
                  , a = e.currentDate
                  , i = e.currentMonth
                  , n = e.currentYear
                  , r = e.minutesWidthOnXAxis
                  , o = e.numberOfHours
                  , s = new T(this.ctx)
                  , l = "hour"
                  , c = function(e, t) {
                    return e > s.determineDaysOfMonths(t + 1, n) && (g = 1,
                    t += 1),
                    {
                        month: t,
                        date: g
                    }
                }
                  , u = function(e, t) {
                    return e > s.determineDaysOfMonths(t + 1, n) ? t += 1 : t
                }
                  , d = 60 - (t.minMinute + t.minSecond / 60)
                  , h = d * r
                  , p = t.minHour + 1
                  , v = p;
                60 === d && (h = 0,
                v = p = t.minHour);
                var g = a;
                v >= 24 && (v = 0,
                g += 1,
                l = "day");
                var f = c(g, i).month;
                f = u(g, f),
                this.timeScaleArray.push({
                    position: h,
                    value: p,
                    unit: l,
                    day: g,
                    hour: v,
                    year: n,
                    month: b.monthMod(f)
                }),
                v++;
                for (var m = h, x = 0; x < o; x++) {
                    l = "hour",
                    v >= 24 && (v = 0,
                    l = "day",
                    f = c(g += 1, f).month,
                    f = u(g, f));
                    var y = this._getYear(n, f, 0);
                    m = 60 * r + m;
                    var w = 0 === v ? g : v;
                    this.timeScaleArray.push({
                        position: m,
                        value: w,
                        unit: l,
                        hour: v,
                        day: g,
                        year: y,
                        month: b.monthMod(f)
                    }),
                    v++
                }
            }
        }, {
            key: "generateMinuteScale",
            value: function(e) {
                for (var t = e.currentMillisecond, a = e.currentSecond, i = e.currentMinute, n = e.currentHour, r = e.currentDate, o = e.currentMonth, s = e.currentYear, l = e.minutesWidthOnXAxis, c = e.secondsWidthOnXAxis, u = e.numberOfMinutes, d = i + 1, h = r, p = o, v = s, g = n, f = (60 - a - t / 1e3) * c, m = 0; m < u; m++)
                    d >= 60 && (d = 0,
                    24 === (g += 1) && (g = 0)),
                    this.timeScaleArray.push({
                        position: f,
                        value: d,
                        unit: "minute",
                        hour: g,
                        minute: d,
                        day: h,
                        year: this._getYear(v, p, 0),
                        month: b.monthMod(p)
                    }),
                    f += l,
                    d++
            }
        }, {
            key: "generateSecondScale",
            value: function(e) {
                for (var t = e.currentMillisecond, a = e.currentSecond, i = e.currentMinute, n = e.currentHour, r = e.currentDate, o = e.currentMonth, s = e.currentYear, l = e.secondsWidthOnXAxis, c = e.numberOfSeconds, u = a + 1, d = i, h = r, p = o, v = s, g = n, f = (1e3 - t) / 1e3 * l, m = 0; m < c; m++)
                    u >= 60 && (u = 0,
                    ++d >= 60 && (d = 0,
                    24 == ++g && (g = 0))),
                    this.timeScaleArray.push({
                        position: f,
                        value: u,
                        unit: "second",
                        hour: g,
                        minute: d,
                        second: u,
                        day: h,
                        year: this._getYear(v, p, 0),
                        month: b.monthMod(p)
                    }),
                    f += l,
                    u++
            }
        }, {
            key: "createRawDateString",
            value: function(e, t) {
                var a = e.year;
                return 0 === e.month && (e.month = 1),
                a += "-" + ("0" + e.month.toString()).slice(-2),
                "day" === e.unit ? a += "day" === e.unit ? "-" + ("0" + t).slice(-2) : "-01" : a += "-" + ("0" + (e.day ? e.day : "1")).slice(-2),
                "hour" === e.unit ? a += "hour" === e.unit ? "T" + ("0" + t).slice(-2) : "T00" : a += "T" + ("0" + (e.hour ? e.hour : "0")).slice(-2),
                "minute" === e.unit ? a += ":" + ("0" + t).slice(-2) : a += ":" + (e.minute ? ("0" + e.minute).slice(-2) : "00"),
                "second" === e.unit ? a += ":" + ("0" + t).slice(-2) : a += ":00",
                this.utc && (a += ".000Z"),
                a
            }
        }, {
            key: "formatDates",
            value: function(e) {
                var t = this
                  , a = this.w;
                return e.map((function(e) {
                    var i = e.value.toString()
                      , n = new T(t.ctx)
                      , r = t.createRawDateString(e, i)
                      , o = n.getDate(n.parseDate(r));
                    if (t.utc || (o = n.getDate(n.parseDateWithTimezone(r))),
                    void 0 === a.config.xaxis.labels.format) {
                        var s = "dd MMM"
                          , l = a.config.xaxis.labels.datetimeFormatter;
                        "year" === e.unit && (s = l.year),
                        "month" === e.unit && (s = l.month),
                        "day" === e.unit && (s = l.day),
                        "hour" === e.unit && (s = l.hour),
                        "minute" === e.unit && (s = l.minute),
                        "second" === e.unit && (s = l.second),
                        i = n.formatDate(o, s)
                    } else
                        i = n.formatDate(o, a.config.xaxis.labels.format);
                    return {
                        dateString: r,
                        position: e.position,
                        value: i,
                        unit: e.unit,
                        year: e.year,
                        month: e.month
                    }
                }
                ))
            }
        }, {
            key: "removeOverlappingTS",
            value: function(e) {
                var t, a = this, i = new w(this.ctx), n = !1;
                e.length > 0 && e[0].value && e.every((function(t) {
                    return t.value.length === e[0].value.length
                }
                )) && (n = !0,
                t = i.getTextRects(e[0].value).width);
                var r = 0
                  , o = e.map((function(o, s) {
                    if (s > 0 && a.w.config.xaxis.labels.hideOverlappingLabels) {
                        var l = n ? t : i.getTextRects(e[r].value).width
                          , c = e[r].position;
                        return o.position > c + l + 10 ? (r = s,
                        o) : null
                    }
                    return o
                }
                ));
                return o.filter((function(e) {
                    return null !== e
                }
                ))
            }
        }, {
            key: "_getYear",
            value: function(e, t, a) {
                return e + Math.floor(t / 12) + a
            }
        }]),
        e
    }(), He = function() {
        function e(t, a) {
            r(this, e),
            this.ctx = a,
            this.w = a.w,
            this.el = t
        }
        return s(e, [{
            key: "setupElements",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config
                  , a = t.chart.type;
                e.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(a) > -1,
                e.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(a) > -1,
                e.isBarHorizontal = ("bar" === t.chart.type || "rangeBar" === t.chart.type || "boxPlot" === t.chart.type) && t.plotOptions.bar.horizontal,
                e.chartClass = ".apexcharts" + e.chartID,
                e.dom.baseEl = this.el,
                e.dom.elWrap = document.createElement("div"),
                w.setAttrs(e.dom.elWrap, {
                    id: e.chartClass.substring(1),
                    class: "apexcharts-canvas " + e.chartClass.substring(1)
                }),
                this.el.appendChild(e.dom.elWrap),
                e.dom.Paper = new window.SVG.Doc(e.dom.elWrap),
                e.dom.Paper.attr({
                    class: "apexcharts-svg",
                    "xmlns:data": "ApexChartsNS",
                    transform: "translate(".concat(t.chart.offsetX, ", ").concat(t.chart.offsetY, ")")
                }),
                e.dom.Paper.node.style.background = "dark" !== t.theme.mode || t.chart.background ? t.chart.background : "rgba(0, 0, 0, 0.8)",
                this.setSVGDimensions(),
                e.dom.elLegendForeign = document.createElementNS(e.SVGNS, "foreignObject"),
                w.setAttrs(e.dom.elLegendForeign, {
                    x: 0,
                    y: 0,
                    width: e.svgWidth,
                    height: e.svgHeight
                }),
                e.dom.elLegendWrap = document.createElement("div"),
                e.dom.elLegendWrap.classList.add("apexcharts-legend"),
                e.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"),
                e.dom.elLegendForeign.appendChild(e.dom.elLegendWrap),
                e.dom.Paper.node.appendChild(e.dom.elLegendForeign),
                e.dom.elGraphical = e.dom.Paper.group().attr({
                    class: "apexcharts-inner apexcharts-graphical"
                }),
                e.dom.elDefs = e.dom.Paper.defs(),
                e.dom.Paper.add(e.dom.elGraphical),
                e.dom.elGraphical.add(e.dom.elDefs)
            }
        }, {
            key: "plotChartType",
            value: function(e, t) {
                var a = this.w
                  , i = a.config
                  , n = a.globals
                  , r = {
                    series: [],
                    i: []
                }
                  , o = {
                    series: [],
                    i: []
                }
                  , s = {
                    series: [],
                    i: []
                }
                  , l = {
                    series: [],
                    i: []
                }
                  , c = {
                    series: [],
                    i: []
                }
                  , u = {
                    series: [],
                    i: []
                }
                  , d = {
                    series: [],
                    i: []
                }
                  , h = {
                    series: [],
                    i: []
                }
                  , p = {
                    series: [],
                    seriesRangeEnd: [],
                    i: []
                };
                n.series.map((function(t, v) {
                    var g = 0;
                    void 0 !== e[v].type ? ("column" === e[v].type || "bar" === e[v].type ? (n.series.length > 1 && i.plotOptions.bar.horizontal,
                    c.series.push(t),
                    c.i.push(v),
                    g++,
                    a.globals.columnSeries = c.series) : "area" === e[v].type ? (o.series.push(t),
                    o.i.push(v),
                    g++) : "line" === e[v].type ? (r.series.push(t),
                    r.i.push(v),
                    g++) : "scatter" === e[v].type ? (s.series.push(t),
                    s.i.push(v)) : "bubble" === e[v].type ? (l.series.push(t),
                    l.i.push(v),
                    g++) : "candlestick" === e[v].type ? (u.series.push(t),
                    u.i.push(v),
                    g++) : "boxPlot" === e[v].type ? (d.series.push(t),
                    d.i.push(v),
                    g++) : "rangeBar" === e[v].type ? (h.series.push(t),
                    h.i.push(v),
                    g++) : "rangeArea" === e[v].type && (p.series.push(n.seriesRangeStart[v]),
                    p.seriesRangeEnd.push(n.seriesRangeEnd[v]),
                    p.i.push(v),
                    g++),
                    g > 1 && (n.comboCharts = !0)) : (r.series.push(t),
                    r.i.push(v))
                }
                ));
                var v = new Me(this.ctx,t)
                  , g = new Ce(this.ctx,t);
                this.ctx.pie = new Ie(this.ctx);
                var f = new Te(this.ctx);
                this.ctx.rangeBar = new Ee(this.ctx,t);
                var m = new _e(this.ctx)
                  , b = [];
                if (n.comboCharts) {
                    if (o.series.length > 0 && b.push(v.draw(o.series, "area", o.i)),
                    c.series.length > 0)
                        if (a.config.chart.stacked) {
                            var x = new Se(this.ctx,t);
                            b.push(x.draw(c.series, c.i))
                        } else
                            this.ctx.bar = new ke(this.ctx,t),
                            b.push(this.ctx.bar.draw(c.series, c.i));
                    if (p.series.length > 0 && b.push(v.draw(p.series, "rangeArea", p.i, p.seriesRangeEnd)),
                    r.series.length > 0 && b.push(v.draw(r.series, "line", r.i)),
                    u.series.length > 0 && b.push(g.draw(u.series, "candlestick", u.i)),
                    d.series.length > 0 && b.push(g.draw(d.series, "boxPlot", d.i)),
                    h.series.length > 0 && b.push(this.ctx.rangeBar.draw(h.series, h.i)),
                    s.series.length > 0) {
                        var y = new Me(this.ctx,t,!0);
                        b.push(y.draw(s.series, "scatter", s.i))
                    }
                    if (l.series.length > 0) {
                        var w = new Me(this.ctx,t,!0);
                        b.push(w.draw(l.series, "bubble", l.i))
                    }
                } else
                    switch (i.chart.type) {
                    case "line":
                        b = v.draw(n.series, "line");
                        break;
                    case "area":
                        b = v.draw(n.series, "area");
                        break;
                    case "bar":
                        i.chart.stacked ? b = new Se(this.ctx,t).draw(n.series) : (this.ctx.bar = new ke(this.ctx,t),
                        b = this.ctx.bar.draw(n.series));
                        break;
                    case "candlestick":
                        b = new Ce(this.ctx,t).draw(n.series, "candlestick");
                        break;
                    case "boxPlot":
                        b = new Ce(this.ctx,t).draw(n.series, i.chart.type);
                        break;
                    case "rangeBar":
                        b = this.ctx.rangeBar.draw(n.series);
                        break;
                    case "rangeArea":
                        b = v.draw(n.seriesRangeStart, "rangeArea", void 0, n.seriesRangeEnd);
                        break;
                    case "heatmap":
                        b = new Pe(this.ctx,t).draw(n.series);
                        break;
                    case "treemap":
                        b = new Ne(this.ctx,t).draw(n.series);
                        break;
                    case "pie":
                    case "donut":
                    case "polarArea":
                        b = this.ctx.pie.draw(n.series);
                        break;
                    case "radialBar":
                        b = f.draw(n.series);
                        break;
                    case "radar":
                        b = m.draw(n.series);
                        break;
                    default:
                        b = v.draw(n.series)
                    }
                return b
            }
        }, {
            key: "setSVGDimensions",
            value: function() {
                var e = this.w.globals
                  , t = this.w.config;
                e.svgWidth = t.chart.width,
                e.svgHeight = t.chart.height;
                var a = b.getDimensions(this.el)
                  , i = t.chart.width.toString().split(/[0-9]+/g).pop();
                "%" === i ? b.isNumber(a[0]) && (0 === a[0].width && (a = b.getDimensions(this.el.parentNode)),
                e.svgWidth = a[0] * parseInt(t.chart.width, 10) / 100) : "px" !== i && "" !== i || (e.svgWidth = parseInt(t.chart.width, 10));
                var n = t.chart.height.toString().split(/[0-9]+/g).pop();
                if ("auto" !== e.svgHeight && "" !== e.svgHeight)
                    if ("%" === n) {
                        var r = b.getDimensions(this.el.parentNode);
                        e.svgHeight = r[1] * parseInt(t.chart.height, 10) / 100
                    } else
                        e.svgHeight = parseInt(t.chart.height, 10);
                else
                    e.axisCharts ? e.svgHeight = e.svgWidth / 1.61 : e.svgHeight = e.svgWidth / 1.2;
                if (e.svgWidth < 0 && (e.svgWidth = 0),
                e.svgHeight < 0 && (e.svgHeight = 0),
                w.setAttrs(e.dom.Paper.node, {
                    width: e.svgWidth,
                    height: e.svgHeight
                }),
                "%" !== n) {
                    var o = t.chart.sparkline.enabled ? 0 : e.axisCharts ? t.chart.parentHeightOffset : 0;
                    e.dom.Paper.node.parentNode.parentNode.style.minHeight = e.svgHeight + o + "px"
                }
                e.dom.elWrap.style.width = e.svgWidth + "px",
                e.dom.elWrap.style.height = e.svgHeight + "px"
            }
        }, {
            key: "shiftGraphPosition",
            value: function() {
                var e = this.w.globals
                  , t = e.translateY
                  , a = {
                    transform: "translate(" + e.translateX + ", " + t + ")"
                };
                w.setAttrs(e.dom.elGraphical.node, a)
            }
        }, {
            key: "resizeNonAxisCharts",
            value: function() {
                var e = this.w
                  , t = e.globals
                  , a = 0
                  , i = e.config.chart.sparkline.enabled ? 1 : 15;
                i += e.config.grid.padding.bottom,
                "top" !== e.config.legend.position && "bottom" !== e.config.legend.position || !e.config.legend.show || e.config.legend.floating || (a = new ue(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                var n = e.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie")
                  , r = 2.05 * e.globals.radialSize;
                if (n && !e.config.chart.sparkline.enabled && 0 !== e.config.plotOptions.radialBar.startAngle) {
                    var o = b.getBoundingClientRect(n);
                    r = o.bottom;
                    var s = o.bottom - o.top;
                    r = Math.max(2.05 * e.globals.radialSize, s)
                }
                var l = r + t.translateY + a + i;
                t.dom.elLegendForeign && t.dom.elLegendForeign.setAttribute("height", l),
                e.config.chart.height && String(e.config.chart.height).indexOf("%") > 0 || (t.dom.elWrap.style.height = l + "px",
                w.setAttrs(t.dom.Paper.node, {
                    height: l
                }),
                t.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px")
            }
        }, {
            key: "coreCalculations",
            value: function() {
                new q(this.ctx).init()
            }
        }, {
            key: "resetGlobals",
            value: function() {
                var e = this
                  , t = function() {
                    return e.w.config.series.map((function(e) {
                        return []
                    }
                    ))
                }
                  , a = new M
                  , i = this.w.globals;
                a.initGlobalVars(i),
                i.seriesXvalues = t(),
                i.seriesYvalues = t()
            }
        }, {
            key: "isMultipleY",
            value: function() {
                if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1)
                    return this.w.globals.isMultipleYAxis = !0,
                    !0
            }
        }, {
            key: "xySettings",
            value: function() {
                var e = null
                  , t = this.w;
                if (t.globals.axisCharts) {
                    if ("back" === t.config.xaxis.crosshairs.position && new ee(this.ctx).drawXCrosshairs(),
                    "back" === t.config.yaxis[0].crosshairs.position && new ee(this.ctx).drawYCrosshairs(),
                    "datetime" === t.config.xaxis.type && void 0 === t.config.xaxis.labels.formatter) {
                        this.ctx.timeScale = new ze(this.ctx);
                        var a = [];
                        isFinite(t.globals.minX) && isFinite(t.globals.maxX) && !t.globals.isBarHorizontal ? a = this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minX, t.globals.maxX) : t.globals.isBarHorizontal && (a = this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minY, t.globals.maxY)),
                        this.ctx.timeScale.recalcDimensionsBasedOnFormat(a)
                    }
                    e = new k(this.ctx).getCalculatedRatios()
                }
                return e
            }
        }, {
            key: "updateSourceChart",
            value: function(e) {
                this.ctx.w.globals.selection = void 0,
                this.ctx.updateHelpers._updateOptions({
                    chart: {
                        selection: {
                            xaxis: {
                                min: e.w.globals.minX,
                                max: e.w.globals.maxX
                            }
                        }
                    }
                }, !1, !1)
            }
        }, {
            key: "setupBrushHandler",
            value: function() {
                var e = this
                  , t = this.w;
                if (t.config.chart.brush.enabled && "function" != typeof t.config.chart.events.selection) {
                    var a = Array.isArray(t.config.chart.brush.targets) ? t.config.chart.brush.targets : [t.config.chart.brush.target];
                    a.forEach((function(t) {
                        var a = ApexCharts.getChartByID(t);
                        a.w.globals.brushSource = e.ctx,
                        "function" != typeof a.w.config.chart.events.zoomed && (a.w.config.chart.events.zoomed = function() {
                            e.updateSourceChart(a)
                        }
                        ),
                        "function" != typeof a.w.config.chart.events.scrolled && (a.w.config.chart.events.scrolled = function() {
                            e.updateSourceChart(a)
                        }
                        )
                    }
                    )),
                    t.config.chart.events.selection = function(e, n) {
                        a.forEach((function(e) {
                            var a = ApexCharts.getChartByID(e)
                              , r = b.clone(t.config.yaxis);
                            if (t.config.chart.brush.autoScaleYaxis && 1 === a.w.globals.series.length) {
                                var o = new U(a);
                                r = o.autoScaleY(a, r, n)
                            }
                            var s = a.w.config.yaxis.reduce((function(e, t, n) {
                                return [].concat(g(e), [i(i({}, a.w.config.yaxis[n]), {}, {
                                    min: r[0].min,
                                    max: r[0].max
                                })])
                            }
                            ), []);
                            a.ctx.updateHelpers._updateOptions({
                                xaxis: {
                                    min: n.xaxis.min,
                                    max: n.xaxis.max
                                },
                                yaxis: s
                            }, !1, !1, !1, !1)
                        }
                        ))
                    }
                }
            }
        }]),
        e
    }(), Xe = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "_updateOptions",
            value: function(e) {
                var t = this
                  , a = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
                  , o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                return new Promise((function(s) {
                    var l = [t.ctx];
                    r && (l = t.ctx.getSyncedCharts()),
                    t.ctx.w.globals.isExecCalled && (l = [t.ctx],
                    t.ctx.w.globals.isExecCalled = !1),
                    l.forEach((function(r, c) {
                        var u = r.w;
                        if (u.globals.shouldAnimate = i,
                        a || (u.globals.resized = !0,
                        u.globals.dataChanged = !0,
                        i && r.series.getPreviousPaths()),
                        e && "object" === n(e) && (r.config = new B(e),
                        e = k.extendArrayProps(r.config, e, u),
                        r.w.globals.chartID !== t.ctx.w.globals.chartID && delete e.series,
                        u.config = b.extend(u.config, e),
                        o && (u.globals.lastXAxis = e.xaxis ? b.clone(e.xaxis) : [],
                        u.globals.lastYAxis = e.yaxis ? b.clone(e.yaxis) : [],
                        u.globals.initialConfig = b.extend({}, u.config),
                        u.globals.initialSeries = b.clone(u.config.series),
                        e.series))) {
                            for (var d = 0; d < u.globals.collapsedSeriesIndices.length; d++) {
                                var h = u.config.series[u.globals.collapsedSeriesIndices[d]];
                                u.globals.collapsedSeries[d].data = u.globals.axisCharts ? h.data.slice() : h
                            }
                            for (var p = 0; p < u.globals.ancillaryCollapsedSeriesIndices.length; p++) {
                                var v = u.config.series[u.globals.ancillaryCollapsedSeriesIndices[p]];
                                u.globals.ancillaryCollapsedSeries[p].data = u.globals.axisCharts ? v.data.slice() : v
                            }
                            r.series.emptyCollapsedSeries(u.config.series)
                        }
                        return r.update(e).then((function() {
                            c === l.length - 1 && s(r)
                        }
                        ))
                    }
                    ))
                }
                ))
            }
        }, {
            key: "_updateSeries",
            value: function(e, t) {
                var a = this
                  , i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                return new Promise((function(n) {
                    var r, o = a.w;
                    return o.globals.shouldAnimate = t,
                    o.globals.dataChanged = !0,
                    t && a.ctx.series.getPreviousPaths(),
                    o.globals.axisCharts ? (0 === (r = e.map((function(e, t) {
                        return a._extendSeries(e, t)
                    }
                    ))).length && (r = [{
                        data: []
                    }]),
                    o.config.series = r) : o.config.series = e.slice(),
                    i && (o.globals.initialConfig.series = b.clone(o.config.series),
                    o.globals.initialSeries = b.clone(o.config.series)),
                    a.ctx.update().then((function() {
                        n(a.ctx)
                    }
                    ))
                }
                ))
            }
        }, {
            key: "_extendSeries",
            value: function(e, t) {
                var a = this.w
                  , n = a.config.series[t];
                return i(i({}, a.config.series[t]), {}, {
                    name: e.name ? e.name : null == n ? void 0 : n.name,
                    color: e.color ? e.color : null == n ? void 0 : n.color,
                    type: e.type ? e.type : null == n ? void 0 : n.type,
                    group: e.group ? e.group : null == n ? void 0 : n.group,
                    data: e.data ? e.data : null == n ? void 0 : n.data,
                    zIndex: void 0 !== e.zIndex ? e.zIndex : t
                })
            }
        }, {
            key: "toggleDataPointSelection",
            value: function(e, t) {
                var a = this.w
                  , i = null
                  , n = ".apexcharts-series[data\\:realIndex='".concat(e, "']");
                return a.globals.axisCharts ? i = a.globals.dom.Paper.select("".concat(n, " path[j='").concat(t, "'], ").concat(n, " circle[j='").concat(t, "'], ").concat(n, " rect[j='").concat(t, "']")).members[0] : void 0 === t && (i = a.globals.dom.Paper.select("".concat(n, " path[j='").concat(e, "']")).members[0],
                "pie" !== a.config.chart.type && "polarArea" !== a.config.chart.type && "donut" !== a.config.chart.type || this.ctx.pie.pieClicked(e)),
                i ? (new w(this.ctx).pathMouseDown(i, null),
                i.node ? i.node : null) : null
            }
        }, {
            key: "forceXAxisUpdate",
            value: function(e) {
                var t = this.w;
                if (["min", "max"].forEach((function(a) {
                    void 0 !== e.xaxis[a] && (t.config.xaxis[a] = e.xaxis[a],
                    t.globals.lastXAxis[a] = e.xaxis[a])
                }
                )),
                e.xaxis.categories && e.xaxis.categories.length && (t.config.xaxis.categories = e.xaxis.categories),
                t.config.xaxis.convertedCatToNumeric) {
                    var a = new F(e);
                    e = a.convertCatToNumericXaxis(e, this.ctx)
                }
                return e
            }
        }, {
            key: "forceYAxisUpdate",
            value: function(e) {
                return e.chart && e.chart.stacked && "100%" === e.chart.stackType && (Array.isArray(e.yaxis) ? e.yaxis.forEach((function(t, a) {
                    e.yaxis[a].min = 0,
                    e.yaxis[a].max = 100
                }
                )) : (e.yaxis.min = 0,
                e.yaxis.max = 100)),
                e
            }
        }, {
            key: "revertDefaultAxisMinMax",
            value: function(e) {
                var t = this
                  , a = this.w
                  , i = a.globals.lastXAxis
                  , n = a.globals.lastYAxis;
                e && e.xaxis && (i = e.xaxis),
                e && e.yaxis && (n = e.yaxis),
                a.config.xaxis.min = i.min,
                a.config.xaxis.max = i.max;
                a.config.yaxis.map((function(e, i) {
                    a.globals.zoomed || void 0 !== n[i] ? function(e) {
                        void 0 !== n[e] && (a.config.yaxis[e].min = n[e].min,
                        a.config.yaxis[e].max = n[e].max)
                    }(i) : void 0 !== t.ctx.opts.yaxis[i] && (e.min = t.ctx.opts.yaxis[i].min,
                    e.max = t.ctx.opts.yaxis[i].max)
                }
                ))
            }
        }]),
        e
    }();
    De = typeof window < "u" ? window : void 0,
    Re = function(e, t) {
        var a = (void 0 !== this ? this : e).SVG = function(e) {
            if (a.supported)
                return e = new a.Doc(e),
                a.parser.draw || a.prepare(),
                e
        }
        ;
        if (a.ns = "http://www.w3.org/2000/svg",
        a.xmlns = "http://www.w3.org/2000/xmlns/",
        a.xlink = "http://www.w3.org/1999/xlink",
        a.svgjs = "http://svgjs.dev",
        a.supported = !0,
        !a.supported)
            return !1;
        a.did = 1e3,
        a.eid = function(e) {
            return "Svgjs" + d(e) + a.did++
        }
        ,
        a.create = function(e) {
            var a = t.createElementNS(this.ns, e);
            return a.setAttribute("id", this.eid(e)),
            a
        }
        ,
        a.extend = function() {
            var e, t;
            t = (e = [].slice.call(arguments)).pop();
            for (var i = e.length - 1; i >= 0; i--)
                if (e[i])
                    for (var n in t)
                        e[i].prototype[n] = t[n];
            a.Set && a.Set.inherit && a.Set.inherit()
        }
        ,
        a.invent = function(e) {
            var t = "function" == typeof e.create ? e.create : function() {
                this.constructor.call(this, a.create(e.create))
            }
            ;
            return e.inherit && (t.prototype = new e.inherit),
            e.extend && a.extend(t, e.extend),
            e.construct && a.extend(e.parent || a.Container, e.construct),
            t
        }
        ,
        a.adopt = function(t) {
            return t ? t.instance ? t.instance : ((i = "svg" == t.nodeName ? t.parentNode instanceof e.SVGElement ? new a.Nested : new a.Doc : "linearGradient" == t.nodeName ? new a.Gradient("linear") : "radialGradient" == t.nodeName ? new a.Gradient("radial") : a[d(t.nodeName)] ? new (a[d(t.nodeName)]) : new a.Element(t)).type = t.nodeName,
            i.node = t,
            t.instance = i,
            i instanceof a.Doc && i.namespace().defs(),
            i.setData(JSON.parse(t.getAttribute("svgjs:data")) || {}),
            i) : null;
            var i
        }
        ,
        a.prepare = function() {
            var e = t.getElementsByTagName("body")[0]
              , i = (e ? new a.Doc(e) : a.adopt(t.documentElement).nested()).size(2, 0);
            a.parser = {
                body: e || t.documentElement,
                draw: i.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                poly: i.polyline().node,
                path: i.path().node,
                native: a.create("svg")
            }
        }
        ,
        a.parser = {
            native: a.create("svg")
        },
        t.addEventListener("DOMContentLoaded", (function() {
            a.parser.draw || a.prepare()
        }
        ), !1),
        a.regex = {
            numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
            hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
            rgb: /rgb\((\d+),(\d+),(\d+)\)/,
            reference: /#([a-z0-9\-_]+)/i,
            transforms: /\)\s*,?\s*/,
            whitespace: /\s/g,
            isHex: /^#[a-f0-9]{3,6}$/i,
            isRgb: /^rgb\(/,
            isCss: /[^:]+:[^;]+;?/,
            isBlank: /^(\s+)?$/,
            isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
            isPercent: /^-?[\d\.]+%$/,
            isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
            delimiter: /[\s,]+/,
            hyphen: /([^e])\-/gi,
            pathLetters: /[MLHVCSQTAZ]/gi,
            isPathLetter: /[MLHVCSQTAZ]/i,
            numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
            dots: /\./g
        },
        a.utils = {
            map: function(e, t) {
                for (var a = e.length, i = [], n = 0; n < a; n++)
                    i.push(t(e[n]));
                return i
            },
            filter: function(e, t) {
                for (var a = e.length, i = [], n = 0; n < a; n++)
                    t(e[n]) && i.push(e[n]);
                return i
            },
            filterSVGElements: function(t) {
                return this.filter(t, (function(t) {
                    return t instanceof e.SVGElement
                }
                ))
            }
        },
        a.defaults = {
            attrs: {
                "fill-opacity": 1,
                "stroke-opacity": 1,
                "stroke-width": 0,
                "stroke-linejoin": "miter",
                "stroke-linecap": "butt",
                fill: "#000000",
                stroke: "#000000",
                opacity: 1,
                x: 0,
                y: 0,
                cx: 0,
                cy: 0,
                width: 0,
                height: 0,
                r: 0,
                rx: 0,
                ry: 0,
                offset: 0,
                "stop-opacity": 1,
                "stop-color": "#000000",
                "font-size": 16,
                "font-family": "Helvetica, Arial, sans-serif",
                "text-anchor": "start"
            }
        },
        a.Color = function(e) {
            var t, i;
            this.r = 0,
            this.g = 0,
            this.b = 0,
            e && ("string" == typeof e ? a.regex.isRgb.test(e) ? (t = a.regex.rgb.exec(e.replace(a.regex.whitespace, "")),
            this.r = parseInt(t[1]),
            this.g = parseInt(t[2]),
            this.b = parseInt(t[3])) : a.regex.isHex.test(e) && (t = a.regex.hex.exec(4 == (i = e).length ? ["#", i.substring(1, 2), i.substring(1, 2), i.substring(2, 3), i.substring(2, 3), i.substring(3, 4), i.substring(3, 4)].join("") : i),
            this.r = parseInt(t[1], 16),
            this.g = parseInt(t[2], 16),
            this.b = parseInt(t[3], 16)) : "object" === n(e) && (this.r = e.r,
            this.g = e.g,
            this.b = e.b))
        }
        ,
        a.extend(a.Color, {
            toString: function() {
                return this.toHex()
            },
            toHex: function() {
                return "#" + h(this.r) + h(this.g) + h(this.b)
            },
            toRgb: function() {
                return "rgb(" + [this.r, this.g, this.b].join() + ")"
            },
            brightness: function() {
                return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
            },
            morph: function(e) {
                return this.destination = new a.Color(e),
                this
            },
            at: function(e) {
                return this.destination ? (e = e < 0 ? 0 : e > 1 ? 1 : e,
                new a.Color({
                    r: ~~(this.r + (this.destination.r - this.r) * e),
                    g: ~~(this.g + (this.destination.g - this.g) * e),
                    b: ~~(this.b + (this.destination.b - this.b) * e)
                })) : this
            }
        }),
        a.Color.test = function(e) {
            return e += "",
            a.regex.isHex.test(e) || a.regex.isRgb.test(e)
        }
        ,
        a.Color.isRgb = function(e) {
            return e && "number" == typeof e.r && "number" == typeof e.g && "number" == typeof e.b
        }
        ,
        a.Color.isColor = function(e) {
            return a.Color.isRgb(e) || a.Color.test(e)
        }
        ,
        a.Array = function(e, t) {
            0 == (e = (e || []).valueOf()).length && t && (e = t.valueOf()),
            this.value = this.parse(e)
        }
        ,
        a.extend(a.Array, {
            toString: function() {
                return this.value.join(" ")
            },
            valueOf: function() {
                return this.value
            },
            parse: function(e) {
                return e = e.valueOf(),
                Array.isArray(e) ? e : this.split(e)
            }
        }),
        a.PointArray = function(e, t) {
            a.Array.call(this, e, t || [[0, 0]])
        }
        ,
        a.PointArray.prototype = new a.Array,
        a.PointArray.prototype.constructor = a.PointArray;
        for (var i = {
            M: function(e, t, a) {
                return t.x = a.x = e[0],
                t.y = a.y = e[1],
                ["M", t.x, t.y]
            },
            L: function(e, t) {
                return t.x = e[0],
                t.y = e[1],
                ["L", e[0], e[1]]
            },
            H: function(e, t) {
                return t.x = e[0],
                ["H", e[0]]
            },
            V: function(e, t) {
                return t.y = e[0],
                ["V", e[0]]
            },
            C: function(e, t) {
                return t.x = e[4],
                t.y = e[5],
                ["C", e[0], e[1], e[2], e[3], e[4], e[5]]
            },
            Q: function(e, t) {
                return t.x = e[2],
                t.y = e[3],
                ["Q", e[0], e[1], e[2], e[3]]
            },
            S: function(e, t) {
                return t.x = e[2],
                t.y = e[3],
                ["S", e[0], e[1], e[2], e[3]]
            },
            Z: function(e, t, a) {
                return t.x = a.x,
                t.y = a.y,
                ["Z"]
            }
        }, r = "mlhvqtcsaz".split(""), o = 0, s = r.length; o < s; ++o)
            i[r[o]] = function(e) {
                return function(t, a, n) {
                    if ("H" == e)
                        t[0] = t[0] + a.x;
                    else if ("V" == e)
                        t[0] = t[0] + a.y;
                    else if ("A" == e)
                        t[5] = t[5] + a.x,
                        t[6] = t[6] + a.y;
                    else
                        for (var r = 0, o = t.length; r < o; ++r)
                            t[r] = t[r] + (r % 2 ? a.y : a.x);
                    if (i && "function" == typeof i[e])
                        return i[e](t, a, n)
                }
            }(r[o].toUpperCase());
        a.PathArray = function(e, t) {
            a.Array.call(this, e, t || [["M", 0, 0]])
        }
        ,
        a.PathArray.prototype = new a.Array,
        a.PathArray.prototype.constructor = a.PathArray,
        a.extend(a.PathArray, {
            toString: function() {
                return function(e) {
                    for (var t = 0, a = e.length, i = ""; t < a; t++)
                        i += e[t][0],
                        null != e[t][1] && (i += e[t][1],
                        null != e[t][2] && (i += " ",
                        i += e[t][2],
                        null != e[t][3] && (i += " ",
                        i += e[t][3],
                        i += " ",
                        i += e[t][4],
                        null != e[t][5] && (i += " ",
                        i += e[t][5],
                        i += " ",
                        i += e[t][6],
                        null != e[t][7] && (i += " ",
                        i += e[t][7])))));
                    return i + " "
                }(this.value)
            },
            move: function(e, t) {
                var a = this.bbox();
                return a.x,
                a.y,
                this
            },
            at: function(e) {
                if (!this.destination)
                    return this;
                for (var t = this.value, i = this.destination.value, n = [], r = new a.PathArray, o = 0, s = t.length; o < s; o++) {
                    n[o] = [t[o][0]];
                    for (var l = 1, c = t[o].length; l < c; l++)
                        n[o][l] = t[o][l] + (i[o][l] - t[o][l]) * e;
                    "A" === n[o][0] && (n[o][4] = +(0 != n[o][4]),
                    n[o][5] = +(0 != n[o][5]))
                }
                return r.value = n,
                r
            },
            parse: function(e) {
                if (e instanceof a.PathArray)
                    return e.valueOf();
                var t, n = {
                    M: 2,
                    L: 2,
                    H: 1,
                    V: 1,
                    C: 6,
                    S: 4,
                    Q: 4,
                    T: 2,
                    A: 7,
                    Z: 0
                };
                e = "string" == typeof e ? e.replace(a.regex.numbersWithDots, c).replace(a.regex.pathLetters, " $& ").replace(a.regex.hyphen, "$1 -").trim().split(a.regex.delimiter) : e.reduce((function(e, t) {
                    return [].concat.call(e, t)
                }
                ), []);
                var r = []
                  , o = new a.Point
                  , s = new a.Point
                  , l = 0
                  , u = e.length;
                do {
                    a.regex.isPathLetter.test(e[l]) ? (t = e[l],
                    ++l) : "M" == t ? t = "L" : "m" == t && (t = "l"),
                    r.push(i[t].call(null, e.slice(l, l += n[t.toUpperCase()]).map(parseFloat), o, s))
                } while (u > l);
                return r
            },
            bbox: function() {
                return a.parser.draw || a.prepare(),
                a.parser.path.setAttribute("d", this.toString()),
                a.parser.path.getBBox()
            }
        }),
        a.Number = a.invent({
            create: function(e, t) {
                this.value = 0,
                this.unit = t || "",
                "number" == typeof e ? this.value = isNaN(e) ? 0 : isFinite(e) ? e : e < 0 ? -34e37 : 34e37 : "string" == typeof e ? (t = e.match(a.regex.numberAndUnit)) && (this.value = parseFloat(t[1]),
                "%" == t[5] ? this.value /= 100 : "s" == t[5] && (this.value *= 1e3),
                this.unit = t[5]) : e instanceof a.Number && (this.value = e.valueOf(),
                this.unit = e.unit)
            },
            extend: {
                toString: function() {
                    return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                },
                toJSON: function() {
                    return this.toString()
                },
                valueOf: function() {
                    return this.value
                },
                plus: function(e) {
                    return e = new a.Number(e),
                    new a.Number(this + e,this.unit || e.unit)
                },
                minus: function(e) {
                    return e = new a.Number(e),
                    new a.Number(this - e,this.unit || e.unit)
                },
                times: function(e) {
                    return e = new a.Number(e),
                    new a.Number(this * e,this.unit || e.unit)
                },
                divide: function(e) {
                    return e = new a.Number(e),
                    new a.Number(this / e,this.unit || e.unit)
                },
                to: function(e) {
                    var t = new a.Number(this);
                    return "string" == typeof e && (t.unit = e),
                    t
                },
                morph: function(e) {
                    return this.destination = new a.Number(e),
                    e.relative && (this.destination.value += this.value),
                    this
                },
                at: function(e) {
                    return this.destination ? new a.Number(this.destination).minus(this).times(e).plus(this) : this
                }
            }
        }),
        a.Element = a.invent({
            create: function(e) {
                this._stroke = a.defaults.attrs.stroke,
                this._event = null,
                this.dom = {},
                (this.node = e) && (this.type = e.nodeName,
                this.node.instance = this,
                this._stroke = e.getAttribute("stroke") || this._stroke)
            },
            extend: {
                x: function(e) {
                    return this.attr("x", e)
                },
                y: function(e) {
                    return this.attr("y", e)
                },
                cx: function(e) {
                    return null == e ? this.x() + this.width() / 2 : this.x(e - this.width() / 2)
                },
                cy: function(e) {
                    return null == e ? this.y() + this.height() / 2 : this.y(e - this.height() / 2)
                },
                move: function(e, t) {
                    return this.x(e).y(t)
                },
                center: function(e, t) {
                    return this.cx(e).cy(t)
                },
                width: function(e) {
                    return this.attr("width", e)
                },
                height: function(e) {
                    return this.attr("height", e)
                },
                size: function(e, t) {
                    var i = p(this, e, t);
                    return this.width(new a.Number(i.width)).height(new a.Number(i.height))
                },
                clone: function(e) {
                    this.writeDataToDom();
                    var t = f(this.node.cloneNode(!0));
                    return e ? e.add(t) : this.after(t),
                    t
                },
                remove: function() {
                    return this.parent() && this.parent().removeElement(this),
                    this
                },
                replace: function(e) {
                    return this.after(e).remove(),
                    e
                },
                addTo: function(e) {
                    return e.put(this)
                },
                putIn: function(e) {
                    return e.add(this)
                },
                id: function(e) {
                    return this.attr("id", e)
                },
                show: function() {
                    return this.style("display", "")
                },
                hide: function() {
                    return this.style("display", "none")
                },
                visible: function() {
                    return "none" != this.style("display")
                },
                toString: function() {
                    return this.attr("id")
                },
                classes: function() {
                    var e = this.attr("class");
                    return null == e ? [] : e.trim().split(a.regex.delimiter)
                },
                hasClass: function(e) {
                    return -1 != this.classes().indexOf(e)
                },
                addClass: function(e) {
                    if (!this.hasClass(e)) {
                        var t = this.classes();
                        t.push(e),
                        this.attr("class", t.join(" "))
                    }
                    return this
                },
                removeClass: function(e) {
                    return this.hasClass(e) && this.attr("class", this.classes().filter((function(t) {
                        return t != e
                    }
                    )).join(" ")),
                    this
                },
                toggleClass: function(e) {
                    return this.hasClass(e) ? this.removeClass(e) : this.addClass(e)
                },
                reference: function(e) {
                    return a.get(this.attr(e))
                },
                parent: function(t) {
                    var i = this;
                    if (!i.node.parentNode)
                        return null;
                    if (i = a.adopt(i.node.parentNode),
                    !t)
                        return i;
                    for (; i && i.node instanceof e.SVGElement; ) {
                        if ("string" == typeof t ? i.matches(t) : i instanceof t)
                            return i;
                        if (!i.node.parentNode || "#document" == i.node.parentNode.nodeName)
                            return null;
                        i = a.adopt(i.node.parentNode)
                    }
                },
                doc: function() {
                    return this instanceof a.Doc ? this : this.parent(a.Doc)
                },
                parents: function(e) {
                    var t = []
                      , a = this;
                    do {
                        if (!(a = a.parent(e)) || !a.node)
                            break;
                        t.push(a)
                    } while (a.parent);
                    return t
                },
                matches: function(e) {
                    return t = this.node,
                    a = e,
                    (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, a);
                    var t, a
                },
                native: function() {
                    return this.node
                },
                svg: function(e) {
                    var i = t.createElement("svg");
                    if (!(e && this instanceof a.Parent))
                        return i.appendChild(e = t.createElement("svg")),
                        this.writeDataToDom(),
                        e.appendChild(this.node.cloneNode(!0)),
                        i.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                    i.innerHTML = "<svg>" + e.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                    for (var n = 0, r = i.firstChild.childNodes.length; n < r; n++)
                        this.node.appendChild(i.firstChild.firstChild);
                    return this
                },
                writeDataToDom: function() {
                    return (this.each || this.lines) && (this.each ? this : this.lines()).each((function() {
                        this.writeDataToDom()
                    }
                    )),
                    this.node.removeAttribute("svgjs:data"),
                    Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)),
                    this
                },
                setData: function(e) {
                    return this.dom = e,
                    this
                },
                is: function(e) {
                    return this instanceof e
                }
            }
        }),
        a.easing = {
            "-": function(e) {
                return e
            },
            "<>": function(e) {
                return -Math.cos(e * Math.PI) / 2 + .5
            },
            ">": function(e) {
                return Math.sin(e * Math.PI / 2)
            },
            "<": function(e) {
                return 1 - Math.cos(e * Math.PI / 2)
            }
        },
        a.morph = function(e) {
            return function(t, i) {
                return new a.MorphObj(t,i).at(e)
            }
        }
        ,
        a.Situation = a.invent({
            create: function(e) {
                this.init = !1,
                this.reversed = !1,
                this.reversing = !1,
                this.duration = new a.Number(e.duration).valueOf(),
                this.delay = new a.Number(e.delay).valueOf(),
                this.start = +new Date + this.delay,
                this.finish = this.start + this.duration,
                this.ease = e.ease,
                this.loop = 0,
                this.loops = !1,
                this.animations = {},
                this.attrs = {},
                this.styles = {},
                this.transforms = [],
                this.once = {}
            }
        }),
        a.FX = a.invent({
            create: function(e) {
                this._target = e,
                this.situations = [],
                this.active = !1,
                this.situation = null,
                this.paused = !1,
                this.lastPos = 0,
                this.pos = 0,
                this.absPos = 0,
                this._speed = 1
            },
            extend: {
                animate: function(e, t, i) {
                    "object" === n(e) && (t = e.ease,
                    i = e.delay,
                    e = e.duration);
                    var r = new a.Situation({
                        duration: e || 1e3,
                        delay: i || 0,
                        ease: a.easing[t || "-"] || t
                    });
                    return this.queue(r),
                    this
                },
                target: function(e) {
                    return e && e instanceof a.Element ? (this._target = e,
                    this) : this._target
                },
                timeToAbsPos: function(e) {
                    return (e - this.situation.start) / (this.situation.duration / this._speed)
                },
                absPosToTime: function(e) {
                    return this.situation.duration / this._speed * e + this.situation.start
                },
                startAnimFrame: function() {
                    this.stopAnimFrame(),
                    this.animationFrame = e.requestAnimationFrame(function() {
                        this.step()
                    }
                    .bind(this))
                },
                stopAnimFrame: function() {
                    e.cancelAnimationFrame(this.animationFrame)
                },
                start: function() {
                    return !this.active && this.situation && (this.active = !0,
                    this.startCurrent()),
                    this
                },
                startCurrent: function() {
                    return this.situation.start = +new Date + this.situation.delay / this._speed,
                    this.situation.finish = this.situation.start + this.situation.duration / this._speed,
                    this.initAnimations().step()
                },
                queue: function(e) {
                    return ("function" == typeof e || e instanceof a.Situation) && this.situations.push(e),
                    this.situation || (this.situation = this.situations.shift()),
                    this
                },
                dequeue: function() {
                    return this.stop(),
                    this.situation = this.situations.shift(),
                    this.situation && (this.situation instanceof a.Situation ? this.start() : this.situation.call(this)),
                    this
                },
                initAnimations: function() {
                    var e, t = this.situation;
                    if (t.init)
                        return this;
                    for (var i in t.animations) {
                        e = this.target()[i](),
                        Array.isArray(e) || (e = [e]),
                        Array.isArray(t.animations[i]) || (t.animations[i] = [t.animations[i]]);
                        for (var n = e.length; n--; )
                            t.animations[i][n]instanceof a.Number && (e[n] = new a.Number(e[n])),
                            t.animations[i][n] = e[n].morph(t.animations[i][n])
                    }
                    for (var i in t.attrs)
                        t.attrs[i] = new a.MorphObj(this.target().attr(i),t.attrs[i]);
                    for (var i in t.styles)
                        t.styles[i] = new a.MorphObj(this.target().style(i),t.styles[i]);
                    return t.initialTransformation = this.target().matrixify(),
                    t.init = !0,
                    this
                },
                clearQueue: function() {
                    return this.situations = [],
                    this
                },
                clearCurrent: function() {
                    return this.situation = null,
                    this
                },
                stop: function(e, t) {
                    var a = this.active;
                    return this.active = !1,
                    t && this.clearQueue(),
                    e && this.situation && (!a && this.startCurrent(),
                    this.atEnd()),
                    this.stopAnimFrame(),
                    this.clearCurrent()
                },
                after: function(e) {
                    var t = this.last();
                    return this.target().on("finished.fx", (function a(i) {
                        i.detail.situation == t && (e.call(this, t),
                        this.off("finished.fx", a))
                    }
                    )),
                    this._callStart()
                },
                during: function(e) {
                    var t = this.last()
                      , i = function(i) {
                        i.detail.situation == t && e.call(this, i.detail.pos, a.morph(i.detail.pos), i.detail.eased, t)
                    };
                    return this.target().off("during.fx", i).on("during.fx", i),
                    this.after((function() {
                        this.off("during.fx", i)
                    }
                    )),
                    this._callStart()
                },
                afterAll: function(e) {
                    var t = function t(a) {
                        e.call(this),
                        this.off("allfinished.fx", t)
                    };
                    return this.target().off("allfinished.fx", t).on("allfinished.fx", t),
                    this._callStart()
                },
                last: function() {
                    return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                },
                add: function(e, t, a) {
                    return this.last()[a || "animations"][e] = t,
                    this._callStart()
                },
                step: function(e) {
                    var t, a, i;
                    e || (this.absPos = this.timeToAbsPos(+new Date)),
                    !1 !== this.situation.loops ? (t = Math.max(this.absPos, 0),
                    a = Math.floor(t),
                    !0 === this.situation.loops || a < this.situation.loops ? (this.pos = t - a,
                    i = this.situation.loop,
                    this.situation.loop = a) : (this.absPos = this.situation.loops,
                    this.pos = 1,
                    i = this.situation.loop - 1,
                    this.situation.loop = this.situation.loops),
                    this.situation.reversing && (this.situation.reversed = this.situation.reversed != !!((this.situation.loop - i) % 2))) : (this.absPos = Math.min(this.absPos, 1),
                    this.pos = this.absPos),
                    this.pos < 0 && (this.pos = 0),
                    this.situation.reversed && (this.pos = 1 - this.pos);
                    var n = this.situation.ease(this.pos);
                    for (var r in this.situation.once)
                        r > this.lastPos && r <= n && (this.situation.once[r].call(this.target(), this.pos, n),
                        delete this.situation.once[r]);
                    return this.active && this.target().fire("during", {
                        pos: this.pos,
                        eased: n,
                        fx: this,
                        situation: this.situation
                    }),
                    this.situation ? (this.eachAt(),
                    1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(),
                    this.target().fire("finished", {
                        fx: this,
                        situation: this.situation
                    }),
                    this.situations.length || (this.target().fire("allfinished"),
                    this.situations.length || (this.target().off(".fx"),
                    this.active = !1)),
                    this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(),
                    this.lastPos = n,
                    this) : this
                },
                eachAt: function() {
                    var e, t = this, i = this.target(), n = this.situation;
                    for (var r in n.animations)
                        e = [].concat(n.animations[r]).map((function(e) {
                            return "string" != typeof e && e.at ? e.at(n.ease(t.pos), t.pos) : e
                        }
                        )),
                        i[r].apply(i, e);
                    for (var r in n.attrs)
                        e = [r].concat(n.attrs[r]).map((function(e) {
                            return "string" != typeof e && e.at ? e.at(n.ease(t.pos), t.pos) : e
                        }
                        )),
                        i.attr.apply(i, e);
                    for (var r in n.styles)
                        e = [r].concat(n.styles[r]).map((function(e) {
                            return "string" != typeof e && e.at ? e.at(n.ease(t.pos), t.pos) : e
                        }
                        )),
                        i.style.apply(i, e);
                    if (n.transforms.length) {
                        e = n.initialTransformation,
                        r = 0;
                        for (var o = n.transforms.length; r < o; r++) {
                            var s = n.transforms[r];
                            s instanceof a.Matrix ? e = s.relative ? e.multiply((new a.Matrix).morph(s).at(n.ease(this.pos))) : e.morph(s).at(n.ease(this.pos)) : (s.relative || s.undo(e.extract()),
                            e = e.multiply(s.at(n.ease(this.pos))))
                        }
                        i.matrix(e)
                    }
                    return this
                },
                once: function(e, t, a) {
                    var i = this.last();
                    return a || (e = i.ease(e)),
                    i.once[e] = t,
                    this
                },
                _callStart: function() {
                    return setTimeout(function() {
                        this.start()
                    }
                    .bind(this), 0),
                    this
                }
            },
            parent: a.Element,
            construct: {
                animate: function(e, t, i) {
                    return (this.fx || (this.fx = new a.FX(this))).animate(e, t, i)
                },
                delay: function(e) {
                    return (this.fx || (this.fx = new a.FX(this))).delay(e)
                },
                stop: function(e, t) {
                    return this.fx && this.fx.stop(e, t),
                    this
                },
                finish: function() {
                    return this.fx && this.fx.finish(),
                    this
                }
            }
        }),
        a.MorphObj = a.invent({
            create: function(e, t) {
                return a.Color.isColor(t) ? new a.Color(e).morph(t) : a.regex.delimiter.test(e) ? a.regex.pathLetters.test(e) ? new a.PathArray(e).morph(t) : new a.Array(e).morph(t) : a.regex.numberAndUnit.test(t) ? new a.Number(e).morph(t) : (this.value = e,
                void (this.destination = t))
            },
            extend: {
                at: function(e, t) {
                    return t < 1 ? this.value : this.destination
                },
                valueOf: function() {
                    return this.value
                }
            }
        }),
        a.extend(a.FX, {
            attr: function(e, t, a) {
                if ("object" === n(e))
                    for (var i in e)
                        this.attr(i, e[i]);
                else
                    this.add(e, t, "attrs");
                return this
            },
            plot: function(e, t, a, i) {
                return 4 == arguments.length ? this.plot([e, t, a, i]) : this.add("plot", new (this.target().morphArray)(e))
            }
        }),
        a.Box = a.invent({
            create: function(e, t, i, r) {
                if (!("object" !== n(e) || e instanceof a.Element))
                    return a.Box.call(this, null != e.left ? e.left : e.x, null != e.top ? e.top : e.y, e.width, e.height);
                var o;
                4 == arguments.length && (this.x = e,
                this.y = t,
                this.width = i,
                this.height = r),
                null == (o = this).x && (o.x = 0,
                o.y = 0,
                o.width = 0,
                o.height = 0),
                o.w = o.width,
                o.h = o.height,
                o.x2 = o.x + o.width,
                o.y2 = o.y + o.height,
                o.cx = o.x + o.width / 2,
                o.cy = o.y + o.height / 2
            }
        }),
        a.BBox = a.invent({
            create: function(e) {
                if (a.Box.apply(this, [].slice.call(arguments)),
                e instanceof a.Element) {
                    var i;
                    try {
                        if (!t.documentElement.contains) {
                            for (var n = e.node; n.parentNode; )
                                n = n.parentNode;
                            if (n != t)
                                throw new Error("Element not in the dom")
                        }
                        i = e.node.getBBox()
                    } catch {
                        if (e instanceof a.Shape) {
                            a.parser.draw || a.prepare();
                            var r = e.clone(a.parser.draw.instance).show();
                            r && r.node && "function" == typeof r.node.getBBox && (i = r.node.getBBox()),
                            r && "function" == typeof r.remove && r.remove()
                        } else
                            i = {
                                x: e.node.clientLeft,
                                y: e.node.clientTop,
                                width: e.node.clientWidth,
                                height: e.node.clientHeight
                            }
                    }
                    a.Box.call(this, i)
                }
            },
            inherit: a.Box,
            parent: a.Element,
            construct: {
                bbox: function() {
                    return new a.BBox(this)
                }
            }
        }),
        a.BBox.prototype.constructor = a.BBox,
        a.Matrix = a.invent({
            create: function(e) {
                var t = g([1, 0, 0, 1, 0, 0]);
                e = null === e ? t : e instanceof a.Element ? e.matrixify() : "string" == typeof e ? g(e.split(a.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? g([].slice.call(arguments)) : Array.isArray(e) ? g(e) : e && "object" === n(e) ? e : t;
                for (var i = b.length - 1; i >= 0; --i)
                    this[b[i]] = null != e[b[i]] ? e[b[i]] : t[b[i]]
            },
            extend: {
                extract: function() {
                    var e = v(this, 0, 1);
                    v(this, 1, 0);
                    var t = 180 / Math.PI * Math.atan2(e.y, e.x) - 90;
                    return {
                        x: this.e,
                        y: this.f,
                        transformedX: (this.e * Math.cos(t * Math.PI / 180) + this.f * Math.sin(t * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                        transformedY: (this.f * Math.cos(t * Math.PI / 180) + this.e * Math.sin(-t * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                        rotation: t,
                        a: this.a,
                        b: this.b,
                        c: this.c,
                        d: this.d,
                        e: this.e,
                        f: this.f,
                        matrix: new a.Matrix(this)
                    }
                },
                clone: function() {
                    return new a.Matrix(this)
                },
                morph: function(e) {
                    return this.destination = new a.Matrix(e),
                    this
                },
                multiply: function(e) {
                    return new a.Matrix(this.native().multiply((t = e,
                    t instanceof a.Matrix || (t = new a.Matrix(t)),
                    t).native()));
                    var t
                },
                inverse: function() {
                    return new a.Matrix(this.native().inverse())
                },
                translate: function(e, t) {
                    return new a.Matrix(this.native().translate(e || 0, t || 0))
                },
                native: function() {
                    for (var e = a.parser.native.createSVGMatrix(), t = b.length - 1; t >= 0; t--)
                        e[b[t]] = this[b[t]];
                    return e
                },
                toString: function() {
                    return "matrix(" + m(this.a) + "," + m(this.b) + "," + m(this.c) + "," + m(this.d) + "," + m(this.e) + "," + m(this.f) + ")"
                }
            },
            parent: a.Element,
            construct: {
                ctm: function() {
                    return new a.Matrix(this.node.getCTM())
                },
                screenCTM: function() {
                    if (this instanceof a.Nested) {
                        var e = this.rect(1, 1)
                          , t = e.node.getScreenCTM();
                        return e.remove(),
                        new a.Matrix(t)
                    }
                    return new a.Matrix(this.node.getScreenCTM())
                }
            }
        }),
        a.Point = a.invent({
            create: function(e, t) {
                var a;
                a = Array.isArray(e) ? {
                    x: e[0],
                    y: e[1]
                } : "object" === n(e) ? {
                    x: e.x,
                    y: e.y
                } : null != e ? {
                    x: e,
                    y: t ?? e
                } : {
                    x: 0,
                    y: 0
                },
                this.x = a.x,
                this.y = a.y
            },
            extend: {
                clone: function() {
                    return new a.Point(this)
                },
                morph: function(e, t) {
                    return this.destination = new a.Point(e,t),
                    this
                }
            }
        }),
        a.extend(a.Element, {
            point: function(e, t) {
                return new a.Point(e,t).transform(this.screenCTM().inverse())
            }
        }),
        a.extend(a.Element, {
            attr: function(e, t, i) {
                if (null == e) {
                    for (e = {},
                    i = (t = this.node.attributes).length - 1; i >= 0; i--)
                        e[t[i].nodeName] = a.regex.isNumber.test(t[i].nodeValue) ? parseFloat(t[i].nodeValue) : t[i].nodeValue;
                    return e
                }
                if ("object" === n(e))
                    for (var r in e)
                        this.attr(r, e[r]);
                else if (null === t)
                    this.node.removeAttribute(e);
                else {
                    if (null == t)
                        return null == (t = this.node.getAttribute(e)) ? a.defaults.attrs[e] : a.regex.isNumber.test(t) ? parseFloat(t) : t;
                    "stroke-width" == e ? this.attr("stroke", parseFloat(t) > 0 ? this._stroke : null) : "stroke" == e && (this._stroke = t),
                    "fill" != e && "stroke" != e || (a.regex.isImage.test(t) && (t = this.doc().defs().image(t, 0, 0)),
                    t instanceof a.Image && (t = this.doc().defs().pattern(0, 0, (function() {
                        this.add(t)
                    }
                    )))),
                    "number" == typeof t ? t = new a.Number(t) : a.Color.isColor(t) ? t = new a.Color(t) : Array.isArray(t) && (t = new a.Array(t)),
                    "leading" == e ? this.leading && this.leading(t) : "string" == typeof i ? this.node.setAttributeNS(i, e, t.toString()) : this.node.setAttribute(e, t.toString()),
                    !this.rebuild || "font-size" != e && "x" != e || this.rebuild(e, t)
                }
                return this
            }
        }),
        a.extend(a.Element, {
            transform: function(e, t) {
                var i;
                return "object" !== n(e) ? (i = new a.Matrix(this).extract(),
                "string" == typeof e ? i[e] : i) : (i = new a.Matrix(this),
                t = !!t || !!e.relative,
                null != e.a && (i = t ? i.multiply(new a.Matrix(e)) : new a.Matrix(e)),
                this.attr("transform", i))
            }
        }),
        a.extend(a.Element, {
            untransform: function() {
                return this.attr("transform", null)
            },
            matrixify: function() {
                return (this.attr("transform") || "").split(a.regex.transforms).slice(0, -1).map((function(e) {
                    var t = e.trim().split("(");
                    return [t[0], t[1].split(a.regex.delimiter).map((function(e) {
                        return parseFloat(e)
                    }
                    ))]
                }
                )).reduce((function(e, t) {
                    return "matrix" == t[0] ? e.multiply(g(t[1])) : e[t[0]].apply(e, t[1])
                }
                ), new a.Matrix)
            },
            toParent: function(e) {
                if (this == e)
                    return this;
                var t = this.screenCTM()
                  , a = e.screenCTM().inverse();
                return this.addTo(e).untransform().transform(a.multiply(t)),
                this
            },
            toDoc: function() {
                return this.toParent(this.doc())
            }
        }),
        a.Transformation = a.invent({
            create: function(e, t) {
                if (arguments.length > 1 && "boolean" != typeof t)
                    return this.constructor.call(this, [].slice.call(arguments));
                if (Array.isArray(e))
                    for (var a = 0, i = this.arguments.length; a < i; ++a)
                        this[this.arguments[a]] = e[a];
                else if (e && "object" === n(e))
                    for (a = 0,
                    i = this.arguments.length; a < i; ++a)
                        this[this.arguments[a]] = e[this.arguments[a]];
                this.inversed = !1,
                !0 === t && (this.inversed = !0)
            }
        }),
        a.Translate = a.invent({
            parent: a.Matrix,
            inherit: a.Transformation,
            create: function(e, t) {
                this.constructor.apply(this, [].slice.call(arguments))
            },
            extend: {
                arguments: ["transformedX", "transformedY"],
                method: "translate"
            }
        }),
        a.extend(a.Element, {
            style: function(e, t) {
                if (0 == arguments.length)
                    return this.node.style.cssText || "";
                if (arguments.length < 2)
                    if ("object" === n(e))
                        for (var i in e)
                            this.style(i, e[i]);
                    else {
                        if (!a.regex.isCss.test(e))
                            return this.node.style[u(e)];
                        for (e = e.split(/\s*;\s*/).filter((function(e) {
                            return !!e
                        }
                        )).map((function(e) {
                            return e.split(/\s*:\s*/)
                        }
                        )); t = e.pop(); )
                            this.style(t[0], t[1])
                    }
                else
                    this.node.style[u(e)] = null === t || a.regex.isBlank.test(t) ? "" : t;
                return this
            }
        }),
        a.Parent = a.invent({
            create: function(e) {
                this.constructor.call(this, e)
            },
            inherit: a.Element,
            extend: {
                children: function() {
                    return a.utils.map(a.utils.filterSVGElements(this.node.childNodes), (function(e) {
                        return a.adopt(e)
                    }
                    ))
                },
                add: function(e, t) {
                    return null == t ? this.node.appendChild(e.node) : e.node != this.node.childNodes[t] && this.node.insertBefore(e.node, this.node.childNodes[t]),
                    this
                },
                put: function(e, t) {
                    return this.add(e, t),
                    e
                },
                has: function(e) {
                    return this.index(e) >= 0
                },
                index: function(e) {
                    return [].slice.call(this.node.childNodes).indexOf(e.node)
                },
                get: function(e) {
                    return a.adopt(this.node.childNodes[e])
                },
                first: function() {
                    return this.get(0)
                },
                last: function() {
                    return this.get(this.node.childNodes.length - 1)
                },
                each: function(e, t) {
                    for (var i = this.children(), n = 0, r = i.length; n < r; n++)
                        i[n]instanceof a.Element && e.apply(i[n], [n, i]),
                        t && i[n]instanceof a.Container && i[n].each(e, t);
                    return this
                },
                removeElement: function(e) {
                    return this.node.removeChild(e.node),
                    this
                },
                clear: function() {
                    for (; this.node.hasChildNodes(); )
                        this.node.removeChild(this.node.lastChild);
                    return delete this._defs,
                    this
                },
                defs: function() {
                    return this.doc().defs()
                }
            }
        }),
        a.extend(a.Parent, {
            ungroup: function(e, t) {
                return 0 === t || this instanceof a.Defs || this.node == a.parser.draw || (e = e || (this instanceof a.Doc ? this : this.parent(a.Parent)),
                t = t || 1 / 0,
                this.each((function() {
                    return this instanceof a.Defs ? this : this instanceof a.Parent ? this.ungroup(e, t - 1) : this.toParent(e)
                }
                )),
                this.node.firstChild || this.remove()),
                this
            },
            flatten: function(e, t) {
                return this.ungroup(e, t)
            }
        }),
        a.Container = a.invent({
            create: function(e) {
                this.constructor.call(this, e)
            },
            inherit: a.Parent
        }),
        a.ViewBox = a.invent({
            parent: a.Container,
            construct: {}
        }),
        ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach((function(e) {
            a.Element.prototype[e] = function(t) {
                return a.on(this.node, e, t),
                this
            }
        }
        )),
        a.listeners = [],
        a.handlerMap = [],
        a.listenerId = 0,
        a.on = function(e, t, i, n, r) {
            var o = i.bind(n || e.instance || e)
              , s = (a.handlerMap.indexOf(e) + 1 || a.handlerMap.push(e)) - 1
              , l = t.split(".")[0]
              , c = t.split(".")[1] || "*";
            a.listeners[s] = a.listeners[s] || {},
            a.listeners[s][l] = a.listeners[s][l] || {},
            a.listeners[s][l][c] = a.listeners[s][l][c] || {},
            i._svgjsListenerId || (i._svgjsListenerId = ++a.listenerId),
            a.listeners[s][l][c][i._svgjsListenerId] = o,
            e.addEventListener(l, o, r || {
                passive: !0
            })
        }
        ,
        a.off = function(e, t, i) {
            var n = a.handlerMap.indexOf(e)
              , r = t && t.split(".")[0]
              , o = t && t.split(".")[1]
              , s = "";
            if (-1 != n)
                if (i) {
                    if ("function" == typeof i && (i = i._svgjsListenerId),
                    !i)
                        return;
                    a.listeners[n][r] && a.listeners[n][r][o || "*"] && (e.removeEventListener(r, a.listeners[n][r][o || "*"][i], !1),
                    delete a.listeners[n][r][o || "*"][i])
                } else if (o && r) {
                    if (a.listeners[n][r] && a.listeners[n][r][o]) {
                        for (var l in a.listeners[n][r][o])
                            a.off(e, [r, o].join("."), l);
                        delete a.listeners[n][r][o]
                    }
                } else if (o)
                    for (var c in a.listeners[n])
                        for (var s in a.listeners[n][c])
                            o === s && a.off(e, [c, o].join("."));
                else if (r) {
                    if (a.listeners[n][r]) {
                        for (var s in a.listeners[n][r])
                            a.off(e, [r, s].join("."));
                        delete a.listeners[n][r]
                    }
                } else {
                    for (var c in a.listeners[n])
                        a.off(e, c);
                    delete a.listeners[n],
                    delete a.handlerMap[n]
                }
        }
        ,
        a.extend(a.Element, {
            on: function(e, t, i, n) {
                return a.on(this.node, e, t, i, n),
                this
            },
            off: function(e, t) {
                return a.off(this.node, e, t),
                this
            },
            fire: function(t, i) {
                return t instanceof e.Event ? this.node.dispatchEvent(t) : this.node.dispatchEvent(t = new a.CustomEvent(t,{
                    detail: i,
                    cancelable: !0
                })),
                this._event = t,
                this
            },
            event: function() {
                return this._event
            }
        }),
        a.Defs = a.invent({
            create: "defs",
            inherit: a.Container
        }),
        a.G = a.invent({
            create: "g",
            inherit: a.Container,
            extend: {
                x: function(e) {
                    return null == e ? this.transform("x") : this.transform({
                        x: e - this.x()
                    }, !0)
                }
            },
            construct: {
                group: function() {
                    return this.put(new a.G)
                }
            }
        }),
        a.Doc = a.invent({
            create: function(e) {
                e && ("svg" == (e = "string" == typeof e ? t.getElementById(e) : e).nodeName ? this.constructor.call(this, e) : (this.constructor.call(this, a.create("svg")),
                e.appendChild(this.node),
                this.size("100%", "100%")),
                this.namespace().defs())
            },
            inherit: a.Container,
            extend: {
                namespace: function() {
                    return this.attr({
                        xmlns: a.ns,
                        version: "1.1"
                    }).attr("xmlns:xlink", a.xlink, a.xmlns).attr("xmlns:svgjs", a.svgjs, a.xmlns)
                },
                defs: function() {
                    var e;
                    return this._defs || ((e = this.node.getElementsByTagName("defs")[0]) ? this._defs = a.adopt(e) : this._defs = new a.Defs,
                    this.node.appendChild(this._defs.node)),
                    this._defs
                },
                parent: function() {
                    return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                },
                remove: function() {
                    return this.parent() && this.parent().removeChild(this.node),
                    this
                },
                clear: function() {
                    for (; this.node.hasChildNodes(); )
                        this.node.removeChild(this.node.lastChild);
                    return delete this._defs,
                    a.parser.draw && !a.parser.draw.parentNode && this.node.appendChild(a.parser.draw),
                    this
                },
                clone: function(e) {
                    this.writeDataToDom();
                    var t = this.node
                      , a = f(t.cloneNode(!0));
                    return e ? (e.node || e).appendChild(a.node) : t.parentNode.insertBefore(a.node, t.nextSibling),
                    a
                }
            }
        }),
        a.extend(a.Element, {}),
        a.Gradient = a.invent({
            create: function(e) {
                this.constructor.call(this, a.create(e + "Gradient")),
                this.type = e
            },
            inherit: a.Container,
            extend: {
                at: function(e, t, i) {
                    return this.put(new a.Stop).update(e, t, i)
                },
                update: function(e) {
                    return this.clear(),
                    "function" == typeof e && e.call(this, this),
                    this
                },
                fill: function() {
                    return "url(#" + this.id() + ")"
                },
                toString: function() {
                    return this.fill()
                },
                attr: function(e, t, i) {
                    return "transform" == e && (e = "gradientTransform"),
                    a.Container.prototype.attr.call(this, e, t, i)
                }
            },
            construct: {
                gradient: function(e, t) {
                    return this.defs().gradient(e, t)
                }
            }
        }),
        a.extend(a.Gradient, a.FX, {
            from: function(e, t) {
                return "radial" == (this._target || this).type ? this.attr({
                    fx: new a.Number(e),
                    fy: new a.Number(t)
                }) : this.attr({
                    x1: new a.Number(e),
                    y1: new a.Number(t)
                })
            },
            to: function(e, t) {
                return "radial" == (this._target || this).type ? this.attr({
                    cx: new a.Number(e),
                    cy: new a.Number(t)
                }) : this.attr({
                    x2: new a.Number(e),
                    y2: new a.Number(t)
                })
            }
        }),
        a.extend(a.Defs, {
            gradient: function(e, t) {
                return this.put(new a.Gradient(e)).update(t)
            }
        }),
        a.Stop = a.invent({
            create: "stop",
            inherit: a.Element,
            extend: {
                update: function(e) {
                    return ("number" == typeof e || e instanceof a.Number) && (e = {
                        offset: arguments[0],
                        color: arguments[1],
                        opacity: arguments[2]
                    }),
                    null != e.opacity && this.attr("stop-opacity", e.opacity),
                    null != e.color && this.attr("stop-color", e.color),
                    null != e.offset && this.attr("offset", new a.Number(e.offset)),
                    this
                }
            }
        }),
        a.Pattern = a.invent({
            create: "pattern",
            inherit: a.Container,
            extend: {
                fill: function() {
                    return "url(#" + this.id() + ")"
                },
                update: function(e) {
                    return this.clear(),
                    "function" == typeof e && e.call(this, this),
                    this
                },
                toString: function() {
                    return this.fill()
                },
                attr: function(e, t, i) {
                    return "transform" == e && (e = "patternTransform"),
                    a.Container.prototype.attr.call(this, e, t, i)
                }
            },
            construct: {
                pattern: function(e, t, a) {
                    return this.defs().pattern(e, t, a)
                }
            }
        }),
        a.extend(a.Defs, {
            pattern: function(e, t, i) {
                return this.put(new a.Pattern).update(i).attr({
                    x: 0,
                    y: 0,
                    width: e,
                    height: t,
                    patternUnits: "userSpaceOnUse"
                })
            }
        }),
        a.Shape = a.invent({
            create: function(e) {
                this.constructor.call(this, e)
            },
            inherit: a.Element
        }),
        a.Symbol = a.invent({
            create: "symbol",
            inherit: a.Container,
            construct: {
                symbol: function() {
                    return this.put(new a.Symbol)
                }
            }
        }),
        a.Use = a.invent({
            create: "use",
            inherit: a.Shape,
            extend: {
                element: function(e, t) {
                    return this.attr("href", (t || "") + "#" + e, a.xlink)
                }
            },
            construct: {
                use: function(e, t) {
                    return this.put(new a.Use).element(e, t)
                }
            }
        }),
        a.Rect = a.invent({
            create: "rect",
            inherit: a.Shape,
            construct: {
                rect: function(e, t) {
                    return this.put(new a.Rect).size(e, t)
                }
            }
        }),
        a.Circle = a.invent({
            create: "circle",
            inherit: a.Shape,
            construct: {
                circle: function(e) {
                    return this.put(new a.Circle).rx(new a.Number(e).divide(2)).move(0, 0)
                }
            }
        }),
        a.extend(a.Circle, a.FX, {
            rx: function(e) {
                return this.attr("r", e)
            },
            ry: function(e) {
                return this.rx(e)
            }
        }),
        a.Ellipse = a.invent({
            create: "ellipse",
            inherit: a.Shape,
            construct: {
                ellipse: function(e, t) {
                    return this.put(new a.Ellipse).size(e, t).move(0, 0)
                }
            }
        }),
        a.extend(a.Ellipse, a.Rect, a.FX, {
            rx: function(e) {
                return this.attr("rx", e)
            },
            ry: function(e) {
                return this.attr("ry", e)
            }
        }),
        a.extend(a.Circle, a.Ellipse, {
            x: function(e) {
                return null == e ? this.cx() - this.rx() : this.cx(e + this.rx())
            },
            y: function(e) {
                return null == e ? this.cy() - this.ry() : this.cy(e + this.ry())
            },
            cx: function(e) {
                return null == e ? this.attr("cx") : this.attr("cx", e)
            },
            cy: function(e) {
                return null == e ? this.attr("cy") : this.attr("cy", e)
            },
            width: function(e) {
                return null == e ? 2 * this.rx() : this.rx(new a.Number(e).divide(2))
            },
            height: function(e) {
                return null == e ? 2 * this.ry() : this.ry(new a.Number(e).divide(2))
            },
            size: function(e, t) {
                var i = p(this, e, t);
                return this.rx(new a.Number(i.width).divide(2)).ry(new a.Number(i.height).divide(2))
            }
        }),
        a.Line = a.invent({
            create: "line",
            inherit: a.Shape,
            extend: {
                array: function() {
                    return new a.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]])
                },
                plot: function(e, t, i, n) {
                    return null == e ? this.array() : (e = void 0 !== t ? {
                        x1: e,
                        y1: t,
                        x2: i,
                        y2: n
                    } : new a.PointArray(e).toLine(),
                    this.attr(e))
                },
                move: function(e, t) {
                    return this.attr(this.array().move(e, t).toLine())
                },
                size: function(e, t) {
                    var a = p(this, e, t);
                    return this.attr(this.array().size(a.width, a.height).toLine())
                }
            },
            construct: {
                line: function(e, t, i, n) {
                    return a.Line.prototype.plot.apply(this.put(new a.Line), null != e ? [e, t, i, n] : [0, 0, 0, 0])
                }
            }
        }),
        a.Polyline = a.invent({
            create: "polyline",
            inherit: a.Shape,
            construct: {
                polyline: function(e) {
                    return this.put(new a.Polyline).plot(e || new a.PointArray)
                }
            }
        }),
        a.Polygon = a.invent({
            create: "polygon",
            inherit: a.Shape,
            construct: {
                polygon: function(e) {
                    return this.put(new a.Polygon).plot(e || new a.PointArray)
                }
            }
        }),
        a.extend(a.Polyline, a.Polygon, {
            array: function() {
                return this._array || (this._array = new a.PointArray(this.attr("points")))
            },
            plot: function(e) {
                return null == e ? this.array() : this.clear().attr("points", "string" == typeof e ? e : this._array = new a.PointArray(e))
            },
            clear: function() {
                return delete this._array,
                this
            },
            move: function(e, t) {
                return this.attr("points", this.array().move(e, t))
            },
            size: function(e, t) {
                var a = p(this, e, t);
                return this.attr("points", this.array().size(a.width, a.height))
            }
        }),
        a.extend(a.Line, a.Polyline, a.Polygon, {
            morphArray: a.PointArray,
            x: function(e) {
                return null == e ? this.bbox().x : this.move(e, this.bbox().y)
            },
            y: function(e) {
                return null == e ? this.bbox().y : this.move(this.bbox().x, e)
            },
            width: function(e) {
                var t = this.bbox();
                return null == e ? t.width : this.size(e, t.height)
            },
            height: function(e) {
                var t = this.bbox();
                return null == e ? t.height : this.size(t.width, e)
            }
        }),
        a.Path = a.invent({
            create: "path",
            inherit: a.Shape,
            extend: {
                morphArray: a.PathArray,
                array: function() {
                    return this._array || (this._array = new a.PathArray(this.attr("d")))
                },
                plot: function(e) {
                    return null == e ? this.array() : this.clear().attr("d", "string" == typeof e ? e : this._array = new a.PathArray(e))
                },
                clear: function() {
                    return delete this._array,
                    this
                }
            },
            construct: {
                path: function(e) {
                    return this.put(new a.Path).plot(e || new a.PathArray)
                }
            }
        }),
        a.Image = a.invent({
            create: "image",
            inherit: a.Shape,
            extend: {
                load: function(t) {
                    if (!t)
                        return this;
                    var i = this
                      , n = new e.Image;
                    return a.on(n, "load", (function() {
                        a.off(n);
                        var e = i.parent(a.Pattern);
                        null !== e && (0 == i.width() && 0 == i.height() && i.size(n.width, n.height),
                        e && 0 == e.width() && 0 == e.height() && e.size(i.width(), i.height()),
                        "function" == typeof i._loaded && i._loaded.call(i, {
                            width: n.width,
                            height: n.height,
                            ratio: n.width / n.height,
                            url: t
                        }))
                    }
                    )),
                    a.on(n, "error", (function(e) {
                        a.off(n),
                        "function" == typeof i._error && i._error.call(i, e)
                    }
                    )),
                    this.attr("href", n.src = this.src = t, a.xlink)
                },
                loaded: function(e) {
                    return this._loaded = e,
                    this
                },
                error: function(e) {
                    return this._error = e,
                    this
                }
            },
            construct: {
                image: function(e, t, i) {
                    return this.put(new a.Image).load(e).size(t || 0, i || t || 0)
                }
            }
        }),
        a.Text = a.invent({
            create: function() {
                this.constructor.call(this, a.create("text")),
                this.dom.leading = new a.Number(1.3),
                this._rebuild = !0,
                this._build = !1,
                this.attr("font-family", a.defaults.attrs["font-family"])
            },
            inherit: a.Shape,
            extend: {
                x: function(e) {
                    return null == e ? this.attr("x") : this.attr("x", e)
                },
                text: function(e) {
                    if (void 0 === e) {
                        e = "";
                        for (var t = this.node.childNodes, i = 0, n = t.length; i < n; ++i)
                            0 != i && 3 != t[i].nodeType && 1 == a.adopt(t[i]).dom.newLined && (e += "\n"),
                            e += t[i].textContent;
                        return e
                    }
                    if (this.clear().build(!0),
                    "function" == typeof e)
                        e.call(this, this);
                    else {
                        i = 0;
                        for (var r = (e = e.split("\n")).length; i < r; i++)
                            this.tspan(e[i]).newLine()
                    }
                    return this.build(!1).rebuild()
                },
                size: function(e) {
                    return this.attr("font-size", e).rebuild()
                },
                leading: function(e) {
                    return null == e ? this.dom.leading : (this.dom.leading = new a.Number(e),
                    this.rebuild())
                },
                lines: function() {
                    var e = (this.textPath && this.textPath() || this).node
                      , t = a.utils.map(a.utils.filterSVGElements(e.childNodes), (function(e) {
                        return a.adopt(e)
                    }
                    ));
                    return new a.Set(t)
                },
                rebuild: function(e) {
                    if ("boolean" == typeof e && (this._rebuild = e),
                    this._rebuild) {
                        var t = this
                          , i = 0
                          , n = this.dom.leading * new a.Number(this.attr("font-size"));
                        this.lines().each((function() {
                            this.dom.newLined && (t.textPath() || this.attr("x", t.attr("x")),
                            "\n" == this.text() ? i += n : (this.attr("dy", n + i),
                            i = 0))
                        }
                        )),
                        this.fire("rebuild")
                    }
                    return this
                },
                build: function(e) {
                    return this._build = !!e,
                    this
                },
                setData: function(e) {
                    return this.dom = e,
                    this.dom.leading = new a.Number(e.leading || 1.3),
                    this
                }
            },
            construct: {
                text: function(e) {
                    return this.put(new a.Text).text(e)
                },
                plain: function(e) {
                    return this.put(new a.Text).plain(e)
                }
            }
        }),
        a.Tspan = a.invent({
            create: "tspan",
            inherit: a.Shape,
            extend: {
                text: function(e) {
                    return null == e ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof e ? e.call(this, this) : this.plain(e),
                    this)
                },
                dx: function(e) {
                    return this.attr("dx", e)
                },
                dy: function(e) {
                    return this.attr("dy", e)
                },
                newLine: function() {
                    var e = this.parent(a.Text);
                    return this.dom.newLined = !0,
                    this.dy(e.dom.leading * e.attr("font-size")).attr("x", e.x())
                }
            }
        }),
        a.extend(a.Text, a.Tspan, {
            plain: function(e) {
                return !1 === this._build && this.clear(),
                this.node.appendChild(t.createTextNode(e)),
                this
            },
            tspan: function(e) {
                var t = (this.textPath && this.textPath() || this).node
                  , i = new a.Tspan;
                return !1 === this._build && this.clear(),
                t.appendChild(i.node),
                i.text(e)
            },
            clear: function() {
                for (var e = (this.textPath && this.textPath() || this).node; e.hasChildNodes(); )
                    e.removeChild(e.lastChild);
                return this
            },
            length: function() {
                return this.node.getComputedTextLength()
            }
        }),
        a.TextPath = a.invent({
            create: "textPath",
            inherit: a.Parent,
            parent: a.Text,
            construct: {
                morphArray: a.PathArray,
                array: function() {
                    var e = this.track();
                    return e ? e.array() : null
                },
                plot: function(e) {
                    var t = this.track()
                      , a = null;
                    return t && (a = t.plot(e)),
                    null == e ? a : this
                },
                track: function() {
                    var e = this.textPath();
                    if (e)
                        return e.reference("href")
                },
                textPath: function() {
                    if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName)
                        return a.adopt(this.node.firstChild)
                }
            }
        }),
        a.Nested = a.invent({
            create: function() {
                this.constructor.call(this, a.create("svg")),
                this.style("overflow", "visible")
            },
            inherit: a.Container,
            construct: {
                nested: function() {
                    return this.put(new a.Nested)
                }
            }
        });
        var l = {
            stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
            fill: ["color", "opacity", "rule"],
            prefix: function(e, t) {
                return "color" == t ? e : e + "-" + t
            }
        };
        function c(e, t, i, n) {
            return i + n.replace(a.regex.dots, " .")
        }
        function u(e) {
            return e.toLowerCase().replace(/-(.)/g, (function(e, t) {
                return t.toUpperCase()
            }
            ))
        }
        function d(e) {
            return e.charAt(0).toUpperCase() + e.slice(1)
        }
        function h(e) {
            var t = e.toString(16);
            return 1 == t.length ? "0" + t : t
        }
        function p(e, t, a) {
            if (null == t || null == a) {
                var i = e.bbox();
                null == t ? t = i.width / i.height * a : null == a && (a = i.height / i.width * t)
            }
            return {
                width: t,
                height: a
            }
        }
        function v(e, t, a) {
            return {
                x: t * e.a + a * e.c + 0,
                y: t * e.b + a * e.d + 0
            }
        }
        function g(e) {
            return {
                a: e[0],
                b: e[1],
                c: e[2],
                d: e[3],
                e: e[4],
                f: e[5]
            }
        }
        function f(t) {
            for (var i = t.childNodes.length - 1; i >= 0; i--)
                t.childNodes[i]instanceof e.SVGElement && f(t.childNodes[i]);
            return a.adopt(t).id(a.eid(t.nodeName))
        }
        function m(e) {
            return Math.abs(e) > 1e-37 ? e : 0
        }
        ["fill", "stroke"].forEach((function(e) {
            var t = {};
            t[e] = function(t) {
                if (void 0 === t)
                    return this;
                if ("string" == typeof t || a.Color.isRgb(t) || t && "function" == typeof t.fill)
                    this.attr(e, t);
                else
                    for (var i = l[e].length - 1; i >= 0; i--)
                        null != t[l[e][i]] && this.attr(l.prefix(e, l[e][i]), t[l[e][i]]);
                return this
            }
            ,
            a.extend(a.Element, a.FX, t)
        }
        )),
        a.extend(a.Element, a.FX, {
            translate: function(e, t) {
                return this.transform({
                    x: e,
                    y: t
                })
            },
            matrix: function(e) {
                return this.attr("transform", new a.Matrix(6 == arguments.length ? [].slice.call(arguments) : e))
            },
            opacity: function(e) {
                return this.attr("opacity", e)
            },
            dx: function(e) {
                return this.x(new a.Number(e).plus(this instanceof a.FX ? 0 : this.x()), !0)
            },
            dy: function(e) {
                return this.y(new a.Number(e).plus(this instanceof a.FX ? 0 : this.y()), !0)
            }
        }),
        a.extend(a.Path, {
            length: function() {
                return this.node.getTotalLength()
            },
            pointAt: function(e) {
                return this.node.getPointAtLength(e)
            }
        }),
        a.Set = a.invent({
            create: function(e) {
                Array.isArray(e) ? this.members = e : this.clear()
            },
            extend: {
                add: function() {
                    for (var e = [].slice.call(arguments), t = 0, a = e.length; t < a; t++)
                        this.members.push(e[t]);
                    return this
                },
                remove: function(e) {
                    var t = this.index(e);
                    return t > -1 && this.members.splice(t, 1),
                    this
                },
                each: function(e) {
                    for (var t = 0, a = this.members.length; t < a; t++)
                        e.apply(this.members[t], [t, this.members]);
                    return this
                },
                clear: function() {
                    return this.members = [],
                    this
                },
                length: function() {
                    return this.members.length
                },
                has: function(e) {
                    return this.index(e) >= 0
                },
                index: function(e) {
                    return this.members.indexOf(e)
                },
                get: function(e) {
                    return this.members[e]
                },
                first: function() {
                    return this.get(0)
                },
                last: function() {
                    return this.get(this.members.length - 1)
                },
                valueOf: function() {
                    return this.members
                }
            },
            construct: {
                set: function(e) {
                    return new a.Set(e)
                }
            }
        }),
        a.FX.Set = a.invent({
            create: function(e) {
                this.set = e
            }
        }),
        a.Set.inherit = function() {
            var e = [];
            for (var t in a.Shape.prototype)
                "function" == typeof a.Shape.prototype[t] && "function" != typeof a.Set.prototype[t] && e.push(t);
            for (var t in e.forEach((function(e) {
                a.Set.prototype[e] = function() {
                    for (var t = 0, i = this.members.length; t < i; t++)
                        this.members[t] && "function" == typeof this.members[t][e] && this.members[t][e].apply(this.members[t], arguments);
                    return "animate" == e ? this.fx || (this.fx = new a.FX.Set(this)) : this
                }
            }
            )),
            e = [],
            a.FX.prototype)
                "function" == typeof a.FX.prototype[t] && "function" != typeof a.FX.Set.prototype[t] && e.push(t);
            e.forEach((function(e) {
                a.FX.Set.prototype[e] = function() {
                    for (var t = 0, a = this.set.members.length; t < a; t++)
                        this.set.members[t].fx[e].apply(this.set.members[t].fx, arguments);
                    return this
                }
            }
            ))
        }
        ,
        a.extend(a.Element, {}),
        a.extend(a.Element, {
            remember: function(e, t) {
                if ("object" === n(arguments[0]))
                    for (var a in e)
                        this.remember(a, e[a]);
                else {
                    if (1 == arguments.length)
                        return this.memory()[e];
                    this.memory()[e] = t
                }
                return this
            },
            forget: function() {
                if (0 == arguments.length)
                    this._memory = {};
                else
                    for (var e = arguments.length - 1; e >= 0; e--)
                        delete this.memory()[arguments[e]];
                return this
            },
            memory: function() {
                return this._memory || (this._memory = {})
            }
        }),
        a.get = function(e) {
            var i = t.getElementById(function(e) {
                var t = (e || "").toString().match(a.regex.reference);
                if (t)
                    return t[1]
            }(e) || e);
            return a.adopt(i)
        }
        ,
        a.select = function(e, i) {
            return new a.Set(a.utils.map((i || t).querySelectorAll(e), (function(e) {
                return a.adopt(e)
            }
            )))
        }
        ,
        a.extend(a.Parent, {
            select: function(e) {
                return a.select(e, this.node)
            }
        });
        var b = "abcdef".split("");
        if ("function" != typeof e.CustomEvent) {
            var x = function(e, a) {
                a = a || {
                    bubbles: !1,
                    cancelable: !1,
                    detail: void 0
                };
                var i = t.createEvent("CustomEvent");
                return i.initCustomEvent(e, a.bubbles, a.cancelable, a.detail),
                i
            };
            x.prototype = e.Event.prototype,
            a.CustomEvent = x
        } else
            a.CustomEvent = e.CustomEvent;
        return a
    }
    ,
    "object" === n(t) ? e.exports = De.document ? Re(De, De.document) : function(e) {
        return Re(e, e.document)
    }
    : De.SVG = Re(De, De.document),
    function() {
        SVG.Filter = SVG.invent({
            create: "filter",
            inherit: SVG.Parent,
            extend: {
                source: "SourceGraphic",
                sourceAlpha: "SourceAlpha",
                background: "BackgroundImage",
                backgroundAlpha: "BackgroundAlpha",
                fill: "FillPaint",
                stroke: "StrokePaint",
                autoSetIn: !0,
                put: function(e, t) {
                    return this.add(e, t),
                    !e.attr("in") && this.autoSetIn && e.attr("in", this.source),
                    e.attr("result") || e.attr("result", e),
                    e
                },
                blend: function(e, t, a) {
                    return this.put(new SVG.BlendEffect(e,t,a))
                },
                colorMatrix: function(e, t) {
                    return this.put(new SVG.ColorMatrixEffect(e,t))
                },
                convolveMatrix: function(e) {
                    return this.put(new SVG.ConvolveMatrixEffect(e))
                },
                componentTransfer: function(e) {
                    return this.put(new SVG.ComponentTransferEffect(e))
                },
                composite: function(e, t, a) {
                    return this.put(new SVG.CompositeEffect(e,t,a))
                },
                flood: function(e, t) {
                    return this.put(new SVG.FloodEffect(e,t))
                },
                offset: function(e, t) {
                    return this.put(new SVG.OffsetEffect(e,t))
                },
                image: function(e) {
                    return this.put(new SVG.ImageEffect(e))
                },
                merge: function() {
                    var e = [void 0];
                    for (var t in arguments)
                        e.push(arguments[t]);
                    return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, e)))
                },
                gaussianBlur: function(e, t) {
                    return this.put(new SVG.GaussianBlurEffect(e,t))
                },
                morphology: function(e, t) {
                    return this.put(new SVG.MorphologyEffect(e,t))
                },
                diffuseLighting: function(e, t, a) {
                    return this.put(new SVG.DiffuseLightingEffect(e,t,a))
                },
                displacementMap: function(e, t, a, i, n) {
                    return this.put(new SVG.DisplacementMapEffect(e,t,a,i,n))
                },
                specularLighting: function(e, t, a, i) {
                    return this.put(new SVG.SpecularLightingEffect(e,t,a,i))
                },
                tile: function() {
                    return this.put(new SVG.TileEffect)
                },
                turbulence: function(e, t, a, i, n) {
                    return this.put(new SVG.TurbulenceEffect(e,t,a,i,n))
                },
                toString: function() {
                    return "url(#" + this.attr("id") + ")"
                }
            }
        }),
        SVG.extend(SVG.Defs, {
            filter: function(e) {
                var t = this.put(new SVG.Filter);
                return "function" == typeof e && e.call(t, t),
                t
            }
        }),
        SVG.extend(SVG.Container, {
            filter: function(e) {
                return this.defs().filter(e)
            }
        }),
        SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
            filter: function(e) {
                return this.filterer = e instanceof SVG.Element ? e : this.doc().filter(e),
                this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer),
                this.attr("filter", this.filterer),
                this.filterer
            },
            unfilter: function(e) {
                return this.filterer && !0 === e && this.filterer.remove(),
                delete this.filterer,
                this.attr("filter", null)
            }
        }),
        SVG.Effect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Element,
            extend: {
                in: function(e) {
                    return null == e ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", e)
                },
                result: function(e) {
                    return null == e ? this.attr("result") : this.attr("result", e)
                },
                toString: function() {
                    return this.result()
                }
            }
        }),
        SVG.ParentEffect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Parent,
            extend: {
                in: function(e) {
                    return null == e ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", e)
                },
                result: function(e) {
                    return null == e ? this.attr("result") : this.attr("result", e)
                },
                toString: function() {
                    return this.result()
                }
            }
        });
        var e = {
            blend: function(e, t) {
                return this.parent() && this.parent().blend(this, e, t)
            },
            colorMatrix: function(e, t) {
                return this.parent() && this.parent().colorMatrix(e, t).in(this)
            },
            convolveMatrix: function(e) {
                return this.parent() && this.parent().convolveMatrix(e).in(this)
            },
            componentTransfer: function(e) {
                return this.parent() && this.parent().componentTransfer(e).in(this)
            },
            composite: function(e, t) {
                return this.parent() && this.parent().composite(this, e, t)
            },
            flood: function(e, t) {
                return this.parent() && this.parent().flood(e, t)
            },
            offset: function(e, t) {
                return this.parent() && this.parent().offset(e, t).in(this)
            },
            image: function(e) {
                return this.parent() && this.parent().image(e)
            },
            merge: function() {
                return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
            },
            gaussianBlur: function(e, t) {
                return this.parent() && this.parent().gaussianBlur(e, t).in(this)
            },
            morphology: function(e, t) {
                return this.parent() && this.parent().morphology(e, t).in(this)
            },
            diffuseLighting: function(e, t, a) {
                return this.parent() && this.parent().diffuseLighting(e, t, a).in(this)
            },
            displacementMap: function(e, t, a, i) {
                return this.parent() && this.parent().displacementMap(this, e, t, a, i)
            },
            specularLighting: function(e, t, a, i) {
                return this.parent() && this.parent().specularLighting(e, t, a, i).in(this)
            },
            tile: function() {
                return this.parent() && this.parent().tile().in(this)
            },
            turbulence: function(e, t, a, i, n) {
                return this.parent() && this.parent().turbulence(e, t, a, i, n).in(this)
            }
        };
        SVG.extend(SVG.Effect, e),
        SVG.extend(SVG.ParentEffect, e),
        SVG.ChildEffect = SVG.invent({
            create: function() {
                this.constructor.call(this)
            },
            inherit: SVG.Element,
            extend: {
                in: function(e) {
                    this.attr("in", e)
                }
            }
        });
        var t = {
            blend: function(e, t, a) {
                this.attr({
                    in: e,
                    in2: t,
                    mode: a || "normal"
                })
            },
            colorMatrix: function(e, t) {
                "matrix" == e && (t = n(t)),
                this.attr({
                    type: e,
                    values: void 0 === t ? null : t
                })
            },
            convolveMatrix: function(e) {
                e = n(e),
                this.attr({
                    order: Math.sqrt(e.split(" ").length),
                    kernelMatrix: e
                })
            },
            composite: function(e, t, a) {
                this.attr({
                    in: e,
                    in2: t,
                    operator: a
                })
            },
            flood: function(e, t) {
                this.attr("flood-color", e),
                null != t && this.attr("flood-opacity", t)
            },
            offset: function(e, t) {
                this.attr({
                    dx: e,
                    dy: t
                })
            },
            image: function(e) {
                this.attr("href", e, SVG.xlink)
            },
            displacementMap: function(e, t, a, i, n) {
                this.attr({
                    in: e,
                    in2: t,
                    scale: a,
                    xChannelSelector: i,
                    yChannelSelector: n
                })
            },
            gaussianBlur: function(e, t) {
                null != e || null != t ? this.attr("stdDeviation", function(e) {
                    if (!Array.isArray(e))
                        return e;
                    for (var t = 0, a = e.length, i = []; t < a; t++)
                        i.push(e[t]);
                    return i.join(" ")
                }(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0")
            },
            morphology: function(e, t) {
                this.attr({
                    operator: e,
                    radius: t
                })
            },
            tile: function() {},
            turbulence: function(e, t, a, i, n) {
                this.attr({
                    numOctaves: t,
                    seed: a,
                    stitchTiles: i,
                    baseFrequency: e,
                    type: n
                })
            }
        }
          , a = {
            merge: function() {
                var e;
                if (arguments[0]instanceof SVG.Set) {
                    var t = this;
                    arguments[0].each((function(e) {
                        this instanceof SVG.MergeNode ? t.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && t.put(new SVG.MergeNode(this))
                    }
                    ))
                } else {
                    e = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                    for (var a = 0; a < e.length; a++)
                        e[a]instanceof SVG.MergeNode ? this.put(e[a]) : this.put(new SVG.MergeNode(e[a]))
                }
            },
            componentTransfer: function(e) {
                if (this.rgb = new SVG.Set,
                ["r", "g", "b", "a"].forEach(function(e) {
                    this[e] = new (SVG["Func" + e.toUpperCase()])("identity"),
                    this.rgb.add(this[e]),
                    this.node.appendChild(this[e].node)
                }
                .bind(this)),
                e)
                    for (var t in e.rgb && (["r", "g", "b"].forEach(function(t) {
                        this[t].attr(e.rgb)
                    }
                    .bind(this)),
                    delete e.rgb),
                    e)
                        this[t].attr(e[t])
            },
            diffuseLighting: function(e, t, a) {
                this.attr({
                    surfaceScale: e,
                    diffuseConstant: t,
                    kernelUnitLength: a
                })
            },
            specularLighting: function(e, t, a, i) {
                this.attr({
                    surfaceScale: e,
                    diffuseConstant: t,
                    specularExponent: a,
                    kernelUnitLength: i
                })
            }
        }
          , i = {
            distantLight: function(e, t) {
                this.attr({
                    azimuth: e,
                    elevation: t
                })
            },
            pointLight: function(e, t, a) {
                this.attr({
                    x: e,
                    y: t,
                    z: a
                })
            },
            spotLight: function(e, t, a, i, n, r) {
                this.attr({
                    x: e,
                    y: t,
                    z: a,
                    pointsAtX: i,
                    pointsAtY: n,
                    pointsAtZ: r
                })
            },
            mergeNode: function(e) {
                this.attr("in", e)
            }
        };
        function n(e) {
            return Array.isArray(e) && (e = new SVG.Array(e)),
            e.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
        }
        function r() {
            var e = function() {};
            for (var t in "function" == typeof arguments[arguments.length - 1] && (e = arguments[arguments.length - 1],
            Array.prototype.splice.call(arguments, arguments.length - 1, 1)),
            arguments)
                for (var a in arguments[t])
                    e(arguments[t][a], a, arguments[t])
        }
        ["r", "g", "b", "a"].forEach((function(e) {
            i["Func" + e.toUpperCase()] = function(e) {
                switch (this.attr("type", e),
                e) {
                case "table":
                    this.attr("tableValues", arguments[1]);
                    break;
                case "linear":
                    this.attr("slope", arguments[1]),
                    this.attr("intercept", arguments[2]);
                    break;
                case "gamma":
                    this.attr("amplitude", arguments[1]),
                    this.attr("exponent", arguments[2]),
                    this.attr("offset", arguments[2])
                }
            }
        }
        )),
        r(t, (function(e, t) {
            var a = t.charAt(0).toUpperCase() + t.slice(1);
            SVG[a + "Effect"] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + a)),
                    e.apply(this, arguments),
                    this.result(this.attr("id") + "Out")
                },
                inherit: SVG.Effect,
                extend: {}
            })
        }
        )),
        r(a, (function(e, t) {
            var a = t.charAt(0).toUpperCase() + t.slice(1);
            SVG[a + "Effect"] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + a)),
                    e.apply(this, arguments),
                    this.result(this.attr("id") + "Out")
                },
                inherit: SVG.ParentEffect,
                extend: {}
            })
        }
        )),
        r(i, (function(e, t) {
            var a = t.charAt(0).toUpperCase() + t.slice(1);
            SVG[a] = SVG.invent({
                create: function() {
                    this.constructor.call(this, SVG.create("fe" + a)),
                    e.apply(this, arguments)
                },
                inherit: SVG.ChildEffect,
                extend: {}
            })
        }
        )),
        SVG.extend(SVG.MergeEffect, {
            in: function(e) {
                return e instanceof SVG.MergeNode ? this.add(e, 0) : this.add(new SVG.MergeNode(e), 0),
                this
            }
        }),
        SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
            in2: function(e) {
                return null == e ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", e)
            }
        }),
        SVG.filter = {
            sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
        }
    }
    .call(void 0),
    function() {
        function e(e, n, r, o, s, l, c) {
            for (var u = e.slice(n, r || c), d = o.slice(s, l || c), h = 0, p = {
                pos: [0, 0],
                start: [0, 0]
            }, v = {
                pos: [0, 0],
                start: [0, 0]
            }; u[h] = t.call(p, u[h]),
            d[h] = t.call(v, d[h]),
            u[h][0] != d[h][0] || "M" == u[h][0] || "A" == u[h][0] && (u[h][4] != d[h][4] || u[h][5] != d[h][5]) ? (Array.prototype.splice.apply(u, [h, 1].concat(i.call(p, u[h]))),
            Array.prototype.splice.apply(d, [h, 1].concat(i.call(v, d[h])))) : (u[h] = a.call(p, u[h]),
            d[h] = a.call(v, d[h])),
            ++h != u.length || h != d.length; )
                h == u.length && u.push(["C", p.pos[0], p.pos[1], p.pos[0], p.pos[1], p.pos[0], p.pos[1]]),
                h == d.length && d.push(["C", v.pos[0], v.pos[1], v.pos[0], v.pos[1], v.pos[0], v.pos[1]]);
            return {
                start: u,
                dest: d
            }
        }
        function t(e) {
            switch (e[0]) {
            case "z":
            case "Z":
                e[0] = "L",
                e[1] = this.start[0],
                e[2] = this.start[1];
                break;
            case "H":
                e[0] = "L",
                e[2] = this.pos[1];
                break;
            case "V":
                e[0] = "L",
                e[2] = e[1],
                e[1] = this.pos[0];
                break;
            case "T":
                e[0] = "Q",
                e[3] = e[1],
                e[4] = e[2],
                e[1] = this.reflection[1],
                e[2] = this.reflection[0];
                break;
            case "S":
                e[0] = "C",
                e[6] = e[4],
                e[5] = e[3],
                e[4] = e[2],
                e[3] = e[1],
                e[2] = this.reflection[1],
                e[1] = this.reflection[0]
            }
            return e
        }
        function a(e) {
            var t = e.length;
            return this.pos = [e[t - 2], e[t - 1]],
            -1 != "SCQT".indexOf(e[0]) && (this.reflection = [2 * this.pos[0] - e[t - 4], 2 * this.pos[1] - e[t - 3]]),
            e
        }
        function i(e) {
            var t = [e];
            switch (e[0]) {
            case "M":
                return this.pos = this.start = [e[1], e[2]],
                t;
            case "L":
                e[5] = e[3] = e[1],
                e[6] = e[4] = e[2],
                e[1] = this.pos[0],
                e[2] = this.pos[1];
                break;
            case "Q":
                e[6] = e[4],
                e[5] = e[3],
                e[4] = 1 * e[4] / 3 + 2 * e[2] / 3,
                e[3] = 1 * e[3] / 3 + 2 * e[1] / 3,
                e[2] = 1 * this.pos[1] / 3 + 2 * e[2] / 3,
                e[1] = 1 * this.pos[0] / 3 + 2 * e[1] / 3;
                break;
            case "A":
                e = (t = function(e, t) {
                    var a, i, n, r, o, s, l, c, u, d, h, p, v, g, f, m, b, x, y, w, k, S, C, A, P, L, I = Math.abs(t[1]), _ = Math.abs(t[2]), T = t[3] % 360, E = t[4], O = t[5], V = t[6], F = t[7], B = new SVG.Point(e), M = new SVG.Point(V,F), D = [];
                    if (0 === I || 0 === _ || B.x === M.x && B.y === M.y)
                        return [["C", B.x, B.y, M.x, M.y, M.x, M.y]];
                    for ((i = (a = new SVG.Point((B.x - M.x) / 2,(B.y - M.y) / 2).transform((new SVG.Matrix).rotate(T))).x * a.x / (I * I) + a.y * a.y / (_ * _)) > 1 && (I *= i = Math.sqrt(i),
                    _ *= i),
                    n = (new SVG.Matrix).rotate(T).scale(1 / I, 1 / _).rotate(-T),
                    B = B.transform(n),
                    s = (r = [(M = M.transform(n)).x - B.x, M.y - B.y])[0] * r[0] + r[1] * r[1],
                    o = Math.sqrt(s),
                    r[0] /= o,
                    r[1] /= o,
                    l = s < 4 ? Math.sqrt(1 - s / 4) : 0,
                    E === O && (l *= -1),
                    c = new SVG.Point((M.x + B.x) / 2 + l * -r[1],(M.y + B.y) / 2 + l * r[0]),
                    u = new SVG.Point(B.x - c.x,B.y - c.y),
                    d = new SVG.Point(M.x - c.x,M.y - c.y),
                    h = Math.acos(u.x / Math.sqrt(u.x * u.x + u.y * u.y)),
                    u.y < 0 && (h *= -1),
                    p = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)),
                    d.y < 0 && (p *= -1),
                    O && h > p && (p += 2 * Math.PI),
                    !O && h < p && (p -= 2 * Math.PI),
                    m = [],
                    b = h,
                    v = (p - h) / (g = Math.ceil(2 * Math.abs(h - p) / Math.PI)),
                    f = 4 * Math.tan(v / 4) / 3,
                    k = 0; k <= g; k++)
                        y = Math.cos(b),
                        x = Math.sin(b),
                        w = new SVG.Point(c.x + y,c.y + x),
                        m[k] = [new SVG.Point(w.x + f * x,w.y - f * y), w, new SVG.Point(w.x - f * x,w.y + f * y)],
                        b += v;
                    for (m[0][0] = m[0][1].clone(),
                    m[m.length - 1][2] = m[m.length - 1][1].clone(),
                    n = (new SVG.Matrix).rotate(T).scale(I, _).rotate(-T),
                    k = 0,
                    S = m.length; k < S; k++)
                        m[k][0] = m[k][0].transform(n),
                        m[k][1] = m[k][1].transform(n),
                        m[k][2] = m[k][2].transform(n);
                    for (k = 1,
                    S = m.length; k < S; k++)
                        C = (w = m[k - 1][2]).x,
                        A = w.y,
                        P = (w = m[k][0]).x,
                        L = w.y,
                        V = (w = m[k][1]).x,
                        F = w.y,
                        D.push(["C", C, A, P, L, V, F]);
                    return D
                }(this.pos, e))[0]
            }
            return e[0] = "C",
            this.pos = [e[5], e[6]],
            this.reflection = [2 * e[5] - e[3], 2 * e[6] - e[4]],
            t
        }
        function n(e, t) {
            if (!1 === t)
                return !1;
            for (var a = t, i = e.length; a < i; ++a)
                if ("M" == e[a][0])
                    return a;
            return !1
        }
        SVG.extend(SVG.PathArray, {
            morph: function(t) {
                for (var a = this.value, i = this.parse(t), r = 0, o = 0, s = !1, l = !1; !1 !== r || !1 !== o; ) {
                    var c;
                    s = n(a, !1 !== r && r + 1),
                    l = n(i, !1 !== o && o + 1),
                    !1 === r && (r = 0 == (c = new SVG.PathArray(u.start).bbox()).height || 0 == c.width ? a.push(a[0]) - 1 : a.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1),
                    !1 === o && (o = 0 == (c = new SVG.PathArray(u.dest).bbox()).height || 0 == c.width ? i.push(i[0]) - 1 : i.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1);
                    var u = e(a, r, s, i, o, l);
                    a = a.slice(0, r).concat(u.start, !1 === s ? [] : a.slice(s)),
                    i = i.slice(0, o).concat(u.dest, !1 === l ? [] : i.slice(l)),
                    r = !1 !== s && r + u.start.length,
                    o = !1 !== l && o + u.dest.length
                }
                return this.value = a,
                this.destination = new SVG.PathArray,
                this.destination.value = i,
                this
            }
        })
    }(),
    function() {
        function e(e) {
            e.remember("_draggable", this),
            this.el = e
        }
        e.prototype.init = function(e, t) {
            var a = this;
            this.constraint = e,
            this.value = t,
            this.el.on("mousedown.drag", (function(e) {
                a.start(e)
            }
            )),
            this.el.on("touchstart.drag", (function(e) {
                a.start(e)
            }
            ))
        }
        ,
        e.prototype.transformPoint = function(e, t) {
            var a = (e = e || window.event).changedTouches && e.changedTouches[0] || e;
            return this.p.x = a.clientX - (t || 0),
            this.p.y = a.clientY,
            this.p.matrixTransform(this.m)
        }
        ,
        e.prototype.getBBox = function() {
            var e = this.el.bbox();
            return this.el instanceof SVG.Nested && (e = this.el.rbox()),
            (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (e.x = this.el.x(),
            e.y = this.el.y()),
            e
        }
        ,
        e.prototype.start = function(e) {
            if ("click" != e.type && "mousedown" != e.type && "mousemove" != e.type || 1 == (e.which || e.buttons)) {
                var t = this;
                if (this.el.fire("beforedrag", {
                    event: e,
                    handler: this
                }),
                !this.el.event().defaultPrevented) {
                    e.preventDefault(),
                    e.stopPropagation(),
                    this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc),
                    this.p = this.parent.node.createSVGPoint(),
                    this.m = this.el.node.getScreenCTM().inverse();
                    var a, i = this.getBBox();
                    if (this.el instanceof SVG.Text)
                        switch (a = this.el.node.getComputedTextLength(),
                        this.el.attr("text-anchor")) {
                        case "middle":
                            a /= 2;
                            break;
                        case "start":
                            a = 0
                        }
                    this.startPoints = {
                        point: this.transformPoint(e, a),
                        box: i,
                        transform: this.el.transform()
                    },
                    SVG.on(window, "mousemove.drag", (function(e) {
                        t.drag(e)
                    }
                    )),
                    SVG.on(window, "touchmove.drag", (function(e) {
                        t.drag(e)
                    }
                    )),
                    SVG.on(window, "mouseup.drag", (function(e) {
                        t.end(e)
                    }
                    )),
                    SVG.on(window, "touchend.drag", (function(e) {
                        t.end(e)
                    }
                    )),
                    this.el.fire("dragstart", {
                        event: e,
                        p: this.startPoints.point,
                        m: this.m,
                        handler: this
                    })
                }
            }
        }
        ,
        e.prototype.drag = function(e) {
            var t = this.getBBox()
              , a = this.transformPoint(e)
              , i = this.startPoints.box.x + a.x - this.startPoints.point.x
              , n = this.startPoints.box.y + a.y - this.startPoints.point.y
              , r = this.constraint
              , o = a.x - this.startPoints.point.x
              , s = a.y - this.startPoints.point.y;
            if (this.el.fire("dragmove", {
                event: e,
                p: a,
                m: this.m,
                handler: this
            }),
            this.el.event().defaultPrevented)
                return a;
            if ("function" == typeof r) {
                var l = r.call(this.el, i, n, this.m);
                "boolean" == typeof l && (l = {
                    x: l,
                    y: l
                }),
                !0 === l.x ? this.el.x(i) : !1 !== l.x && this.el.x(l.x),
                !0 === l.y ? this.el.y(n) : !1 !== l.y && this.el.y(l.y)
            } else
                "object" == typeof r && (null != r.minX && i < r.minX ? o = (i = r.minX) - this.startPoints.box.x : null != r.maxX && i > r.maxX - t.width && (o = (i = r.maxX - t.width) - this.startPoints.box.x),
                null != r.minY && n < r.minY ? s = (n = r.minY) - this.startPoints.box.y : null != r.maxY && n > r.maxY - t.height && (s = (n = r.maxY - t.height) - this.startPoints.box.y),
                null != r.snapToGrid && (i -= i % r.snapToGrid,
                n -= n % r.snapToGrid,
                o -= o % r.snapToGrid,
                s -= s % r.snapToGrid),
                this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                    x: o,
                    y: s
                }, !0) : this.el.move(i, n));
            return a
        }
        ,
        e.prototype.end = function(e) {
            var t = this.drag(e);
            this.el.fire("dragend", {
                event: e,
                p: t,
                m: this.m,
                handler: this
            }),
            SVG.off(window, "mousemove.drag"),
            SVG.off(window, "touchmove.drag"),
            SVG.off(window, "mouseup.drag"),
            SVG.off(window, "touchend.drag")
        }
        ,
        SVG.extend(SVG.Element, {
            draggable: function(t, a) {
                "function" != typeof t && "object" != typeof t || (a = t,
                t = !0);
                var i = this.remember("_draggable") || new e(this);
                return (t = void 0 === t || t) ? i.init(a || {}, t) : (this.off("mousedown.drag"),
                this.off("touchstart.drag")),
                this
            }
        })
    }
    .call(void 0),
    function() {
        function e(e) {
            this.el = e,
            e.remember("_selectHandler", this),
            this.pointSelection = {
                isSelected: !1
            },
            this.rectSelection = {
                isSelected: !1
            },
            this.pointsList = {
                lt: [0, 0],
                rt: ["width", 0],
                rb: ["width", "height"],
                lb: [0, "height"],
                t: ["width", 0],
                r: ["width", "height"],
                b: ["width", "height"],
                l: [0, "height"]
            },
            this.pointCoord = function(e, t, a) {
                var i = "string" != typeof e ? e : t[e];
                return a ? i / 2 : i
            }
            ,
            this.pointCoords = function(e, t) {
                var a = this.pointsList[e];
                return {
                    x: this.pointCoord(a[0], t, "t" === e || "b" === e),
                    y: this.pointCoord(a[1], t, "r" === e || "l" === e)
                }
            }
        }
        e.prototype.init = function(e, t) {
            var a = this.el.bbox();
            this.options = {};
            var i = this.el.selectize.defaults.points;
            for (var n in this.el.selectize.defaults)
                this.options[n] = this.el.selectize.defaults[n],
                void 0 !== t[n] && (this.options[n] = t[n]);
            var r = ["points", "pointsExclude"];
            for (var n in r) {
                var o = this.options[r[n]];
                "string" == typeof o ? o = o.length > 0 ? o.split(/\s*,\s*/i) : [] : "boolean" == typeof o && "points" === r[n] && (o = o ? i : []),
                this.options[r[n]] = o
            }
            this.options.points = [i, this.options.points].reduce((function(e, t) {
                return e.filter((function(e) {
                    return t.indexOf(e) > -1
                }
                ))
            }
            )),
            this.options.points = [this.options.points, this.options.pointsExclude].reduce((function(e, t) {
                return e.filter((function(e) {
                    return t.indexOf(e) < 0
                }
                ))
            }
            )),
            this.parent = this.el.parent(),
            this.nested = this.nested || this.parent.group(),
            this.nested.matrix(new SVG.Matrix(this.el).translate(a.x, a.y)),
            this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(e) : this.selectRect(e),
            this.observe(),
            this.cleanup()
        }
        ,
        e.prototype.selectPoints = function(e) {
            return this.pointSelection.isSelected = e,
            this.pointSelection.set || (this.pointSelection.set = this.parent.set(),
            this.drawPoints()),
            this
        }
        ,
        e.prototype.getPointArray = function() {
            var e = this.el.bbox();
            return this.el.array().valueOf().map((function(t) {
                return [t[0] - e.x, t[1] - e.y]
            }
            ))
        }
        ,
        e.prototype.drawPoints = function() {
            for (var e = this, t = this.getPointArray(), a = 0, i = t.length; a < i; ++a) {
                var n = function(t) {
                    return function(a) {
                        (a = a || window.event).preventDefault ? a.preventDefault() : a.returnValue = !1,
                        a.stopPropagation();
                        var i = a.pageX || a.touches[0].pageX
                          , n = a.pageY || a.touches[0].pageY;
                        e.el.fire("point", {
                            x: i,
                            y: n,
                            i: t,
                            event: a
                        })
                    }
                }(a)
                  , r = this.drawPoint(t[a][0], t[a][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", n).on("mousedown", n);
                this.pointSelection.set.add(r)
            }
        }
        ,
        e.prototype.drawPoint = function(e, t) {
            var a = this.options.pointType;
            switch (a) {
            case "circle":
                return this.drawCircle(e, t);
            case "rect":
                return this.drawRect(e, t);
            default:
                if ("function" == typeof a)
                    return a.call(this, e, t);
                throw new Error("Unknown " + a + " point type!")
            }
        }
        ,
        e.prototype.drawCircle = function(e, t) {
            return this.nested.circle(this.options.pointSize).center(e, t)
        }
        ,
        e.prototype.drawRect = function(e, t) {
            return this.nested.rect(this.options.pointSize, this.options.pointSize).center(e, t)
        }
        ,
        e.prototype.updatePointSelection = function() {
            var e = this.getPointArray();
            this.pointSelection.set.each((function(t) {
                this.cx() === e[t][0] && this.cy() === e[t][1] || this.center(e[t][0], e[t][1])
            }
            ))
        }
        ,
        e.prototype.updateRectSelection = function() {
            var e = this
              , t = this.el.bbox();
            if (this.rectSelection.set.get(0).attr({
                width: t.width,
                height: t.height
            }),
            this.options.points.length && this.options.points.map((function(a, i) {
                var n = e.pointCoords(a, t);
                e.rectSelection.set.get(i + 1).center(n.x, n.y)
            }
            )),
            this.options.rotationPoint) {
                var a = this.rectSelection.set.length();
                this.rectSelection.set.get(a - 1).center(t.width / 2, 20)
            }
        }
        ,
        e.prototype.selectRect = function(e) {
            var t = this
              , a = this.el.bbox();
            function i(e) {
                return function(a) {
                    (a = a || window.event).preventDefault ? a.preventDefault() : a.returnValue = !1,
                    a.stopPropagation();
                    var i = a.pageX || a.touches[0].pageX
                      , n = a.pageY || a.touches[0].pageY;
                    t.el.fire(e, {
                        x: i,
                        y: n,
                        event: a
                    })
                }
            }
            if (this.rectSelection.isSelected = e,
            this.rectSelection.set = this.rectSelection.set || this.parent.set(),
            this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(a.width, a.height).addClass(this.options.classRect)),
            this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map((function(e, n) {
                var r = t.pointCoords(e, a)
                  , o = t.drawPoint(r.x, r.y).attr("class", t.options.classPoints + "_" + e).on("mousedown", i(e)).on("touchstart", i(e));
                t.rectSelection.set.add(o)
            }
            )),
            this.rectSelection.set.each((function() {
                this.addClass(t.options.classPoints)
            }
            ))),
            this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
                var n = function(e) {
                    (e = e || window.event).preventDefault ? e.preventDefault() : e.returnValue = !1,
                    e.stopPropagation();
                    var a = e.pageX || e.touches[0].pageX
                      , i = e.pageY || e.touches[0].pageY;
                    t.el.fire("rot", {
                        x: a,
                        y: i,
                        event: e
                    })
                }
                  , r = this.drawPoint(a.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", n).on("mousedown", n);
                this.rectSelection.set.add(r)
            }
        }
        ,
        e.prototype.handler = function() {
            var e = this.el.bbox();
            this.nested.matrix(new SVG.Matrix(this.el).translate(e.x, e.y)),
            this.rectSelection.isSelected && this.updateRectSelection(),
            this.pointSelection.isSelected && this.updatePointSelection()
        }
        ,
        e.prototype.observe = function() {
            var e = this;
            if (MutationObserver)
                if (this.rectSelection.isSelected || this.pointSelection.isSelected)
                    this.observerInst = this.observerInst || new MutationObserver((function() {
                        e.handler()
                    }
                    )),
                    this.observerInst.observe(this.el.node, {
                        attributes: !0
                    });
                else
                    try {
                        this.observerInst.disconnect(),
                        delete this.observerInst
                    } catch {}
            else
                this.el.off("DOMAttrModified.select"),
                (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", (function() {
                    e.handler()
                }
                ))
        }
        ,
        e.prototype.cleanup = function() {
            !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each((function() {
                this.remove()
            }
            )),
            this.rectSelection.set.clear(),
            delete this.rectSelection.set),
            !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each((function() {
                this.remove()
            }
            )),
            this.pointSelection.set.clear(),
            delete this.pointSelection.set),
            this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(),
            delete this.nested)
        }
        ,
        SVG.extend(SVG.Element, {
            selectize: function(t, a) {
                return "object" == typeof t && (a = t,
                t = !0),
                (this.remember("_selectHandler") || new e(this)).init(void 0 === t || t, a || {}),
                this
            }
        }),
        SVG.Element.prototype.selectize.defaults = {
            points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
            pointsExclude: [],
            classRect: "svg_select_boundingRect",
            classPoints: "svg_select_points",
            pointSize: 7,
            rotationPoint: !0,
            deepSelect: !1,
            pointType: "circle"
        }
    }(),
    function() {
        (function() {
            function e(e) {
                e.remember("_resizeHandler", this),
                this.el = e,
                this.parameters = {},
                this.lastUpdateCall = null,
                this.p = e.doc().node.createSVGPoint()
            }
            e.prototype.transformPoint = function(e, t, a) {
                return this.p.x = e - (this.offset.x - window.pageXOffset),
                this.p.y = t - (this.offset.y - window.pageYOffset),
                this.p.matrixTransform(a || this.m)
            }
            ,
            e.prototype._extractPosition = function(e) {
                return {
                    x: null != e.clientX ? e.clientX : e.touches[0].clientX,
                    y: null != e.clientY ? e.clientY : e.touches[0].clientY
                }
            }
            ,
            e.prototype.init = function(e) {
                var t = this;
                if (this.stop(),
                "stop" !== e) {
                    for (var a in this.options = {},
                    this.el.resize.defaults)
                        this.options[a] = this.el.resize.defaults[a],
                        void 0 !== e[a] && (this.options[a] = e[a]);
                    this.el.on("lt.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("rt.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("rb.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("lb.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("t.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("r.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("b.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("l.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("rot.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.el.on("point.resize", (function(e) {
                        t.resize(e || window.event)
                    }
                    )),
                    this.update()
                }
            }
            ,
            e.prototype.stop = function() {
                return this.el.off("lt.resize"),
                this.el.off("rt.resize"),
                this.el.off("rb.resize"),
                this.el.off("lb.resize"),
                this.el.off("t.resize"),
                this.el.off("r.resize"),
                this.el.off("b.resize"),
                this.el.off("l.resize"),
                this.el.off("rot.resize"),
                this.el.off("point.resize"),
                this
            }
            ,
            e.prototype.resize = function(e) {
                var t = this;
                this.m = this.el.node.getScreenCTM().inverse(),
                this.offset = {
                    x: window.pageXOffset,
                    y: window.pageYOffset
                };
                var a = this._extractPosition(e.detail.event);
                if (this.parameters = {
                    type: this.el.type,
                    p: this.transformPoint(a.x, a.y),
                    x: e.detail.x,
                    y: e.detail.y,
                    box: this.el.bbox(),
                    rotation: this.el.transform().rotation
                },
                "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]),
                void 0 !== e.detail.i) {
                    var i = this.el.array().valueOf();
                    this.parameters.i = e.detail.i,
                    this.parameters.pointCoords = [i[e.detail.i][0], i[e.detail.i][1]]
                }
                switch (e.type) {
                case "lt":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t);
                        if (this.parameters.box.width - a[0] > 0 && this.parameters.box.height - a[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x + a[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize - a[0]);
                            a = this.checkAspectRatio(a),
                            this.el.move(this.parameters.box.x + a[0], this.parameters.box.y + a[1]).size(this.parameters.box.width - a[0], this.parameters.box.height - a[1])
                        }
                    }
                    ;
                    break;
                case "rt":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, 2);
                        if (this.parameters.box.width + a[0] > 0 && this.parameters.box.height - a[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x - a[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize + a[0]);
                            a = this.checkAspectRatio(a, !0),
                            this.el.move(this.parameters.box.x, this.parameters.box.y + a[1]).size(this.parameters.box.width + a[0], this.parameters.box.height - a[1])
                        }
                    }
                    ;
                    break;
                case "rb":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, 0);
                        if (this.parameters.box.width + a[0] > 0 && this.parameters.box.height + a[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x - a[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize + a[0]);
                            a = this.checkAspectRatio(a),
                            this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + a[0], this.parameters.box.height + a[1])
                        }
                    }
                    ;
                    break;
                case "lb":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, 1);
                        if (this.parameters.box.width - a[0] > 0 && this.parameters.box.height + a[1] > 0) {
                            if ("text" === this.parameters.type)
                                return this.el.move(this.parameters.box.x + a[0], this.parameters.box.y),
                                void this.el.attr("font-size", this.parameters.fontSize - a[0]);
                            a = this.checkAspectRatio(a, !0),
                            this.el.move(this.parameters.box.x + a[0], this.parameters.box.y).size(this.parameters.box.width - a[0], this.parameters.box.height + a[1])
                        }
                    }
                    ;
                    break;
                case "t":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, 2);
                        if (this.parameters.box.height - a[1] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y + a[1]).height(this.parameters.box.height - a[1])
                        }
                    }
                    ;
                    break;
                case "r":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, 0);
                        if (this.parameters.box.width + a[0] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + a[0])
                        }
                    }
                    ;
                    break;
                case "b":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, 0);
                        if (this.parameters.box.height + a[1] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + a[1])
                        }
                    }
                    ;
                    break;
                case "l":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, 1);
                        if (this.parameters.box.width - a[0] > 0) {
                            if ("text" === this.parameters.type)
                                return;
                            this.el.move(this.parameters.box.x + a[0], this.parameters.box.y).width(this.parameters.box.width - a[0])
                        }
                    }
                    ;
                    break;
                case "rot":
                    this.calc = function(e, t) {
                        var a = e + this.parameters.p.x
                          , i = t + this.parameters.p.y
                          , n = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2)
                          , r = Math.atan2(i - this.parameters.box.y - this.parameters.box.height / 2, a - this.parameters.box.x - this.parameters.box.width / 2)
                          , o = this.parameters.rotation + 180 * (r - n) / Math.PI + this.options.snapToAngle / 2;
                        this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o - o % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                    }
                    ;
                    break;
                case "point":
                    this.calc = function(e, t) {
                        var a = this.snapToGrid(e, t, this.parameters.pointCoords[0], this.parameters.pointCoords[1])
                          , i = this.el.array().valueOf();
                        i[this.parameters.i][0] = this.parameters.pointCoords[0] + a[0],
                        i[this.parameters.i][1] = this.parameters.pointCoords[1] + a[1],
                        this.el.plot(i)
                    }
                }
                this.el.fire("resizestart", {
                    dx: this.parameters.x,
                    dy: this.parameters.y,
                    event: e
                }),
                SVG.on(window, "touchmove.resize", (function(e) {
                    t.update(e || window.event)
                }
                )),
                SVG.on(window, "touchend.resize", (function() {
                    t.done()
                }
                )),
                SVG.on(window, "mousemove.resize", (function(e) {
                    t.update(e || window.event)
                }
                )),
                SVG.on(window, "mouseup.resize", (function() {
                    t.done()
                }
                ))
            }
            ,
            e.prototype.update = function(e) {
                if (e) {
                    var t = this._extractPosition(e)
                      , a = this.transformPoint(t.x, t.y)
                      , i = a.x - this.parameters.p.x
                      , n = a.y - this.parameters.p.y;
                    this.lastUpdateCall = [i, n],
                    this.calc(i, n),
                    this.el.fire("resizing", {
                        dx: i,
                        dy: n,
                        event: e
                    })
                } else
                    this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
            }
            ,
            e.prototype.done = function() {
                this.lastUpdateCall = null,
                SVG.off(window, "mousemove.resize"),
                SVG.off(window, "mouseup.resize"),
                SVG.off(window, "touchmove.resize"),
                SVG.off(window, "touchend.resize"),
                this.el.fire("resizedone")
            }
            ,
            e.prototype.snapToGrid = function(e, t, a, i) {
                var n;
                return void 0 !== i ? n = [(a + e) % this.options.snapToGrid, (i + t) % this.options.snapToGrid] : (a = a ?? 3,
                n = [(this.parameters.box.x + e + (1 & a ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + t + (2 & a ? 0 : this.parameters.box.height)) % this.options.snapToGrid]),
                e < 0 && (n[0] -= this.options.snapToGrid),
                t < 0 && (n[1] -= this.options.snapToGrid),
                e -= Math.abs(n[0]) < this.options.snapToGrid / 2 ? n[0] : n[0] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid),
                t -= Math.abs(n[1]) < this.options.snapToGrid / 2 ? n[1] : n[1] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid),
                this.constraintToBox(e, t, a, i)
            }
            ,
            e.prototype.constraintToBox = function(e, t, a, i) {
                var n, r, o = this.options.constraint || {};
                return void 0 !== i ? (n = a,
                r = i) : (n = this.parameters.box.x + (1 & a ? 0 : this.parameters.box.width),
                r = this.parameters.box.y + (2 & a ? 0 : this.parameters.box.height)),
                void 0 !== o.minX && n + e < o.minX && (e = o.minX - n),
                void 0 !== o.maxX && n + e > o.maxX && (e = o.maxX - n),
                void 0 !== o.minY && r + t < o.minY && (t = o.minY - r),
                void 0 !== o.maxY && r + t > o.maxY && (t = o.maxY - r),
                [e, t]
            }
            ,
            e.prototype.checkAspectRatio = function(e, t) {
                if (!this.options.saveAspectRatio)
                    return e;
                var a = e.slice()
                  , i = this.parameters.box.width / this.parameters.box.height
                  , n = this.parameters.box.width + e[0]
                  , r = this.parameters.box.height - e[1]
                  , o = n / r;
                return o < i ? (a[1] = n / i - this.parameters.box.height,
                t && (a[1] = -a[1])) : o > i && (a[0] = this.parameters.box.width - r * i,
                t && (a[0] = -a[0])),
                a
            }
            ,
            SVG.extend(SVG.Element, {
                resize: function(t) {
                    return (this.remember("_resizeHandler") || new e(this)).init(t || {}),
                    this
                }
            }),
            SVG.Element.prototype.resize.defaults = {
                snapToAngle: .1,
                snapToGrid: 1,
                constraint: {},
                saveAspectRatio: !1
            }
        }
        ).call(this)
    }(),
    void 0 === window.Apex && (window.Apex = {});
    var Ye = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "initModules",
            value: function() {
                this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"],
                this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"],
                this.ctx.animations = new x(this.ctx),
                this.ctx.axes = new Q(this.ctx),
                this.ctx.core = new He(this.ctx.el,this.ctx),
                this.ctx.config = new B({}),
                this.ctx.data = new Y(this.ctx),
                this.ctx.grid = new $(this.ctx),
                this.ctx.graphics = new w(this.ctx),
                this.ctx.coreUtils = new k(this.ctx),
                this.ctx.crosshairs = new ee(this.ctx),
                this.ctx.events = new K(this.ctx),
                this.ctx.exports = new G(this.ctx),
                this.ctx.localization = new J(this.ctx),
                this.ctx.options = new I,
                this.ctx.responsive = new te(this.ctx),
                this.ctx.series = new X(this.ctx),
                this.ctx.theme = new ae(this.ctx),
                this.ctx.formatters = new E(this.ctx),
                this.ctx.titleSubtitle = new ie(this.ctx),
                this.ctx.legend = new ue(this.ctx),
                this.ctx.toolbar = new de(this.ctx),
                this.ctx.tooltip = new xe(this.ctx),
                this.ctx.dimensions = new le(this.ctx),
                this.ctx.updateHelpers = new Xe(this.ctx),
                this.ctx.zoomPanSelection = new he(this.ctx),
                this.ctx.w.globals.tooltip = new xe(this.ctx)
            }
        }]),
        e
    }()
      , We = function() {
        function e(t) {
            r(this, e),
            this.ctx = t,
            this.w = t.w
        }
        return s(e, [{
            key: "clear",
            value: function(e) {
                var t = e.isUpdating;
                this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(),
                this.ctx.toolbar && this.ctx.toolbar.destroy(),
                this.ctx.animations = null,
                this.ctx.axes = null,
                this.ctx.annotations = null,
                this.ctx.core = null,
                this.ctx.data = null,
                this.ctx.grid = null,
                this.ctx.series = null,
                this.ctx.responsive = null,
                this.ctx.theme = null,
                this.ctx.formatters = null,
                this.ctx.titleSubtitle = null,
                this.ctx.legend = null,
                this.ctx.dimensions = null,
                this.ctx.options = null,
                this.ctx.crosshairs = null,
                this.ctx.zoomPanSelection = null,
                this.ctx.updateHelpers = null,
                this.ctx.toolbar = null,
                this.ctx.localization = null,
                this.ctx.w.globals.tooltip = null,
                this.clearDomElements({
                    isUpdating: t
                })
            }
        }, {
            key: "killSVG",
            value: function(e) {
                e.each((function(e, t) {
                    this.removeClass("*"),
                    this.off(),
                    this.stop()
                }
                ), !0),
                e.ungroup(),
                e.clear()
            }
        }, {
            key: "clearDomElements",
            value: function(e) {
                var t = this
                  , a = e.isUpdating
                  , i = this.w.globals.dom.Paper.node;
                i.parentNode && i.parentNode.parentNode && !a && (i.parentNode.parentNode.style.minHeight = "unset");
                var n = this.w.globals.dom.baseEl;
                n && this.ctx.eventList.forEach((function(e) {
                    n.removeEventListener(e, t.ctx.events.documentEvent)
                }
                ));
                var r = this.w.globals.dom;
                if (null !== this.ctx.el)
                    for (; this.ctx.el.firstChild; )
                        this.ctx.el.removeChild(this.ctx.el.firstChild);
                this.killSVG(r.Paper),
                r.Paper.remove(),
                r.elWrap = null,
                r.elGraphical = null,
                r.elLegendWrap = null,
                r.elLegendForeign = null,
                r.baseEl = null,
                r.elGridRect = null,
                r.elGridRectMask = null,
                r.elGridRectMarkerMask = null,
                r.elForecastMask = null,
                r.elNonForecastMask = null,
                r.elDefs = null
            }
        }]),
        e
    }()
      , Ge = new WeakMap
      , je = function() {
        function e(t, a) {
            r(this, e),
            this.opts = a,
            this.ctx = this,
            this.w = new D(a).init(),
            this.el = t,
            this.w.globals.cuid = b.randomId(),
            this.w.globals.chartID = this.w.config.chart.id ? b.escapeString(this.w.config.chart.id) : this.w.globals.cuid,
            new Ye(this).initModules(),
            this.create = b.bind(this.create, this),
            this.windowResizeHandler = this._windowResizeHandler.bind(this),
            this.parentResizeHandler = this._parentResizeCallback.bind(this)
        }
        return s(e, [{
            key: "render",
            value: function() {
                var e = this;
                return new Promise((function(t, a) {
                    if (null !== e.el) {
                        void 0 === Apex._chartInstances && (Apex._chartInstances = []),
                        e.w.config.chart.id && Apex._chartInstances.push({
                            id: e.w.globals.chartID,
                            group: e.w.config.chart.group,
                            chart: e
                        }),
                        e.setLocale(e.w.config.chart.defaultLocale);
                        var i = e.w.config.chart.events.beforeMount;
                        if ("function" == typeof i && i(e, e.w),
                        e.events.fireEvent("beforeMount", [e, e.w]),
                        window.addEventListener("resize", e.windowResizeHandler),
                        function(e, t) {
                            var a = !1;
                            if (e.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                                var i = e.getBoundingClientRect();
                                "none" !== e.style.display && 0 !== i.width || (a = !0)
                            }
                            var n = new ResizeObserver((function(i) {
                                a && t.call(e, i),
                                a = !0
                            }
                            ));
                            e.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(e.children).forEach((function(e) {
                                return n.observe(e)
                            }
                            )) : n.observe(e),
                            Ge.set(t, n)
                        }(e.el.parentNode, e.parentResizeHandler),
                        !e.css) {
                            var n = e.el.getRootNode && e.el.getRootNode()
                              , r = b.is("ShadowRoot", n)
                              , o = e.el.ownerDocument
                              , s = o.getElementById("apexcharts-css");
                            if (r || !s) {
                                var l;
                                e.css = document.createElement("style"),
                                e.css.id = "apexcharts-css",
                                e.css.textContent = '@keyframes opaque {\n  0% {\n      opacity: 0\n  }\n\n  to {\n      opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n  0%,to {\n      opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0,0,0,.5);\n  box-shadow: 0 0 1px rgba(255,255,255,.5);\n  -webkit-box-shadow: 0 0 1px rgba(255,255,255,.5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\n.legend-mouseover-inactive {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255,255,255,.96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30,30,30,.8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0,0,0,.7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,.apexcharts-tooltip-text-y-value,.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,.apexcharts-tooltip-text-goals-value:empty,.apexcharts-tooltip-text-y-label:empty,.apexcharts-tooltip-text-y-value:empty,.apexcharts-tooltip-text-z-value:empty,.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,.apexcharts-tooltip-text-goals-label,.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0!important\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0,0,0,.7);\n  border: 1px solid rgba(0,0,0,.5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0,0,0,.5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_boundingRect,.svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_boundingRect,.apexcharts-selection-rect+g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden\n}\n\n.apexcharts-selection-rect+g .svg_select_points_l,.apexcharts-selection-rect+g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,.apexcharts-pan-icon,.apexcharts-reset-icon,.apexcharts-selection-icon,.apexcharts-toolbar-custom-icon,.apexcharts-zoom-icon,.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,.apexcharts-reset-icon svg,.apexcharts-zoom-icon svg,.apexcharts-zoomin-icon svg,.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,.apexcharts-theme-dark .apexcharts-pan-icon svg,.apexcharts-theme-dark .apexcharts-reset-icon svg,.apexcharts-theme-dark .apexcharts-selection-icon svg,.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,.apexcharts-theme-dark .apexcharts-zoom-icon svg,.apexcharts-theme-dark .apexcharts-zoomin-icon svg,.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,.apexcharts-theme-light .apexcharts-reset-icon:hover svg,.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,.apexcharts-reset-icon,.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0,0,0,.7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n      opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,.apexcharts-datalabel.apexcharts-element-hidden,.apexcharts-hide .apexcharts-series-points {\n  opacity: 0\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n.apexcharts-datalabel,.apexcharts-datalabel-label,.apexcharts-datalabel-value,.apexcharts-datalabels,.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,.apexcharts-area-series .apexcharts-area,.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-gridline,.apexcharts-line,.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,.apexcharts-point-annotation-label,.apexcharts-radar-series path,.apexcharts-radar-series polygon,.apexcharts-toolbar svg,.apexcharts-tooltip .apexcharts-marker,.apexcharts-xaxis-annotation-label,.apexcharts-yaxis-annotation-label,.apexcharts-zoom-rect {\n  pointer-events: none\n}\n\n.apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,.resize-triggers,.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers{\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows{\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers{\n  pointer-events: none\n}';
                                var c = (null === (l = e.opts.chart) || void 0 === l ? void 0 : l.nonce) || e.w.config.chart.nonce;
                                c && e.css.setAttribute("nonce", c),
                                r ? n.prepend(e.css) : o.head.appendChild(e.css)
                            }
                        }
                        var u = e.create(e.w.config.series, {});
                        if (!u)
                            return t(e);
                        e.mount(u).then((function() {
                            "function" == typeof e.w.config.chart.events.mounted && e.w.config.chart.events.mounted(e, e.w),
                            e.events.fireEvent("mounted", [e, e.w]),
                            t(u)
                        }
                        )).catch((function(e) {
                            a(e)
                        }
                        ))
                    } else
                        a(new Error("Element not found"))
                }
                ))
            }
        }, {
            key: "create",
            value: function(e, t) {
                var a = this.w;
                new Ye(this).initModules();
                var i = this.w.globals;
                if (i.noData = !1,
                i.animationEnded = !1,
                this.responsive.checkResponsiveConfig(t),
                a.config.xaxis.convertedCatToNumeric && new F(a.config).convertCatToNumericXaxis(a.config, this.ctx),
                null === this.el || (this.core.setupElements(),
                "treemap" === a.config.chart.type && (a.config.grid.show = !1,
                a.config.yaxis[0].show = !1),
                0 === i.svgWidth))
                    return i.animationEnded = !0,
                    null;
                var n = k.checkComboSeries(e);
                i.comboCharts = n.comboCharts,
                i.comboBarCount = n.comboBarCount;
                var r = e.every((function(e) {
                    return e.data && 0 === e.data.length
                }
                ));
                (0 === e.length || r) && this.series.handleNoData(),
                this.events.setupEventHandlers(),
                this.data.parseData(e),
                this.theme.init(),
                new N(this).setGlobalMarkerSize(),
                this.formatters.setLabelFormatters(),
                this.titleSubtitle.draw(),
                i.noData && i.collapsedSeries.length !== i.series.length && !a.config.legend.showForSingleSeries || this.legend.init(),
                this.series.hasAllSeriesEqualX(),
                i.axisCharts && (this.core.coreCalculations(),
                "category" !== a.config.xaxis.type && this.formatters.setLabelFormatters(),
                this.ctx.toolbar.minX = a.globals.minX,
                this.ctx.toolbar.maxX = a.globals.maxX),
                this.formatters.heatmapLabelFormatters(),
                new k(this).getLargestMarkerSize(),
                this.dimensions.plotCoords();
                var o = this.core.xySettings();
                this.grid.createGridMask();
                var s = this.core.plotChartType(e, o)
                  , l = new H(this);
                return l.bringForward(),
                a.config.dataLabels.background.enabled && l.dataLabelsBackground(),
                this.core.shiftGraphPosition(),
                {
                    elGraph: s,
                    xyRatios: o,
                    dimensions: {
                        plot: {
                            left: a.globals.translateX,
                            top: a.globals.translateY,
                            width: a.globals.gridWidth,
                            height: a.globals.gridHeight
                        }
                    }
                }
            }
        }, {
            key: "mount",
            value: function() {
                var e = this
                  , t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null
                  , a = this
                  , i = a.w;
                return new Promise((function(n, r) {
                    if (null === a.el)
                        return r(new Error("Not enough data to display or target element not found"));
                    (null === t || i.globals.allSeriesCollapsed) && a.series.handleNoData(),
                    a.grid = new $(a);
                    var o, s, l = a.grid.drawGrid();
                    if (a.annotations = new _(a),
                    a.annotations.drawImageAnnos(),
                    a.annotations.drawTextAnnos(),
                    "back" === i.config.grid.position && (l && i.globals.dom.elGraphical.add(l.el),
                    null != l && null !== (o = l.elGridBorders) && void 0 !== o && o.node && i.globals.dom.elGraphical.add(l.elGridBorders)),
                    Array.isArray(t.elGraph))
                        for (var c = 0; c < t.elGraph.length; c++)
                            i.globals.dom.elGraphical.add(t.elGraph[c]);
                    else
                        i.globals.dom.elGraphical.add(t.elGraph);
                    "front" === i.config.grid.position && (l && i.globals.dom.elGraphical.add(l.el),
                    null != l && null !== (s = l.elGridBorders) && void 0 !== s && s.node && i.globals.dom.elGraphical.add(l.elGridBorders)),
                    "front" === i.config.xaxis.crosshairs.position && a.crosshairs.drawXCrosshairs(),
                    "front" === i.config.yaxis[0].crosshairs.position && a.crosshairs.drawYCrosshairs(),
                    "treemap" !== i.config.chart.type && a.axes.drawAxis(i.config.chart.type, l);
                    var u = new j(e.ctx,l)
                      , d = new Z(e.ctx,l);
                    if (null !== l && (u.xAxisLabelCorrections(l.xAxisTickWidth),
                    d.setYAxisTextAlignments(),
                    i.config.yaxis.map((function(e, t) {
                        -1 === i.globals.ignoreYAxisIndexes.indexOf(t) && d.yAxisTitleRotate(t, e.opposite)
                    }
                    ))),
                    a.annotations.drawAxesAnnotations(),
                    !i.globals.noData) {
                        if (i.config.tooltip.enabled && !i.globals.noData && a.w.globals.tooltip.drawTooltip(t.xyRatios),
                        i.globals.axisCharts && (i.globals.isXNumeric || i.config.xaxis.convertedCatToNumeric || i.globals.isRangeBar))
                            (i.config.chart.zoom.enabled || i.config.chart.selection && i.config.chart.selection.enabled || i.config.chart.pan && i.config.chart.pan.enabled) && a.zoomPanSelection.init({
                                xyRatios: t.xyRatios
                            });
                        else {
                            var h = i.config.chart.toolbar.tools;
                            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach((function(e) {
                                h[e] = !1
                            }
                            ))
                        }
                        i.config.chart.toolbar.show && !i.globals.allSeriesCollapsed && a.toolbar.createToolbar()
                    }
                    i.globals.memory.methodsToExec.length > 0 && i.globals.memory.methodsToExec.forEach((function(e) {
                        e.method(e.params, !1, e.context)
                    }
                    )),
                    i.globals.axisCharts || i.globals.noData || a.core.resizeNonAxisCharts(),
                    n(a)
                }
                ))
            }
        }, {
            key: "destroy",
            value: function() {
                var e, t;
                window.removeEventListener("resize", this.windowResizeHandler),
                this.el.parentNode,
                e = this.parentResizeHandler,
                (t = Ge.get(e)) && (t.disconnect(),
                Ge.delete(e));
                var a = this.w.config.chart.id;
                a && Apex._chartInstances.forEach((function(e, t) {
                    e.id === b.escapeString(a) && Apex._chartInstances.splice(t, 1)
                }
                )),
                new We(this.ctx).clear({
                    isUpdating: !1
                })
            }
        }, {
            key: "updateOptions",
            value: function(e) {
                var t = this
                  , a = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]
                  , i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , n = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3]
                  , r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4]
                  , o = this.w;
                return o.globals.selection = void 0,
                e.series && (this.series.resetSeries(!1, !0, !1),
                e.series.length && e.series[0].data && (e.series = e.series.map((function(e, a) {
                    return t.updateHelpers._extendSeries(e, a)
                }
                ))),
                this.updateHelpers.revertDefaultAxisMinMax()),
                e.xaxis && (e = this.updateHelpers.forceXAxisUpdate(e)),
                e.yaxis && (e = this.updateHelpers.forceYAxisUpdate(e)),
                o.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(),
                e.theme && (e = this.theme.updateThemeOptions(e)),
                this.updateHelpers._updateOptions(e, a, i, n, r)
            }
        }, {
            key: "updateSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                return this.series.resetSeries(!1),
                this.updateHelpers.revertDefaultAxisMinMax(),
                this.updateHelpers._updateSeries(e, t, a)
            }
        }, {
            key: "appendSeries",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
                  , i = this.w.config.series.slice();
                return i.push(e),
                this.series.resetSeries(!1),
                this.updateHelpers.revertDefaultAxisMinMax(),
                this.updateHelpers._updateSeries(i, t, a)
            }
        }, {
            key: "appendData",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , a = this;
                a.w.globals.dataChanged = !0,
                a.series.getPreviousPaths();
                for (var i = a.w.config.series.slice(), n = 0; n < i.length; n++)
                    if (null !== e[n] && void 0 !== e[n])
                        for (var r = 0; r < e[n].data.length; r++)
                            i[n].data.push(e[n].data[r]);
                return a.w.config.series = i,
                t && (a.w.globals.initialSeries = b.clone(a.w.config.series)),
                this.update()
            }
        }, {
            key: "update",
            value: function(e) {
                var t = this;
                return new Promise((function(a, i) {
                    new We(t.ctx).clear({
                        isUpdating: !0
                    });
                    var n = t.create(t.w.config.series, e);
                    if (!n)
                        return a(t);
                    t.mount(n).then((function() {
                        "function" == typeof t.w.config.chart.events.updated && t.w.config.chart.events.updated(t, t.w),
                        t.events.fireEvent("updated", [t, t.w]),
                        t.w.globals.isDirty = !0,
                        a(t)
                    }
                    )).catch((function(e) {
                        i(e)
                    }
                    ))
                }
                ))
            }
        }, {
            key: "getSyncedCharts",
            value: function() {
                var e = this.getGroupedCharts()
                  , t = [this];
                return e.length && (t = [],
                e.forEach((function(e) {
                    t.push(e)
                }
                ))),
                t
            }
        }, {
            key: "getGroupedCharts",
            value: function() {
                var e = this;
                return Apex._chartInstances.filter((function(e) {
                    if (e.group)
                        return !0
                }
                )).map((function(t) {
                    return e.w.config.chart.group === t.group ? t.chart : e
                }
                ))
            }
        }, {
            key: "toggleSeries",
            value: function(e) {
                return this.series.toggleSeries(e)
            }
        }, {
            key: "highlightSeriesOnLegendHover",
            value: function(e, t) {
                return this.series.toggleSeriesOnHover(e, t)
            }
        }, {
            key: "showSeries",
            value: function(e) {
                this.series.showSeries(e)
            }
        }, {
            key: "hideSeries",
            value: function(e) {
                this.series.hideSeries(e)
            }
        }, {
            key: "isSeriesHidden",
            value: function(e) {
                this.series.isSeriesHidden(e)
            }
        }, {
            key: "resetSeries",
            value: function() {
                var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
                  , t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.series.resetSeries(e, t)
            }
        }, {
            key: "addEventListener",
            value: function(e, t) {
                this.events.addEventListener(e, t)
            }
        }, {
            key: "removeEventListener",
            value: function(e, t) {
                this.events.removeEventListener(e, t)
            }
        }, {
            key: "addXaxisAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , i = this;
                a && (i = a),
                i.annotations.addXaxisAnnotationExternal(e, t, i)
            }
        }, {
            key: "addYaxisAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , i = this;
                a && (i = a),
                i.annotations.addYaxisAnnotationExternal(e, t, i)
            }
        }, {
            key: "addPointAnnotation",
            value: function(e) {
                var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1]
                  , a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0
                  , i = this;
                a && (i = a),
                i.annotations.addPointAnnotationExternal(e, t, i)
            }
        }, {
            key: "clearAnnotations",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0
                  , t = this;
                e && (t = e),
                t.annotations.clearAnnotations(t)
            }
        }, {
            key: "removeAnnotation",
            value: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0
                  , a = this;
                t && (a = t),
                a.annotations.removeAnnotation(a, e)
            }
        }, {
            key: "getChartArea",
            value: function() {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
            }
        }, {
            key: "getSeriesTotalXRange",
            value: function(e, t) {
                return this.coreUtils.getSeriesTotalsXRange(e, t)
            }
        }, {
            key: "getHighestValueInSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return new q(this.ctx).getMinYMaxY(e).highestY
            }
        }, {
            key: "getLowestValueInSeries",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                return new q(this.ctx).getMinYMaxY(e).lowestY
            }
        }, {
            key: "getSeriesTotal",
            value: function() {
                return this.w.globals.seriesTotals
            }
        }, {
            key: "toggleDataPointSelection",
            value: function(e, t) {
                return this.updateHelpers.toggleDataPointSelection(e, t)
            }
        }, {
            key: "zoomX",
            value: function(e, t) {
                this.ctx.toolbar.zoomUpdateOptions(e, t)
            }
        }, {
            key: "setLocale",
            value: function(e) {
                this.localization.setCurrentLocaleValues(e)
            }
        }, {
            key: "dataURI",
            value: function(e) {
                return new G(this.ctx).dataURI(e)
            }
        }, {
            key: "exportToCSV",
            value: function() {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                return new G(this.ctx).exportToCSV(e)
            }
        }, {
            key: "paper",
            value: function() {
                return this.w.globals.dom.Paper
            }
        }, {
            key: "_parentResizeCallback",
            value: function() {
                this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
            }
        }, {
            key: "_windowResize",
            value: function() {
                var e = this;
                clearTimeout(this.w.globals.resizeTimer),
                this.w.globals.resizeTimer = window.setTimeout((function() {
                    e.w.globals.resized = !0,
                    e.w.globals.dataChanged = !1,
                    e.ctx.update()
                }
                ), 150)
            }
        }, {
            key: "_windowResizeHandler",
            value: function() {
                var e = this.w.config.chart.redrawOnWindowResize;
                "function" == typeof e && (e = e()),
                e && this._windowResize()
            }
        }], [{
            key: "getChartByID",
            value: function(e) {
                var t = b.escapeString(e);
                if (Apex._chartInstances) {
                    var a = Apex._chartInstances.filter((function(e) {
                        return e.id === t
                    }
                    ))[0];
                    return a && a.chart
                }
            }
        }, {
            key: "initOnLoad",
            value: function() {
                for (var t = document.querySelectorAll("[data-apexcharts]"), a = 0; a < t.length; a++)
                    new e(t[a],JSON.parse(t[a].getAttribute("data-options"))).render()
            }
        }, {
            key: "exec",
            value: function(e, t) {
                var a = this.getChartByID(e);
                if (a) {
                    a.w.globals.isExecCalled = !0;
                    var i = null;
                    if (-1 !== a.publicMethods.indexOf(t)) {
                        for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
                            r[o - 2] = arguments[o];
                        i = a[t].apply(a, r)
                    }
                    return i
                }
            }
        }, {
            key: "merge",
            value: function(e, t) {
                return b.extend(e, t)
            }
        }]),
        e
    }();
    e.exports = je
}(pv, pv.exports);
const vv = hv(pv.exports)
  , gv = ["animationEnd", "beforeMount", "mounted", "updated", "click", "mouseMove", "mouseLeave", "legendClick", "markerClick", "selection", "dataPointSelection", "dataPointMouseEnter", "dataPointMouseLeave", "beforeZoom", "beforeResetZoom", "zoomed", "scrolled", "brushScrolled"]
  , fv = a({
    name: "apexchart",
    props: {
        options: {
            type: Object
        },
        type: {
            type: String
        },
        series: {
            type: Array,
            required: !0
        },
        width: {
            default: "100%"
        },
        height: {
            default: "auto"
        }
    },
    emits: gv,
    setup(e, {emit: t}) {
        const a = l(null)
          , i = l(null)
          , n = e => e && "object" == typeof e && !Array.isArray(e) && null != e
          , r = (e, t) => {
            "function" != typeof Object.assign && (Object.assign = function(e) {
                if (null == e)
                    throw new TypeError("Cannot convert undefined or null to object");
                let t = Object(e);
                for (let a = 1; a < arguments.length; a++) {
                    let e = arguments[a];
                    if (null != e)
                        for (let a in e)
                            e.hasOwnProperty(a) && (t[a] = e[a])
                }
                return t
            }
            );
            let a = Object.assign({}, e);
            return n(e) && n(t) && Object.keys(t).forEach((i => {
                n(t[i]) ? i in e ? a[i] = r(e[i], t[i]) : Object.assign(a, {
                    [i]: t[i]
                }) : Object.assign(a, {
                    [i]: t[i]
                })
            }
            )),
            a
        }
          , o = async () => {
            if (await q(),
            i.value)
                return;
            const n = {
                chart: {
                    type: e.type || e.options.chart.type || "line",
                    height: e.height,
                    width: e.width,
                    events: {}
                },
                series: e.series
            };
            gv.forEach((e => {
                n.chart.events[e] = (...a) => t(e, ...a)
            }
            ));
            const o = r(e.options, n);
            return i.value = new vv(a.value,o),
            i.value.render()
        }
          , s = () => (c(),
        o())
          , c = () => {
            i.value.destroy()
        }
        ;
        U(( () => {
            window.ApexCharts = vv
        }
        )),
        ae(( () => {
            a.value = oa().proxy.$el,
            o()
        }
        )),
        Z(( () => {
            i.value && c()
        }
        ));
        const u = O(e);
        return $(u.options, ( () => {
            !i.value && e.options ? o() : i.value.updateOptions(e.options)
        }
        )),
        $(u.series, ( () => {
            !i.value && e.series ? o() : i.value.updateSeries(e.series)
        }
        ), {
            deep: !0
        }),
        $(u.type, ( () => {
            s()
        }
        )),
        $(u.width, ( () => {
            s()
        }
        )),
        $(u.height, ( () => {
            s()
        }
        )),
        {
            chart: i,
            init: o,
            refresh: s,
            destroy: c,
            updateOptions: (e, t, a, n) => i.value.updateOptions(e, t, a, n),
            updateSeries: (e, t) => i.value.updateSeries(e, t),
            toggleSeries: e => i.value.toggleSeries(e),
            showSeries: e => {
                i.value.showSeries(e)
            }
            ,
            hideSeries: e => {
                i.value.hideSeries(e)
            }
            ,
            resetSeries: () => {
                i.value.resetSeries()
            }
            ,
            zoomX: (e, t) => i.value.zoomX(e, t),
            toggleDataPointSelection: (e, t) => {
                i.value.toggleDataPointSelection(e, t)
            }
            ,
            appendData: e => i.value.appendData(e),
            appendSeries: (e, t) => i.value.appendSeries(e, t),
            addXaxisAnnotation: (e, t) => {
                i.value.addXaxisAnnotation(e, t)
            }
            ,
            addYaxisAnnotation: (e, t) => {
                i.value.addYaxisAnnotation(e, t)
            }
            ,
            addPointAnnotation: (e, t) => {
                i.value.addPointAnnotation(e, t)
            }
            ,
            removeAnnotation: (e, t) => {
                i.value.removeAnnotation(e, t)
            }
            ,
            clearAnnotations: () => {
                i.value.clearAnnotations()
            }
            ,
            setLocale: e => i.value.setLocale(e),
            dataURI: e => i.value.dataURI(e)
        }
    },
    render: () => S("div", {
        class: "vue-apexcharts"
    })
});
fv.install = e => {
    e.component(fv.name, fv)
}
,
function() {
    try {
        if ("undefined" != typeof document) {
            var e = document.createElement("style");
            e.appendChild(document.createTextNode('.vue3-marquee{display:flex!important;position:relative}.vue3-marquee.horizontal{overflow-x:hidden!important;flex-direction:row!important;width:100%;height:max-content}.vue3-marquee.vertical{overflow-y:hidden!important;flex-direction:column!important;height:100%;width:max-content}.vue3-marquee:hover>.marquee{animation-play-state:var(--pauseOnHover)}.vue3-marquee:active>.marquee{animation-play-state:var(--pauseOnClick)}.vue3-marquee>.marquee{flex:0 0 auto;min-width:var(--min-width);min-height:var(--min-height);z-index:1;animation:var(--orientation) var(--duration) linear var(--delay) var(--loops);animation-play-state:var(--pauseAnimation);animation-direction:var(--direction)}.vue3-marquee.horizontal>.marquee{display:flex;flex-direction:row;align-items:center}.vue3-marquee.vertical>.marquee{display:flex;flex-direction:column;align-items:center}@keyframes scrollX{0%{transform:translate(0)}to{transform:translate(-100%)}}@keyframes scrollY{0%{transform:translateY(0)}to{transform:translateY(-100%)}}.vue3-marquee>.overlay{position:absolute;width:100%;height:100%}.vue3-marquee>.transparent-overlay{position:absolute;width:100%;height:100%}.vue3-marquee>.overlay:before,.vue3-marquee>.overlay:after{content:"";position:absolute;z-index:2}.vue3-marquee.horizontal>.overlay:before,.vue3-marquee.horizontal>.overlay:after{background:linear-gradient(to right,var(--gradient-color));height:100%;width:var(--gradient-length)}.vue3-marquee.vertical>.overlay:before,.vue3-marquee.vertical>.overlay:after{background:linear-gradient(to bottom,var(--gradient-color));height:var(--gradient-length);width:100%}.vue3-marquee.horizontal>.overlay:after{transform:rotate(180deg)}.vue3-marquee.vertical>.overlay:after{transform:rotate(-180deg)}.vue3-marquee>.overlay:before{left:0;top:0}.vue3-marquee.horizontal>.overlay:after{right:0;top:0}.vue3-marquee.vertical>.overlay:after{left:0;bottom:0}')),
            document.head.appendChild(e)
        }
    } catch (t) {}
}();
var mv = Object.defineProperty
  , bv = Object.getOwnPropertySymbols
  , xv = Object.prototype.hasOwnProperty
  , yv = Object.prototype.propertyIsEnumerable
  , wv = (e, t, a) => t in e ? mv(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : e[t] = a
  , kv = (e, t) => {
    for (var a in t || (t = {}))
        xv.call(t, a) && wv(e, a, t[a]);
    if (bv)
        for (var a of bv(t))
            yv.call(t, a) && wv(e, a, t[a]);
    return e
}
  , Sv = (e, t) => {
    const a = e.__vccOpts || e;
    for (const [i,n] of t)
        a[i] = n;
    return a
}
;
const Cv = a({
    props: {
        vertical: {
            type: Boolean,
            default: !1
        },
        direction: {
            type: String,
            default: "normal"
        },
        duration: {
            type: Number,
            default: 20
        },
        delay: {
            type: Number,
            default: 0
        },
        loop: {
            type: Number,
            default: 0
        },
        clone: {
            type: Boolean,
            default: !1
        },
        gradient: {
            type: Boolean,
            default: !1
        },
        gradientColor: {
            type: Array,
            default: [255, 255, 255]
        },
        gradientWidth: {
            type: String
        },
        gradientLength: {
            type: String
        },
        pauseOnHover: {
            type: Boolean,
            default: !1
        },
        pauseOnClick: {
            type: Boolean,
            default: !1
        },
        pause: {
            type: Boolean,
            default: !1
        },
        animateOnOverflowOnly: {
            type: Boolean,
            default: !1
        }
    },
    emits: ["onComplete", "onLoopComplete", "onPause", "onResume", "onOverflowDetected", "onOverflowCleared"],
    setup(e, {emit: t}) {
        const a = l(0)
          , i = l("100%")
          , n = l("100%")
          , r = l(0)
          , o = l(!1)
          , s = l(!0)
          , c = l(0)
          , u = l(0)
          , d = l(0)
          , h = l(0)
          , p = l(!1)
          , v = l(!1)
          , g = l(0)
          , f = l(null)
          , m = l("200px")
          , b = l(!1)
          , x = l(null)
          , y = l(null)
          , w = async () => {
            await k(),
            r.value++
        }
          , k = async () => {
            e.vertical && (o.value = !0),
            setInterval(( () => {
                if (i.value = "0%",
                n.value = "0%",
                null !== x.value && null !== y.value && x.value && y.value) {
                    if (e.vertical && "clientHeight"in x.value && "clientHeight"in y.value) {
                        h.value = x.value.clientHeight,
                        d.value = y.value.clientHeight;
                        const t = Math.ceil(d.value / h.value);
                        return a.value = e.animateOnOverflowOnly ? 0 : isFinite(t) ? t : 0,
                        o.value = !1,
                        a.value
                    }
                    if (!e.vertical && "clientWidth"in x.value && "clientWidth"in y.value) {
                        if (u.value = x.value.clientWidth,
                        c.value = y.value.clientWidth,
                        e.animateOnOverflowOnly && b.value)
                            return u.value <= c.value ? (s.value = !0,
                            t("onOverflowCleared")) : (s.value = !1,
                            t("onOverflowDetected")),
                            0;
                        const i = Math.ceil(c.value / u.value);
                        return a.value = isFinite(i) ? i : 0,
                        a.value
                    }
                    return i.value = "100%",
                    n.value = "100%",
                    0
                }
                return i.value = "100%",
                n.value = "100%",
                0
            }
            ), 100)
        }
        ;
        $(u, (async () => {
            e.clone && w()
        }
        )),
        $(c, (async () => {
            (e.clone || e.animateOnOverflowOnly) && w()
        }
        )),
        $(( () => e.pause), ( (e, a) => {
            e !== a && t(e ? "onResume" : "onPause")
        }
        ));
        const S = F(( () => e.pause || e.vertical && o.value || e.animateOnOverflowOnly && s.value ? "paused" : "running"))
          , C = F(( () => e.pauseOnHover && (p.value || v.value) ? "paused" : e.pauseOnHover || "paused" !== S.value ? "running" : "paused"))
          , A = F(( () => e.pauseOnHover && p.value || e.pauseOnClick && v.value ? "paused" : e.pauseOnHover || "paused" !== S.value ? "running" : "paused"))
          , P = F(( () => {
            const t = {
                "--duration": `${e.duration}s`,
                "--delay": `${e.delay}s`,
                "--direction": `${e.direction}`,
                "--pauseOnHover": `${C.value}`,
                "--pauseOnClick": `${A.value}`,
                "--pauseAnimation": `${S.value}`,
                "--loops": `${0 === e.loop ? "infinite" : e.loop}`,
                "--gradient-color": `rgba(${e.gradientColor[0]}, ${e.gradientColor[1]}, ${e.gradientColor[2]}, 1), rgba(${e.gradientColor[0]}, ${e.gradientColor[1]}, ${e.gradientColor[2]}, 0)`,
                "--gradient-length": `${m.value}`,
                "--min-width": `${i.value}`,
                "--min-height": `${n.value}`
            }
              , a = {
                "--orientation": "scrollX",
                orientation: "horizontal"
            };
            e.vertical && (a["--orientation"] = "scrollY");
            return kv(kv({}, t), a)
        }
        ))
          , L = F(( () => !!e.gradient))
          , I = async () => {
            e.vertical ? (n.value = "100%",
            i.value = "auto",
            e.animateOnOverflowOnly) : (n.value = "auto",
            e.animateOnOverflowOnly ? i.value = "auto" : i.value = "100%"),
            e.gradient && (e.gradientWidth ? m.value = e.gradientWidth : e.gradientLength && (m.value = e.gradientLength)),
            e.clone || e.animateOnOverflowOnly ? (await k(),
            w(),
            b.value = !0) : b.value = !0
        }
        ;
        return ae((async () => {
            I(),
            f.value = setInterval(( () => {
                g.value++,
                0 !== e.loop && g.value === e.loop && (t("onComplete"),
                clearInterval(f.value)),
                t("onLoopComplete")
            }
            ), 1e3 * e.duration)
        }
        )),
        Z(( () => {
            clearInterval(f.value)
        }
        )),
        {
            ready: b,
            contentWidth: u,
            containerWidth: c,
            contentHeight: h,
            containerHeight: d,
            loopCounter: g,
            loopInterval: f,
            mouseOverMarquee: p,
            mouseDownMarquee: v,
            minWidth: i,
            minHeight: n,
            animateOnOverflowPause: s,
            marqueeContent: x,
            marqueeOverlayContainer: y,
            componentKey: r,
            showGradient: L,
            cloneAmount: a,
            ForcesUpdate: w,
            checkForClone: k,
            setupMarquee: I,
            getCurrentStyle: P,
            hoverStarted: () => {
                e.pauseOnHover && (t("onPause"),
                p.value = !0)
            }
            ,
            hoverEnded: () => {
                e.pauseOnHover && (t("onResume"),
                p.value = !1)
            }
            ,
            mouseDown: () => {
                e.pauseOnClick && (t("onPause"),
                v.value = !0)
            }
            ,
            mouseUp: () => {
                e.pauseOnClick && (t("onResume"),
                v.value = !1)
            }
        }
    }
})
  , Av = {
    class: "transparent-overlay",
    ref: "marqueeOverlayContainer",
    "aria-hidden": !0
}
  , Pv = {
    class: "marquee",
    ref: "marqueeContent"
}
  , Lv = {
    key: 1,
    "aria-hidden": !0,
    class: "marquee"
};
var Iv = Sv(Cv, [["render", function(e, t, a, n, r, o) {
    return e.ready ? (i(),
    sa("div", {
        class: ca(["vue3-marquee", {
            vertical: e.vertical,
            horizontal: !e.vertical
        }]),
        style: pa(e.getCurrentStyle),
        key: e.componentKey,
        onMouseenter: t[0] || (t[0] = (...t) => e.hoverStarted && e.hoverStarted(...t)),
        onMouseleave: t[1] || (t[1] = (...t) => e.hoverEnded && e.hoverEnded(...t)),
        onMousedown: t[2] || (t[2] = (...t) => e.mouseDown && e.mouseDown(...t)),
        onMouseup: t[3] || (t[3] = (...t) => e.mouseUp && e.mouseUp(...t))
    }, [la("div", Av, null, 512), e.showGradient ? (i(),
    sa("div", {
        key: 0,
        "aria-hidden": !0,
        class: ca(["overlay", {
            vertical: e.vertical,
            horizontal: !e.vertical
        }])
    }, null, 2)) : ua("", !0), la("div", Pv, [da(e.$slots, "default")], 512), !e.animateOnOverflowOnly || e.animateOnOverflowOnly && !e.animateOnOverflowPause ? (i(),
    sa("div", Lv, [da(e.$slots, "default")])) : ua("", !0), (i(!0),
    sa(Q, null, ha(e.cloneAmount, (t => (i(),
    sa("div", {
        "aria-hidden": !0,
        class: "marquee cloned",
        key: t
    }, [da(e.$slots, "default")])))), 128))], 38)) : ua("", !0)
}
]])
  , _v = {
    install(e, t) {
        var a;
        const i = null != (a = null == t ? void 0 : t.name) ? a : "Vue3Marquee";
        e.component(i, Iv)
    }
};
const Tv = {
    class: "pc-icon"
}
  , Ev = ["xlink:href"]
  , Ov = a({
    __name: "SvgSprite",
    props: {
        name: String
    },
    setup(e) {
        const t = e
          , a = l(null);
        return ae((async () => {
            try {
                a.value = await "/" + "assets/svg/sprite.svg"
            } catch (e) {}
        }
        )),
        (e, n) => (i(),
        sa("svg", Tv, [la("use", {
            "xlink:href": `${a.value}#${t.name}`
        }, null, 8, Ev)]))
    }
})
  , Vv = (e, t) => {
    const a = e.__vccOpts || e;
    for (const [i,n] of t)
        a[i] = n;
    return a
}
;
const Fv = Vv({
    data: () => ({
        snackbar: {
            show: !1,
            message: "",
            timeout: 6e3
        }
    }),
    methods: {
        triggerSnackbar(e, t=6e3) {
            this.snackbar.message = e,
            this.snackbar.timeout = t,
            this.snackbar.show = !0
        }
    }
}, [["render", function(e, t, a, r, o, s) {
    return i(),
    n(Ih, {
        modelValue: o.snackbar.show,
        "onUpdate:modelValue": t[1] || (t[1] = e => o.snackbar.show = e),
        timeout: o.snackbar.timeout,
        color: "red"
    }, {
        action: va(( ({attrs: e}) => [y(sr, A({
            color: "white",
            text: ""
        }, e, {
            onClick: t[0] || (t[0] = e => o.snackbar.show = !1)
        }), {
            default: va(( () => [vt(" Close ")])),
            _: 2
        }, 1040)])),
        default: va(( () => [vt(Yt(o.snackbar.message) + " ", 1)])),
        _: 1
    }, 8, ["modelValue", "timeout"])
}
]]);
var Bv = Object.defineProperty
  , Mv = (e, t, a) => (( (e, t, a) => {
    t in e ? Bv(e, t, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: a
    }) : e[t] = a
}
)(e, "symbol" != typeof t ? t + "" : t, a),
a);
const Dv = {
    "#": {
        pattern: /[0-9]/
    },
    "@": {
        pattern: /[a-zA-Z]/
    },
    "*": {
        pattern: /[a-zA-Z0-9]/
    }
};
class Rv {
    constructor(e={}) {
        Mv(this, "opts", {}),
        Mv(this, "memo", new Map);
        const t = {
            ...e
        };
        if (null != t.tokens) {
            t.tokens = t.tokensReplace ? {
                ...t.tokens
            } : {
                ...Dv,
                ...t.tokens
            };
            for (const e of Object.values(t.tokens))
                "string" == typeof e.pattern && (e.pattern = new RegExp(e.pattern))
        } else
            t.tokens = Dv;
        Array.isArray(t.mask) && (t.mask.length > 1 ? t.mask = [...t.mask].sort(( (e, t) => e.length - t.length)) : t.mask = t.mask[0] ?? ""),
        "" === t.mask && (t.mask = null),
        this.opts = t
    }
    masked(e) {
        return this.process(e, this.findMask(e))
    }
    unmasked(e) {
        return this.process(e, this.findMask(e), !1)
    }
    isEager() {
        return !0 === this.opts.eager
    }
    isReversed() {
        return !0 === this.opts.reversed
    }
    completed(e) {
        const t = this.findMask(e);
        if (null == this.opts.mask || null == t)
            return !1;
        const a = this.process(e, t).length;
        return "string" == typeof this.opts.mask ? a >= this.opts.mask.length : "function" == typeof this.opts.mask ? a >= t.length : this.opts.mask.filter((e => a >= e.length)).length === this.opts.mask.length
    }
    findMask(e) {
        const t = this.opts.mask;
        if (null == t)
            return null;
        if ("string" == typeof t)
            return t;
        if ("function" == typeof t)
            return t(e);
        const a = this.process(e, t.slice(-1).pop() ?? "", !1);
        return t.find((t => this.process(e, t, !1).length >= a.length)) ?? ""
    }
    escapeMask(e) {
        const t = []
          , a = [];
        return e.split("").forEach(( (i, n) => {
            "!" === i && "!" !== e[n - 1] ? a.push(n - a.length) : t.push(i)
        }
        )),
        {
            mask: t.join(""),
            escaped: a
        }
    }
    process(e, t, a=!0) {
        if (null == t)
            return e;
        const i = `value=${e},mask=${t},masked=${a ? 1 : 0}`;
        if (this.memo.has(i))
            return this.memo.get(i);
        const {mask: n, escaped: r} = this.escapeMask(t)
          , o = []
          , s = null != this.opts.tokens ? this.opts.tokens : {}
          , l = this.isReversed() ? -1 : 1
          , c = this.isReversed() ? "unshift" : "push"
          , u = this.isReversed() ? 0 : n.length - 1
          , d = this.isReversed() ? () => g > -1 && f > -1 : () => g < n.length && f < e.length
          , h = e => !this.isReversed() && e <= u || this.isReversed() && e >= u;
        let p, v = -1, g = this.isReversed() ? n.length - 1 : 0, f = this.isReversed() ? e.length - 1 : 0, m = !1;
        for (; d(); ) {
            const t = n.charAt(g)
              , i = s[t]
              , d = null != (null == i ? void 0 : i.transform) ? i.transform(e.charAt(f)) : e.charAt(f);
            if (r.includes(g) || null == i ? (a && !this.isEager() && o[c](t),
            d !== t || this.isEager() ? p = t : f += l,
            this.isEager() || (g += l)) : (null != d.match(i.pattern) ? (o[c](d),
            i.repeated ? (-1 === v ? v = g : g === u && g !== v && (g = v - l),
            u === v && (g -= l)) : i.multiple && (m = !0,
            g -= l),
            g += l) : i.multiple ? m && (g += l,
            f -= l,
            m = !1) : d === p ? p = void 0 : i.optional && (g += l,
            f -= l),
            f += l),
            this.isEager())
                for (; h(g) && (null == s[n.charAt(g)] || r.includes(g)); )
                    a ? o[c](n.charAt(g)) : n.charAt(g) === e.charAt(f) && (f += l),
                    g += l
        }
        return this.memo.set(i, o.join("")),
        this.memo.get(i)
    }
}
const Nv = e => JSON.parse(e.replaceAll("'", '"'))
  , zv = (e, t={}) => {
    const a = {
        ...t
    };
    return null != e.dataset.maska && "" !== e.dataset.maska && (a.mask = Xv(e.dataset.maska)),
    null != e.dataset.maskaEager && (a.eager = Hv(e.dataset.maskaEager)),
    null != e.dataset.maskaReversed && (a.reversed = Hv(e.dataset.maskaReversed)),
    null != e.dataset.maskaTokensReplace && (a.tokensReplace = Hv(e.dataset.maskaTokensReplace)),
    null != e.dataset.maskaTokens && (a.tokens = Yv(e.dataset.maskaTokens)),
    a
}
  , Hv = e => "" === e || !!JSON.parse(e)
  , Xv = e => e.startsWith("[") && e.endsWith("]") ? Nv(e) : e
  , Yv = e => {
    if (e.startsWith("{") && e.endsWith("}"))
        return Nv(e);
    const t = {};
    return e.split("|").forEach((e => {
        const a = e.split(":");
        t[a[0]] = {
            pattern: new RegExp(a[1]),
            optional: "optional" === a[2],
            multiple: "multiple" === a[2],
            repeated: "repeated" === a[2]
        }
    }
    )),
    t
}
;
class Wv {
    constructor(e, t={}) {
        Mv(this, "items", new Map),
        Mv(this, "beforeinputEvent", (e => {
            const t = e.target
              , a = this.items.get(t);
            a.isEager() && "inputType"in e && e.inputType.startsWith("delete") && a.unmasked(t.value).length <= 1 && this.setMaskedValue(t, "")
        }
        )),
        Mv(this, "inputEvent", (e => {
            if (e instanceof CustomEvent && "input" === e.type && null != e.detail && "object" == typeof e.detail && "masked"in e.detail)
                return;
            const t = e.target
              , a = this.items.get(t)
              , i = t.value
              , n = t.selectionStart
              , r = t.selectionEnd;
            let o = i;
            if (a.isEager()) {
                const t = a.masked(i)
                  , n = a.unmasked(i);
                "" === n && "data"in e && null != e.data ? o = e.data : n !== a.unmasked(t) && (o = n)
            }
            if (this.setMaskedValue(t, o),
            "inputType"in e && (e.inputType.startsWith("delete") || null != n && n < i.length))
                try {
                    t.setSelectionRange(n, r)
                } catch {}
        }
        )),
        this.options = t,
        "string" == typeof e ? this.init(Array.from(document.querySelectorAll(e)), this.getMaskOpts(t)) : this.init("length"in e ? Array.from(e) : [e], this.getMaskOpts(t))
    }
    destroy() {
        for (const e of this.items.keys())
            e.removeEventListener("input", this.inputEvent),
            e.removeEventListener("beforeinput", this.beforeinputEvent);
        this.items.clear()
    }
    needUpdateOptions(e, t) {
        const a = this.items.get(e)
          , i = new Rv(zv(e, this.getMaskOpts(t)));
        return JSON.stringify(a.opts) !== JSON.stringify(i.opts)
    }
    needUpdateValue(e) {
        const t = e.dataset.maskaValue;
        return null == t && "" !== e.value || null != t && t !== e.value
    }
    getMaskOpts(e) {
        const {onMaska: t, preProcess: a, postProcess: i, ...n} = e;
        return n
    }
    init(e, t) {
        for (const a of e) {
            const e = new Rv(zv(a, t));
            this.items.set(a, e),
            "" !== a.value && this.setMaskedValue(a, a.value),
            a.addEventListener("input", this.inputEvent),
            a.addEventListener("beforeinput", this.beforeinputEvent)
        }
    }
    setMaskedValue(e, t) {
        const a = this.items.get(e);
        null != this.options.preProcess && (t = this.options.preProcess(t));
        const i = a.masked(t)
          , n = {
            masked: i,
            unmasked: a.unmasked(a.isEager() ? i : t),
            completed: a.completed(t)
        };
        t = i,
        null != this.options.postProcess && (t = this.options.postProcess(t)),
        e.value = t,
        e.dataset.maskaValue = t,
        null != this.options.onMaska && (Array.isArray(this.options.onMaska) ? this.options.onMaska.forEach((e => e(n))) : this.options.onMaska(n)),
        e.dispatchEvent(new CustomEvent("maska",{
            detail: n
        })),
        e.dispatchEvent(new CustomEvent("input",{
            detail: n
        }))
    }
}
const Gv = new WeakMap;
class jv {
    constructor(e) {
        this.standards = {
            strict: "strict",
            loose: "loose",
            html5: "html5"
        },
        this.previewBody = null,
        this.close = null,
        this.previewBodyUtilPrintBtn = null,
        this.selectArray = [],
        this.counter = 0,
        this.settings = {
            standard: this.standards.html5
        },
        Object.assign(this.settings, e),
        this.init()
    }
    init() {
        this.counter++,
        this.settings.id = `printArea_${this.counter}`;
        let e = "";
        this.settings.url && !this.settings.asyncUrl && (e = this.settings.url);
        let t = this;
        if (this.settings.asyncUrl)
            return void t.settings.asyncUrl((function(e) {
                let a = t.getPrintWindow(e);
                t.settings.preview ? t.previewIfrmaeLoad() : t.print(a)
            }
            ), t.settings.vue);
        let a = this.getPrintWindow(e);
        this.settings.url || this.write(a.doc),
        this.settings.preview ? this.previewIfrmaeLoad() : this.print(a)
    }
    addEvent(e, t, a) {
        e.addEventListener ? e.addEventListener(t, a, !1) : e.attachEvent ? e.attachEvent("on" + t, a) : e["on" + t] = a
    }
    previewIfrmaeLoad() {
        let e = document.getElementById("vue-pirnt-nb-previewBox");
        if (e) {
            let t = this
              , a = e.querySelector("iframe");
            this.settings.previewBeforeOpenCallback(),
            this.addEvent(a, "load", (function() {
                t.previewBoxShow(),
                t.removeCanvasImg(),
                t.settings.previewOpenCallback()
            }
            )),
            this.addEvent(e.querySelector(".previewBodyUtilPrintBtn"), "click", (function() {
                t.settings.beforeOpenCallback(),
                t.settings.openCallback(),
                a.contentWindow.print(),
                t.settings.closeCallback()
            }
            ))
        }
    }
    removeCanvasImg() {
        let e = this;
        try {
            if (e.elsdom) {
                let t = e.elsdom.querySelectorAll(".canvasImg");
                for (let e = 0; e < t.length; e++)
                    t[e].remove()
            }
        } catch (t) {}
    }
    print(e) {
        var t = this;
        let a = document.getElementById(this.settings.id) || e.f
          , i = document.getElementById(this.settings.id).contentWindow || e.f.contentWindow;
        t.settings.beforeOpenCallback(),
        t.addEvent(a, "load", (function() {
            i.focus(),
            t.settings.openCallback(),
            i.print(),
            a.remove(),
            t.settings.closeCallback(),
            t.removeCanvasImg()
        }
        ))
    }
    write(e) {
        e.open(),
        e.write(`${this.docType()}<html>${this.getHead()}${this.getBody()}</html>`),
        e.close()
    }
    docType() {
        return this.settings.standard === this.standards.html5 ? "<!DOCTYPE html>" : `<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01${this.settings.standard === this.standards.loose ? " Transitional" : ""}//EN" "http://www.w3.org/TR/html4/${this.settings.standard === this.standards.loose ? "loose" : "strict"}.dtd">`
    }
    getHead() {
        let e = ""
          , t = ""
          , a = "";
        this.settings.extraHead && this.settings.extraHead.replace(/([^,]+)/g, (t => {
            e += t
        }
        )),
        [].forEach.call(document.querySelectorAll("link"), (function(e) {
            e.href.indexOf(".css") >= 0 && (t += `<link type="text/css" rel="stylesheet" href="${e.href}" >`)
        }
        ));
        let i = document.styleSheets;
        if (i && i.length > 0)
            for (let r = 0; r < i.length; r++)
                try {
                    if (i[r].cssRules || i[r].rules) {
                        let e = i[r].cssRules || i[r].rules;
                        for (let t = 0; t < e.length; t++)
                            a += e[t].cssText
                    }
                } catch (n) {}
        return this.settings.extraCss && this.settings.extraCss.replace(/([^,\s]+)/g, (e => {
            t += `<link type="text/css" rel="stylesheet" href="${e}">`
        }
        )),
        `<head><title>${this.settings.popTitle}</title>${e}${t}<style type="text/css">${a}</style></head>`
    }
    getBody() {
        let e = this.settings.ids;
        return e = e.replace(new RegExp("#","g"), ""),
        this.elsdom = this.beforeHanler(document.getElementById(e)),
        "<body>" + this.getFormData(this.elsdom).outerHTML + "</body>"
    }
    beforeHanler(e) {
        let t = e.querySelectorAll("canvas");
        for (let a = 0; a < t.length; a++)
            if (!t[a].style.display) {
                let e = t[a].parentNode
                  , i = t[a].toDataURL("image/png")
                  , n = new Image;
                n.className = "canvasImg",
                n.style.display = "none",
                n.src = i,
                e.appendChild(n)
            }
        return e
    }
    getFormData(e) {
        let t = e.cloneNode(!0)
          , a = t.querySelectorAll("input,select,textarea")
          , i = t.querySelectorAll(".canvasImg,canvas")
          , n = -1;
        for (let r = 0; r < i.length; r++) {
            let e = i[r].parentNode
              , t = i[r];
            "canvas" === t.tagName.toLowerCase() ? e.removeChild(t) : t.style.display = "block"
        }
        for (let r = 0; r < a.length; r++) {
            let t = a[r]
              , i = t.getAttribute("type")
              , o = a[r];
            if (i || (i = "SELECT" === t.tagName ? "select" : "TEXTAREA" === t.tagName ? "textarea" : ""),
            "INPUT" === t.tagName)
                "radio" === i || "checkbox" === i ? t.checked && o.setAttribute("checked", t.checked) : (o.value = t.value,
                o.setAttribute("value", t.value));
            else if ("select" === i) {
                n++;
                for (let a = 0; a < e.querySelectorAll("select").length; a++) {
                    let i = e.querySelectorAll("select")[a];
                    if (!i.getAttribute("newbs") && i.setAttribute("newbs", a),
                    i.getAttribute("newbs") == n) {
                        let a = e.querySelectorAll("select")[n].selectedIndex;
                        t.options[a].setAttribute("selected", !0)
                    }
                }
            } else
                o.innerHTML = t.value,
                o.setAttribute("html", t.value)
        }
        return t
    }
    getPrintWindow(e) {
        var t = this.Iframe(e);
        return {
            f: t,
            win: t.contentWindow || t,
            doc: t.doc
        }
    }
    previewBoxShow() {
        let e = document.getElementById("vue-pirnt-nb-previewBox");
        e && (document.querySelector("html").setAttribute("style", "overflow: hidden"),
        e.style.display = "block")
    }
    previewBoxHide() {
        let e = document.getElementById("vue-pirnt-nb-previewBox");
        e && (document.querySelector("html").setAttribute("style", "overflow: visible;"),
        e.querySelector("iframe") && e.querySelector("iframe").remove(),
        e.style.display = "none")
    }
    previewBox() {
        let e = document.getElementById("vue-pirnt-nb-previewBox");
        if (e)
            return e.querySelector("iframe") && e.querySelector("iframe").remove(),
            {
                close: e.querySelector(".previewClose"),
                previewBody: e.querySelector(".previewBody")
            };
        let t = document.createElement("div");
        t.setAttribute("id", "vue-pirnt-nb-previewBox"),
        t.setAttribute("style", "position: fixed;top: 0px;left: 0px;width: 100%;height: 100%;background: white;display:none"),
        t.style.zIndex = this.settings.zIndex;
        let a = document.createElement("div");
        a.setAttribute("class", "previewHeader"),
        a.setAttribute("style", "padding: 5px 20px;"),
        a.innerHTML = this.settings.previewTitle,
        t.appendChild(a),
        this.close = document.createElement("div");
        let i = this.close;
        i.setAttribute("class", "previewClose"),
        i.setAttribute("style", "position: absolute;top: 5px;right: 20px;width: 25px;height: 20px;cursor: pointer;");
        let n = document.createElement("div")
          , r = document.createElement("div");
        n.setAttribute("class", "closeBefore"),
        n.setAttribute("style", "position: absolute;width: 3px;height: 100%;background: #040404;transform: rotate(45deg); top: 0px;left: 50%;"),
        r.setAttribute("class", "closeAfter"),
        r.setAttribute("style", "position: absolute;width: 3px;height: 100%;background: #040404;transform: rotate(-45deg); top: 0px;left: 50%;"),
        i.appendChild(n),
        i.appendChild(r),
        a.appendChild(i),
        this.previewBody = document.createElement("div");
        let o = this.previewBody;
        o.setAttribute("class", "previewBody"),
        o.setAttribute("style", "display: flex;flex-direction: column; height: 100%;"),
        t.appendChild(o);
        let s = document.createElement("div");
        s.setAttribute("class", "previewBodyUtil"),
        s.setAttribute("style", "height: 32px;background: #474747;position: relative;"),
        o.appendChild(s),
        this.previewBodyUtilPrintBtn = document.createElement("div");
        let l = this.previewBodyUtilPrintBtn;
        return l.setAttribute("class", "previewBodyUtilPrintBtn"),
        l.innerHTML = this.settings.previewPrintBtnLabel,
        l.setAttribute("style", "position: absolute;padding: 2px 10px;margin-top: 3px;left: 24px;font-size: 14px;color: white;cursor: pointer;background-color: rgba(0,0,0,.12);background-image: linear-gradient(hsla(0,0%,100%,.05),hsla(0,0%,100%,0));background-clip: padding-box;border: 1px solid rgba(0,0,0,.35);border-color: rgba(0,0,0,.32) rgba(0,0,0,.38) rgba(0,0,0,.42);box-shadow: inset 0 1px 0 hsla(0,0%,100%,.05), inset 0 0 1px hsla(0,0%,100%,.15), 0 1px 0 hsla(0,0%,100%,.05);"),
        s.appendChild(l),
        document.body.appendChild(t),
        {
            close: this.close,
            previewBody: this.previewBody
        }
    }
    iframeBox(e, t) {
        let a = document.createElement("iframe");
        return a.style.border = "0px",
        a.style.position = "absolute",
        a.style.width = "0px",
        a.style.height = "0px",
        a.style.right = "0px",
        a.style.top = "0px",
        a.setAttribute("id", e),
        a.setAttribute("src", t),
        a
    }
    Iframe(e) {
        let t = this.settings.id;
        e = e || (new Date).getTime();
        let a = this
          , i = this.iframeBox(t, e);
        try {
            if (this.settings.preview) {
                i.setAttribute("style", "border: 0px;flex: 1;");
                let e = this.previewBox()
                  , t = e.previewBody
                  , n = e.close;
                t.appendChild(i),
                this.addEvent(n, "click", (function() {
                    a.previewBoxHide()
                }
                ))
            } else
                document.body.appendChild(i);
            i.doc = null,
            i.doc = i.contentDocument ? i.contentDocument : i.contentWindow ? i.contentWindow.document : i.document
        } catch (n) {
            throw new Error(n + ". iframes may not be supported in this browser.")
        }
        if (null == i.doc)
            throw new Error("Cannot find document.");
        return i
    }
}
var $v = {
    directiveName: "print",
    mounted(e, t, a) {
        let i = t.instance
          , n = "";
        var r, o, s;
        o = "click",
        s = () => {
            if ("string" == typeof t.value)
                n = t.value;
            else {
                if ("object" != typeof t.value || !t.value.id)
                    return void window.print();
                {
                    n = t.value.id;
                    let e = n.replace(new RegExp("#","g"), "");
                    document.getElementById(e) || (n = "")
                }
            }
            l()
        }
        ,
        (r = e).addEventListener ? r.addEventListener(o, s, !1) : r.attachEvent ? r.attachEvent("on" + o, s) : r["on" + o] = s;
        const l = () => {
            new jv({
                ids: n,
                vue: i,
                url: t.value.url,
                standard: "",
                extraHead: t.value.extraHead,
                extraCss: t.value.extraCss,
                zIndex: t.value.zIndex || 20002,
                previewTitle: t.value.previewTitle || "",
                previewPrintBtnLabel: t.value.previewPrintBtnLabel || "",
                popTitle: t.value.popTitle,
                preview: t.value.preview || !1,
                asyncUrl: t.value.asyncUrl,
                previewBeforeOpenCallback() {
                    t.value.previewBeforeOpenCallback && t.value.previewBeforeOpenCallback(i)
                },
                previewOpenCallback() {
                    t.value.previewOpenCallback && t.value.previewOpenCallback(i)
                },
                openCallback() {
                    t.value.openCallback && t.value.openCallback(i)
                },
                closeCallback() {
                    t.value.closeCallback && t.value.closeCallback(i)
                },
                beforeOpenCallback() {
                    t.value.beforeOpenCallback && t.value.beforeOpenCallback(i)
                }
            })
        }
    },
    install: function(e) {
        e.directive("print", $v)
    }
}
  , Uv = Object.defineProperty
  , qv = Object.defineProperties
  , Zv = Object.getOwnPropertyDescriptors
  , Kv = Object.getOwnPropertySymbols
  , Jv = Object.prototype.hasOwnProperty
  , Qv = Object.prototype.propertyIsEnumerable
  , eg = (e, t, a) => t in e ? Uv(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: a
}) : e[t] = a
  , tg = (e, t) => {
    for (var a in t || (t = {}))
        Jv.call(t, a) && eg(e, a, t[a]);
    if (Kv)
        for (var a of Kv(t))
            Qv.call(t, a) && eg(e, a, t[a]);
    return e
}
  , ag = (e, t) => qv(e, Zv(t))
  , ig = (e, t) => {
    const a = e.__vccOpts || e;
    for (const [i,n] of t)
        a[i] = n;
    return a
}
;
const ng = ["onClick"]
  , rg = ["checked"]
  , og = (e => (ya("data-v-e0a0b7f0"),
e = e(),
wa(),
e))(( () => la("label", {
    for: "checbox"
}, null, -1)));
var sg = ig(a({
    __name: "MultipleSelectCheckBox",
    props: {
        status: {
            type: String,
            required: !0
        }
    },
    emits: ["change"],
    setup(e, {emit: t}) {
        const a = e;
        ga((e => ({
            "51ab8a49": r(s)
        })));
        const n = F(( () => "allSelected" === a.status))
          , o = () => {
            t("change", !n.value)
        }
          , s = de("themeColor");
        return (t, a) => (i(),
        sa("div", {
            class: "easy-checkbox",
            onClick: Xt(o, ["stop", "prevent"])
        }, [la("input", {
            type: "checkbox",
            checked: r(n),
            class: ca(e.status)
        }, null, 10, rg), og], 8, ng))
    }
}), [["__scopeId", "data-v-e0a0b7f0"]]);
const lg = ["checked"]
  , cg = (e => (ya("data-v-7e69a276"),
e = e(),
wa(),
e))(( () => la("label", {
    for: "checbox"
}, null, -1)));
var ug = ig(a({
    __name: "SingleSelectCheckBox",
    props: {
        checked: {
            type: Boolean,
            required: !0
        }
    },
    emits: ["change"],
    setup(e, {emit: t}) {
        ga((e => ({
            fdaf7e9e: r(a)
        })));
        const a = de("themeColor");
        return (a, n) => (i(),
        sa("div", {
            class: "easy-checkbox",
            onClick: n[0] || (n[0] = Xt((e => t("change")), ["stop", "prevent"]))
        }, [la("input", {
            type: "checkbox",
            checked: e.checked
        }, null, 8, lg), cg]))
    }
}), [["__scopeId", "data-v-7e69a276"]]);
const dg = {
    class: "easy-data-table__rows-selector"
}
  , hg = {
    class: "rows-input"
}
  , pg = (e => (ya("data-v-4ca5de3a"),
e = e(),
wa(),
e))(( () => la("div", {
    class: "triangle"
}, null, -1)))
  , vg = ["onClick"];
var gg = ig(a({
    __name: "RowsSelector",
    props: {
        modelValue: {
            type: Number,
            required: !0
        },
        rowsItems: {
            type: Array,
            required: !0
        }
    },
    emits: ["update:modelValue"],
    setup(e, {emit: t}) {
        const a = e;
        ga((e => ({
            "1b889342": r(d)
        })));
        const n = l(!1)
          , o = l(!1)
          , s = de("dataTable");
        $(n, (e => {
            if (e && s) {
                const e = window.innerHeight
                  , t = s.value.getBoundingClientRect().height
                  , a = s.value.getBoundingClientRect().top;
                o.value = e - (t + a) <= 100
            }
        }
        ));
        const c = F({
            get: () => a.modelValue,
            set: e => {
                t("update:modelValue", e)
            }
        })
          , u = e => {
            ( (e, t) => {
                let a = e.parentNode;
                for (; null != a; ) {
                    if (a.classList && a.classList.contains(t))
                        return !0;
                    a = a.parentNode
                }
                return !1
            }
            )(e.target, "easy-data-table__rows-selector") || (n.value = !1)
        }
        ;
        ae(( () => {
            document.addEventListener("click", u)
        }
        )),
        Z(( () => {
            document.removeEventListener("click", u)
        }
        ));
        const d = de("themeColor");
        return (t, a) => (i(),
        sa("div", dg, [la("div", {
            class: "rows-input__wrapper",
            onClick: a[0] || (a[0] = e => n.value = !n.value)
        }, [la("div", hg, Yt(r(c)), 1), pg]), la("ul", {
            class: ca(["select-items", {
                show: n.value,
                inside: o.value
            }])
        }, [(i(!0),
        sa(Q, null, ha(e.rowsItems, (e => (i(),
        sa("li", {
            key: e,
            class: ca({
                selected: e === r(c)
            }),
            onClick: t => {
                return a = e,
                c.value = a,
                void (n.value = !1);
                var a
            }
        }, Yt(e), 11, vg)))), 128))], 2)]))
    }
}), [["__scopeId", "data-v-4ca5de3a"]]);
const fg = e => (ya("data-v-1fa3a520"),
e = e(),
wa(),
e)
  , mg = {
    class: "lds-ring"
}
  , bg = [fg(( () => la("div", null, null, -1))), fg(( () => la("div", null, null, -1))), fg(( () => la("div", null, null, -1))), fg(( () => la("div", null, null, -1)))];
var xg = ig(a({
    __name: "Loading",
    setup(e) {
        ga((e => ({
            26774109: r(t)
        })));
        const t = de("themeColor");
        return (e, t) => (i(),
        sa("div", mg, bg))
    }
}), [["__scopeId", "data-v-1fa3a520"]]);
const yg = {
    class: "loader-line"
};
var wg = ig(a({
    __name: "LoadingLine",
    setup(e) {
        ga((e => ({
            "0d327f57": r(t)
        })));
        const t = de("themeColor");
        return (e, t) => (i(),
        sa("div", yg))
    }
}), [["__scopeId", "data-v-7d281cac"]]);
const kg = {
    class: "buttons-pagination"
}
  , Sg = ["onClick"];
var Cg = ig(a({
    __name: "ButtonsPagination",
    props: {
        maxPaginationNumber: {
            type: Number,
            required: !0
        },
        currentPaginationNumber: {
            type: Number,
            required: !0
        }
    },
    emits: ["updatePage"],
    setup(e, {emit: t}) {
        const a = e;
        ga((e => ({
            "40dd4f07": r(o)
        })));
        const n = F(( () => {
            const e = [];
            if (a.maxPaginationNumber <= 7)
                for (let t = 1; t <= a.maxPaginationNumber; t += 1)
                    e.push({
                        type: "button",
                        page: t,
                        active: t === a.currentPaginationNumber,
                        activePrev: t + 1 === a.currentPaginationNumber
                    });
            else if ([1, 2, a.maxPaginationNumber, a.maxPaginationNumber - 1].includes(a.currentPaginationNumber))
                for (let t = 1; t <= 7; t += 1)
                    if (t <= 3)
                        e.push({
                            type: "button",
                            page: t,
                            active: t === a.currentPaginationNumber,
                            activePrev: t + 1 === a.currentPaginationNumber
                        });
                    else if (4 === t)
                        e.push({
                            type: "omission"
                        });
                    else {
                        const i = a.maxPaginationNumber - (7 - t);
                        e.push({
                            type: "button",
                            page: i,
                            active: i === a.currentPaginationNumber,
                            activePrev: i + 1 === a.currentPaginationNumber
                        })
                    }
            else if ([3, 4].includes(a.currentPaginationNumber))
                for (let t = 1; t <= 7; t += 1)
                    t <= 5 ? e.push({
                        type: "button",
                        page: t,
                        active: t === a.currentPaginationNumber,
                        activePrev: t + 1 === a.currentPaginationNumber
                    }) : 6 === t ? e.push({
                        type: "omission"
                    }) : e.push({
                        type: "button",
                        page: a.maxPaginationNumber,
                        active: a.maxPaginationNumber === a.currentPaginationNumber,
                        activePrev: t + 1 === a.currentPaginationNumber
                    });
            else if ([a.maxPaginationNumber - 2, a.maxPaginationNumber - 3].includes(a.currentPaginationNumber))
                for (let t = 1; t <= 7; t += 1)
                    if (1 === t)
                        e.push({
                            type: "button",
                            page: 1,
                            active: 1 === a.currentPaginationNumber,
                            activePrev: t + 1 === a.currentPaginationNumber
                        });
                    else if (2 === t)
                        e.push({
                            type: "omission"
                        });
                    else {
                        const i = a.maxPaginationNumber - (7 - t);
                        e.push({
                            type: "button",
                            page: i,
                            active: i === a.currentPaginationNumber,
                            activePrev: i + 1 === a.currentPaginationNumber
                        })
                    }
            else
                for (let t = 1; t <= 7; t += 1)
                    if (1 === t)
                        e.push({
                            type: "button",
                            page: 1,
                            active: 1 === a.currentPaginationNumber,
                            activePrev: t + 1 === a.currentPaginationNumber
                        });
                    else if (2 === t || 6 === t)
                        e.push({
                            type: "omission"
                        });
                    else if (7 === t)
                        e.push({
                            type: "button",
                            page: a.maxPaginationNumber,
                            active: a.maxPaginationNumber === a.currentPaginationNumber,
                            activePrev: t + 1 === a.currentPaginationNumber
                        });
                    else {
                        const i = 4 - t
                          , n = a.currentPaginationNumber - i;
                        e.push({
                            type: "button",
                            page: n,
                            active: n === a.currentPaginationNumber,
                            activePrev: n + 1 === a.currentPaginationNumber
                        })
                    }
            return e
        }
        ))
          , o = de("themeColor");
        return (e, a) => (i(),
        sa("div", kg, [(i(!0),
        sa(Q, null, ha(r(n), ( (e, a) => (i(),
        sa("div", {
            key: a,
            class: ca(["item", {
                button: "button" === e.type,
                active: "button" === e.type && e.active,
                "active-prev": "button" === e.type && e.activePrev,
                omission: "omission" === e.type
            }]),
            onClick: a => (e => {
                "button" !== e.type || e.active || t("updatePage", e.page)
            }
            )(e)
        }, Yt("button" === e.type ? e.page : "..."), 11, Sg)))), 128))]))
    }
}), [["__scopeId", "data-v-4c681fa2"]]);
const Ag = e => (ya("data-v-c9da5286"),
e = e(),
wa(),
e)
  , Pg = [Ag(( () => la("span", {
    class: "arrow arrow-right"
}, null, -1)))]
  , Lg = [Ag(( () => la("span", {
    class: "arrow arrow-left"
}, null, -1)))];
var Ig = ig(a({
    __name: "PaginationArrows",
    props: {
        isFirstPage: {
            type: Boolean,
            required: !1
        },
        isLastPage: {
            type: Boolean,
            required: !1
        }
    },
    emits: ["clickPrevPage", "clickNextPage"],
    setup(e, {emit: t}) {
        const a = fa();
        return (n, o) => (i(),
        sa(Q, null, [la("div", {
            class: ca(["previous-page__click-button", {
                "first-page": e.isFirstPage
            }]),
            onClick: o[0] || (o[0] = e => t("clickPrevPage"))
        }, Pg, 2), r(a).buttonsPagination ? da(n.$slots, "buttonsPagination", {
            key: 0
        }, void 0, !0) : ua("", !0), la("div", {
            class: ca(["next-page__click-button", {
                "last-page": e.isLastPage
            }]),
            onClick: o[1] || (o[1] = e => t("clickNextPage"))
        }, Lg, 2)], 64))
    }
}), [["__scopeId", "data-v-c9da5286"]]);
function _g(e, t) {
    var a;
    if (e.includes(".")) {
        const a = e.split(".")
          , {length: i} = a;
        let n, r = 0;
        for (; r < i; ) {
            if (0 === r)
                n = t[a[0]];
            else {
                if (!n || "object" != typeof n) {
                    n = "";
                    break
                }
                n = n[a[r]]
            }
            r += 1
        }
        return null != n ? n : ""
    }
    return null != (a = t[e]) ? a : ""
}
function Tg(e, t) {
    const a = _g(e, t);
    return Array.isArray(a) ? a.join(",") : a
}
function Eg(e, t, a, i, n, r, o, s, l, c) {
    const u = F(( () => {
        if (!a.value && "" !== o.value) {
            const e = new RegExp(o.value,"i");
            return i.value.filter((t => e.test((e => {
                if ("string" == typeof r.value && "" !== r.value)
                    return _g(r.value, e);
                if (Array.isArray(r.value)) {
                    let t = "";
                    return r.value.forEach((a => {
                        t += _g(a, e)
                    }
                    )),
                    t
                }
                return Object.values(e).join(" ")
            }
            )(t))))
        }
        return i.value
    }
    ))
      , d = F(( () => {
        let e = [...u.value];
        return t.value ? (t.value.forEach((t => {
            e = e.filter((e => {
                const {field: a, comparison: i, criteria: n} = t;
                if ("function" == typeof i)
                    return i(_g(a, e), n);
                const r = _g(a, e);
                switch (i) {
                case "=":
                default:
                    return r === n;
                case "!=":
                    return r !== n;
                case ">":
                    return r > n;
                case "<":
                    return r < n;
                case "<=":
                    return r <= n;
                case ">=":
                    return r >= n;
                case "between":
                    return r >= Math.min(...n) && r <= Math.max(...n);
                case "in":
                    return n.includes(r)
                }
            }
            ))
        }
        )),
        e) : u.value
    }
    ));
    function h(e, t, a, i) {
        const n = e[i]
          , r = t[i];
        return (0 === i ? a : h(e, t, a, i - 1)).sort(( (t, a) => {
            let o = !0;
            for (let n = 0; n < i; n += 1)
                if (_g(e[n], t) !== _g(e[n], a)) {
                    o = !1;
                    break
                }
            return o ? _g(n, t) < _g(n, a) ? r ? 1 : -1 : _g(n, t) > _g(n, a) ? r ? -1 : 1 : 0 : 0
        }
        ))
    }
    $(d, (e => {
        t.value && c("updateFilter", e)
    }
    ), {
        immediate: !0,
        deep: !0
    });
    const p = F(( () => {
        if (a.value)
            return i.value;
        if (null === e.value)
            return d.value;
        const {sortBy: t, sortDesc: n} = e.value
          , r = [...d.value];
        return l && Array.isArray(t) && Array.isArray(n) ? 0 === t.length ? r : h(t, n, r, t.length - 1) : r.sort(( (e, a) => _g(t, e) < _g(t, a) ? n ? 1 : -1 : _g(t, e) > _g(t, a) ? n ? -1 : 1 : 0))
    }
    ))
      , v = F(( () => a.value ? s.value : p.value.length))
      , g = F({
        get: () => {
            var e;
            return null != (e = n.value) ? e : []
        }
        ,
        set: e => {
            c("update:itemsSelected", e)
        }
    });
    return {
        totalItems: p,
        selectItemsComputed: g,
        totalItemsLength: v,
        toggleSelectAll: e => {
            g.value = e ? p.value : [],
            e && c("selectAll")
        }
        ,
        toggleSelectItem: e => {
            const t = e.checkbox;
            if (delete e.checkbox,
            delete e.index,
            t)
                g.value = g.value.filter((t => JSON.stringify(t) !== JSON.stringify(e))),
                c("deselectRow", e);
            else {
                const t = g.value;
                t.unshift(e),
                g.value = t,
                c("selectRow", e)
            }
        }
    }
}
var Og = {
    alternating: {
        type: Boolean,
        default: !1
    },
    buttonsPagination: {
        type: Boolean,
        default: !1
    },
    checkboxColumnWidth: {
        type: Number,
        default: null
    },
    currentPage: {
        type: Number,
        default: 1
    },
    emptyMessage: {
        type: String,
        default: "No Available Data"
    },
    expandColumnWidth: {
        type: Number,
        default: 36
    },
    filterOptions: {
        type: Array,
        default: null
    },
    fixedExpand: {
        type: Boolean,
        default: !1
    },
    fixedHeader: {
        type: Boolean,
        default: !0
    },
    fixedCheckbox: {
        type: Boolean,
        default: !1
    },
    fixedIndex: {
        type: Boolean,
        default: !1
    },
    headerTextDirection: {
        type: String,
        default: "left"
    },
    bodyTextDirection: {
        type: String,
        default: "left"
    },
    hideFooter: {
        type: Boolean,
        default: !1
    },
    hideRowsPerPage: {
        type: Boolean,
        default: !1
    },
    hideHeader: {
        type: Boolean,
        default: !1
    },
    indexColumnWidth: {
        type: Number,
        default: 60
    },
    itemsSelected: {
        type: Array,
        default: null
    },
    loading: {
        type: Boolean,
        default: !1
    },
    rowsPerPage: {
        type: Number,
        default: 25
    },
    rowsItems: {
        type: Array,
        default: () => [25, 50, 100]
    },
    rowsPerPageMessage: {
        type: String,
        default: "rows per page:"
    },
    searchField: {
        type: [String, Array],
        default: ""
    },
    searchValue: {
        type: String,
        default: ""
    },
    serverOptions: {
        type: Object,
        default: null
    },
    serverItemsLength: {
        type: Number,
        default: 0
    },
    showIndex: {
        type: Boolean,
        default: !1
    },
    sortBy: {
        type: [String, Array],
        default: ""
    },
    sortType: {
        type: [String, Array],
        default: "asc"
    },
    multiSort: {
        type: Boolean,
        default: !1
    },
    tableMinHeight: {
        type: Number,
        default: 180
    },
    tableHeight: {
        type: Number,
        default: null
    },
    themeColor: {
        type: String,
        default: "#42b883"
    },
    tableClassName: {
        type: String,
        default: ""
    },
    headerClassName: {
        type: String,
        default: ""
    },
    headerItemClassName: {
        type: [Function, String],
        default: ""
    },
    bodyRowClassName: {
        type: [Function, String],
        default: ""
    },
    bodyExpandRowClassName: {
        type: [Function, String],
        default: ""
    },
    bodyItemClassName: {
        type: [Function, String],
        default: ""
    },
    noHover: {
        type: Boolean,
        default: !1
    },
    borderCell: {
        type: Boolean,
        default: !1
    },
    mustSort: {
        type: Boolean,
        default: !1
    },
    rowsOfPageSeparatorMessage: {
        type: String,
        default: "of"
    },
    clickEventType: {
        type: String,
        default: "single"
    },
    clickRowToExpand: {
        type: Boolean,
        default: !1
    },
    tableNodeId: {
        type: String,
        default: ""
    },
    showIndexSymbol: {
        type: String,
        default: "#"
    },
    preventContextMenuRow: {
        type: Boolean,
        default: !0
    }
};
const Vg = ["id"]
  , Fg = ["onClick"]
  , Bg = {
    key: 3,
    class: "header-text"
}
  , Mg = {
    key: 5,
    class: "multi-sort__number"
}
  , Dg = ["onClick", "onDblclick", "onContextmenu"]
  , Rg = ["onClick"]
  , Ng = ["colspan"]
  , zg = {
    key: 0,
    class: "vue3-easy-data-table__loading"
}
  , Hg = (e => (ya("data-v-32683533"),
e = e(),
wa(),
e))(( () => la("div", {
    class: "vue3-easy-data-table__loading-mask"
}, null, -1)))
  , Xg = {
    class: "loading-entity"
}
  , Yg = {
    key: 1,
    class: "vue3-easy-data-table__message"
}
  , Wg = {
    key: 0,
    class: "vue3-easy-data-table__footer"
}
  , Gg = {
    key: 0,
    class: "pagination__rows-per-page"
}
  , jg = {
    class: "pagination__items-index"
};
var $g = ig(a({
    __name: "DataTable",
    props: ag(tg({}, Og), {
        items: {
            type: Array,
            required: !0
        },
        headers: {
            type: Array,
            required: !0
        }
    }),
    emits: ["clickRow", "contextmenuRow", "selectRow", "deselectRow", "expandRow", "updateSort", "updateFilter", "update:itemsSelected", "update:serverOptions", "updatePageItems", "updateTotalItems", "selectAll"],
    setup(e, {expose: t, emit: a}) {
        const o = e;
        ga((e => ({
            da0d4328: r(q),
            "3037e504": r(U)
        })));
        const {tableNodeId: s, clickEventType: c, bodyTextDirection: u, checkboxColumnWidth: d, currentPage: h, expandColumnWidth: p, filterOptions: v, fixedCheckbox: g, fixedExpand: f, fixedHeader: m, fixedIndex: b, headers: x, headerTextDirection: w, indexColumnWidth: k, items: S, itemsSelected: C, loading: P, mustSort: L, multiSort: I, rowsItems: _, rowsPerPage: T, searchField: E, searchValue: V, serverItemsLength: B, serverOptions: D, showIndex: R, sortBy: N, sortType: z, tableHeight: H, tableMinHeight: X, themeColor: Y, rowsOfPageSeparatorMessage: W, showIndexSymbol: G, preventContextMenuRow: j} = O(o)
          , U = F(( () => H.value ? `${H.value}px` : null))
          , q = F(( () => `${X.value}px`));
        ue("themeColor", Y.value);
        const Z = fa()
          , K = F(( () => !!Z.pagination))
          , J = F(( () => !!Z.loading))
          , ee = F(( () => !!Z.expand))
          , te = F(( () => !!Z.body))
          , ie = l()
          , ne = l();
        ue("dataTable", ie);
        const re = l(!1);
        ae(( () => {
            ne.value.addEventListener("scroll", ( () => {
                re.value = ne.value.scrollLeft > 0
            }
            ))
        }
        ));
        const oe = F(( () => null !== C.value))
          , se = F(( () => null !== D.value))
          , {serverOptionsComputed: le, updateServerOptionsPage: ce, updateServerOptionsSort: de, updateServerOptionsRowsPerPage: he} = function(e, t, a) {
            const i = F({
                get: () => {
                    if (e.value) {
                        const {page: t, rowsPerPage: a, sortBy: i, sortType: n} = e.value;
                        return {
                            page: t,
                            rowsPerPage: a,
                            sortBy: null != i ? i : null,
                            sortType: null != n ? n : null
                        }
                    }
                    return null
                }
                ,
                set: e => {
                    a("update:serverOptions", e)
                }
            });
            return {
                serverOptionsComputed: i,
                updateServerOptionsPage: e => {
                    i.value && (i.value = ag(tg({}, i.value), {
                        page: e
                    }))
                }
                ,
                updateServerOptionsSort: (e, a) => {
                    if (i.value)
                        if (t.value && Array.isArray(i.value.sortBy) && Array.isArray(i.value.sortType)) {
                            const t = i.value.sortBy.findIndex((t => t === e));
                            -1 === t && null !== a && (i.value.sortBy.push(e),
                            i.value.sortType.push(a)),
                            null === a ? (i.value.sortBy.splice(t, 1),
                            i.value.sortType.splice(t, 1)) : i.value.sortType[t] = a
                        } else
                            i.value = ag(tg({}, i.value), {
                                sortBy: null !== a ? e : null,
                                sortType: a
                            })
                }
                ,
                updateServerOptionsRowsPerPage: e => {
                    i.value && (i.value = ag(tg({}, i.value), {
                        page: 1,
                        rowsPerPage: e
                    }))
                }
            }
        }(D, I, a)
          , {clientSortOptions: pe, headerColumns: ve, headersForRender: ge, updateSortField: fe, isMultiSorting: me, getMultiSortNumber: be} = function(e, t, a, i, n, r, o, s, c, u, d, h, p, v, g, f, m, b, x) {
            const y = F(( () => -1 !== o.value.findIndex((e => e.fixed))))
              , w = F(( () => y.value ? o.value.filter((e => e.fixed)) : []))
              , k = F(( () => o.value.filter((e => !e.fixed))))
              , S = l((C = g.value,
            A = f.value,
            Array.isArray(C) && Array.isArray(A) ? {
                sortBy: C,
                sortDesc: A.map((e => "desc" === e))
            } : "" !== C ? {
                sortBy: g.value,
                sortDesc: "desc" === f.value
            } : null));
            var C, A;
            const P = F(( () => {
                var o;
                const l = [...w.value, ...k.value].map((e => {
                    const t = Object.assign(e);
                    if (t.sortable && (t.sortType = "none"),
                    p.value)
                        if (Array.isArray(p.value.sortBy) && Array.isArray(p.value.sortType) && p.value.sortBy.includes(t.value)) {
                            const e = p.value.sortBy.indexOf(t.value);
                            t.sortType = p.value.sortType[e]
                        } else
                            t.value === p.value.sortBy && p.value.sortType && (t.sortType = p.value.sortType);
                    if (S.value && Array.isArray(S.value.sortBy) && Array.isArray(S.value.sortDesc) && S.value.sortBy.includes(t.value)) {
                        const e = S.value.sortBy.indexOf(t.value);
                        t.sortType = S.value.sortDesc[e] ? "desc" : "asc"
                    } else
                        S.value && t.value === S.value.sortBy && (t.sortType = S.value.sortDesc ? "desc" : "asc");
                    return t
                }
                ));
                let d = [];
                d = s.value ? [n.value || y.value ? {
                    text: "",
                    value: "expand",
                    fixed: !0,
                    width: a.value
                } : {
                    text: "",
                    value: "expand"
                }, ...l] : l;
                let h = [];
                h = v.value ? [r.value || y.value ? {
                    text: e.value,
                    value: "index",
                    fixed: !0,
                    width: c.value
                } : {
                    text: e.value,
                    value: "index"
                }, ...d] : d;
                let g = [];
                return g = u.value ? [i.value || y.value ? {
                    text: "checkbox",
                    value: "checkbox",
                    fixed: !0,
                    width: null != (o = t.value) ? o : 36
                } : {
                    text: "checkbox",
                    value: "checkbox"
                }, ...h] : h,
                g
            }
            ))
              , L = F(( () => P.value.map((e => e.value))));
            return {
                clientSortOptions: S,
                headerColumns: L,
                headersForRender: P,
                updateSortField: (e, t) => {
                    let a = null;
                    if (a = "none" === t ? "asc" : "asc" === t ? "desc" : h.value ? "asc" : null,
                    d.value && b(e, a),
                    S.value && Array.isArray(S.value.sortBy) && Array.isArray(S.value.sortDesc)) {
                        const t = S.value.sortBy.indexOf(e);
                        -1 === t ? null !== a && (S.value.sortBy.push(e),
                        S.value.sortDesc.push("desc" === a)) : null === a ? (S.value.sortDesc.splice(t, 1),
                        S.value.sortBy.splice(t, 1)) : S.value.sortDesc[t] = "desc" === a
                    } else
                        S.value = null === a ? null : {
                            sortBy: e,
                            sortDesc: "desc" === a
                        };
                    x("updateSort", {
                        sortType: a,
                        sortBy: e
                    })
                }
                ,
                isMultiSorting: e => p.value && Array.isArray(p.value.sortBy) ? p.value.sortBy.includes(e) : !(!S.value || !Array.isArray(S.value.sortBy)) && S.value.sortBy.includes(e),
                getMultiSortNumber: e => p.value && Array.isArray(p.value.sortBy) ? p.value.sortBy.indexOf(e) + 1 : !(!S.value || !Array.isArray(S.value.sortBy)) && S.value.sortBy.indexOf(e) + 1
            }
        }(G, d, p, g, f, b, x, ee, k, oe, se, L, le, R, N, z, 0, de, a)
          , {rowsItemsComputed: xe, rowsPerPageRef: ye, updateRowsPerPage: we} = function(e, t, a, i) {
            const n = F(( () => e.value || -1 !== t.value.findIndex((e => e === i.value)) ? t.value : [i.value, ...t.value]))
              , r = l(a.value ? a.value.rowsPerPage : i.value);
            return {
                rowsItemsComputed: n,
                rowsPerPageRef: r,
                updateRowsPerPage: e => {
                    r.value = e
                }
            }
        }(se, _, D, T)
          , {totalItems: ke, selectItemsComputed: Se, totalItemsLength: Ce, toggleSelectAll: Ae, toggleSelectItem: Pe} = Eg(pe, v, se, S, C, E, V, B, I, a)
          , {currentPaginationNumber: Le, maxPaginationNumber: Ie, isLastPage: _e, isFirstPage: Te, nextPage: Ee, prevPage: Oe, updatePage: Ve, updateCurrentPaginationNumber: Fe} = function(e, t, a, i, n, r, o) {
            const s = l(r.value ? r.value.page : e.value)
              , c = F(( () => Math.ceil(i.value / n.value)))
              , u = F(( () => 0 === c.value || s.value === c.value))
              , d = F(( () => 1 === s.value));
            return {
                currentPaginationNumber: s,
                maxPaginationNumber: c,
                isLastPage: u,
                isFirstPage: d,
                nextPage: () => {
                    if (0 !== i.value && !u.value && !a.value)
                        if (t.value) {
                            const e = s.value + 1;
                            o(e)
                        } else
                            s.value += 1
                }
                ,
                prevPage: () => {
                    if (0 !== i.value && !d.value && !a.value)
                        if (t.value) {
                            const e = s.value - 1;
                            o(e)
                        } else
                            s.value -= 1
                }
                ,
                updatePage: e => {
                    a.value || (t.value ? o(e) : s.value = e)
                }
                ,
                updateCurrentPaginationNumber: e => {
                    s.value = e
                }
            }
        }(h, se, P, Ce, ye, D, ce)
          , {currentPageFirstIndex: Be, currentPageLastIndex: Me, multipleSelectStatus: De, pageItems: Re} = function(e, t, a, i, n, r, o, s, l) {
            const c = F(( () => (e.value - 1) * n.value + 1))
              , u = F(( () => a.value ? Math.min(l.value, e.value * n.value) : Math.min(s.value.length, e.value * n.value)))
              , d = F(( () => a.value ? i.value : s.value.slice(c.value - 1, u.value)))
              , h = F(( () => o.value ? d.value.map(( (e, t) => tg({
                index: c.value + t
            }, e))) : d.value))
              , p = F(( () => 0 === r.value.length || r.value.every((e => -1 === s.value.findIndex((t => JSON.stringify(e) === JSON.stringify(t))))) ? "noneSelected" : r.value.length === s.value.length && r.value.every((e => -1 !== s.value.findIndex((t => JSON.stringify(e) === JSON.stringify(t))))) ? "allSelected" : "partSelected"))
              , v = F(( () => t.value ? "allSelected" === p.value ? h.value.map((e => tg({
                checkbox: !0
            }, e))) : "noneSelected" === p.value ? h.value.map((e => tg({
                checkbox: !1
            }, e))) : h.value.map((e => {
                const t = -1 !== r.value.findIndex((t => {
                    const a = tg({}, e);
                    return delete a.index,
                    JSON.stringify(t) === JSON.stringify(a)
                }
                ));
                return tg({
                    checkbox: t
                }, e)
            }
            )) : h.value));
            return {
                currentPageFirstIndex: c,
                currentPageLastIndex: u,
                multipleSelectStatus: p,
                pageItems: v
            }
        }(Le, oe, se, S, ye, Se, R, ke, Ce)
          , Ne = F(( () => 0 === Le.value ? 0 : (Le.value - 1) * ye.value))
          , {expandingItemIndexList: ze, updateExpandingItemIndexList: He, clearExpandingItemIndexList: Xe} = function(e, t, a) {
            const i = l([]);
            return {
                expandingItemIndexList: i,
                updateExpandingItemIndexList: (n, r, o) => {
                    o.stopPropagation();
                    const s = i.value.indexOf(n);
                    if (-1 !== s)
                        i.value.splice(s, 1);
                    else {
                        const n = e.value.findIndex((e => JSON.stringify(e) === JSON.stringify(r)));
                        a("expandRow", t.value + n, r),
                        i.value.push(t.value + n)
                    }
                }
                ,
                clearExpandingItemIndexList: () => {
                    i.value = []
                }
            }
        }(Re, Ne, a)
          , {fixedHeaders: Ye, lastFixedColumn: We, fixedColumnsInfos: Ge} = function(e) {
            const t = F(( () => e.value.filter((e => e.fixed))))
              , a = F(( () => t.value.length ? t.value[t.value.length - 1].value : ""))
              , i = F(( () => {
                if (!t.value.length)
                    return [];
                const e = t.value.map((e => {
                    var t;
                    return null != (t = e.width) ? t : 100
                }
                ));
                return t.value.map(( (t, a) => {
                    var i, n;
                    return {
                        value: t.value,
                        fixed: null == (i = t.fixed) || i,
                        width: null != (n = t.width) ? n : 100,
                        distance: 0 === a ? 0 : e.reduce(( (e, t, i) => {
                            let n = e;
                            return i < a && (n += t),
                            n
                        }
                        ))
                    }
                }
                ))
            }
            ));
            return {
                fixedHeaders: t,
                lastFixedColumn: a,
                fixedColumnsInfos: i
            }
        }(ge)
          , {clickRow: je} = function(e, t, a, i) {
            return {
                clickRow: (n, r, o) => {
                    if (e.value !== r)
                        return;
                    const s = tg({}, n);
                    if (t.value) {
                        const {checkbox: e} = n;
                        delete s.checkbox,
                        s.isSelected = e
                    }
                    if (a.value) {
                        const {index: e} = n;
                        delete s.index,
                        s.indexInCurrentPage = e
                    }
                    i("clickRow", s, o)
                }
            }
        }(c, oe, R, a)
          , $e = e => {
            var t;
            const a = null != (t = e.width) ? t : Ye.value.length ? 100 : null;
            if (a)
                return `width: ${a}px; min-width: ${a}px;`
        }
          , Ue = (e, t="th") => {
            if (!Ye.value.length)
                return;
            const a = Ge.value.find((t => t.value === e));
            return a ? `left: ${a.distance}px;z-index: ${"th" === t ? 3 : 1};position: sticky;` : void 0
        }
        ;
        return $(P, ( (e, t) => {
            le.value && !1 === e && !0 === t && (Fe(le.value.page),
            Xe())
        }
        )),
        $(ye, (e => {
            se.value ? he(e) : Ve(1)
        }
        )),
        $([V, v], ( () => {
            se.value || Ve(1)
        }
        )),
        $([Le, pe, E, V, v], ( () => {
            Xe()
        }
        ), {
            deep: !0
        }),
        $(Re, (e => {
            a("updatePageItems", e)
        }
        ), {
            deep: !0
        }),
        $(ke, (e => {
            a("updateTotalItems", e)
        }
        ), {
            deep: !0
        }),
        t({
            currentPageFirstIndex: Be,
            currentPageLastIndex: Me,
            clientItemsLength: Ce,
            maxPaginationNumber: Ie,
            currentPaginationNumber: Le,
            isLastPage: _e,
            isFirstPage: Te,
            nextPage: Ee,
            prevPage: Oe,
            updatePage: Ve,
            rowsPerPageOptions: xe,
            rowsPerPageActiveOption: ye,
            updateRowsPerPageActiveOption: we
        }),
        (e, t) => (i(),
        sa("div", {
            ref_key: "dataTable",
            ref: ie,
            class: ca(["vue3-easy-data-table", [e.tableClassName]])
        }, [la("div", {
            ref_key: "tableBody",
            ref: ne,
            class: ca(["vue3-easy-data-table__main", {
                "fixed-header": r(m),
                "fixed-height": r(H),
                "show-shadow": re.value,
                "table-fixed": r(Ye).length,
                hoverable: !e.noHover,
                "border-cell": e.borderCell
            }])
        }, [la("table", {
            id: r(s)
        }, [la("colgroup", null, [(i(!0),
        sa(Q, null, ha(r(ge), ( (e, t) => (i(),
        sa("col", {
            key: t,
            style: pa($e(e))
        }, null, 4)))), 128))]), r(Z)["customize-headers"] ? da(e.$slots, "customize-headers", {
            key: 0
        }, void 0, !0) : r(ge).length && !e.hideHeader ? (i(),
        sa("thead", {
            key: 1,
            class: ca(["vue3-easy-data-table__header", [e.headerClassName]])
        }, [la("tr", null, [(i(!0),
        sa(Q, null, ha(r(ge), ( (t, a) => (i(),
        sa("th", {
            key: a,
            class: ca([{
                sortable: t.sortable,
                none: t.sortable && "none" === t.sortType,
                desc: t.sortable && "desc" === t.sortType,
                asc: t.sortable && "asc" === t.sortType,
                shadow: t.value === r(We)
            }, "string" == typeof e.headerItemClassName ? e.headerItemClassName : e.headerItemClassName(t, a + 1)]),
            style: pa(Ue(t.value)),
            onClick: Xt((e => t.sortable && t.sortType ? r(fe)(t.value, t.sortType) : null), ["stop"])
        }, ["checkbox" === t.text ? (i(),
        n(sg, {
            key: r(De),
            status: r(De),
            onChange: r(Ae)
        }, null, 8, ["status", "onChange"])) : (i(),
        sa("span", {
            key: 1,
            class: ca(["header", `direction-${r(w)}`])
        }, [r(Z)[`header-${t.value}`] ? da(e.$slots, `header-${t.value}`, ma(A({
            key: 0
        }, t)), void 0, !0) : r(Z)[`header-${t.value.toLowerCase()}`] ? da(e.$slots, `header-${t.value.toLowerCase()}`, ma(A({
            key: 1
        }, t)), void 0, !0) : r(Z).header ? da(e.$slots, "header", ma(A({
            key: 2
        }, t)), void 0, !0) : (i(),
        sa("span", Bg, Yt(t.text), 1)), t.sortable ? (i(),
        sa("i", {
            key: t.sortType ? t.sortType : "none",
            class: ca(["sortType-icon", {
                desc: "desc" === t.sortType
            }])
        }, null, 2)) : ua("", !0), r(I) && r(me)(t.value) ? (i(),
        sa("span", Mg, Yt(r(be)(t.value)), 1)) : ua("", !0)], 2))], 14, Fg)))), 128))])], 2)) : ua("", !0), r(te) ? da(e.$slots, "body", ma(A({
            key: 2
        }, r(Re))), void 0, !0) : r(ve).length ? (i(),
        sa("tbody", {
            key: 3,
            class: ca(["vue3-easy-data-table__body", {
                "row-alternation": e.alternating
            }])
        }, [da(e.$slots, "body-prepend", ma(ba({
            items: r(Re),
            pagination: {
                isFirstPage: r(Te),
                isLastPage: r(_e),
                currentPaginationNumber: r(Le),
                maxPaginationNumber: r(Ie),
                nextPage: r(Ee),
                prevPage: r(Oe)
            },
            headers: r(ge)
        })), void 0, !0), (i(!0),
        sa(Q, null, ha(r(Re), ( (t, o) => (i(),
        sa(Q, {
            key: o
        }, [la("tr", {
            class: ca([{
                "even-row": (o + 1) % 2 == 0
            }, "string" == typeof e.bodyRowClassName ? e.bodyRowClassName : e.bodyRowClassName(t, o + 1)]),
            onClick: a => {
                r(je)(t, "single", a),
                e.clickRowToExpand && r(He)(o + r(Ne), t, a)
            }
            ,
            onDblclick: e => {
                r(je)(t, "double", e)
            }
            ,
            onContextmenu: e => {
                ( (e, t) => {
                    j.value && t.preventDefault(),
                    a("contextmenuRow", e, t)
                }
                )(t, e)
            }
        }, [(i(!0),
        sa(Q, null, ha(r(ve), ( (a, s) => (i(),
        sa("td", {
            key: s,
            style: pa(Ue(a, "td")),
            class: ca([{
                shadow: a === r(We),
                "can-expand": "expand" === a
            }, "string" == typeof e.bodyItemClassName ? e.bodyItemClassName : e.bodyItemClassName(a, o + 1), `direction-${r(u)}`]),
            onClick: e => "expand" === a ? r(He)(o + r(Ne), t, e) : null
        }, [r(Z)[`item-${a}`] ? da(e.$slots, `item-${a}`, ma(A({
            key: 0
        }, t)), void 0, !0) : r(Z)[`item-${a.toLowerCase()}`] ? da(e.$slots, `item-${a.toLowerCase()}`, ma(A({
            key: 1
        }, t)), void 0, !0) : "expand" === a ? (i(),
        sa("i", {
            key: 2,
            class: ca(["expand-icon", {
                expanding: r(ze).includes(r(Ne) + o)
            }])
        }, null, 2)) : "checkbox" === a ? (i(),
        n(ug, {
            key: 3,
            checked: t[a],
            onChange: e => r(Pe)(t)
        }, null, 8, ["checked", "onChange"])) : r(Z).item ? da(e.$slots, "item", ma(A({
            key: 4
        }, {
            column: a,
            item: t
        })), void 0, !0) : (i(),
        sa(Q, {
            key: 5
        }, [vt(Yt(r(Tg)(a, t)), 1)], 64))], 14, Rg)))), 128))], 42, Dg), r(ee) && r(ze).includes(o + r(Ne)) ? (i(),
        sa("tr", {
            key: 0,
            class: ca([{
                "even-row": (o + 1) % 2 == 0
            }, "string" == typeof e.bodyExpandRowClassName ? e.bodyExpandRowClassName : e.bodyExpandRowClassName(t, o + 1)])
        }, [la("td", {
            colspan: r(ge).length,
            class: "expand"
        }, [t.expandLoading ? (i(),
        n(wg, {
            key: 0,
            class: "expand-loading"
        })) : ua("", !0), da(e.$slots, "expand", ma(ba(t)), void 0, !0)], 8, Ng)], 2)) : ua("", !0)], 64)))), 128)), da(e.$slots, "body-append", ma(ba({
            items: r(Re),
            pagination: {
                isFirstPage: r(Te),
                isLastPage: r(_e),
                currentPaginationNumber: r(Le),
                maxPaginationNumber: r(Ie),
                nextPage: r(Ee),
                prevPage: r(Oe),
                updatePage: r(Ve)
            },
            headers: r(ge)
        })), void 0, !0)], 2)) : ua("", !0)], 8, Vg), r(P) ? (i(),
        sa("div", zg, [Hg, la("div", Xg, [r(J) ? da(e.$slots, "loading", {
            key: 0
        }, void 0, !0) : (i(),
        n(xg, {
            key: 1
        }))])])) : ua("", !0), r(Re).length || r(P) ? ua("", !0) : (i(),
        sa("div", Yg, [da(e.$slots, "empty-message", {}, ( () => [vt(Yt(e.emptyMessage), 1)]), !0)]))], 2), e.hideFooter ? ua("", !0) : (i(),
        sa("div", Wg, [e.hideRowsPerPage ? ua("", !0) : (i(),
        sa("div", Gg, [vt(Yt(e.rowsPerPageMessage) + " ", 1), y(gg, {
            modelValue: r(ye),
            "onUpdate:modelValue": t[0] || (t[0] = e => M(ye) ? ye.value = e : null),
            "rows-items": r(xe)
        }, null, 8, ["modelValue", "rows-items"])])), la("div", jg, Yt(`${r(Be)}${r(Me)}`) + " " + Yt(r(W)) + " " + Yt(r(Ce)), 1), r(K) ? da(e.$slots, "pagination", ma(A({
            key: 1
        }, {
            isFirstPage: r(Te),
            isLastPage: r(_e),
            currentPaginationNumber: r(Le),
            maxPaginationNumber: r(Ie),
            nextPage: r(Ee),
            prevPage: r(Oe)
        })), void 0, !0) : (i(),
        n(Ig, {
            key: 2,
            "is-first-page": r(Te),
            "is-last-page": r(_e),
            onClickNextPage: r(Ee),
            onClickPrevPage: r(Oe)
        }, xa({
            _: 2
        }, [e.buttonsPagination ? {
            name: "buttonsPagination",
            fn: va(( () => [y(Cg, {
                "current-pagination-number": r(Le),
                "max-pagination-number": r(Ie),
                onUpdatePage: r(Ve)
            }, null, 8, ["current-pagination-number", "max-pagination-number", "onUpdatePage"])])),
            key: "0"
        } : void 0]), 1032, ["is-first-page", "is-last-page", "onClickNextPage", "onClickPrevPage"]))]))], 2))
    }
}), [["__scopeId", "data-v-32683533"]]);
"undefined" != typeof window && window.Vue && window.Vue.createApp({}).component("Vue3EasyDataTable", $g);
const Ug = "undefined" != typeof window
  , qg = (e, t=!1) => t ? Symbol.for(e) : Symbol(e)
  , Zg = e => JSON.stringify(e).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027")
  , Kg = e => "number" == typeof e && isFinite(e)
  , Jg = e => "[object RegExp]" === pf(e)
  , Qg = e => vf(e) && 0 === Object.keys(e).length
  , ef = Object.assign;
let tf;
const af = () => tf || (tf = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : "undefined" != typeof global ? global : {});
function nf(e) {
    return e.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;")
}
const rf = Object.prototype.hasOwnProperty;
function of(e, t) {
    return rf.call(e, t)
}
const sf = Array.isArray
  , lf = e => "function" == typeof e
  , cf = e => "string" == typeof e
  , uf = e => "boolean" == typeof e
  , df = e => null !== e && "object" == typeof e
  , hf = Object.prototype.toString
  , pf = e => hf.call(e)
  , vf = e => {
    if (!df(e))
        return !1;
    const t = Object.getPrototypeOf(e);
    return null === t || t.constructor === Object
}
;
function gf(e) {
    let t = e;
    return () => ++t
}
function ff(e, t) {}
const mf = e => !df(e) || sf(e);
function bf(e, t) {
    if (mf(e) || mf(t))
        throw new Error("Invalid value");
    const a = [{
        src: e,
        des: t
    }];
    for (; a.length; ) {
        const {src: e, des: t} = a.pop();
        Object.keys(e).forEach((i => {
            mf(e[i]) || mf(t[i]) ? t[i] = e[i] : a.push({
                src: e[i],
                des: t[i]
            })
        }
        ))
    }
}
function xf(e, t, a) {
    return {
        start: e,
        end: t
    }
}
const yf = /\{([0-9a-zA-Z]+)\}/g;
const wf = Object.assign
  , kf = e => "string" == typeof e
  , Sf = e => null !== e && "object" == typeof e;
function Cf(e, t="") {
    return e.reduce(( (e, a, i) => 0 === i ? e + a : e + t + a), "")
}
const Af = 1
  , Pf = 2
  , Lf = 3
  , If = 4
  , _f = 5
  , Tf = 6
  , Ef = 7
  , Of = 8
  , Vf = 9
  , Ff = 10
  , Bf = 11
  , Mf = 12
  , Df = 13
  , Rf = 14
  , Nf = 15
  , zf = 16
  , Hf = 17
  , Xf = {
    [Af]: "Expected token: '{0}'",
    [Pf]: "Invalid token in placeholder: '{0}'",
    [Lf]: "Unterminated single quote in placeholder",
    [If]: "Unknown escape sequence: \\{0}",
    [_f]: "Invalid unicode escape sequence: {0}",
    [Tf]: "Unbalanced closing brace",
    [Ef]: "Unterminated closing brace",
    [Of]: "Empty placeholder",
    [Vf]: "Not allowed nest placeholder",
    [Ff]: "Invalid linked format",
    [Bf]: "Plural must have messages",
    [Mf]: "Unexpected empty linked modifier",
    [Df]: "Unexpected empty linked key",
    [Rf]: "Unexpected lexical analysis in token: '{0}'",
    [Nf]: "unhandled codegen node type: '{0}'",
    [zf]: "unhandled mimifier node type: '{0}'"
};
function Yf(e, t, a={}) {
    const {domain: i, messages: n, args: r} = a
      , o = function(e, ...t) {
        return 1 === t.length && Sf(t[0]) && (t = t[0]),
        t && t.hasOwnProperty || (t = {}),
        e.replace(yf, ( (e, a) => t.hasOwnProperty(a) ? t[a] : ""))
    }((n || Xf)[e] || "", ...r || [])
      , s = new SyntaxError(String(o));
    return s.code = e,
    t && (s.location = t),
    s.domain = i,
    s
}
function Wf(e) {
    throw e
}
const Gf = " "
  , jf = "\n"
  , $f = String.fromCharCode(8232)
  , Uf = String.fromCharCode(8233);
function qf(e) {
    const t = e;
    let a = 0
      , i = 1
      , n = 1
      , r = 0;
    const o = e => "\r" === t[e] && t[e + 1] === jf
      , s = e => t[e] === Uf
      , l = e => t[e] === $f
      , c = e => o(e) || (e => t[e] === jf)(e) || s(e) || l(e)
      , u = e => o(e) || s(e) || l(e) ? jf : t[e];
    function d() {
        return r = 0,
        c(a) && (i++,
        n = 0),
        o(a) && a++,
        a++,
        n++,
        t[a]
    }
    return {
        index: () => a,
        line: () => i,
        column: () => n,
        peekOffset: () => r,
        charAt: u,
        currentChar: () => u(a),
        currentPeek: () => u(a + r),
        next: d,
        peek: function() {
            return o(a + r) && r++,
            r++,
            t[a + r]
        },
        reset: function() {
            a = 0,
            i = 1,
            n = 1,
            r = 0
        },
        resetPeek: function(e=0) {
            r = e
        },
        skipToPeek: function() {
            const e = a + r;
            for (; e !== a; )
                d();
            r = 0
        }
    }
}
const Zf = void 0;
function Kf(e, t={}) {
    const a = !1 !== t.location
      , i = qf(e)
      , n = () => i.index()
      , r = () => {
        return e = i.line(),
        t = i.column(),
        a = i.index(),
        {
            line: e,
            column: t,
            offset: a
        };
        var e, t, a
    }
      , o = r()
      , s = n()
      , l = {
        currentType: 14,
        offset: s,
        startLoc: o,
        endLoc: o,
        lastType: 14,
        lastOffset: s,
        lastStartLoc: o,
        lastEndLoc: o,
        braceNest: 0,
        inLinked: !1,
        text: ""
    }
      , c = () => l
      , {onError: u} = t;
    function d(e, t, i, ...n) {
        const r = c();
        if (t.column += i,
        t.offset += i,
        u) {
            const i = Yf(e, a ? xf(r.startLoc, t) : null, {
                domain: "tokenizer",
                args: n
            });
            u(i)
        }
    }
    function h(e, t, i) {
        e.endLoc = r(),
        e.currentType = t;
        const n = {
            type: t
        };
        return a && (n.loc = xf(e.startLoc, e.endLoc)),
        null != i && (n.value = i),
        n
    }
    const p = e => h(e, 14);
    function v(e, t) {
        return e.currentChar() === t ? (e.next(),
        t) : (d(Af, r(), 0, t),
        "")
    }
    function g(e) {
        let t = "";
        for (; e.currentPeek() === Gf || e.currentPeek() === jf; )
            t += e.currentPeek(),
            e.peek();
        return t
    }
    function f(e) {
        const t = g(e);
        return e.skipToPeek(),
        t
    }
    function m(e) {
        if (e === Zf)
            return !1;
        const t = e.charCodeAt(0);
        return t >= 97 && t <= 122 || t >= 65 && t <= 90 || 95 === t
    }
    function b(e, t) {
        const {currentType: a} = t;
        if (2 !== a)
            return !1;
        g(e);
        const i = function(e) {
            if (e === Zf)
                return !1;
            const t = e.charCodeAt(0);
            return t >= 48 && t <= 57
        }("-" === e.currentPeek() ? e.peek() : e.currentPeek());
        return e.resetPeek(),
        i
    }
    function x(e) {
        g(e);
        const t = "|" === e.currentPeek();
        return e.resetPeek(),
        t
    }
    function y(e, t=!0) {
        const a = (t=!1, i="", n=!1) => {
            const r = e.currentPeek();
            return "{" === r ? "%" !== i && t : "@" !== r && r ? "%" === r ? (e.peek(),
            a(t, "%", !0)) : "|" === r ? !("%" !== i && !n) || !(i === Gf || i === jf) : r === Gf ? (e.peek(),
            a(!0, Gf, n)) : r !== jf || (e.peek(),
            a(!0, jf, n)) : "%" === i || t
        }
          , i = a();
        return t && e.resetPeek(),
        i
    }
    function w(e, t) {
        const a = e.currentChar();
        return a === Zf ? Zf : t(a) ? (e.next(),
        a) : null
    }
    function k(e) {
        return w(e, (e => {
            const t = e.charCodeAt(0);
            return t >= 97 && t <= 122 || t >= 65 && t <= 90 || t >= 48 && t <= 57 || 95 === t || 36 === t
        }
        ))
    }
    function S(e) {
        return w(e, (e => {
            const t = e.charCodeAt(0);
            return t >= 48 && t <= 57
        }
        ))
    }
    function C(e) {
        return w(e, (e => {
            const t = e.charCodeAt(0);
            return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102
        }
        ))
    }
    function A(e) {
        let t = ""
          , a = "";
        for (; t = S(e); )
            a += t;
        return a
    }
    function P(e) {
        let t = "";
        for (; ; ) {
            const a = e.currentChar();
            if ("{" === a || "}" === a || "@" === a || "|" === a || !a)
                break;
            if ("%" === a) {
                if (!y(e))
                    break;
                t += a,
                e.next()
            } else if (a === Gf || a === jf)
                if (y(e))
                    t += a,
                    e.next();
                else {
                    if (x(e))
                        break;
                    t += a,
                    e.next()
                }
            else
                t += a,
                e.next()
        }
        return t
    }
    function L(e) {
        const t = e.currentChar();
        switch (t) {
        case "\\":
        case "'":
            return e.next(),
            `\\${t}`;
        case "u":
            return I(e, t, 4);
        case "U":
            return I(e, t, 6);
        default:
            return d(If, r(), 0, t),
            ""
        }
    }
    function I(e, t, a) {
        v(e, t);
        let i = "";
        for (let n = 0; n < a; n++) {
            const a = C(e);
            if (!a) {
                d(_f, r(), 0, `\\${t}${i}${e.currentChar()}`);
                break
            }
            i += a
        }
        return `\\${t}${i}`
    }
    function _(e) {
        f(e);
        const t = v(e, "|");
        return f(e),
        t
    }
    function T(e, t) {
        let a = null;
        switch (e.currentChar()) {
        case "{":
            return t.braceNest >= 1 && d(Vf, r(), 0),
            e.next(),
            a = h(t, 2, "{"),
            f(e),
            t.braceNest++,
            a;
        case "}":
            return t.braceNest > 0 && 2 === t.currentType && d(Of, r(), 0),
            e.next(),
            a = h(t, 3, "}"),
            t.braceNest--,
            t.braceNest > 0 && f(e),
            t.inLinked && 0 === t.braceNest && (t.inLinked = !1),
            a;
        case "@":
            return t.braceNest > 0 && d(Ef, r(), 0),
            a = E(e, t) || p(t),
            t.braceNest = 0,
            a;
        default:
            let i = !0
              , n = !0
              , o = !0;
            if (x(e))
                return t.braceNest > 0 && d(Ef, r(), 0),
                a = h(t, 1, _(e)),
                t.braceNest = 0,
                t.inLinked = !1,
                a;
            if (t.braceNest > 0 && (5 === t.currentType || 6 === t.currentType || 7 === t.currentType))
                return d(Ef, r(), 0),
                t.braceNest = 0,
                O(e, t);
            if (i = function(e, t) {
                const {currentType: a} = t;
                if (2 !== a)
                    return !1;
                g(e);
                const i = m(e.currentPeek());
                return e.resetPeek(),
                i
            }(e, t))
                return a = h(t, 5, function(e) {
                    f(e);
                    let t = ""
                      , a = "";
                    for (; t = k(e); )
                        a += t;
                    return e.currentChar() === Zf && d(Ef, r(), 0),
                    a
                }(e)),
                f(e),
                a;
            if (n = b(e, t))
                return a = h(t, 6, function(e) {
                    f(e);
                    let t = "";
                    return "-" === e.currentChar() ? (e.next(),
                    t += `-${A(e)}`) : t += A(e),
                    e.currentChar() === Zf && d(Ef, r(), 0),
                    t
                }(e)),
                f(e),
                a;
            if (o = function(e, t) {
                const {currentType: a} = t;
                if (2 !== a)
                    return !1;
                g(e);
                const i = "'" === e.currentPeek();
                return e.resetPeek(),
                i
            }(e, t))
                return a = h(t, 7, function(e) {
                    f(e),
                    v(e, "'");
                    let t = ""
                      , a = "";
                    const i = e => "'" !== e && e !== jf;
                    for (; t = w(e, i); )
                        a += "\\" === t ? L(e) : t;
                    const n = e.currentChar();
                    return n === jf || n === Zf ? (d(Lf, r(), 0),
                    n === jf && (e.next(),
                    v(e, "'")),
                    a) : (v(e, "'"),
                    a)
                }(e)),
                f(e),
                a;
            if (!i && !n && !o)
                return a = h(t, 13, function(e) {
                    f(e);
                    let t = ""
                      , a = "";
                    const i = e => "{" !== e && "}" !== e && e !== Gf && e !== jf;
                    for (; t = w(e, i); )
                        a += t;
                    return a
                }(e)),
                d(Pf, r(), 0, a.value),
                f(e),
                a
        }
        return a
    }
    function E(e, t) {
        const {currentType: a} = t;
        let i = null;
        const n = e.currentChar();
        switch (8 !== a && 9 !== a && 12 !== a && 10 !== a || n !== jf && n !== Gf || d(Ff, r(), 0),
        n) {
        case "@":
            return e.next(),
            i = h(t, 8, "@"),
            t.inLinked = !0,
            i;
        case ".":
            return f(e),
            e.next(),
            h(t, 9, ".");
        case ":":
            return f(e),
            e.next(),
            h(t, 10, ":");
        default:
            return x(e) ? (i = h(t, 1, _(e)),
            t.braceNest = 0,
            t.inLinked = !1,
            i) : function(e, t) {
                const {currentType: a} = t;
                if (8 !== a)
                    return !1;
                g(e);
                const i = "." === e.currentPeek();
                return e.resetPeek(),
                i
            }(e, t) || function(e, t) {
                const {currentType: a} = t;
                if (8 !== a && 12 !== a)
                    return !1;
                g(e);
                const i = ":" === e.currentPeek();
                return e.resetPeek(),
                i
            }(e, t) ? (f(e),
            E(e, t)) : function(e, t) {
                const {currentType: a} = t;
                if (9 !== a)
                    return !1;
                g(e);
                const i = m(e.currentPeek());
                return e.resetPeek(),
                i
            }(e, t) ? (f(e),
            h(t, 12, function(e) {
                let t = ""
                  , a = "";
                for (; t = k(e); )
                    a += t;
                return a
            }(e))) : function(e, t) {
                const {currentType: a} = t;
                if (10 !== a)
                    return !1;
                const i = () => {
                    const t = e.currentPeek();
                    return "{" === t ? m(e.peek()) : !("@" === t || "%" === t || "|" === t || ":" === t || "." === t || t === Gf || !t) && (t === jf ? (e.peek(),
                    i()) : m(t))
                }
                  , n = i();
                return e.resetPeek(),
                n
            }(e, t) ? (f(e),
            "{" === n ? T(e, t) || i : h(t, 11, function(e) {
                const t = (a=!1, i) => {
                    const n = e.currentChar();
                    return "{" !== n && "%" !== n && "@" !== n && "|" !== n && "(" !== n && ")" !== n && n ? n === Gf ? i : n === jf || "." === n ? (i += n,
                    e.next(),
                    t(a, i)) : (i += n,
                    e.next(),
                    t(!0, i)) : i
                }
                ;
                return t(!1, "")
            }(e))) : (8 === a && d(Ff, r(), 0),
            t.braceNest = 0,
            t.inLinked = !1,
            O(e, t))
        }
    }
    function O(e, t) {
        let a = {
            type: 14
        };
        if (t.braceNest > 0)
            return T(e, t) || p(t);
        if (t.inLinked)
            return E(e, t) || p(t);
        switch (e.currentChar()) {
        case "{":
            return T(e, t) || p(t);
        case "}":
            return d(Tf, r(), 0),
            e.next(),
            h(t, 3, "}");
        case "@":
            return E(e, t) || p(t);
        default:
            if (x(e))
                return a = h(t, 1, _(e)),
                t.braceNest = 0,
                t.inLinked = !1,
                a;
            const {isModulo: i, hasSpace: n} = function(e) {
                const t = g(e)
                  , a = "%" === e.currentPeek() && "{" === e.peek();
                return e.resetPeek(),
                {
                    isModulo: a,
                    hasSpace: t.length > 0
                }
            }(e);
            if (i)
                return n ? h(t, 0, P(e)) : h(t, 4, function(e) {
                    f(e);
                    const t = e.currentChar();
                    return "%" !== t && d(Af, r(), 0, t),
                    e.next(),
                    "%"
                }(e));
            if (y(e))
                return h(t, 0, P(e))
        }
        return a
    }
    return {
        nextToken: function() {
            const {currentType: e, offset: t, startLoc: a, endLoc: o} = l;
            return l.lastType = e,
            l.lastOffset = t,
            l.lastStartLoc = a,
            l.lastEndLoc = o,
            l.offset = n(),
            l.startLoc = r(),
            i.currentChar() === Zf ? h(l, 14) : O(i, l)
        },
        currentOffset: n,
        currentPosition: r,
        context: c
    }
}
const Jf = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function Qf(e, t, a) {
    switch (e) {
    case "\\\\":
        return "\\";
    case "\\'":
        return "'";
    default:
        {
            const e = parseInt(t || a, 16);
            return e <= 55295 || e >= 57344 ? String.fromCodePoint(e) : ""
        }
    }
}
function em(e={}) {
    const t = !1 !== e.location
      , {onError: a} = e;
    function i(e, i, n, r, ...o) {
        const s = e.currentPosition();
        if (s.offset += r,
        s.column += r,
        a) {
            const e = Yf(i, t ? xf(n, s) : null, {
                domain: "parser",
                args: o
            });
            a(e)
        }
    }
    function n(e, a, i) {
        const n = {
            type: e
        };
        return t && (n.start = a,
        n.end = a,
        n.loc = {
            start: i,
            end: i
        }),
        n
    }
    function r(e, a, i, n) {
        t && (e.end = a,
        e.loc && (e.loc.end = i))
    }
    function o(e, t) {
        const a = e.context()
          , i = n(3, a.offset, a.startLoc);
        return i.value = t,
        r(i, e.currentOffset(), e.currentPosition()),
        i
    }
    function s(e, t) {
        const a = e.context()
          , {lastOffset: i, lastStartLoc: o} = a
          , s = n(5, i, o);
        return s.index = parseInt(t, 10),
        e.nextToken(),
        r(s, e.currentOffset(), e.currentPosition()),
        s
    }
    function l(e, t) {
        const a = e.context()
          , {lastOffset: i, lastStartLoc: o} = a
          , s = n(4, i, o);
        return s.key = t,
        e.nextToken(),
        r(s, e.currentOffset(), e.currentPosition()),
        s
    }
    function c(e, t) {
        const a = e.context()
          , {lastOffset: i, lastStartLoc: o} = a
          , s = n(9, i, o);
        return s.value = t.replace(Jf, Qf),
        e.nextToken(),
        r(s, e.currentOffset(), e.currentPosition()),
        s
    }
    function u(e) {
        const t = e.context()
          , a = n(6, t.offset, t.startLoc);
        let o = e.nextToken();
        if (9 === o.type) {
            const t = function(e) {
                const t = e.nextToken()
                  , a = e.context()
                  , {lastOffset: o, lastStartLoc: s} = a
                  , l = n(8, o, s);
                return 12 !== t.type ? (i(e, Mf, a.lastStartLoc, 0),
                l.value = "",
                r(l, o, s),
                {
                    nextConsumeToken: t,
                    node: l
                }) : (null == t.value && i(e, Rf, a.lastStartLoc, 0, tm(t)),
                l.value = t.value || "",
                r(l, e.currentOffset(), e.currentPosition()),
                {
                    node: l
                })
            }(e);
            a.modifier = t.node,
            o = t.nextConsumeToken || e.nextToken()
        }
        switch (10 !== o.type && i(e, Rf, t.lastStartLoc, 0, tm(o)),
        o = e.nextToken(),
        2 === o.type && (o = e.nextToken()),
        o.type) {
        case 11:
            null == o.value && i(e, Rf, t.lastStartLoc, 0, tm(o)),
            a.key = function(e, t) {
                const a = e.context()
                  , i = n(7, a.offset, a.startLoc);
                return i.value = t,
                r(i, e.currentOffset(), e.currentPosition()),
                i
            }(e, o.value || "");
            break;
        case 5:
            null == o.value && i(e, Rf, t.lastStartLoc, 0, tm(o)),
            a.key = l(e, o.value || "");
            break;
        case 6:
            null == o.value && i(e, Rf, t.lastStartLoc, 0, tm(o)),
            a.key = s(e, o.value || "");
            break;
        case 7:
            null == o.value && i(e, Rf, t.lastStartLoc, 0, tm(o)),
            a.key = c(e, o.value || "");
            break;
        default:
            i(e, Df, t.lastStartLoc, 0);
            const u = e.context()
              , d = n(7, u.offset, u.startLoc);
            return d.value = "",
            r(d, u.offset, u.startLoc),
            a.key = d,
            r(a, u.offset, u.startLoc),
            {
                nextConsumeToken: o,
                node: a
            }
        }
        return r(a, e.currentOffset(), e.currentPosition()),
        {
            node: a
        }
    }
    function d(e) {
        const t = e.context()
          , a = n(2, 1 === t.currentType ? e.currentOffset() : t.offset, 1 === t.currentType ? t.endLoc : t.startLoc);
        a.items = [];
        let d = null;
        do {
            const n = d || e.nextToken();
            switch (d = null,
            n.type) {
            case 0:
                null == n.value && i(e, Rf, t.lastStartLoc, 0, tm(n)),
                a.items.push(o(e, n.value || ""));
                break;
            case 6:
                null == n.value && i(e, Rf, t.lastStartLoc, 0, tm(n)),
                a.items.push(s(e, n.value || ""));
                break;
            case 5:
                null == n.value && i(e, Rf, t.lastStartLoc, 0, tm(n)),
                a.items.push(l(e, n.value || ""));
                break;
            case 7:
                null == n.value && i(e, Rf, t.lastStartLoc, 0, tm(n)),
                a.items.push(c(e, n.value || ""));
                break;
            case 8:
                const r = u(e);
                a.items.push(r.node),
                d = r.nextConsumeToken || null
            }
        } while (14 !== t.currentType && 1 !== t.currentType);
        return r(a, 1 === t.currentType ? t.lastOffset : e.currentOffset(), 1 === t.currentType ? t.lastEndLoc : e.currentPosition()),
        a
    }
    function h(e) {
        const t = e.context()
          , {offset: a, startLoc: o} = t
          , s = d(e);
        return 14 === t.currentType ? s : function(e, t, a, o) {
            const s = e.context();
            let l = 0 === o.items.length;
            const c = n(1, t, a);
            c.cases = [],
            c.cases.push(o);
            do {
                const t = d(e);
                l || (l = 0 === t.items.length),
                c.cases.push(t)
            } while (14 !== s.currentType);
            return l && i(e, Bf, a, 0),
            r(c, e.currentOffset(), e.currentPosition()),
            c
        }(e, a, o, s)
    }
    return {
        parse: function(a) {
            const o = Kf(a, wf({}, e))
              , s = o.context()
              , l = n(0, s.offset, s.startLoc);
            return t && l.loc && (l.loc.source = a),
            l.body = h(o),
            e.onCacheKey && (l.cacheKey = e.onCacheKey(a)),
            14 !== s.currentType && i(o, Rf, s.lastStartLoc, 0, a[s.offset] || ""),
            r(l, o.currentOffset(), o.currentPosition()),
            l
        }
    }
}
function tm(e) {
    if (14 === e.type)
        return "EOF";
    const t = (e.value || "").replace(/\r?\n/gu, "\\n");
    return t.length > 10 ? t.slice(0, 9) + "" : t
}
function am(e, t) {
    for (let a = 0; a < e.length; a++)
        im(e[a], t)
}
function im(e, t) {
    switch (e.type) {
    case 1:
        am(e.cases, t),
        t.helper("plural");
        break;
    case 2:
        am(e.items, t);
        break;
    case 6:
        im(e.key, t),
        t.helper("linked"),
        t.helper("type");
        break;
    case 5:
        t.helper("interpolate"),
        t.helper("list");
        break;
    case 4:
        t.helper("interpolate"),
        t.helper("named")
    }
}
function nm(e, t={}) {
    const a = function(e) {
        const t = {
            ast: e,
            helpers: new Set
        };
        return {
            context: () => t,
            helper: e => (t.helpers.add(e),
            e)
        }
    }(e);
    a.helper("normalize"),
    e.body && im(e.body, a);
    const i = a.context();
    e.helpers = Array.from(i.helpers)
}
function rm(e) {
    if (1 === e.items.length) {
        const t = e.items[0];
        3 !== t.type && 9 !== t.type || (e.static = t.value,
        delete t.value)
    } else {
        const t = [];
        for (let a = 0; a < e.items.length; a++) {
            const i = e.items[a];
            if (3 !== i.type && 9 !== i.type)
                break;
            if (null == i.value)
                break;
            t.push(i.value)
        }
        if (t.length === e.items.length) {
            e.static = Cf(t);
            for (let t = 0; t < e.items.length; t++) {
                const a = e.items[t];
                3 !== a.type && 9 !== a.type || delete a.value
            }
        }
    }
}
function om(e) {
    switch (e.t = e.type,
    e.type) {
    case 0:
        const t = e;
        om(t.body),
        t.b = t.body,
        delete t.body;
        break;
    case 1:
        const a = e
          , i = a.cases;
        for (let e = 0; e < i.length; e++)
            om(i[e]);
        a.c = i,
        delete a.cases;
        break;
    case 2:
        const n = e
          , r = n.items;
        for (let e = 0; e < r.length; e++)
            om(r[e]);
        n.i = r,
        delete n.items,
        n.static && (n.s = n.static,
        delete n.static);
        break;
    case 3:
    case 9:
    case 8:
    case 7:
        const o = e;
        o.value && (o.v = o.value,
        delete o.value);
        break;
    case 6:
        const s = e;
        om(s.key),
        s.k = s.key,
        delete s.key,
        s.modifier && (om(s.modifier),
        s.m = s.modifier,
        delete s.modifier);
        break;
    case 5:
        const l = e;
        l.i = l.index,
        delete l.index;
        break;
    case 4:
        const c = e;
        c.k = c.key,
        delete c.key;
        break;
    default:
        throw Yf(zf, null, {
            domain: "minifier",
            args: [e.type]
        })
    }
    delete e.type
}
function sm(e, t) {
    const {helper: a} = e;
    switch (t.type) {
    case 0:
        !function(e, t) {
            t.body ? sm(e, t.body) : e.push("null")
        }(e, t);
        break;
    case 1:
        !function(e, t) {
            const {helper: a, needIndent: i} = e;
            if (t.cases.length > 1) {
                e.push(`${a("plural")}([`),
                e.indent(i());
                const n = t.cases.length;
                for (let a = 0; a < n && (sm(e, t.cases[a]),
                a !== n - 1); a++)
                    e.push(", ");
                e.deindent(i()),
                e.push("])")
            }
        }(e, t);
        break;
    case 2:
        !function(e, t) {
            const {helper: a, needIndent: i} = e;
            e.push(`${a("normalize")}([`),
            e.indent(i());
            const n = t.items.length;
            for (let r = 0; r < n && (sm(e, t.items[r]),
            r !== n - 1); r++)
                e.push(", ");
            e.deindent(i()),
            e.push("])")
        }(e, t);
        break;
    case 6:
        !function(e, t) {
            const {helper: a} = e;
            e.push(`${a("linked")}(`),
            sm(e, t.key),
            t.modifier ? (e.push(", "),
            sm(e, t.modifier),
            e.push(", _type")) : e.push(", undefined, _type"),
            e.push(")")
        }(e, t);
        break;
    case 8:
    case 7:
    case 9:
    case 3:
        e.push(JSON.stringify(t.value), t);
        break;
    case 5:
        e.push(`${a("interpolate")}(${a("list")}(${t.index}))`, t);
        break;
    case 4:
        e.push(`${a("interpolate")}(${a("named")}(${JSON.stringify(t.key)}))`, t);
        break;
    default:
        throw Yf(Nf, null, {
            domain: "parser",
            args: [t.type]
        })
    }
}
function lm(e, t={}) {
    const a = wf({}, t)
      , i = !!a.jit
      , n = !!a.minify
      , r = null == a.optimize || a.optimize
      , o = em(a).parse(e);
    return i ? (r && function(e) {
        const t = e.body;
        2 === t.type ? rm(t) : t.cases.forEach((e => rm(e)))
    }(o),
    n && om(o),
    {
        ast: o,
        code: ""
    }) : (nm(o, a),
    ( (e, t={}) => {
        const a = kf(t.mode) ? t.mode : "normal"
          , i = kf(t.filename) ? t.filename : "message.intl"
          , n = !!t.sourceMap
          , r = null != t.breakLineCode ? t.breakLineCode : "arrow" === a ? ";" : "\n"
          , o = t.needIndent ? t.needIndent : "arrow" !== a
          , s = e.helpers || []
          , l = function(e, t) {
            const {sourceMap: a, filename: i, breakLineCode: n, needIndent: r} = t
              , o = !1 !== t.location
              , s = {
                filename: i,
                code: "",
                column: 1,
                line: 1,
                offset: 0,
                map: void 0,
                breakLineCode: n,
                needIndent: r,
                indentLevel: 0
            };
            function l(e, t) {
                s.code += e
            }
            function c(e, t=!0) {
                const a = t ? n : "";
                l(r ? a + "  ".repeat(e) : a)
            }
            return o && e.loc && (s.source = e.loc.source),
            {
                context: () => s,
                push: l,
                indent: function(e=!0) {
                    const t = ++s.indentLevel;
                    e && c(t)
                },
                deindent: function(e=!0) {
                    const t = --s.indentLevel;
                    e && c(t)
                },
                newline: function() {
                    c(s.indentLevel)
                },
                helper: e => `_${e}`,
                needIndent: () => s.needIndent
            }
        }(e, {
            mode: a,
            filename: i,
            sourceMap: n,
            breakLineCode: r,
            needIndent: o
        });
        l.push("normal" === a ? "function __msg__ (ctx) {" : "(ctx) => {"),
        l.indent(o),
        s.length > 0 && (l.push(`const { ${Cf(s.map((e => `${e}: _${e}`)), ", ")} } = ctx`),
        l.newline()),
        l.push("return "),
        sm(l, e),
        l.deindent(o),
        l.push("}"),
        delete e.helpers;
        const {code: c, map: u} = l.context();
        return {
            ast: e,
            code: c,
            map: u ? u.toJSON() : void 0
        }
    }
    )(o, a))
}
const cm = [];
cm[0] = {
    w: [0],
    i: [3, 0],
    "[": [4],
    o: [7]
},
cm[1] = {
    w: [1],
    ".": [2],
    "[": [4],
    o: [7]
},
cm[2] = {
    w: [2],
    i: [3, 0],
    0: [3, 0]
},
cm[3] = {
    i: [3, 0],
    0: [3, 0],
    w: [1, 1],
    ".": [2, 1],
    "[": [4, 1],
    o: [7, 1]
},
cm[4] = {
    "'": [5, 0],
    '"': [6, 0],
    "[": [4, 2],
    "]": [1, 3],
    o: 8,
    l: [4, 0]
},
cm[5] = {
    "'": [4, 0],
    o: 8,
    l: [5, 0]
},
cm[6] = {
    '"': [4, 0],
    o: 8,
    l: [6, 0]
};
const um = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function dm(e) {
    if (null == e)
        return "o";
    switch (e.charCodeAt(0)) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
        return e;
    case 95:
    case 36:
    case 45:
        return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
        return "w"
    }
    return "i"
}
function hm(e) {
    const t = e.trim();
    return ("0" !== e.charAt(0) || !isNaN(parseInt(e))) && (a = t,
    um.test(a) ? function(e) {
        const t = e.charCodeAt(0);
        return t !== e.charCodeAt(e.length - 1) || 34 !== t && 39 !== t ? e : e.slice(1, -1)
    }(t) : "*" + t);
    var a
}
const pm = new Map;
function vm(e, t) {
    return df(e) ? e[t] : null
}
const gm = e => e
  , fm = e => ""
  , mm = e => 0 === e.length ? "" : function(e, t="") {
    return e.reduce(( (e, a, i) => 0 === i ? e + a : e + t + a), "")
}(e)
  , bm = e => null == e ? "" : sf(e) || vf(e) && e.toString === hf ? JSON.stringify(e, null, 2) : String(e);
function xm(e, t) {
    return e = Math.abs(e),
    2 === t ? e ? e > 1 ? 1 : 0 : 1 : e ? Math.min(e, 2) : 0
}
function ym(e={}) {
    const t = e.locale
      , a = function(e) {
        const t = Kg(e.pluralIndex) ? e.pluralIndex : -1;
        return e.named && (Kg(e.named.count) || Kg(e.named.n)) ? Kg(e.named.count) ? e.named.count : Kg(e.named.n) ? e.named.n : t : t
    }(e)
      , i = df(e.pluralRules) && cf(t) && lf(e.pluralRules[t]) ? e.pluralRules[t] : xm
      , n = df(e.pluralRules) && cf(t) && lf(e.pluralRules[t]) ? xm : void 0
      , r = e.list || []
      , o = e.named || {};
    Kg(e.pluralIndex) && function(e, t) {
        t.count || (t.count = e),
        t.n || (t.n = e)
    }(a, o);
    function s(t) {
        const a = lf(e.messages) ? e.messages(t) : !!df(e.messages) && e.messages[t];
        return a || (e.parent ? e.parent.message(t) : fm)
    }
    const l = vf(e.processor) && lf(e.processor.normalize) ? e.processor.normalize : mm
      , c = vf(e.processor) && lf(e.processor.interpolate) ? e.processor.interpolate : bm
      , u = {
        list: e => r[e],
        named: e => o[e],
        plural: e => e[i(a, e.length, n)],
        linked: (t, ...a) => {
            const [i,n] = a;
            let r = "text"
              , o = "";
            1 === a.length ? df(i) ? (o = i.modifier || o,
            r = i.type || r) : cf(i) && (o = i || o) : 2 === a.length && (cf(i) && (o = i || o),
            cf(n) && (r = n || r));
            const l = s(t)(u)
              , c = "vnode" === r && sf(l) && o ? l[0] : l;
            return o ? (d = o,
            e.modifiers ? e.modifiers[d] : gm)(c, r) : c;
            var d
        }
        ,
        message: s,
        type: vf(e.processor) && cf(e.processor.type) ? e.processor.type : "text",
        interpolate: c,
        normalize: l,
        values: ef({}, r, o)
    };
    return u
}
let wm = null;
const km = Sm("function:translate");
function Sm(e) {
    return t => wm && wm.emit(e, t)
}
const Cm = Hf
  , Am = gf(Cm)
  , Pm = {
    INVALID_ARGUMENT: Cm,
    INVALID_DATE_ARGUMENT: Am(),
    INVALID_ISO_DATE_ARGUMENT: Am(),
    NOT_SUPPORT_NON_STRING_MESSAGE: Am(),
    NOT_SUPPORT_LOCALE_PROMISE_VALUE: Am(),
    NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: Am(),
    NOT_SUPPORT_LOCALE_TYPE: Am(),
    __EXTEND_POINT__: Am()
};
function Lm(e) {
    return Yf(e, null, void 0)
}
function Im(e, t) {
    return null != t.locale ? Tm(t.locale) : Tm(e.locale)
}
let _m;
function Tm(e) {
    if (cf(e))
        return e;
    if (lf(e)) {
        if (e.resolvedOnce && null != _m)
            return _m;
        if ("Function" === e.constructor.name) {
            const a = e();
            if (df(t = a) && lf(t.then) && lf(t.catch))
                throw Lm(Pm.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
            return _m = a
        }
        throw Lm(Pm.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
    }
    throw Lm(Pm.NOT_SUPPORT_LOCALE_TYPE);
    var t
}
function Em(e, t, a) {
    return [...new Set([a, ...sf(t) ? t : df(t) ? Object.keys(t) : cf(t) ? [t] : [a]])]
}
function Om(e, t, a) {
    const i = cf(a) ? a : Mm
      , n = e;
    n.__localeChainCache || (n.__localeChainCache = new Map);
    let r = n.__localeChainCache.get(i);
    if (!r) {
        r = [];
        let e = [a];
        for (; sf(e); )
            e = Vm(r, e, t);
        const o = sf(t) || !vf(t) ? t : t.default ? t.default : null;
        e = cf(o) ? [o] : o,
        sf(e) && Vm(r, e, !1),
        n.__localeChainCache.set(i, r)
    }
    return r
}
function Vm(e, t, a) {
    let i = !0;
    for (let n = 0; n < t.length && uf(i); n++) {
        const r = t[n];
        cf(r) && (i = Fm(e, t[n], a))
    }
    return i
}
function Fm(e, t, a) {
    let i;
    const n = t.split("-");
    do {
        i = Bm(e, n.join("-"), a),
        n.splice(-1, 1)
    } while (n.length && !0 === i);
    return i
}
function Bm(e, t, a) {
    let i = !1;
    if (!e.includes(t) && (i = !0,
    t)) {
        i = "!" !== t[t.length - 1];
        const n = t.replace(/!/g, "");
        e.push(n),
        (sf(a) || vf(a)) && a[n] && (i = a[n])
    }
    return i
}
const Mm = "en-US"
  , Dm = e => `${e.charAt(0).toLocaleUpperCase()}${e.substr(1)}`;
let Rm, Nm, zm;
function Hm(e) {
    Rm = e
}
let Xm = null;
const Ym = () => Xm;
let Wm = null;
const Gm = e => {
    Wm = e
}
;
let jm = 0;
function $m(e={}) {
    const t = lf(e.onWarn) ? e.onWarn : ff
      , a = cf(e.version) ? e.version : "9.9.1"
      , i = cf(e.locale) || lf(e.locale) ? e.locale : Mm
      , n = lf(i) ? Mm : i
      , r = sf(e.fallbackLocale) || vf(e.fallbackLocale) || cf(e.fallbackLocale) || !1 === e.fallbackLocale ? e.fallbackLocale : n
      , o = vf(e.messages) ? e.messages : {
        [n]: {}
    }
      , s = vf(e.datetimeFormats) ? e.datetimeFormats : {
        [n]: {}
    }
      , l = vf(e.numberFormats) ? e.numberFormats : {
        [n]: {}
    }
      , c = ef({}, e.modifiers || {}, {
        upper: (e, t) => "text" === t && cf(e) ? e.toUpperCase() : "vnode" === t && df(e) && "__v_isVNode"in e ? e.children.toUpperCase() : e,
        lower: (e, t) => "text" === t && cf(e) ? e.toLowerCase() : "vnode" === t && df(e) && "__v_isVNode"in e ? e.children.toLowerCase() : e,
        capitalize: (e, t) => "text" === t && cf(e) ? Dm(e) : "vnode" === t && df(e) && "__v_isVNode"in e ? Dm(e.children) : e
    })
      , u = e.pluralRules || {}
      , d = lf(e.missing) ? e.missing : null
      , h = !uf(e.missingWarn) && !Jg(e.missingWarn) || e.missingWarn
      , p = !uf(e.fallbackWarn) && !Jg(e.fallbackWarn) || e.fallbackWarn
      , v = !!e.fallbackFormat
      , g = !!e.unresolving
      , f = lf(e.postTranslation) ? e.postTranslation : null
      , m = vf(e.processor) ? e.processor : null
      , b = !uf(e.warnHtmlMessage) || e.warnHtmlMessage
      , x = !!e.escapeParameter
      , y = lf(e.messageCompiler) ? e.messageCompiler : Rm
      , w = lf(e.messageResolver) ? e.messageResolver : Nm || vm
      , k = lf(e.localeFallbacker) ? e.localeFallbacker : zm || Em
      , S = df(e.fallbackContext) ? e.fallbackContext : void 0
      , C = e
      , A = df(C.__datetimeFormatters) ? C.__datetimeFormatters : new Map
      , P = df(C.__numberFormatters) ? C.__numberFormatters : new Map
      , L = df(C.__meta) ? C.__meta : {};
    jm++;
    const I = {
        version: a,
        cid: jm,
        locale: i,
        fallbackLocale: r,
        messages: o,
        modifiers: c,
        pluralRules: u,
        missing: d,
        missingWarn: h,
        fallbackWarn: p,
        fallbackFormat: v,
        unresolving: g,
        postTranslation: f,
        processor: m,
        warnHtmlMessage: b,
        escapeParameter: x,
        messageCompiler: y,
        messageResolver: w,
        localeFallbacker: k,
        fallbackContext: S,
        onWarn: t,
        __meta: L
    };
    return I.datetimeFormats = s,
    I.numberFormats = l,
    I.__datetimeFormatters = A,
    I.__numberFormatters = P,
    __INTLIFY_PROD_DEVTOOLS__ && function(e, t, a) {
        wm && wm.emit("i18n:init", {
            timestamp: Date.now(),
            i18n: e,
            version: t,
            meta: a
        })
    }(I, a, L),
    I
}
function Um(e, t, a, i, n) {
    const {missing: r, onWarn: o} = e;
    if (null !== r) {
        const i = r(e, a, t, n);
        return cf(i) ? i : t
    }
    return t
}
function qm(e, t, a) {
    e.__localeChainCache = new Map,
    e.localeFallbacker(e, a, t)
}
function Zm(e) {
    return t => function(e, t) {
        const a = t.b || t.body;
        if (1 === (a.t || a.type)) {
            const t = a
              , i = t.c || t.cases;
            return e.plural(i.reduce(( (t, a) => [...t, Km(e, a)]), []))
        }
        return Km(e, a)
    }(t, e)
}
function Km(e, t) {
    const a = t.s || t.static;
    if (a)
        return "text" === e.type ? a : e.normalize([a]);
    {
        const a = (t.i || t.items).reduce(( (t, a) => [...t, Jm(e, a)]), []);
        return e.normalize(a)
    }
}
function Jm(e, t) {
    const a = t.t || t.type;
    switch (a) {
    case 3:
        const i = t;
        return i.v || i.value;
    case 9:
        const n = t;
        return n.v || n.value;
    case 4:
        const r = t;
        return e.interpolate(e.named(r.k || r.key));
    case 5:
        const o = t;
        return e.interpolate(e.list(null != o.i ? o.i : o.index));
    case 6:
        const s = t
          , l = s.m || s.modifier;
        return e.linked(Jm(e, s.k || s.key), l ? Jm(e, l) : void 0, e.type);
    case 7:
        const c = t;
        return c.v || c.value;
    case 8:
        const u = t;
        return u.v || u.value;
    default:
        throw new Error(`unhandled node type on format message part: ${a}`)
    }
}
const Qm = e => e;
let eb = Object.create(null);
const tb = e => df(e) && (0 === e.t || 0 === e.type) && ("b"in e || "body"in e);
function ab(e, t={}) {
    let a = !1;
    const i = t.onError || Wf;
    return t.onError = e => {
        a = !0,
        i(e)
    }
    ,
    {
        ...lm(e, t),
        detectError: a
    }
}
const ib = (e, t) => {
    if (!cf(e))
        throw Lm(Pm.NOT_SUPPORT_NON_STRING_MESSAGE);
    {
        !uf(t.warnHtmlMessage) || t.warnHtmlMessage;
        const a = (t.onCacheKey || Qm)(e)
          , i = eb[a];
        if (i)
            return i;
        const {code: n, detectError: r} = ab(e, t)
          , o = new Function(`return ${n}`)();
        return r ? o : eb[a] = o
    }
}
;
const nb = () => ""
  , rb = e => lf(e);
function ob(e, ...t) {
    const {fallbackFormat: a, postTranslation: i, unresolving: n, messageCompiler: r, fallbackLocale: o, messages: s} = e
      , [l,c] = cb(...t)
      , u = uf(c.missingWarn) ? c.missingWarn : e.missingWarn
      , d = uf(c.fallbackWarn) ? c.fallbackWarn : e.fallbackWarn
      , h = uf(c.escapeParameter) ? c.escapeParameter : e.escapeParameter
      , p = !!c.resolvedMessage
      , v = cf(c.default) || uf(c.default) ? uf(c.default) ? r ? l : () => l : c.default : a ? r ? l : () => l : ""
      , g = a || "" !== v
      , f = Im(e, c);
    h && function(e) {
        sf(e.list) ? e.list = e.list.map((e => cf(e) ? nf(e) : e)) : df(e.named) && Object.keys(e.named).forEach((t => {
            cf(e.named[t]) && (e.named[t] = nf(e.named[t]))
        }
        ))
    }(c);
    let[m,b,x] = p ? [l, f, s[f] || {}] : sb(e, l, f, o, d, u)
      , y = m
      , w = l;
    if (p || cf(y) || tb(y) || rb(y) || g && (y = v,
    w = y),
    !(p || (cf(y) || tb(y) || rb(y)) && cf(b)))
        return n ? -1 : l;
    let k = !1;
    const S = rb(y) ? y : lb(e, l, b, y, w, ( () => {
        k = !0
    }
    ));
    if (k)
        return y;
    const C = function(e, t, a, i) {
        const {modifiers: n, pluralRules: r, messageResolver: o, fallbackLocale: s, fallbackWarn: l, missingWarn: c, fallbackContext: u} = e
          , d = i => {
            let n = o(a, i);
            if (null == n && u) {
                const [,,e] = sb(u, i, t, s, l, c);
                n = o(e, i)
            }
            if (cf(n) || tb(n)) {
                let a = !1;
                const r = lb(e, i, t, n, i, ( () => {
                    a = !0
                }
                ));
                return a ? nb : r
            }
            return rb(n) ? n : nb
        }
          , h = {
            locale: t,
            modifiers: n,
            pluralRules: r,
            messages: d
        };
        e.processor && (h.processor = e.processor);
        i.list && (h.list = i.list);
        i.named && (h.named = i.named);
        Kg(i.plural) && (h.pluralIndex = i.plural);
        return h
    }(e, b, x, c)
      , A = function(e, t, a) {
        const i = t(a);
        return i
    }(0, S, ym(C))
      , P = i ? i(A, l) : A;
    if (__INTLIFY_PROD_DEVTOOLS__) {
        const t = {
            timestamp: Date.now(),
            key: cf(l) ? l : rb(y) ? y.key : "",
            locale: b || (rb(y) ? y.locale : ""),
            format: cf(y) ? y : rb(y) ? y.source : "",
            message: P
        };
        t.meta = ef({}, e.__meta, Ym() || {}),
        km(t)
    }
    return P
}
function sb(e, t, a, i, n, r) {
    const {messages: o, onWarn: s, messageResolver: l, localeFallbacker: c} = e
      , u = c(e, i, a);
    let d, h = {}, p = null;
    for (let v = 0; v < u.length && (d = u[v],
    h = o[d] || {},
    null === (p = l(h, t)) && (p = h[t]),
    !(cf(p) || tb(p) || rb(p))); v++) {
        const a = Um(e, t, d, 0, "translate");
        a !== t && (p = a)
    }
    return [p, d, h]
}
function lb(e, t, a, i, n, r) {
    const {messageCompiler: o, warnHtmlMessage: s} = e;
    if (rb(i)) {
        const e = i;
        return e.locale = e.locale || a,
        e.key = e.key || t,
        e
    }
    if (null == o) {
        const e = () => i;
        return e.locale = a,
        e.key = t,
        e
    }
    const l = o(i, function(e, t, a, i, n, r) {
        return {
            locale: t,
            key: a,
            warnHtmlMessage: n,
            onError: e => {
                throw r && r(e),
                e
            }
            ,
            onCacheKey: e => ( (e, t, a) => Zg({
                l: e,
                k: t,
                s: a
            }))(t, a, e)
        }
    }(0, a, n, 0, s, r));
    return l.locale = a,
    l.key = t,
    l.source = i,
    l
}
function cb(...e) {
    const [t,a,i] = e
      , n = {};
    if (!(cf(t) || Kg(t) || rb(t) || tb(t)))
        throw Lm(Pm.INVALID_ARGUMENT);
    const r = Kg(t) ? String(t) : (rb(t),
    t);
    return Kg(a) ? n.plural = a : cf(a) ? n.default = a : vf(a) && !Qg(a) ? n.named = a : sf(a) && (n.list = a),
    Kg(i) ? n.plural = i : cf(i) ? n.default = i : vf(i) && ef(n, i),
    [r, n]
}
function ub(e, ...t) {
    const {datetimeFormats: a, unresolving: i, fallbackLocale: n, onWarn: r, localeFallbacker: o} = e
      , {__datetimeFormatters: s} = e
      , [l,c,u,d] = hb(...t);
    uf(u.missingWarn) ? u.missingWarn : e.missingWarn;
    uf(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn;
    const h = !!u.part
      , p = Im(e, u)
      , v = o(e, n, p);
    if (!cf(l) || "" === l)
        return new Intl.DateTimeFormat(p,d).format(c);
    let g, f = {}, m = null;
    for (let y = 0; y < v.length && (g = v[y],
    f = a[g] || {},
    m = f[l],
    !vf(m)); y++)
        Um(e, l, g, 0, "datetime format");
    if (!vf(m) || !cf(g))
        return i ? -1 : l;
    let b = `${g}__${l}`;
    Qg(d) || (b = `${b}__${JSON.stringify(d)}`);
    let x = s.get(b);
    return x || (x = new Intl.DateTimeFormat(g,ef({}, m, d)),
    s.set(b, x)),
    h ? x.formatToParts(c) : x.format(c)
}
const db = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];
function hb(...e) {
    const [t,a,i,n] = e
      , r = {};
    let o, s = {};
    if (cf(t)) {
        const e = t.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!e)
            throw Lm(Pm.INVALID_ISO_DATE_ARGUMENT);
        const a = e[3] ? e[3].trim().startsWith("T") ? `${e[1].trim()}${e[3].trim()}` : `${e[1].trim()}T${e[3].trim()}` : e[1].trim();
        o = new Date(a);
        try {
            o.toISOString()
        } catch (l) {
            throw Lm(Pm.INVALID_ISO_DATE_ARGUMENT)
        }
    } else if ("[object Date]" === pf(t)) {
        if (isNaN(t.getTime()))
            throw Lm(Pm.INVALID_DATE_ARGUMENT);
        o = t
    } else {
        if (!Kg(t))
            throw Lm(Pm.INVALID_ARGUMENT);
        o = t
    }
    return cf(a) ? r.key = a : vf(a) && Object.keys(a).forEach((e => {
        db.includes(e) ? s[e] = a[e] : r[e] = a[e]
    }
    )),
    cf(i) ? r.locale = i : vf(i) && (s = i),
    vf(n) && (s = n),
    [r.key || "", o, r, s]
}
function pb(e, t, a) {
    const i = e;
    for (const n in a) {
        const e = `${t}__${n}`;
        i.__datetimeFormatters.has(e) && i.__datetimeFormatters.delete(e)
    }
}
function vb(e, ...t) {
    const {numberFormats: a, unresolving: i, fallbackLocale: n, onWarn: r, localeFallbacker: o} = e
      , {__numberFormatters: s} = e
      , [l,c,u,d] = fb(...t);
    uf(u.missingWarn) ? u.missingWarn : e.missingWarn;
    uf(u.fallbackWarn) ? u.fallbackWarn : e.fallbackWarn;
    const h = !!u.part
      , p = Im(e, u)
      , v = o(e, n, p);
    if (!cf(l) || "" === l)
        return new Intl.NumberFormat(p,d).format(c);
    let g, f = {}, m = null;
    for (let y = 0; y < v.length && (g = v[y],
    f = a[g] || {},
    m = f[l],
    !vf(m)); y++)
        Um(e, l, g, 0, "number format");
    if (!vf(m) || !cf(g))
        return i ? -1 : l;
    let b = `${g}__${l}`;
    Qg(d) || (b = `${b}__${JSON.stringify(d)}`);
    let x = s.get(b);
    return x || (x = new Intl.NumberFormat(g,ef({}, m, d)),
    s.set(b, x)),
    h ? x.formatToParts(c) : x.format(c)
}
const gb = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];
function fb(...e) {
    const [t,a,i,n] = e
      , r = {};
    let o = {};
    if (!Kg(t))
        throw Lm(Pm.INVALID_ARGUMENT);
    const s = t;
    return cf(a) ? r.key = a : vf(a) && Object.keys(a).forEach((e => {
        gb.includes(e) ? o[e] = a[e] : r[e] = a[e]
    }
    )),
    cf(i) ? r.locale = i : vf(i) && (o = i),
    vf(n) && (o = n),
    [r.key || "", s, r, o]
}
function mb(e, t, a) {
    const i = e;
    for (const n in a) {
        const e = `${t}__${n}`;
        i.__numberFormatters.has(e) && i.__numberFormatters.delete(e)
    }
}
"boolean" != typeof __INTLIFY_PROD_DEVTOOLS__ && (af().__INTLIFY_PROD_DEVTOOLS__ = !1),
"boolean" != typeof __INTLIFY_JIT_COMPILATION__ && (af().__INTLIFY_JIT_COMPILATION__ = !1),
"boolean" != typeof __INTLIFY_DROP_MESSAGE_COMPILER__ && (af().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1);
const bb = gf(8);
bb(),
bb(),
bb(),
bb(),
bb(),
bb(),
bb(),
bb();
const xb = Pm.__EXTEND_POINT__
  , yb = gf(xb)
  , wb = {
    UNEXPECTED_RETURN_TYPE: xb,
    INVALID_ARGUMENT: yb(),
    MUST_BE_CALL_SETUP_TOP: yb(),
    NOT_INSTALLED: yb(),
    NOT_AVAILABLE_IN_LEGACY_MODE: yb(),
    REQUIRED_VALUE: yb(),
    INVALID_VALUE: yb(),
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: yb(),
    NOT_INSTALLED_WITH_PROVIDE: yb(),
    UNEXPECTED_ERROR: yb(),
    NOT_COMPATIBLE_LEGACY_VUE_I18N: yb(),
    BRIDGE_SUPPORT_VUE_2_ONLY: yb(),
    MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: yb(),
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: yb(),
    __EXTEND_POINT__: yb()
};
function kb(e, ...t) {
    return Yf(e, null, void 0)
}
const Sb = qg("__translateVNode")
  , Cb = qg("__datetimeParts")
  , Ab = qg("__numberParts")
  , Pb = qg("__setPluralRules")
  , Lb = qg("__injectWithOption")
  , Ib = qg("__dispose");
function _b(e) {
    if (!df(e))
        return e;
    for (const t in e)
        if (of(e, t))
            if (t.includes(".")) {
                const a = t.split(".")
                  , i = a.length - 1;
                let n = e
                  , r = !1;
                for (let e = 0; e < i; e++) {
                    if (a[e]in n || (n[a[e]] = {}),
                    !df(n[a[e]])) {
                        r = !0;
                        break
                    }
                    n = n[a[e]]
                }
                r || (n[a[i]] = e[t],
                delete e[t]),
                df(n[a[i]]) && _b(n[a[i]])
            } else
                df(e[t]) && _b(e[t]);
    return e
}
function Tb(e, t) {
    const {messages: a, __i18n: i, messageResolver: n, flatJson: r} = t
      , o = vf(a) ? a : sf(i) ? {} : {
        [e]: {}
    };
    if (sf(i) && i.forEach((e => {
        if ("locale"in e && "resource"in e) {
            const {locale: t, resource: a} = e;
            t ? (o[t] = o[t] || {},
            bf(a, o[t])) : bf(a, o)
        } else
            cf(e) && bf(JSON.parse(e), o)
    }
    )),
    null == n && r)
        for (const s in o)
            of(o, s) && _b(o[s]);
    return o
}
function Eb(e) {
    return e.type
}
function Ob(e, t, a) {
    let i = df(t.messages) ? t.messages : {};
    "__i18nGlobal"in a && (i = Tb(e.locale.value, {
        messages: i,
        __i18n: a.__i18nGlobal
    }));
    const n = Object.keys(i);
    if (n.length && n.forEach((t => {
        e.mergeLocaleMessage(t, i[t])
    }
    )),
    df(t.datetimeFormats)) {
        const a = Object.keys(t.datetimeFormats);
        a.length && a.forEach((a => {
            e.mergeDateTimeFormat(a, t.datetimeFormats[a])
        }
        ))
    }
    if (df(t.numberFormats)) {
        const a = Object.keys(t.numberFormats);
        a.length && a.forEach((a => {
            e.mergeNumberFormat(a, t.numberFormats[a])
        }
        ))
    }
}
function Vb(e) {
    return y(ye, null, e, 0)
}
const Fb = () => []
  , Bb = () => !1;
let Mb = 0;
function Db(e) {
    return (t, a, i, n) => e(a, i, oa() || void 0, n)
}
function Rb(e={}, t) {
    const {__root: a, __injectWithOption: i} = e
      , n = void 0 === a
      , r = e.flatJson
      , o = Ug ? l : j;
    let s = !uf(e.inheritLocale) || e.inheritLocale;
    const c = o(a && s ? a.locale.value : cf(e.locale) ? e.locale : Mm)
      , u = o(a && s ? a.fallbackLocale.value : cf(e.fallbackLocale) || sf(e.fallbackLocale) || vf(e.fallbackLocale) || !1 === e.fallbackLocale ? e.fallbackLocale : c.value)
      , d = o(Tb(c.value, e))
      , h = o(vf(e.datetimeFormats) ? e.datetimeFormats : {
        [c.value]: {}
    })
      , p = o(vf(e.numberFormats) ? e.numberFormats : {
        [c.value]: {}
    });
    let v = a ? a.missingWarn : !uf(e.missingWarn) && !Jg(e.missingWarn) || e.missingWarn
      , g = a ? a.fallbackWarn : !uf(e.fallbackWarn) && !Jg(e.fallbackWarn) || e.fallbackWarn
      , f = a ? a.fallbackRoot : !uf(e.fallbackRoot) || e.fallbackRoot
      , m = !!e.fallbackFormat
      , b = lf(e.missing) ? e.missing : null
      , x = lf(e.missing) ? Db(e.missing) : null
      , y = lf(e.postTranslation) ? e.postTranslation : null
      , w = a ? a.warnHtmlMessage : !uf(e.warnHtmlMessage) || e.warnHtmlMessage
      , k = !!e.escapeParameter;
    const S = a ? a.modifiers : vf(e.modifiers) ? e.modifiers : {};
    let C, A = e.pluralRules || a && a.pluralRules;
    C = ( () => {
        n && Gm(null);
        const t = {
            version: "9.9.1",
            locale: c.value,
            fallbackLocale: u.value,
            messages: d.value,
            modifiers: S,
            pluralRules: A,
            missing: null === x ? void 0 : x,
            missingWarn: v,
            fallbackWarn: g,
            fallbackFormat: m,
            unresolving: !0,
            postTranslation: null === y ? void 0 : y,
            warnHtmlMessage: w,
            escapeParameter: k,
            messageResolver: e.messageResolver,
            messageCompiler: e.messageCompiler,
            __meta: {
                framework: "vue"
            }
        };
        t.datetimeFormats = h.value,
        t.numberFormats = p.value,
        t.__datetimeFormatters = vf(C) ? C.__datetimeFormatters : void 0,
        t.__numberFormatters = vf(C) ? C.__numberFormatters : void 0;
        const a = $m(t);
        return n && Gm(a),
        a
    }
    )(),
    qm(C, c.value, u.value);
    const P = F({
        get: () => c.value,
        set: e => {
            c.value = e,
            C.locale = c.value
        }
    })
      , L = F({
        get: () => u.value,
        set: e => {
            u.value = e,
            C.fallbackLocale = u.value,
            qm(C, c.value, e)
        }
    })
      , I = F(( () => d.value))
      , _ = F(( () => h.value))
      , T = F(( () => p.value));
    const E = (e, t, i, r, o, s) => {
        let l;
        c.value,
        u.value,
        d.value,
        h.value,
        p.value;
        try {
            __INTLIFY_PROD_DEVTOOLS__,
            n || (C.fallbackContext = a ? Wm : void 0),
            l = e(C)
        } finally {
            __INTLIFY_PROD_DEVTOOLS__,
            n || (C.fallbackContext = void 0)
        }
        if ("translate exists" !== i && Kg(l) && -1 === l || "translate exists" === i && !l) {
            const [e,i] = t();
            return a && f ? r(a) : o(e)
        }
        if (s(l))
            return l;
        throw kb(wb.UNEXPECTED_RETURN_TYPE)
    }
    ;
    function O(...e) {
        return E((t => Reflect.apply(ob, null, [t, ...e])), ( () => cb(...e)), "translate", (t => Reflect.apply(t.t, t, [...e])), (e => e), (e => cf(e)))
    }
    const V = {
        normalize: function(e) {
            return e.map((e => cf(e) || Kg(e) || uf(e) ? Vb(String(e)) : e))
        },
        interpolate: e => e,
        type: "vnode"
    };
    function B(e) {
        return d.value[e] || {}
    }
    Mb++,
    a && Ug && ($(a.locale, (e => {
        s && (c.value = e,
        C.locale = e,
        qm(C, c.value, u.value))
    }
    )),
    $(a.fallbackLocale, (e => {
        s && (u.value = e,
        C.fallbackLocale = e,
        qm(C, c.value, u.value))
    }
    )));
    const M = {
        id: Mb,
        locale: P,
        fallbackLocale: L,
        get inheritLocale() {
            return s
        },
        set inheritLocale(e) {
            s = e,
            e && a && (c.value = a.locale.value,
            u.value = a.fallbackLocale.value,
            qm(C, c.value, u.value))
        },
        get availableLocales() {
            return Object.keys(d.value).sort()
        },
        messages: I,
        get modifiers() {
            return S
        },
        get pluralRules() {
            return A || {}
        },
        get isGlobal() {
            return n
        },
        get missingWarn() {
            return v
        },
        set missingWarn(e) {
            v = e,
            C.missingWarn = v
        },
        get fallbackWarn() {
            return g
        },
        set fallbackWarn(e) {
            g = e,
            C.fallbackWarn = g
        },
        get fallbackRoot() {
            return f
        },
        set fallbackRoot(e) {
            f = e
        },
        get fallbackFormat() {
            return m
        },
        set fallbackFormat(e) {
            m = e,
            C.fallbackFormat = m
        },
        get warnHtmlMessage() {
            return w
        },
        set warnHtmlMessage(e) {
            w = e,
            C.warnHtmlMessage = e
        },
        get escapeParameter() {
            return k
        },
        set escapeParameter(e) {
            k = e,
            C.escapeParameter = e
        },
        t: O,
        getLocaleMessage: B,
        setLocaleMessage: function(e, t) {
            if (r) {
                const a = {
                    [e]: t
                };
                for (const e in a)
                    of(a, e) && _b(a[e]);
                t = a[e]
            }
            d.value[e] = t,
            C.messages = d.value
        },
        mergeLocaleMessage: function(e, t) {
            d.value[e] = d.value[e] || {};
            const a = {
                [e]: t
            };
            if (r)
                for (const i in a)
                    of(a, i) && _b(a[i]);
            bf(t = a[e], d.value[e]),
            C.messages = d.value
        },
        getPostTranslationHandler: function() {
            return lf(y) ? y : null
        },
        setPostTranslationHandler: function(e) {
            y = e,
            C.postTranslation = e
        },
        getMissingHandler: function() {
            return b
        },
        setMissingHandler: function(e) {
            null !== e && (x = Db(e)),
            b = e,
            C.missing = x
        },
        [Pb]: function(e) {
            A = e,
            C.pluralRules = A
        }
    };
    return M.datetimeFormats = _,
    M.numberFormats = T,
    M.rt = function(...e) {
        const [t,a,i] = e;
        if (i && !df(i))
            throw kb(wb.INVALID_ARGUMENT);
        return O(t, a, ef({
            resolvedMessage: !0
        }, i || {}))
    }
    ,
    M.te = function(e, t) {
        return E(( () => {
            if (!e)
                return !1;
            const a = B(cf(t) ? t : c.value)
              , i = C.messageResolver(a, e);
            return tb(i) || rb(i) || cf(i)
        }
        ), ( () => [e]), "translate exists", (a => Reflect.apply(a.te, a, [e, t])), Bb, (e => uf(e)))
    }
    ,
    M.tm = function(e) {
        const t = function(e) {
            let t = null;
            const a = Om(C, u.value, c.value);
            for (let i = 0; i < a.length; i++) {
                const n = d.value[a[i]] || {}
                  , r = C.messageResolver(n, e);
                if (null != r) {
                    t = r;
                    break
                }
            }
            return t
        }(e);
        return null != t ? t : a && a.tm(e) || {}
    }
    ,
    M.d = function(...e) {
        return E((t => Reflect.apply(ub, null, [t, ...e])), ( () => hb(...e)), "datetime format", (t => Reflect.apply(t.d, t, [...e])), ( () => ""), (e => cf(e)))
    }
    ,
    M.n = function(...e) {
        return E((t => Reflect.apply(vb, null, [t, ...e])), ( () => fb(...e)), "number format", (t => Reflect.apply(t.n, t, [...e])), ( () => ""), (e => cf(e)))
    }
    ,
    M.getDateTimeFormat = function(e) {
        return h.value[e] || {}
    }
    ,
    M.setDateTimeFormat = function(e, t) {
        h.value[e] = t,
        C.datetimeFormats = h.value,
        pb(C, e, t)
    }
    ,
    M.mergeDateTimeFormat = function(e, t) {
        h.value[e] = ef(h.value[e] || {}, t),
        C.datetimeFormats = h.value,
        pb(C, e, t)
    }
    ,
    M.getNumberFormat = function(e) {
        return p.value[e] || {}
    }
    ,
    M.setNumberFormat = function(e, t) {
        p.value[e] = t,
        C.numberFormats = p.value,
        mb(C, e, t)
    }
    ,
    M.mergeNumberFormat = function(e, t) {
        p.value[e] = ef(p.value[e] || {}, t),
        C.numberFormats = p.value,
        mb(C, e, t)
    }
    ,
    M[Lb] = i,
    M[Sb] = function(...e) {
        return E((t => {
            let a;
            const i = t;
            try {
                i.processor = V,
                a = Reflect.apply(ob, null, [i, ...e])
            } finally {
                i.processor = null
            }
            return a
        }
        ), ( () => cb(...e)), "translate", (t => t[Sb](...e)), (e => [Vb(e)]), (e => sf(e)))
    }
    ,
    M[Cb] = function(...e) {
        return E((t => Reflect.apply(ub, null, [t, ...e])), ( () => hb(...e)), "datetime format", (t => t[Cb](...e)), Fb, (e => cf(e) || sf(e)))
    }
    ,
    M[Ab] = function(...e) {
        return E((t => Reflect.apply(vb, null, [t, ...e])), ( () => fb(...e)), "number format", (t => t[Ab](...e)), Fb, (e => cf(e) || sf(e)))
    }
    ,
    M
}
function Nb(e={}, t) {
    {
        const t = Rb(function(e) {
            const t = cf(e.locale) ? e.locale : Mm
              , a = cf(e.fallbackLocale) || sf(e.fallbackLocale) || vf(e.fallbackLocale) || !1 === e.fallbackLocale ? e.fallbackLocale : t
              , i = lf(e.missing) ? e.missing : void 0
              , n = !uf(e.silentTranslationWarn) && !Jg(e.silentTranslationWarn) || !e.silentTranslationWarn
              , r = !uf(e.silentFallbackWarn) && !Jg(e.silentFallbackWarn) || !e.silentFallbackWarn
              , o = !uf(e.fallbackRoot) || e.fallbackRoot
              , s = !!e.formatFallbackMessages
              , l = vf(e.modifiers) ? e.modifiers : {}
              , c = e.pluralizationRules
              , u = lf(e.postTranslation) ? e.postTranslation : void 0
              , d = !cf(e.warnHtmlInMessage) || "off" !== e.warnHtmlInMessage
              , h = !!e.escapeParameterHtml
              , p = !uf(e.sync) || e.sync;
            let v = e.messages;
            if (vf(e.sharedMessages)) {
                const t = e.sharedMessages;
                v = Object.keys(t).reduce(( (e, a) => {
                    const i = e[a] || (e[a] = {});
                    return ef(i, t[a]),
                    e
                }
                ), v || {})
            }
            const {__i18n: g, __root: f, __injectWithOption: m} = e
              , b = e.datetimeFormats
              , x = e.numberFormats;
            return {
                locale: t,
                fallbackLocale: a,
                messages: v,
                flatJson: e.flatJson,
                datetimeFormats: b,
                numberFormats: x,
                missing: i,
                missingWarn: n,
                fallbackWarn: r,
                fallbackRoot: o,
                fallbackFormat: s,
                modifiers: l,
                pluralRules: c,
                postTranslation: u,
                warnHtmlMessage: d,
                escapeParameter: h,
                messageResolver: e.messageResolver,
                inheritLocale: p,
                __i18n: g,
                __root: f,
                __injectWithOption: m
            }
        }(e))
          , {__extender: a} = e
          , i = {
            id: t.id,
            get locale() {
                return t.locale.value
            },
            set locale(e) {
                t.locale.value = e
            },
            get fallbackLocale() {
                return t.fallbackLocale.value
            },
            set fallbackLocale(e) {
                t.fallbackLocale.value = e
            },
            get messages() {
                return t.messages.value
            },
            get datetimeFormats() {
                return t.datetimeFormats.value
            },
            get numberFormats() {
                return t.numberFormats.value
            },
            get availableLocales() {
                return t.availableLocales
            },
            get formatter() {
                return {
                    interpolate: () => []
                }
            },
            set formatter(e) {},
            get missing() {
                return t.getMissingHandler()
            },
            set missing(e) {
                t.setMissingHandler(e)
            },
            get silentTranslationWarn() {
                return uf(t.missingWarn) ? !t.missingWarn : t.missingWarn
            },
            set silentTranslationWarn(e) {
                t.missingWarn = uf(e) ? !e : e
            },
            get silentFallbackWarn() {
                return uf(t.fallbackWarn) ? !t.fallbackWarn : t.fallbackWarn
            },
            set silentFallbackWarn(e) {
                t.fallbackWarn = uf(e) ? !e : e
            },
            get modifiers() {
                return t.modifiers
            },
            get formatFallbackMessages() {
                return t.fallbackFormat
            },
            set formatFallbackMessages(e) {
                t.fallbackFormat = e
            },
            get postTranslation() {
                return t.getPostTranslationHandler()
            },
            set postTranslation(e) {
                t.setPostTranslationHandler(e)
            },
            get sync() {
                return t.inheritLocale
            },
            set sync(e) {
                t.inheritLocale = e
            },
            get warnHtmlInMessage() {
                return t.warnHtmlMessage ? "warn" : "off"
            },
            set warnHtmlInMessage(e) {
                t.warnHtmlMessage = "off" !== e
            },
            get escapeParameterHtml() {
                return t.escapeParameter
            },
            set escapeParameterHtml(e) {
                t.escapeParameter = e
            },
            get preserveDirectiveContent() {
                return !0
            },
            set preserveDirectiveContent(e) {},
            get pluralizationRules() {
                return t.pluralRules || {}
            },
            __composer: t,
            t(...e) {
                const [a,i,n] = e
                  , r = {};
                let o = null
                  , s = null;
                if (!cf(a))
                    throw kb(wb.INVALID_ARGUMENT);
                const l = a;
                return cf(i) ? r.locale = i : sf(i) ? o = i : vf(i) && (s = i),
                sf(n) ? o = n : vf(n) && (s = n),
                Reflect.apply(t.t, t, [l, o || s || {}, r])
            },
            rt: (...e) => Reflect.apply(t.rt, t, [...e]),
            tc(...e) {
                const [a,i,n] = e
                  , r = {
                    plural: 1
                };
                let o = null
                  , s = null;
                if (!cf(a))
                    throw kb(wb.INVALID_ARGUMENT);
                const l = a;
                return cf(i) ? r.locale = i : Kg(i) ? r.plural = i : sf(i) ? o = i : vf(i) && (s = i),
                cf(n) ? r.locale = n : sf(n) ? o = n : vf(n) && (s = n),
                Reflect.apply(t.t, t, [l, o || s || {}, r])
            },
            te: (e, a) => t.te(e, a),
            tm: e => t.tm(e),
            getLocaleMessage: e => t.getLocaleMessage(e),
            setLocaleMessage(e, a) {
                t.setLocaleMessage(e, a)
            },
            mergeLocaleMessage(e, a) {
                t.mergeLocaleMessage(e, a)
            },
            d: (...e) => Reflect.apply(t.d, t, [...e]),
            getDateTimeFormat: e => t.getDateTimeFormat(e),
            setDateTimeFormat(e, a) {
                t.setDateTimeFormat(e, a)
            },
            mergeDateTimeFormat(e, a) {
                t.mergeDateTimeFormat(e, a)
            },
            n: (...e) => Reflect.apply(t.n, t, [...e]),
            getNumberFormat: e => t.getNumberFormat(e),
            setNumberFormat(e, a) {
                t.setNumberFormat(e, a)
            },
            mergeNumberFormat(e, a) {
                t.mergeNumberFormat(e, a)
            },
            getChoiceIndex: (e, t) => -1
        };
        return i.__extender = a,
        i
    }
}
const zb = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: e => "parent" === e || "global" === e,
        default: "parent"
    },
    i18n: {
        type: Object
    }
};
function Hb(e) {
    return Q
}
const Xb = a({
    name: "i18n-t",
    props: ef({
        keypath: {
            type: String,
            required: !0
        },
        plural: {
            type: [Number, String],
            validator: e => Kg(e) || !isNaN(e)
        }
    }, zb),
    setup(e, t) {
        const {slots: a, attrs: i} = t
          , n = e.i18n || Kb({
            useScope: e.scope,
            __useComponent: !0
        });
        return () => {
            const r = Object.keys(a).filter((e => "_" !== e))
              , o = {};
            e.locale && (o.locale = e.locale),
            void 0 !== e.plural && (o.plural = cf(e.plural) ? +e.plural : e.plural);
            const s = function({slots: e}, t) {
                if (1 === t.length && "default" === t[0])
                    return (e.default ? e.default() : []).reduce(( (e, t) => [...e, ...t.type === Q ? t.children : [t]]), []);
                return t.reduce(( (t, a) => {
                    const i = e[a];
                    return i && (t[a] = i()),
                    t
                }
                ), {})
            }(t, r)
              , l = n[Sb](e.keypath, s, o)
              , c = ef({}, i)
              , u = cf(e.tag) || df(e.tag) ? e.tag : Hb();
            return S(u, c, l)
        }
    }
});
function Yb(e, t, a, i) {
    const {slots: n, attrs: r} = t;
    return () => {
        const t = {
            part: !0
        };
        let o = {};
        e.locale && (t.locale = e.locale),
        cf(e.format) ? t.key = e.format : df(e.format) && (cf(e.format.key) && (t.key = e.format.key),
        o = Object.keys(e.format).reduce(( (t, i) => a.includes(i) ? ef({}, t, {
            [i]: e.format[i]
        }) : t), {}));
        const s = i(e.value, t, o);
        let l = [t.key];
        sf(s) ? l = s.map(( (e, t) => {
            const a = n[e.type]
              , i = a ? a({
                [e.type]: e.value,
                index: t,
                parts: s
            }) : [e.value];
            var r;
            return sf(r = i) && !cf(r[0]) && (i[0].key = `${e.type}-${t}`),
            i
        }
        )) : cf(s) && (l = [s]);
        const c = ef({}, r)
          , u = cf(e.tag) || df(e.tag) ? e.tag : Hb();
        return S(u, c, l)
    }
}
const Wb = a({
    name: "i18n-n",
    props: ef({
        value: {
            type: Number,
            required: !0
        },
        format: {
            type: [String, Object]
        }
    }, zb),
    setup(e, t) {
        const a = e.i18n || Kb({
            useScope: "parent",
            __useComponent: !0
        });
        return Yb(e, t, gb, ( (...e) => a[Ab](...e)))
    }
})
  , Gb = a({
    name: "i18n-d",
    props: ef({
        value: {
            type: [Number, Date],
            required: !0
        },
        format: {
            type: [String, Object]
        }
    }, zb),
    setup(e, t) {
        const a = e.i18n || Kb({
            useScope: "parent",
            __useComponent: !0
        });
        return Yb(e, t, db, ( (...e) => a[Cb](...e)))
    }
});
function jb(e) {
    if (cf(e))
        return {
            path: e
        };
    if (vf(e)) {
        if (!("path"in e))
            throw kb(wb.REQUIRED_VALUE);
        return e
    }
    throw kb(wb.INVALID_VALUE)
}
function $b(e) {
    const {path: t, locale: a, args: i, choice: n, plural: r} = e
      , o = {}
      , s = i || {};
    return cf(a) && (o.locale = a),
    Kg(n) && (o.plural = n),
    Kg(r) && (o.plural = r),
    [t, s, o]
}
function Ub(e, t, ...a) {
    const i = vf(a[0]) ? a[0] : {}
      , n = !!i.useI18nComponentName;
    (!uf(i.globalInstall) || i.globalInstall) && ([n ? "i18n" : Xb.name, "I18nT"].forEach((t => e.component(t, Xb))),
    [Wb.name, "I18nN"].forEach((t => e.component(t, Wb))),
    [Gb.name, "I18nD"].forEach((t => e.component(t, Gb)))),
    e.directive("t", function(e) {
        const t = t => {
            const {instance: a, modifiers: i, value: n} = t;
            if (!a || !a.$)
                throw kb(wb.UNEXPECTED_ERROR);
            const r = function(e, t) {
                const a = e;
                if ("composition" === e.mode)
                    return a.__getInstance(t) || e.global;
                {
                    const i = a.__getInstance(t);
                    return null != i ? i.__composer : e.global.__composer
                }
            }(e, a.$)
              , o = jb(n);
            return [Reflect.apply(r.t, r, [...$b(o)]), r]
        }
        ;
        return {
            created: (a, i) => {
                const [n,r] = t(i);
                Ug && e.global === r && (a.__i18nWatcher = $(r.locale, ( () => {
                    i.instance && i.instance.$forceUpdate()
                }
                ))),
                a.__composer = r,
                a.textContent = n
            }
            ,
            unmounted: e => {
                Ug && e.__i18nWatcher && (e.__i18nWatcher(),
                e.__i18nWatcher = void 0,
                delete e.__i18nWatcher),
                e.__composer && (e.__composer = void 0,
                delete e.__composer)
            }
            ,
            beforeUpdate: (e, {value: t}) => {
                if (e.__composer) {
                    const a = e.__composer
                      , i = jb(t);
                    e.textContent = Reflect.apply(a.t, a, [...$b(i)])
                }
            }
            ,
            getSSRProps: e => {
                const [a] = t(e);
                return {
                    textContent: a
                }
            }
        }
    }(t))
}
function qb(e, t) {
    e.locale = t.locale || e.locale,
    e.fallbackLocale = t.fallbackLocale || e.fallbackLocale,
    e.missing = t.missing || e.missing,
    e.silentTranslationWarn = t.silentTranslationWarn || e.silentFallbackWarn,
    e.silentFallbackWarn = t.silentFallbackWarn || e.silentFallbackWarn,
    e.formatFallbackMessages = t.formatFallbackMessages || e.formatFallbackMessages,
    e.postTranslation = t.postTranslation || e.postTranslation,
    e.warnHtmlInMessage = t.warnHtmlInMessage || e.warnHtmlInMessage,
    e.escapeParameterHtml = t.escapeParameterHtml || e.escapeParameterHtml,
    e.sync = t.sync || e.sync,
    e.__composer[Pb](t.pluralizationRules || e.pluralizationRules);
    const a = Tb(e.locale, {
        messages: t.messages,
        __i18n: t.__i18n
    });
    return Object.keys(a).forEach((t => e.mergeLocaleMessage(t, a[t]))),
    t.datetimeFormats && Object.keys(t.datetimeFormats).forEach((a => e.mergeDateTimeFormat(a, t.datetimeFormats[a]))),
    t.numberFormats && Object.keys(t.numberFormats).forEach((a => e.mergeNumberFormat(a, t.numberFormats[a]))),
    e
}
const Zb = qg("global-vue-i18n");
function Kb(e={}) {
    const t = oa();
    if (null == t)
        throw kb(wb.MUST_BE_CALL_SETUP_TOP);
    if (!t.isCE && null != t.appContext.app && !t.appContext.app.__VUE_I18N_SYMBOL__)
        throw kb(wb.NOT_INSTALLED);
    const a = function(e) {
        {
            const t = de(e.isCE ? Zb : e.appContext.app.__VUE_I18N_SYMBOL__);
            if (!t)
                throw kb(e.isCE ? wb.NOT_INSTALLED_WITH_PROVIDE : wb.UNEXPECTED_ERROR);
            return t
        }
    }(t)
      , i = function(e) {
        return "composition" === e.mode ? e.global : e.global.__composer
    }(a)
      , n = Eb(t)
      , r = function(e, t) {
        return Qg(e) ? "__i18n"in t ? "local" : "global" : e.useScope ? e.useScope : "local"
    }(e, n);
    if (__VUE_I18N_LEGACY_API__ && "legacy" === a.mode && !e.__useComponent) {
        if (!a.allowComposition)
            throw kb(wb.NOT_AVAILABLE_IN_LEGACY_MODE);
        return function(e, t, a, i={}) {
            const n = "local" === t
              , r = j(null);
            if (n && e.proxy && !e.proxy.$options.i18n && !e.proxy.$options.__i18n)
                throw kb(wb.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
            const o = uf(i.inheritLocale) ? i.inheritLocale : !cf(i.locale)
              , s = l(!n || o ? a.locale.value : cf(i.locale) ? i.locale : Mm)
              , c = l(!n || o ? a.fallbackLocale.value : cf(i.fallbackLocale) || sf(i.fallbackLocale) || vf(i.fallbackLocale) || !1 === i.fallbackLocale ? i.fallbackLocale : s.value)
              , u = l(Tb(s.value, i))
              , d = l(vf(i.datetimeFormats) ? i.datetimeFormats : {
                [s.value]: {}
            })
              , h = l(vf(i.numberFormats) ? i.numberFormats : {
                [s.value]: {}
            })
              , p = n ? a.missingWarn : !uf(i.missingWarn) && !Jg(i.missingWarn) || i.missingWarn
              , v = n ? a.fallbackWarn : !uf(i.fallbackWarn) && !Jg(i.fallbackWarn) || i.fallbackWarn
              , g = n ? a.fallbackRoot : !uf(i.fallbackRoot) || i.fallbackRoot
              , f = !!i.fallbackFormat
              , m = lf(i.missing) ? i.missing : null
              , b = lf(i.postTranslation) ? i.postTranslation : null
              , x = n ? a.warnHtmlMessage : !uf(i.warnHtmlMessage) || i.warnHtmlMessage
              , y = !!i.escapeParameter
              , w = n ? a.modifiers : vf(i.modifiers) ? i.modifiers : {}
              , k = i.pluralRules || n && a.pluralRules;
            function S() {
                return [s.value, c.value, u.value, d.value, h.value]
            }
            const C = F({
                get: () => r.value ? r.value.locale.value : s.value,
                set: e => {
                    r.value && (r.value.locale.value = e),
                    s.value = e
                }
            })
              , A = F({
                get: () => r.value ? r.value.fallbackLocale.value : c.value,
                set: e => {
                    r.value && (r.value.fallbackLocale.value = e),
                    c.value = e
                }
            })
              , P = F(( () => r.value ? r.value.messages.value : u.value))
              , L = F(( () => d.value))
              , I = F(( () => h.value));
            function _() {
                return r.value ? r.value.getPostTranslationHandler() : b
            }
            function T(e) {
                r.value && r.value.setPostTranslationHandler(e)
            }
            function E() {
                return r.value ? r.value.getMissingHandler() : m
            }
            function O(e) {
                r.value && r.value.setMissingHandler(e)
            }
            function V(e) {
                return S(),
                e()
            }
            function B(...e) {
                return r.value ? V(( () => Reflect.apply(r.value.t, null, [...e]))) : V(( () => ""))
            }
            function M(...e) {
                return r.value ? Reflect.apply(r.value.rt, null, [...e]) : ""
            }
            function D(...e) {
                return r.value ? V(( () => Reflect.apply(r.value.d, null, [...e]))) : V(( () => ""))
            }
            function R(...e) {
                return r.value ? V(( () => Reflect.apply(r.value.n, null, [...e]))) : V(( () => ""))
            }
            function N(e) {
                return r.value ? r.value.tm(e) : {}
            }
            function z(e, t) {
                return !!r.value && r.value.te(e, t)
            }
            function H(e) {
                return r.value ? r.value.getLocaleMessage(e) : {}
            }
            function X(e, t) {
                r.value && (r.value.setLocaleMessage(e, t),
                u.value[e] = t)
            }
            function Y(e, t) {
                r.value && r.value.mergeLocaleMessage(e, t)
            }
            function W(e) {
                return r.value ? r.value.getDateTimeFormat(e) : {}
            }
            function G(e, t) {
                r.value && (r.value.setDateTimeFormat(e, t),
                d.value[e] = t)
            }
            function $(e, t) {
                r.value && r.value.mergeDateTimeFormat(e, t)
            }
            function q(e) {
                return r.value ? r.value.getNumberFormat(e) : {}
            }
            function Z(e, t) {
                r.value && (r.value.setNumberFormat(e, t),
                h.value[e] = t)
            }
            function K(e, t) {
                r.value && r.value.mergeNumberFormat(e, t)
            }
            const J = {
                get id() {
                    return r.value ? r.value.id : -1
                },
                locale: C,
                fallbackLocale: A,
                messages: P,
                datetimeFormats: L,
                numberFormats: I,
                get inheritLocale() {
                    return r.value ? r.value.inheritLocale : o
                },
                set inheritLocale(e) {
                    r.value && (r.value.inheritLocale = e)
                },
                get availableLocales() {
                    return r.value ? r.value.availableLocales : Object.keys(u.value)
                },
                get modifiers() {
                    return r.value ? r.value.modifiers : w
                },
                get pluralRules() {
                    return r.value ? r.value.pluralRules : k
                },
                get isGlobal() {
                    return !!r.value && r.value.isGlobal
                },
                get missingWarn() {
                    return r.value ? r.value.missingWarn : p
                },
                set missingWarn(e) {
                    r.value && (r.value.missingWarn = e)
                },
                get fallbackWarn() {
                    return r.value ? r.value.fallbackWarn : v
                },
                set fallbackWarn(e) {
                    r.value && (r.value.missingWarn = e)
                },
                get fallbackRoot() {
                    return r.value ? r.value.fallbackRoot : g
                },
                set fallbackRoot(e) {
                    r.value && (r.value.fallbackRoot = e)
                },
                get fallbackFormat() {
                    return r.value ? r.value.fallbackFormat : f
                },
                set fallbackFormat(e) {
                    r.value && (r.value.fallbackFormat = e)
                },
                get warnHtmlMessage() {
                    return r.value ? r.value.warnHtmlMessage : x
                },
                set warnHtmlMessage(e) {
                    r.value && (r.value.warnHtmlMessage = e)
                },
                get escapeParameter() {
                    return r.value ? r.value.escapeParameter : y
                },
                set escapeParameter(e) {
                    r.value && (r.value.escapeParameter = e)
                },
                t: B,
                getPostTranslationHandler: _,
                setPostTranslationHandler: T,
                getMissingHandler: E,
                setMissingHandler: O,
                rt: M,
                d: D,
                n: R,
                tm: N,
                te: z,
                getLocaleMessage: H,
                setLocaleMessage: X,
                mergeLocaleMessage: Y,
                getDateTimeFormat: W,
                setDateTimeFormat: G,
                mergeDateTimeFormat: $,
                getNumberFormat: q,
                setNumberFormat: Z,
                mergeNumberFormat: K
            };
            function Q(e) {
                e.locale.value = s.value,
                e.fallbackLocale.value = c.value,
                Object.keys(u.value).forEach((t => {
                    e.mergeLocaleMessage(t, u.value[t])
                }
                )),
                Object.keys(d.value).forEach((t => {
                    e.mergeDateTimeFormat(t, d.value[t])
                }
                )),
                Object.keys(h.value).forEach((t => {
                    e.mergeNumberFormat(t, h.value[t])
                }
                )),
                e.escapeParameter = y,
                e.fallbackFormat = f,
                e.fallbackRoot = g,
                e.fallbackWarn = v,
                e.missingWarn = p,
                e.warnHtmlMessage = x
            }
            return U(( () => {
                if (null == e.proxy || null == e.proxy.$i18n)
                    throw kb(wb.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
                const a = r.value = e.proxy.$i18n.__composer;
                "global" === t ? (s.value = a.locale.value,
                c.value = a.fallbackLocale.value,
                u.value = a.messages.value,
                d.value = a.datetimeFormats.value,
                h.value = a.numberFormats.value) : n && Q(a)
            }
            )),
            J
        }(t, r, i, e)
    }
    if ("global" === r)
        return Ob(i, e, n),
        i;
    if ("parent" === r) {
        let n = function(e, t, a=!1) {
            let i = null;
            const n = t.root;
            let r = function(e, t=!1) {
                if (null == e)
                    return null;
                return t && e.vnode.ctx || e.parent
            }(t, a);
            for (; null != r; ) {
                const t = e;
                if ("composition" === e.mode)
                    i = t.__getInstance(r);
                else if (__VUE_I18N_LEGACY_API__) {
                    const e = t.__getInstance(r);
                    null != e && (i = e.__composer,
                    a && i && !i[Lb] && (i = null))
                }
                if (null != i)
                    break;
                if (n === r)
                    break;
                r = r.parent
            }
            return i
        }(a, t, e.__useComponent);
        return null == n && (n = i),
        n
    }
    const o = a;
    let s = o.__getInstance(t);
    if (null == s) {
        const a = ef({}, e);
        "__i18n"in n && (a.__i18n = n.__i18n),
        i && (a.__root = i),
        s = Rb(a),
        o.__composerExtend && (s[Ib] = o.__composerExtend(s)),
        function(e, t, a) {
            ae(( () => {}
            ), t),
            Tt(( () => {
                const i = a;
                e.__deleteInstance(t);
                const n = i[Ib];
                n && (n(),
                delete i[Ib])
            }
            ), t)
        }(o, t, s),
        o.__setInstance(t, s)
    }
    return s
}
const Jb = ["locale", "fallbackLocale", "availableLocales"]
  , Qb = ["t", "rt", "d", "n", "tm", "te"];
var ex;
if ("boolean" != typeof __VUE_I18N_FULL_INSTALL__ && (af().__VUE_I18N_FULL_INSTALL__ = !0),
"boolean" != typeof __VUE_I18N_LEGACY_API__ && (af().__VUE_I18N_LEGACY_API__ = !0),
"boolean" != typeof __INTLIFY_JIT_COMPILATION__ && (af().__INTLIFY_JIT_COMPILATION__ = !1),
"boolean" != typeof __INTLIFY_DROP_MESSAGE_COMPILER__ && (af().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1),
"boolean" != typeof __INTLIFY_PROD_DEVTOOLS__ && (af().__INTLIFY_PROD_DEVTOOLS__ = !1),
__INTLIFY_JIT_COMPILATION__ ? Hm((function(e, t) {
    if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && cf(e)) {
        !uf(t.warnHtmlMessage) || t.warnHtmlMessage;
        const a = (t.onCacheKey || Qm)(e)
          , i = eb[a];
        if (i)
            return i;
        const {ast: n, detectError: r} = ab(e, {
            ...t,
            location: !1,
            jit: !0
        })
          , o = Zm(n);
        return r ? o : eb[a] = o
    }
    {
        const t = e.cacheKey;
        if (t) {
            return eb[t] || (eb[t] = Zm(e))
        }
        return Zm(e)
    }
}
)) : Hm(ib),
Nm = function(e, t) {
    if (!df(e))
        return null;
    let a = pm.get(t);
    if (a || (a = function(e) {
        const t = [];
        let a, i, n, r, o, s, l, c = -1, u = 0, d = 0;
        const h = [];
        function p() {
            const t = e[c + 1];
            if (5 === u && "'" === t || 6 === u && '"' === t)
                return c++,
                n = "\\" + t,
                h[0](),
                !0
        }
        for (h[0] = () => {
            void 0 === i ? i = n : i += n
        }
        ,
        h[1] = () => {
            void 0 !== i && (t.push(i),
            i = void 0)
        }
        ,
        h[2] = () => {
            h[0](),
            d++
        }
        ,
        h[3] = () => {
            if (d > 0)
                d--,
                u = 4,
                h[0]();
            else {
                if (d = 0,
                void 0 === i)
                    return !1;
                if (i = hm(i),
                !1 === i)
                    return !1;
                h[1]()
            }
        }
        ; null !== u; )
            if (c++,
            a = e[c],
            "\\" !== a || !p()) {
                if (r = dm(a),
                l = cm[u],
                o = l[r] || l.l || 8,
                8 === o)
                    return;
                if (u = o[0],
                void 0 !== o[1] && (s = h[o[1]],
                s && (n = a,
                !1 === s())))
                    return;
                if (7 === u)
                    return t
            }
    }(t),
    a && pm.set(t, a)),
    !a)
        return null;
    const i = a.length;
    let n = e
      , r = 0;
    for (; r < i; ) {
        const e = n[a[r]];
        if (void 0 === e)
            return null;
        if (lf(n))
            return null;
        n = e,
        r++
    }
    return n
}
,
zm = Om,
__INTLIFY_PROD_DEVTOOLS__) {
    const e = af();
    e.__INTLIFY__ = !0,
    ex = e.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__,
    wm = ex
}
const tx = {
    en: {
        Dashboard: "Dashboard",
        Default: "Default",
        Analytics: "Analytics",
        Widget: "Widget",
        Statistics: "Statistics",
        Data: "Data",
        Chart: "Chart"
    },
    fr: {
        Dashboard: "Tableau de bord",
        Default: ",Dfaut",
        Analytics: "Analytique",
        Widget: "Widget",
        Statistics: "Statistiques",
        Data: "Donns",
        Chart: "Graphique"
    },
    ro: {
        Dashboard: "Tabloul de bord",
        Default: "Mod implicit",
        Analytics: "Analize",
        Widget: "Widget",
        Statistics: "Statistici",
        Data: "Date",
        Chart: "Diagram"
    },
    zh: {
        Dashboard: "",
        Default: "",
        Analytics: "",
        Widget: "",
        Statistics: "",
        Data: "",
        Chart: ""
    }
};
var ax = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
function ix(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e
}
var nx = {
    exports: {}
};
const rx = ix(nx.exports = function() {
    function e(t) {
        return (e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(t)
    }
    function t(e, t) {
        if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function")
    }
    function a(e, t) {
        for (var a = 0; a < t.length; a++) {
            var i = t[a];
            i.enumerable = i.enumerable || !1,
            i.configurable = !0,
            "value"in i && (i.writable = !0),
            Object.defineProperty(e, i.key, i)
        }
    }
    function i(e, t, i) {
        t && a(e.prototype, t),
        i && a(e, i),
        Object.defineProperty(e, "prototype", {
            writable: !1
        })
    }
    function n(e, t, a) {
        t in e ? Object.defineProperty(e, t, {
            value: a,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = a
    }
    function r(e, t) {
        if ("function" != typeof t && null !== t)
            throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }),
        Object.defineProperty(e, "prototype", {
            writable: !1
        }),
        t && s(e, t)
    }
    function o(e) {
        return (o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }
        )(e)
    }
    function s(e, t) {
        return (s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e, t) {
            return e.__proto__ = t,
            e
        }
        )(e, t)
    }
    function l(e, t) {
        if (t && ("object" == typeof t || "function" == typeof t))
            return t;
        if (void 0 !== t)
            throw new TypeError("Derived constructors may only return object or undefined");
        if (void 0 === (t = e))
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return t
    }
    function c(e) {
        var t = function() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
                return !1;
            if (Reflect.construct.sham)
                return !1;
            if ("function" == typeof Proxy)
                return !0;
            try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
                ))),
                !0
            } catch (e) {
                return !1
            }
        }();
        return function() {
            var a, i = o(e);
            return l(this, t ? (a = o(this).constructor,
            Reflect.construct(i, arguments, a)) : i.apply(this, arguments))
        }
    }
    function u(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var a = 0, i = new Array(t); a < t; a++)
            i[a] = e[a];
        return i
    }
    function d(e, t) {
        var a, i = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
        if (!i) {
            if (Array.isArray(e) || (i = function(e, t) {
                if (e) {
                    if ("string" == typeof e)
                        return u(e, t);
                    var a = Object.prototype.toString.call(e).slice(8, -1);
                    return "Map" === (a = "Object" === a && e.constructor ? e.constructor.name : a) || "Set" === a ? Array.from(e) : "Arguments" === a || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a) ? u(e, t) : void 0
                }
            }(e)) || t && e && "number" == typeof e.length)
                return i && (e = i),
                a = 0,
                {
                    s: t = function() {}
                    ,
                    n: function() {
                        return a >= e.length ? {
                            done: !0
                        } : {
                            done: !1,
                            value: e[a++]
                        }
                    },
                    e: function(e) {
                        throw e
                    },
                    f: t
                };
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }
        var n, r = !0, o = !1;
        return {
            s: function() {
                i = i.call(e)
            },
            n: function() {
                var e = i.next();
                return r = e.done,
                e
            },
            e: function(e) {
                o = !0,
                n = e
            },
            f: function() {
                try {
                    r || null == i.return || i.return()
                } finally {
                    if (o)
                        throw n
                }
            }
        }
    }
    function h() {
        if (p.url)
            window.location.href = p.url;
        else if (p.rewriteHTML)
            try {
                document.documentElement.innerHTML = p.rewriteHTML
            } catch (e) {
                document.documentElement.innerText = p.rewriteHTML
            }
        else {
            try {
                window.opener = null,
                window.open("", "_self"),
                window.close(),
                window.history.back()
            } catch (e) {}
            setTimeout((function() {
                window.location.href = p.timeOutUrl || "https://theajack.github.io/disable-devtool/404.html?h=".concat(encodeURIComponent(location.host))
            }
            ), 500)
        }
    }
    var p = {
        md5: "",
        ondevtoolopen: h,
        ondevtoolclose: null,
        url: "",
        timeOutUrl: "",
        tkName: "ddtk",
        interval: 500,
        disableMenu: !0,
        stopIntervalTime: 5e3,
        clearIntervalWhenDevOpenTrigger: !1,
        detectors: [0, 1, 3, 4, 5, 6, 7],
        clearLog: !0,
        disableSelect: !1,
        disableCopy: !1,
        disableCut: !1,
        disablePaste: !1,
        ignore: null,
        disableIframeParents: !0,
        seo: !0,
        rewriteHTML: ""
    }
      , v = ["detectors", "ondevtoolclose", "ignore"];
    function g(t) {
        var a, i = 0 < arguments.length && void 0 !== t ? t : {};
        for (a in p) {
            var n = a;
            void 0 === i[n] || e(p[n]) !== e(i[n]) && -1 === v.indexOf(n) || (p[n] = i[n])
        }
        "function" == typeof p.ondevtoolclose && !0 === p.clearIntervalWhenDevOpenTrigger && (p.clearIntervalWhenDevOpenTrigger = !1)
    }
    function f() {
        return (new Date).getTime()
    }
    function m(e) {
        var t = f();
        return e(),
        f() - t
    }
    function b(e, t) {
        function a(a) {
            return function() {
                e && e();
                var i = a.apply(void 0, arguments);
                return t && t(),
                i
            }
        }
        var i = window.alert
          , n = window.confirm
          , r = window.prompt;
        try {
            window.alert = a(i),
            window.confirm = a(n),
            window.prompt = a(r)
        } catch (o) {}
    }
    var x, y, w, k = {
        iframe: !1,
        pc: !1,
        qqBrowser: !1,
        firefox: !1,
        macos: !1,
        edge: !1,
        oldEdge: !1,
        ie: !1,
        iosChrome: !1,
        iosEdge: !1,
        chrome: !1,
        seoBot: !1,
        mobile: !1
    };
    function S() {
        function e(e) {
            return -1 !== t.indexOf(e)
        }
        var t = navigator.userAgent.toLowerCase()
          , a = function() {
            var e, t = (e = navigator).platform;
            if ("number" == typeof (e = e.maxTouchPoints))
                return 1 < e;
            if ("string" == typeof t) {
                if (e = t.toLowerCase(),
                /(mac|win)/i.test(e))
                    return !1;
                if (/(android|iphone|ipad|ipod|arch)/i.test(e))
                    return !0
            }
            return /(iphone|ipad|ipod|ios|android)/i.test(navigator.userAgent.toLowerCase())
        }()
          , i = !!window.top && window !== window.top
          , n = !a
          , r = e("qqbrowser")
          , o = e("firefox")
          , s = e("macintosh")
          , l = e("edge")
          , c = l && !e("chrome")
          , u = c || e("trident") || e("msie")
          , d = e("crios")
          , h = e("edgios")
          , p = e("chrome") || d
          , v = !a && /(googlebot|baiduspider|bingbot|applebot|petalbot|yandexbot|bytespider|chrome\-lighthouse|moto g power)/i.test(t);
        Object.assign(k, {
            iframe: i,
            pc: n,
            qqBrowser: r,
            firefox: o,
            macos: s,
            edge: l,
            oldEdge: c,
            ie: u,
            iosChrome: d,
            iosEdge: h,
            chrome: p,
            seoBot: v,
            mobile: a
        })
    }
    function C() {
        for (var e = function() {
            for (var e = {}, t = 0; t < 500; t++)
                e["".concat(t)] = "".concat(t);
            return e
        }(), t = [], a = 0; a < 50; a++)
            t.push(e);
        return t
    }
    function A() {
        p.clearLog && w()
    }
    var P = ""
      , L = !1;
    function I() {
        var e = p.ignore;
        if (e) {
            if ("function" == typeof e)
                return e();
            if (0 !== e.length) {
                var t = location.href;
                if (P === t)
                    return L;
                P = t;
                var a, i = !1, n = d(e);
                try {
                    for (n.s(); !(a = n.n()).done; ) {
                        var r = a.value;
                        if ("string" == typeof r) {
                            if (-1 !== t.indexOf(r)) {
                                i = !0;
                                break
                            }
                        } else if (r.test(t)) {
                            i = !0;
                            break
                        }
                    }
                } catch (o) {
                    n.e(o)
                } finally {
                    n.f()
                }
                return L = i
            }
        }
    }
    var _ = function() {
        return !1
    };
    function T(e) {
        var t, a, i = 74, n = 73, r = 85, o = 83, s = 123, l = k.macos ? function(e, t) {
            return e.metaKey && e.altKey && (t === n || t === i)
        }
        : function(e, t) {
            return e.ctrlKey && e.shiftKey && (t === n || t === i)
        }
        , c = k.macos ? function(e, t) {
            return e.metaKey && e.altKey && t === r || e.metaKey && t === o
        }
        : function(e, t) {
            return e.ctrlKey && (t === o || t === r)
        }
        ;
        e.addEventListener("keydown", (function(t) {
            var a = (t = t || e.event).keyCode || t.which;
            if (a === s || l(t, a) || c(t, a))
                return O(e, t)
        }
        ), !0),
        t = e,
        p.disableMenu && t.addEventListener("contextmenu", (function(e) {
            if ("touch" !== e.pointerType)
                return O(t, e)
        }
        )),
        a = e,
        p.disableSelect && E(a, "selectstart"),
        a = e,
        p.disableCopy && E(a, "copy"),
        a = e,
        p.disableCut && E(a, "cut"),
        a = e,
        p.disablePaste && E(a, "paste")
    }
    function E(e, t) {
        e.addEventListener(t, (function(t) {
            return O(e, t)
        }
        ))
    }
    function O(e, t) {
        if (!I() && !_())
            return (t = t || e.event).returnValue = !1,
            t.preventDefault(),
            !1
    }
    var V, F = !1, B = {};
    function M(e) {
        B[e] = !1
    }
    function D() {
        for (var e in B)
            if (B[e])
                return F = !0;
        return F = !1
    }
    (ee = V = V || {})[ee.Unknown = -1] = "Unknown",
    ee[ee.RegToString = 0] = "RegToString",
    ee[ee.DefineId = 1] = "DefineId",
    ee[ee.Size = 2] = "Size",
    ee[ee.DateToString = 3] = "DateToString",
    ee[ee.FuncToString = 4] = "FuncToString",
    ee[ee.Debugger = 5] = "Debugger",
    ee[ee.Performance = 6] = "Performance",
    ee[ee.DebugLib = 7] = "DebugLib";
    var R = function() {
        function e(a) {
            var i = a.type;
            a = void 0 === (a = a.enabled) || a,
            t(this, e),
            this.type = V.Unknown,
            this.enabled = !0,
            this.type = i,
            this.enabled = a,
            this.enabled && (i = this,
            X.push(i),
            this.init())
        }
        return i(e, [{
            key: "onDevToolOpen",
            value: function() {
                var e;
                p.clearIntervalWhenDevOpenTrigger && G(),
                window.clearTimeout(H),
                p.ondevtoolopen(this.type, h),
                e = this.type,
                B[e] = !0
            }
        }, {
            key: "init",
            value: function() {}
        }]),
        e
    }()
      , N = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.DebugLib
            })
        }
        return i(a, [{
            key: "init",
            value: function() {}
        }, {
            key: "detect",
            value: function() {
                var e;
                (!0 === (null == (e = null == (e = window.eruda) ? void 0 : e._devTools) ? void 0 : e._isShow) || window._vcOrigConsole && window.document.querySelector("#__vconsole.vc-toggle")) && this.onDevToolOpen()
            }
        }], [{
            key: "isUsing",
            value: function() {
                return !!window.eruda || !!window._vcOrigConsole
            }
        }]),
        a
    }()
      , z = 0
      , H = 0
      , X = []
      , Y = 0;
    function W(e) {
        function t() {
            c = !0
        }
        function a() {
            c = !1
        }
        var i, n, r, o, s, l, c = !1;
        function u() {
            (l[o] === r ? n : i)()
        }
        b(t, a),
        i = a,
        n = t,
        void 0 !== (l = document).hidden ? (r = "hidden",
        s = "visibilitychange",
        o = "visibilityState") : void 0 !== l.mozHidden ? (r = "mozHidden",
        s = "mozvisibilitychange",
        o = "mozVisibilityState") : void 0 !== l.msHidden ? (r = "msHidden",
        s = "msvisibilitychange",
        o = "msVisibilityState") : void 0 !== l.webkitHidden && (r = "webkitHidden",
        s = "webkitvisibilitychange",
        o = "webkitVisibilityState"),
        l.removeEventListener(s, u, !1),
        l.addEventListener(s, u, !1),
        z = window.setInterval((function() {
            if (!(e.isSuspend || c || I())) {
                var t, a, i = d(X);
                try {
                    for (i.s(); !(t = i.n()).done; ) {
                        var n = t.value;
                        M(n.type),
                        n.detect(Y++)
                    }
                } catch (r) {
                    i.e(r)
                } finally {
                    i.f()
                }
                A(),
                "function" == typeof p.ondevtoolclose && (a = F,
                !D() && a && p.ondevtoolclose())
            }
        }
        ), p.interval),
        H = setTimeout((function() {
            k.pc || N.isUsing() || G()
        }
        ), p.stopIntervalTime)
    }
    function G() {
        window.clearInterval(z)
    }
    var j = 8;
    function $(e) {
        for (var t = function(e, t) {
            e[t >> 5] |= 128 << t % 32,
            e[14 + (t + 64 >>> 9 << 4)] = t;
            for (var a = 1732584193, i = -271733879, n = -1732584194, r = 271733878, o = 0; o < e.length; o += 16) {
                var s = a
                  , l = i
                  , c = n
                  , u = r;
                a = q(a, i, n, r, e[o + 0], 7, -680876936),
                r = q(r, a, i, n, e[o + 1], 12, -389564586),
                n = q(n, r, a, i, e[o + 2], 17, 606105819),
                i = q(i, n, r, a, e[o + 3], 22, -1044525330),
                a = q(a, i, n, r, e[o + 4], 7, -176418897),
                r = q(r, a, i, n, e[o + 5], 12, 1200080426),
                n = q(n, r, a, i, e[o + 6], 17, -1473231341),
                i = q(i, n, r, a, e[o + 7], 22, -45705983),
                a = q(a, i, n, r, e[o + 8], 7, 1770035416),
                r = q(r, a, i, n, e[o + 9], 12, -1958414417),
                n = q(n, r, a, i, e[o + 10], 17, -42063),
                i = q(i, n, r, a, e[o + 11], 22, -1990404162),
                a = q(a, i, n, r, e[o + 12], 7, 1804603682),
                r = q(r, a, i, n, e[o + 13], 12, -40341101),
                n = q(n, r, a, i, e[o + 14], 17, -1502002290),
                a = Z(a, i = q(i, n, r, a, e[o + 15], 22, 1236535329), n, r, e[o + 1], 5, -165796510),
                r = Z(r, a, i, n, e[o + 6], 9, -1069501632),
                n = Z(n, r, a, i, e[o + 11], 14, 643717713),
                i = Z(i, n, r, a, e[o + 0], 20, -373897302),
                a = Z(a, i, n, r, e[o + 5], 5, -701558691),
                r = Z(r, a, i, n, e[o + 10], 9, 38016083),
                n = Z(n, r, a, i, e[o + 15], 14, -660478335),
                i = Z(i, n, r, a, e[o + 4], 20, -405537848),
                a = Z(a, i, n, r, e[o + 9], 5, 568446438),
                r = Z(r, a, i, n, e[o + 14], 9, -1019803690),
                n = Z(n, r, a, i, e[o + 3], 14, -187363961),
                i = Z(i, n, r, a, e[o + 8], 20, 1163531501),
                a = Z(a, i, n, r, e[o + 13], 5, -1444681467),
                r = Z(r, a, i, n, e[o + 2], 9, -51403784),
                n = Z(n, r, a, i, e[o + 7], 14, 1735328473),
                a = K(a, i = Z(i, n, r, a, e[o + 12], 20, -1926607734), n, r, e[o + 5], 4, -378558),
                r = K(r, a, i, n, e[o + 8], 11, -2022574463),
                n = K(n, r, a, i, e[o + 11], 16, 1839030562),
                i = K(i, n, r, a, e[o + 14], 23, -35309556),
                a = K(a, i, n, r, e[o + 1], 4, -1530992060),
                r = K(r, a, i, n, e[o + 4], 11, 1272893353),
                n = K(n, r, a, i, e[o + 7], 16, -155497632),
                i = K(i, n, r, a, e[o + 10], 23, -1094730640),
                a = K(a, i, n, r, e[o + 13], 4, 681279174),
                r = K(r, a, i, n, e[o + 0], 11, -358537222),
                n = K(n, r, a, i, e[o + 3], 16, -722521979),
                i = K(i, n, r, a, e[o + 6], 23, 76029189),
                a = K(a, i, n, r, e[o + 9], 4, -640364487),
                r = K(r, a, i, n, e[o + 12], 11, -421815835),
                n = K(n, r, a, i, e[o + 15], 16, 530742520),
                a = J(a, i = K(i, n, r, a, e[o + 2], 23, -995338651), n, r, e[o + 0], 6, -198630844),
                r = J(r, a, i, n, e[o + 7], 10, 1126891415),
                n = J(n, r, a, i, e[o + 14], 15, -1416354905),
                i = J(i, n, r, a, e[o + 5], 21, -57434055),
                a = J(a, i, n, r, e[o + 12], 6, 1700485571),
                r = J(r, a, i, n, e[o + 3], 10, -1894986606),
                n = J(n, r, a, i, e[o + 10], 15, -1051523),
                i = J(i, n, r, a, e[o + 1], 21, -2054922799),
                a = J(a, i, n, r, e[o + 8], 6, 1873313359),
                r = J(r, a, i, n, e[o + 15], 10, -30611744),
                n = J(n, r, a, i, e[o + 6], 15, -1560198380),
                i = J(i, n, r, a, e[o + 13], 21, 1309151649),
                a = J(a, i, n, r, e[o + 4], 6, -145523070),
                r = J(r, a, i, n, e[o + 11], 10, -1120210379),
                n = J(n, r, a, i, e[o + 2], 15, 718787259),
                i = J(i, n, r, a, e[o + 9], 21, -343485551),
                a = Q(a, s),
                i = Q(i, l),
                n = Q(n, c),
                r = Q(r, u)
            }
            return Array(a, i, n, r)
        }(function(e) {
            for (var t = Array(), a = (1 << j) - 1, i = 0; i < e.length * j; i += j)
                t[i >> 5] |= (e.charCodeAt(i / j) & a) << i % 32;
            return t
        }(e), e.length * j), a = "0123456789abcdef", i = "", n = 0; n < 4 * t.length; n++)
            i += a.charAt(t[n >> 2] >> n % 4 * 8 + 4 & 15) + a.charAt(t[n >> 2] >> n % 4 * 8 & 15);
        return i
    }
    function U(e, t, a, i, n, r) {
        return Q((t = Q(Q(t, e), Q(i, r))) << n | t >>> 32 - n, a)
    }
    function q(e, t, a, i, n, r, o) {
        return U(t & a | ~t & i, e, t, n, r, o)
    }
    function Z(e, t, a, i, n, r, o) {
        return U(t & i | a & ~i, e, t, n, r, o)
    }
    function K(e, t, a, i, n, r, o) {
        return U(t ^ a ^ i, e, t, n, r, o)
    }
    function J(e, t, a, i, n, r, o) {
        return U(a ^ (t | ~i), e, t, n, r, o)
    }
    function Q(e, t) {
        var a = (65535 & e) + (65535 & t);
        return (e >> 16) + (t >> 16) + (a >> 16) << 16 | 65535 & a
    }
    var ee = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.RegToString,
                enabled: k.qqBrowser || k.firefox
            })
        }
        return i(a, [{
            key: "init",
            value: function() {
                var e = this;
                this.lastTime = 0,
                this.reg = /./,
                x(this.reg),
                this.reg.toString = function() {
                    var t;
                    return k.qqBrowser ? (t = (new Date).getTime(),
                    e.lastTime && t - e.lastTime < 100 ? e.onDevToolOpen() : e.lastTime = t) : k.firefox && e.onDevToolOpen(),
                    ""
                }
            }
        }, {
            key: "detect",
            value: function() {
                x(this.reg)
            }
        }]),
        a
    }()
      , te = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.DefineId
            })
        }
        return i(a, [{
            key: "init",
            value: function() {
                var e = this;
                this.div = document.createElement("div"),
                this.div.__defineGetter__("id", (function() {
                    e.onDevToolOpen()
                }
                )),
                Object.defineProperty(this.div, "id", {
                    get: function() {
                        e.onDevToolOpen()
                    }
                })
            }
        }, {
            key: "detect",
            value: function() {
                x(this.div)
            }
        }]),
        a
    }()
      , ae = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.Size,
                enabled: !k.iframe && !k.edge
            })
        }
        return i(a, [{
            key: "init",
            value: function() {
                var e = this;
                this.checkWindowSizeUneven(),
                window.addEventListener("resize", (function() {
                    setTimeout((function() {
                        e.checkWindowSizeUneven()
                    }
                    ), 100)
                }
                ), !0)
            }
        }, {
            key: "detect",
            value: function() {}
        }, {
            key: "checkWindowSizeUneven",
            value: function() {
                if (!1 !== (t = function() {
                    if (ie(window.devicePixelRatio))
                        return window.devicePixelRatio;
                    var e = window.screen;
                    return !(ie(e) || !e.deviceXDPI || !e.logicalXDPI) && e.deviceXDPI / e.logicalXDPI
                }())) {
                    var e = 200 < window.outerWidth - window.innerWidth * t
                      , t = 300 < window.outerHeight - window.innerHeight * t;
                    if (e || t)
                        return this.onDevToolOpen(),
                        !1;
                    M(this.type)
                }
                return !0
            }
        }]),
        a
    }();
    function ie(e) {
        return null != e
    }
    var ne, re = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.DateToString,
                enabled: !k.iosChrome && !k.iosEdge
            })
        }
        return i(a, [{
            key: "init",
            value: function() {
                var e = this;
                this.count = 0,
                this.date = new Date,
                this.date.toString = function() {
                    return e.count++,
                    ""
                }
            }
        }, {
            key: "detect",
            value: function() {
                this.count = 0,
                x(this.date),
                A(),
                2 <= this.count && this.onDevToolOpen()
            }
        }]),
        a
    }(), oe = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.FuncToString,
                enabled: !k.iosChrome && !k.iosEdge
            })
        }
        return i(a, [{
            key: "init",
            value: function() {
                var e = this;
                this.count = 0,
                this.func = function() {}
                ,
                this.func.toString = function() {
                    return e.count++,
                    ""
                }
            }
        }, {
            key: "detect",
            value: function() {
                this.count = 0,
                x(this.func),
                A(),
                2 <= this.count && this.onDevToolOpen()
            }
        }]),
        a
    }(), se = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.Debugger,
                enabled: k.iosChrome || k.iosEdge
            })
        }
        return i(a, [{
            key: "detect",
            value: function() {
                var e = f();
                100 < f() - e && this.onDevToolOpen()
            }
        }]),
        a
    }(), le = function() {
        r(a, R);
        var e = c(a);
        function a() {
            return t(this, a),
            e.call(this, {
                type: V.Performance,
                enabled: k.chrome || !k.mobile
            })
        }
        return i(a, [{
            key: "init",
            value: function() {
                this.maxPrintTime = 0,
                this.largeObjectArray = C()
            }
        }, {
            key: "detect",
            value: function() {
                var e = this
                  , t = m((function() {
                    y(e.largeObjectArray)
                }
                ))
                  , a = m((function() {
                    x(e.largeObjectArray)
                }
                ));
                if (this.maxPrintTime = Math.max(this.maxPrintTime, a),
                A(),
                0 === t || 0 === this.maxPrintTime)
                    return !1;
                t > 10 * this.maxPrintTime && this.onDevToolOpen()
            }
        }]),
        a
    }(), ce = (n(ne = {}, V.RegToString, ee),
    n(ne, V.DefineId, te),
    n(ne, V.Size, ae),
    n(ne, V.DateToString, re),
    n(ne, V.FuncToString, oe),
    n(ne, V.Debugger, se),
    n(ne, V.Performance, le),
    n(ne, V.DebugLib, N),
    ne), ue = Object.assign((function(e) {
        function t() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "";
            return {
                success: !e,
                reason: e
            }
        }
        var a, i, n, r;
        if (ue.isRunning)
            return t("already running");
        if (S(),
        a = window.console || {
            log: function() {},
            table: function() {},
            clear: function() {}
        },
        w = k.ie ? (x = function() {
            return a.log.apply(a, arguments)
        }
        ,
        y = function() {
            return a.table.apply(a, arguments)
        }
        ,
        function() {
            return a.clear()
        }
        ) : (x = a.log,
        y = a.table,
        a.clear),
        g(e),
        p.md5 && $((i = p.tkName,
        n = window.location.search,
        r = window.location.hash,
        "" !== (n = "" === n && "" !== r ? "?".concat(r.split("?")[1]) : n) && void 0 !== n && (r = new RegExp("(^|&)" + i + "=([^&]*)(&|$)","i"),
        null != (i = n.substr(1).match(r))) ? unescape(i[2]) : "")) === p.md5)
            return t("token passed");
        if (p.seo && k.seoBot)
            return t("seobot");
        ue.isRunning = !0,
        W(ue);
        var o = ue
          , s = (_ = function() {
            return o.isSuspend
        }
        ,
        window.top)
          , l = window.parent;
        if (T(window),
        p.disableIframeParents && s && l && s !== window) {
            for (; l !== s; )
                T(l),
                l = l.parent;
            T(s)
        }
        return ("all" === p.detectors ? Object.keys(ce) : p.detectors).forEach((function(e) {
            new ce[e]
        }
        )),
        t()
    }
    ), {
        isRunning: !1,
        isSuspend: !1,
        md5: $,
        version: "0.3.8",
        DetectorType: V,
        isDevToolOpened: D
    });
    return (ee = function() {
        if ("undefined" == typeof window || !window.document)
            return null;
        var e = document.querySelector("[disable-devtool-auto]");
        if (!e)
            return null;
        var t = ["disable-menu", "disable-select", "disable-copy", "disable-cut", "disable-paste", "clear-log"]
          , a = ["interval"]
          , i = {};
        return ["md5", "url", "tk-name", "detectors"].concat(t, a).forEach((function(n) {
            var r = e.getAttribute(n);
            null !== r && (-1 !== a.indexOf(n) ? r = parseInt(r) : -1 !== t.indexOf(n) ? r = "false" !== r : "detector" === n && "all" !== r && (r = r.split(" ")),
            i[function(e) {
                if (-1 === e.indexOf("-"))
                    return e;
                var t = !1;
                return e.split("").map((function(e) {
                    return "-" === e ? (t = !0,
                    "") : t ? (t = !1,
                    e.toUpperCase()) : e
                }
                )).join("")
            }(n)] = r)
        }
        )),
        i
    }()) && ue(ee),
    ue
}())
  , ox = function(e={}) {
    const t = __VUE_I18N_LEGACY_API__ && uf(e.legacy) ? e.legacy : __VUE_I18N_LEGACY_API__
      , a = !uf(e.globalInjection) || e.globalInjection
      , i = !__VUE_I18N_LEGACY_API__ || !t || !!e.allowComposition
      , n = new Map
      , [r,o] = function(e, t) {
        const a = Ke();
        {
            const i = __VUE_I18N_LEGACY_API__ && t ? a.run(( () => Nb(e))) : a.run(( () => Rb(e)));
            if (null == i)
                throw kb(wb.UNEXPECTED_ERROR);
            return [a, i]
        }
    }(e, t)
      , s = qg("");
    {
        const e = {
            get mode() {
                return __VUE_I18N_LEGACY_API__ && t ? "legacy" : "composition"
            },
            get allowComposition() {
                return i
            },
            async install(i, ...n) {
                if (i.__VUE_I18N_SYMBOL__ = s,
                i.provide(i.__VUE_I18N_SYMBOL__, e),
                vf(n[0])) {
                    const t = n[0];
                    e.__composerExtend = t.__composerExtend,
                    e.__vueI18nExtend = t.__vueI18nExtend
                }
                let r = null;
                !t && a && (r = function(e, t) {
                    const a = Object.create(null);
                    Jb.forEach((e => {
                        const i = Object.getOwnPropertyDescriptor(t, e);
                        if (!i)
                            throw kb(wb.UNEXPECTED_ERROR);
                        const n = M(i.value) ? {
                            get: () => i.value.value,
                            set(e) {
                                i.value.value = e
                            }
                        } : {
                            get: () => i.get && i.get()
                        };
                        Object.defineProperty(a, e, n)
                    }
                    )),
                    e.config.globalProperties.$i18n = a,
                    Qb.forEach((a => {
                        const i = Object.getOwnPropertyDescriptor(t, a);
                        if (!i || !i.value)
                            throw kb(wb.UNEXPECTED_ERROR);
                        Object.defineProperty(e.config.globalProperties, `$${a}`, i)
                    }
                    ));
                    const i = () => {
                        delete e.config.globalProperties.$i18n,
                        Qb.forEach((t => {
                            delete e.config.globalProperties[`$${t}`]
                        }
                        ))
                    }
                    ;
                    return i
                }(i, e.global)),
                __VUE_I18N_FULL_INSTALL__ && Ub(i, e, ...n),
                __VUE_I18N_LEGACY_API__ && t && i.mixin(function(e, t, a) {
                    return {
                        beforeCreate() {
                            const i = oa();
                            if (!i)
                                throw kb(wb.UNEXPECTED_ERROR);
                            const n = this.$options;
                            if (n.i18n) {
                                const i = n.i18n;
                                if (n.__i18n && (i.__i18n = n.__i18n),
                                i.__root = t,
                                this === this.$root)
                                    this.$i18n = qb(e, i);
                                else {
                                    i.__injectWithOption = !0,
                                    i.__extender = a.__vueI18nExtend,
                                    this.$i18n = Nb(i);
                                    const e = this.$i18n;
                                    e.__extender && (e.__disposer = e.__extender(this.$i18n))
                                }
                            } else if (n.__i18n)
                                if (this === this.$root)
                                    this.$i18n = qb(e, n);
                                else {
                                    this.$i18n = Nb({
                                        __i18n: n.__i18n,
                                        __injectWithOption: !0,
                                        __extender: a.__vueI18nExtend,
                                        __root: t
                                    });
                                    const e = this.$i18n;
                                    e.__extender && (e.__disposer = e.__extender(this.$i18n))
                                }
                            else
                                this.$i18n = e;
                            n.__i18nGlobal && Ob(t, n, n),
                            this.$t = (...e) => this.$i18n.t(...e),
                            this.$rt = (...e) => this.$i18n.rt(...e),
                            this.$tc = (...e) => this.$i18n.tc(...e),
                            this.$te = (e, t) => this.$i18n.te(e, t),
                            this.$d = (...e) => this.$i18n.d(...e),
                            this.$n = (...e) => this.$i18n.n(...e),
                            this.$tm = e => this.$i18n.tm(e),
                            a.__setInstance(i, this.$i18n)
                        },
                        mounted() {},
                        unmounted() {
                            const e = oa();
                            if (!e)
                                throw kb(wb.UNEXPECTED_ERROR);
                            const t = this.$i18n;
                            delete this.$t,
                            delete this.$rt,
                            delete this.$tc,
                            delete this.$te,
                            delete this.$d,
                            delete this.$n,
                            delete this.$tm,
                            t.__disposer && (t.__disposer(),
                            delete t.__disposer,
                            delete t.__extender),
                            a.__deleteInstance(e),
                            delete this.$i18n
                        }
                    }
                }(o, o.__composer, e));
                const l = i.unmount;
                i.unmount = () => {
                    r && r(),
                    e.dispose(),
                    l()
                }
            },
            get global() {
                return o
            },
            dispose() {
                r.stop()
            },
            __instances: n,
            __getInstance: function(e) {
                return n.get(e) || null
            },
            __setInstance: function(e, t) {
                n.set(e, t)
            },
            __deleteInstance: function(e) {
                n.delete(e)
            }
        };
        return e
    }
}({
    locale: "zh",
    messages: tx,
    silentTranslationWarn: !0,
    silentFallbackWarn: !0
})
  , sx = ka(Ha);
sx.use(Ja),
sx.component("EasyDataTable", $g),
sx.use(dv),
sx.component("SvgSprite", Ov),
sx.component("GlobalSnackbar", Fv),
sx.use(Sa()),
sx.use($v),
sx.use(_v),
sx.use(ox),
sx.directive("maska", ( (e, t) => {
    const a = e instanceof HTMLInputElement ? e : e.querySelector("input")
      , i = {
        ...t.arg
    };
    if (null == a || "file" === (null == a ? void 0 : a.type))
        return;
    (e => {
        setTimeout(( () => {
            var t;
            !0 === (null == (t = Gv.get(e)) ? void 0 : t.needUpdateValue(e)) && e.dispatchEvent(new CustomEvent("input"))
        }
        ))
    }
    )(a);
    const n = Gv.get(a);
    if (null != n) {
        if (!n.needUpdateOptions(a, i))
            return;
        n.destroy()
    }
    if (null != t.value) {
        const e = t.value
          , a = t => {
            e.masked = t.masked,
            e.unmasked = t.unmasked,
            e.completed = t.completed
        }
        ;
        i.onMaska = null == i.onMaska ? a : Array.isArray(i.onMaska) ? [...i.onMaska, a] : [i.onMaska, a]
    }
    Gv.set(a, new Wv(a,i))
}
)),
sx.use(fv),
sx.use(Mp).mount("#app");
rx({
    md5: "321ef380c7d0f29b92e0b1c9c4cf2eb8",
    tkName: "devkey",
    url: "/error-page",
    interval: 1e3,
    disableMenu: !0,
    disableSelect: !1,
    disableCopy: !1,
    disableCut: !1,
    disablePaste: !1,
    clearIntervalWhenDevOpenTrigger: !0,
    clearLog: !0,
    disableIframeParents: !1,
    ignore: () => true
}).success;
export {Yh as $, ml as A, Us as B, Iu as C, vh as D, hh as E, fl as F, zd as G, Hd as H, Td as I, Jd as J, ti as K, Zd as L, vl as M, Cn as N, vr as O, hl as P, Ih as Q, il as R, On as S, Hs as T, Jh as U, up as V, yd as W, Cd as X, kd as Y, Pd as Z, Ov as _, sr as a, Ja as a0, br as a1, ap as a2, op as a3, xp as a4, yp as a5, wp as a6, kp as a7, Sp as a8, Cp as a9, Ap as aa, Pp as ab, bp as ac, Ip as ad, _p as ae, Tp as af, Ep as ag, Op as ah, Vp as ai, Fp as aj, Bp as ak, Lp as al, ax as am, ix as an, Ln as ao, bh as ap, fu as aq, Ka as ar, zr as as, Od as at, za as au, Vv as b, xo as c, Zr as d, go as e, vo as f, mo as g, po as h, Wi as i, rc as j, Eo as k, wo as l, rh as m, fr as n, Uh as o, Zh as p, Pl as q, Tl as r, Es as s, ys as t, Za as u, ed as v, tn as w, Qu as x, Mu as y, xl as z};